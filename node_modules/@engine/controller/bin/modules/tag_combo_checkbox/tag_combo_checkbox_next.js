var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ParameterTagComboCheckboxNext_1;
import { fetchParamControlAttr, fetchWidgetViewValue } from '../controller.crud';
import { transformControlAttrs, transformValue2TagComboNextValue, preTransformValue2TagComboNextValue, setTagComboCheckboxStyle, setTagComboCheckboxPopupStyle } from './tag_combo_checkbox.service';
import { shortcut } from '@engine/core';
import { AbstractParameterControllerWidget } from '../controller.abstract';
import { LimitCount, transformControlAttrData, setComboFontSize, fetchParamViewValue } from '../controller.service';
import { WIDTH, HEIGHT } from '../controller.constants';
import { ParameterMultiSelectCombo } from './multiselectcombo/multiselectcombo';
import '../combo/combo.less';
let ParameterTagComboCheckboxNext = ParameterTagComboCheckboxNext_1 = class ParameterTagComboCheckboxNext extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        this.props = {
            baseCls: ParameterTagComboCheckboxNext_1.BASE_CLS,
            $testId: 'report-main-parameter-container-controller-tag-combo-checkbox',
            width: WIDTH,
            height: HEIGHT,
            watermark: '',
            value: '',
            fontSize: 12,
            needSubmit: false,
            disabled: false,
            invisible: false,
            allowBlank: true,
            errorMsg: BI.i18nText('Fine-Report_Preview_Can_Not_Null'),
            controlAttr: {
                data: [],
                value: '',
            },
            customData: true,
            needCheckCustomData: true,
            directEdit: true,
            noRepeat: true,
            autoMode: true,
            mode: 'remote',
            searchTime: 200,
            widgetName: '',
            delimiter: '',
            supportTag: true,
            returnArray: true,
            startSymbol: '',
            endSymbol: '',
            getDependenceByWidget: () => [],
            getWidgetDependenceValueByWidget: () => {
                return {};
            },
            add2WaitingQueue: () => '',
            removeFromWaitingQueue: () => { },
            allowCount: false,
            controlAttrFetcher: fetchParamControlAttr,
            extraOptsGetter: () => {
                return {};
            },
            viewValueFetcher: fetchWidgetViewValue,
            allowBg: true,
            sonHeight: 24,
        };
        // 12px配24px的行高
        this.ratio = 2;
    }
    get editComp() {
        return this.combo;
    }
    render() {
        const { width, height, value, watermark, fontSize, widgetName, controlAttr, customData, directEdit, delimiter, returnArray, allowCount, controlAttrFetcher, allowBg, startSymbol, endSymbol } = this.options;
        return {
            type: ParameterMultiSelectCombo.xtype,
            cls: `${setComboFontSize(ParameterTagComboCheckboxNext_1.BASE_CLS, {
                width, height, fontSize,
            })} ${allowBg ? 'bi-card' : ''}`,
            ref: (_ref) => {
                this.combo = _ref;
            },
            allowEdit: directEdit,
            allowCount,
            itemHeightGetter: () => this.options.sonHeight,
            // itemHeight: Math.max(this.ratio * fontSize, 24),
            itemsCreator: (options, callback) => {
                controlAttrFetcher(widgetName, Object.assign(Object.assign({ startIndex: LimitCount * (options.times - 1), limitIndex: options.loadTotal ? undefined : LimitCount * options.times }, options.keyword ? { filter: options.keyword } : {}), this.getRequestOpts()))
                    .then(items => {
                    const dataList = transformControlAttrData(items);
                    this.options.controlAttr.data = (this.options.controlAttr.data || []).concat(dataList);
                    callback({
                        items: transformControlAttrs(dataList, [], {
                            $testId: 'report-main-parameter-container-controller-tag-combo-checkbox-item',
                        }),
                        hasNext: options.loadTotal ? false : items.length >= LimitCount,
                    });
                });
            },
            width,
            height,
            value: transformValue2TagComboNextValue(value, transformControlAttrData(controlAttr.data), delimiter, returnArray, true, startSymbol, endSymbol),
            watermark,
            customData,
            listeners: [{
                    eventName: ParameterMultiSelectCombo.EVENT_CONFIRM,
                    action: () => {
                        const result = !this.silence && this.fireEvent('stopedit');
                        result !== false && this.fireEvent('EVENT_CHANGE');
                    },
                }, {
                    eventName: ParameterMultiSelectCombo.EVENT_BEFORE_EDIT,
                    action: () => {
                        this.hideBubble();
                        !this.silence && this.fireEvent('beforeedit');
                    },
                }, {
                    eventName: ParameterMultiSelectCombo.EVENT_AFTER_EDIT,
                    action: () => {
                        !this.silence && this.fireEvent('afteredit');
                    },
                }, {
                    eventName: ParameterMultiSelectCombo.EVENT_CLICK_ITEM,
                    action: () => {
                        this.hideBubble();
                        !this.silence && this.fireEvent('click');
                    },
                }],
        };
    }
    mounted() {
        super.mounted();
        const { fontSize } = this.options;
        this.setPopupStyle({
            fontSize: `${fontSize}px`,
            itemHeight: `${fontSize * this.ratio}px`,
        });
    }
    async updateControllAttrByValue(v, controlData) {
        const { delimiter, returnArray, customData, add2WaitingQueue, removeFromWaitingQueue, widgetName, viewValueFetcher, startSymbol, endSymbol } = this.options;
        if (!controlData || BI.isEmptyArray(controlData)) {
            const result = [];
            const id = add2WaitingQueue();
            for (const value of preTransformValue2TagComboNextValue(v, delimiter, returnArray, startSymbol, endSymbol)) {
                const re = await fetchParamViewValue(widgetName, customData, viewValueFetcher, Object.assign({ __text__: value }, this.getRequestOpts()));
                if (BI.isNull(re)) {
                    customData && result.push({ text: `${value}`, value: `${value}` });
                }
                else {
                    result.push(re);
                }
                this.options.controlAttr.data = (this.options.controlAttr.data || []).concat(result || []);
            }
            removeFromWaitingQueue(id);
            return result;
        }
        return transformValue2TagComboNextValue(v, transformControlAttrData(controlData), delimiter, returnArray, customData, startSymbol, endSymbol);
    }
    async setControllerValue(v, controlData) {
        this.combo.setValue(await this.updateControllAttrByValue(v, controlData));
    }
    setValue(v, controlData) {
        this.setControllerValue(v, controlData)
            .then(() => {
            this.fireEvent('EVENT_SET_VALUE');
            !this.silence && controlData && this.fireEvent('afteredit');
        });
    }
    preGetValidation() {
        const { allowBlank, value, errorMsg } = this.options;
        return allowBlank || !BI.isEmpty(value) ? {
            result: true,
        } : {
            result: false,
            errorMsg,
        };
    }
    validateCustomData() {
        const { controlAttr } = this.options;
        const values = this.combo.getValue();
        const dataAttr = transformControlAttrData(controlAttr.data);
        if (BI.isEmptyArray(values)) {
            return true;
        }
        const validation = values.every(item => dataAttr.some(data => item.text === data.text && item.value === data.value));
        return validation;
    }
    postGetValidation() {
        const { allowBlank, errorMsg, customData, needCheckCustomData } = this.options;
        const value = this.combo.getValue();
        const validation = customData || !needCheckCustomData || this.validateCustomData();
        if (!validation) {
            return {
                result: false,
                errorMsg: BI.i18nText('Fine-Report_Preview_Not_In_List'),
            };
        }
        if (BI.isEmptyArray(value || []) && !allowBlank) {
            return {
                result: false,
                errorMsg,
            };
        }
        return { result: true };
    }
    postValidateAndToast() {
        const validation = this.getValidation();
        if (validation.result) {
            return true;
        }
        this.showBubble(validation.errorMsg);
        return false;
    }
    emitManualStopEditEvent() {
        this.fireEvent('stopedit');
    }
    getValue() {
        const { delimiter, returnArray, startSymbol, endSymbol } = this.options;
        const value = Array.from(new Set(this.combo.getValue()
            .map(v => v.value)
            .filter(v => BI.isNotEmptyString(v))));
        if (!returnArray) {
            return `${startSymbol}${value.join(delimiter)}${endSymbol}`;
        }
        return value;
    }
    reset() {
        this.combo.reset();
    }
    reloadControlAttr() {
        this.reset();
        this.combo.setRepopulate(true);
    }
    setInteractValue(v) {
        this.combo.setRepopulate(true);
        this.setControllerValue(v.value, v.data);
    }
    resize(width, height) {
        const restoreValue = this.combo.getValue();
        super.resize(width, height);
        this.combo.setValue(restoreValue);
    }
    getRequestOpts() {
        const { getWidgetDependenceValueByWidget, getDependenceByWidget, extraOptsGetter } = this.options;
        const dependences = getWidgetDependenceValueByWidget(this);
        return Object.assign({ dependence: dependences, reload: BI.isNotEmptyArray(getDependenceByWidget(this)) }, extraOptsGetter());
    }
    getText() {
        return this.combo.getValue()
            .map(({ text }) => text)
            .join(this.options.delimiter);
    }
    // 自定义js接口，控件内部不允许使用
    get ck_el_array() {
        return this.combo.getAllButtons();
    }
    getAdapter() {
        return this.combo.getAdapter();
    }
    setText(v) {
        this.combo.setText(v);
    }
    setStyle(styles) {
        this.combo.element.addClass(setTagComboCheckboxStyle(styles));
    }
    setPopupStyle(styles) {
        this.options.sonHeight = parseInt(styles.itemHeight, 10);
        this.combo.element.addClass(setTagComboCheckboxPopupStyle(styles));
    }
    setWaterMark(v) {
        this.options.watermark = v;
        this.combo.setWaterMark(v);
    }
    focus() {
        this.combo.focus();
    }
    blur() {
        this.combo.blur();
    }
};
ParameterTagComboCheckboxNext.xtype = 'report.main.parameter_container.controller.tag_combo_checkbox_next';
ParameterTagComboCheckboxNext.BASE_CLS = 'report-main-parameter-container-controller-tag-combo-checkbox';
ParameterTagComboCheckboxNext = ParameterTagComboCheckboxNext_1 = __decorate([
    shortcut()
], ParameterTagComboCheckboxNext);
export { ParameterTagComboCheckboxNext };
//# sourceMappingURL=tag_combo_checkbox_next.js.map