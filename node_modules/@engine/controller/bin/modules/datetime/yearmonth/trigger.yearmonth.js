var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { shortcut } from '@engine/core';
import { MAX_DATE, MIN_DATE } from '../datetime.constants';
const constants = {
    hgap: 4,
    vgap: 2,
    compareFormat: '%Y-%X',
};
let YearMonthTrigger = class YearMonthTrigger extends BI.Trigger {
    constructor() {
        super(...arguments);
        this.props = {
            extraCls: 'bi-year-month-trigger',
            min: MIN_DATE,
            max: MAX_DATE,
            height: 24,
            format: '',
            allowEdit: true, // 是否允许编辑
        };
    }
    render() {
        const { height, allowEdit, watermark } = this.options, { hgap, vgap } = constants;
        this.storeTriggerValue = '';
        return {
            type: BI.AbsoluteLayout.xtype,
            items: [{
                    el: {
                        type: BI.SignEditor.xtype,
                        height,
                        validationChecker: (v) => {
                            const formatStr = this.getStandardDateStr(v);
                            const date = formatStr.match(/\d+/g);
                            return this.dateCheck(formatStr) && BI.checkDateLegal(formatStr) && this.checkVoid({
                                year: (date ? date[0] : undefined) | 0,
                                month: (date ? date[1] : undefined) | 0,
                            });
                        },
                        quitChecker() {
                            return false;
                        },
                        ref: (_ref) => {
                            this.editor = _ref;
                        },
                        hgap,
                        vgap,
                        allowBlank: true,
                        watermark: BI.isKey(watermark) ? watermark : BI.i18nText('BI-Basic_Unrestricted'),
                        title: BI.bind(this.getFormattedTitle, this),
                        listeners: [{
                                eventName: 'EVENT_KEY_DOWN',
                                action: () => {
                                    this.fireEvent('EVENT_KEY_DOWN', arguments);
                                },
                            }, {
                                eventName: 'EVENT_FOCUS',
                                action: () => {
                                    this.storeTriggerValue = this.getKey();
                                    this.fireEvent('EVENT_FOCUS');
                                },
                            }, {
                                eventName: 'EVENT_BLUR',
                                action: () => {
                                    this.fireEvent('EVENT_BLUR');
                                },
                            }, {
                                eventName: 'EVENT_STOP',
                                action: () => {
                                    this.fireEvent('EVENT_STOP');
                                },
                            }, {
                                eventName: 'EVENT_VALID',
                                action: () => {
                                    this.fireEvent('EVENT_VALID');
                                },
                            }, {
                                eventName: 'EVENT_ERROR',
                                action: () => {
                                    this.fireEvent('EVENT_ERROR');
                                },
                            }, {
                                eventName: 'EVENT_CONFIRM',
                                action: () => {
                                    const value = this.editor.getValue();
                                    if (BI.isNotNull(value)) {
                                        this.editor.setState(value);
                                    }
                                    if (BI.isNotEmptyString(value) && !BI.isEqual(this.storeTriggerValue, this.getKey())) {
                                        const formatStr = this.getStandardDateStr(value);
                                        const date = formatStr.match(/\d+/g);
                                        this.storeValue = {
                                            type: BI.DynamicDateCombo.Static,
                                            value: {
                                                year: (date ? date[0] : undefined) | 0,
                                                month: (date ? date[1] : undefined) | 0,
                                            },
                                        };
                                    }
                                    this.fireEvent('EVENT_CONFIRM');
                                },
                            }, {
                                eventName: 'EVENT_START',
                                action: () => {
                                    this.fireEvent('EVENT_START');
                                },
                            }, {
                                eventName: 'EVENT_CHANGE',
                                action: () => {
                                    this.fireEvent('EVENT_CHANGE');
                                },
                            }],
                    },
                    left: 0,
                    right: 24,
                    top: 0,
                    bottom: 0,
                }, {
                    el: {
                        type: BI.Layout.xtype,
                    },
                    width: 24,
                    right: 24,
                    top: 0,
                    bottom: 0,
                }, {
                    el: {
                        type: BI.Text.xtype,
                        invisible: allowEdit,
                        cls: 'show-text',
                        title: BI.bind(this.getFormattedTitle, this),
                        hgap: 4,
                    },
                    left: 0,
                    right: 24,
                    top: 0,
                    bottom: 0,
                }],
        };
    }
    mounted() {
        this.setValue(this.options.value);
    }
    getFormattedTitle() {
        const { type = BI.DynamicDateCombo.Static, value } = this.storeValue || { type: undefined, value: undefined };
        switch (type) {
            case BI.DynamicDateCombo.Dynamic:
                // eslint-disable-next-line no-case-declarations
                const text = this.getDisplayText(value);
                // eslint-disable-next-line no-case-declarations
                const dateStr = BI.print(BI.DynamicDateHelper.getCalculation(value), this.getFormatString());
                return BI.isEmptyString(text) ? dateStr : `${text}:${dateStr}`;
            case BI.DynamicDateCombo.Static:
            default:
                if (BI.isNull(value) || BI.isNull(value.year) || BI.isNull(value.month)) {
                    return '';
                }
                return BI.print(BI.getDate(value.year, value.month - 1, 1), this.getFormatString());
        }
    }
    getStandardDateStr(value) {
        let v = value;
        const { compareFormat } = constants;
        let result = [0, 1];
        const formatArray = this.getFormatString().match(/%./g);
        BI.each(formatArray || [], (idx, v) => {
            switch (v) {
                case '%Y':
                case '%y':
                    result[0] = idx;
                    break;
                case '%X':
                case '%x':
                    result[1] = idx;
                    break;
                default:
                    break;
            }
        });
        // 这边不能直接用\d+去切日期, 因为format格式可能是201906这样的没有分割符的 = =
        // 先看一下是否是合法的, 如果合法就变成标准格式的走原来的流程, 不合法不关心
        const date = BI.parseDateTime(v, this.getFormatString());
        if (BI.print(date, this.getFormatString()) === v) {
            v = BI.print(date, compareFormat);
            result = [0, 1, 2];
        }
        const dateArray = v.match(/\d+/g) || [];
        const newArray = [];
        BI.each(dateArray, idx => {
            newArray[idx] = dateArray[result[idx]];
        });
        // 这边之所以不直接返回join结果是因为年的格式可能只有2位，所以需要format一下
        if (newArray.length === result.length && newArray[0].length === 2) {
            return BI.print(BI.parseDateTime(newArray.join('-'), compareFormat), compareFormat);
        }
        // 这边format成-20-也没关系, 反正都是不合法的
        return newArray.join('-');
    }
    getFormatString() {
        return this.options.format || constants.compareFormat;
    }
    dateCheck(date) {
        return BI.print(BI.parseDateTime(date, '%Y-%x'), '%Y-%x') === date ||
            BI.print(BI.parseDateTime(date, '%Y-%X'), '%Y-%X') === date ||
            BI.print(BI.parseDateTime(date, '%Y-%x'), '%Y-%x') === date ||
            BI.print(BI.parseDateTime(date, '%Y-%X'), '%Y-%X') === date;
    }
    checkVoid(obj) {
        return !BI.checkDateVoid(obj.year, obj.month, 1, this.options.min, this.options.max)[0];
    }
    setInnerValue(date) {
        const dateStr = BI.print(date, this.getFormatString());
        this.editor.setState(dateStr);
        this.editor.setValue(dateStr);
    }
    getDisplayText(obj) {
        let value = '';
        if (BI.isNull(obj)) {
            return value;
        }
        if (BI.isNotNull(obj.year) && BI.parseInt(obj.year) !== 0) {
            value += `${Math.abs(obj.year)}${BI.i18nText('BI-Basic_Year')}${obj.year < 0 ? BI.i18nText('BI-Basic_Front') : BI.i18nText('BI-Basic_Behind')}`;
        }
        if (BI.isNotNull(obj.month) && BI.parseInt(obj.month) !== 0) {
            value += `${Math.abs(obj.month)}${BI.i18nText('BI-Basic_Month')}${obj.month < 0 ? BI.i18nText('BI-Basic_Front') : BI.i18nText('BI-Basic_Behind')}`;
        }
        return value;
    }
    setValue(v) {
        let type = 0, value = undefined;
        let date = BI.getDate();
        this.storeValue = v;
        if (BI.isNotNull(v)) {
            type = v.type || BI.DynamicDateCombo.Static;
            value = v.value;
        }
        switch (type) {
            case BI.DynamicDateCombo.Dynamic:
                date = BI.DynamicDateHelper.getCalculation(value);
                this.setInnerValue(date);
                break;
            case BI.DynamicDateCombo.Static:
            default:
                if (BI.isNull(value) || BI.isNull(value.year) || BI.isNull(value.month)) {
                    this.editor.setState('');
                    this.editor.setValue('');
                }
                else {
                    const dateStr = BI.print(BI.getDate(value.year, value.month - 1, 1), this.getFormatString());
                    this.editor.setState(dateStr);
                    this.editor.setValue(dateStr);
                }
                break;
        }
    }
    setMinDate(minDate) {
        if (BI.isNotEmptyString(this.options.min)) {
            this.options.min = minDate;
        }
    }
    setMaxDate(maxDate) {
        if (BI.isNotEmptyString(this.options.max)) {
            this.options.max = maxDate;
        }
    }
    getKey() {
        return this.editor.getValue();
    }
    getValue() {
        return this.storeValue;
    }
    focus() {
        this.editor.focus();
    }
    blur() {
        this.editor.blur();
    }
    setWaterMark(v) {
        this.editor.setWaterMark(v);
    }
};
YearMonthTrigger.xtype = 'report.components.dynamic_year_month_trigger';
YearMonthTrigger = __decorate([
    shortcut()
], YearMonthTrigger);
export { YearMonthTrigger };
//# sourceMappingURL=trigger.yearmonth.js.map