var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ParameterDatetime_1;
import { shortcut, store } from '@engine/core';
import { AbstractParameterControllerWidget } from '../controller.abstract';
import { HEIGHT, WIDTH } from '../controller.constants';
import { fetchParamDatetimeControlAttr } from '../controller.crud';
import { MAX_DATE, MIN_DATE } from './datetime.constants';
import { ParameterDatetimeModel } from './datetime.model';
import { getControlTypeByFormat, getDateRangeByFormat, setDatetimeComboFontSize, setDatetimeComboPopupStyle, setDatetimeComboStyle, transform2DateComboValue, transformDateMs2String, transformDateValue2DateMs, transformTimeValue2DateMs } from './datetime.service';
import { ReportDate, transformFormat } from './report_date/report_date';
let ParameterDatetime = ParameterDatetime_1 = class ParameterDatetime extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        this.props = {
            baseCls: ParameterDatetime_1.BASE_CLS,
            $testId: ParameterDatetime_1.BASE_CLS,
            widgetName: '',
            width: WIDTH,
            height: HEIGHT,
            format: 'yyyy-MM-dd',
            startDate: MIN_DATE,
            endDate: MAX_DATE,
            returnDate: false,
            value: {
                date_milliseconds: 0,
            },
            directEdit: true,
            disabled: false,
            invisible: false,
            needSubmit: true,
            fontSize: 12,
            allowBlank: true,
            errorMsg: BI.i18nText('Fine-Report_Preview_Can_Not_Null'),
            // REPORT-57309 不显示无限制
            watermark: ' ',
            getDependenceByWidget: () => [],
            getWidgetDependenceValueByWidget: () => {
                return {};
            },
            controlAttrFetcher: fetchParamDatetimeControlAttr,
            extraOptsGetter: () => {
                return {};
            },
            allowBg: true,
            container: undefined,
            isNeedAdjustWidth: true,
        };
    }
    render() {
        const { width, height, value: defaultValue, startDate, endDate, fontSize, format, directEdit, watermark, disabled, allowBg, container } = this.options;
        const reportDate = new ReportDate(defaultValue, format);
        const value = transform2DateComboValue(reportDate, format, startDate, endDate);
        /**
         * 进一步降低defaultValue在控件中的地位，以经过格式化、时间范围检验后的值为准,保证和combo中的值始终一致
         * 修改 https://work.fineres.com/browse/REPORT-74907 引入
         */
        this.store.setValue(value);
        this.reportDate = reportDate;
        return {
            type: BI.VerticalLayout.xtype,
            cls: allowBg ? 'bi-card' : '',
            items: [Object.assign(Object.assign({ width,
                    height,
                    watermark,
                    disabled, type: getControlTypeByFormat(format), supportDynamic: false, cls: `${setDatetimeComboFontSize(ParameterDatetime_1.BASE_CLS, {
                        fontSize, width, height,
                    })}` }, getDateRangeByFormat(startDate, endDate, format)), { format: transformFormat(format), isNeedAdjustWidth: false, value, ref: (_ref) => {
                        this.combo = _ref;
                        this.btn = _ref.element[0];
                    }, behaviors: {
                        highlight: () => false,
                    }, allowEdit: directEdit, container, listeners: [{
                            eventName: 'EVENT_CONFIRM',
                            action: () => {
                                this.hideBubble();
                                this.store.setValue(this.combo.getValue());
                                this.store.setValid(true);
                                const result = !this.silence && this.fireEvent('stopedit');
                                result !== false && this.fireEvent('EVENT_CHANGE');
                            },
                        }, {
                            eventName: 'EVENT_VALID',
                            action: () => {
                                this.store.setValue(this.combo.getValue());
                                this.store.setValid(true);
                                !this.silence && this.model.validOperationCount && this.fireEvent('afteredit');
                                this.store.operationCountUp();
                            },
                        }, {
                            eventName: 'EVENT_ERROR',
                            action: () => {
                                this.store.setValid(false);
                                !this.silence && this.model.validOperationCount && this.fireEvent('afteredit');
                                this.store.operationCountUp();
                            },
                        }, {
                            eventName: 'EVENT_FOCUS',
                            action: () => {
                                this.hideBubble();
                            },
                        }, {
                            eventName: 'EVENT_KEY_DOWN',
                            action: () => {
                                !this.silence && this.fireEvent('afteredit');
                            },
                        }, {
                            eventName: 'EVENT_BLUR',
                            action: () => {
                                this.store.setValue(this.combo.getValue());
                            },
                        }] })],
        };
    }
    getValue() {
        const { format, returnDate } = this.options;
        // 此处结果会有多种结构，分为空string/number/控件object/{date_milliseconds}
        const widgetValue = this.model.value;
        // 空白字符串
        if (this.model.value === '' || BI.isNull(this.model.value)) {
            return '';
        }
        // 纯字符串/纯数字
        if (BI.isString(this.model.value) || BI.isNumber(this.model.value)) {
            return returnDate ? {
                __time__: BI.getDate(this.model.value).getTime(),
            } : this.model.value;
        }
        // {date_milliseconds}
        if (BI.has(this.model.value, 'date_milliseconds')) {
            return returnDate ? {
                __time__: this.model.value.date_milliseconds,
            } : transformDateMs2String(this.model.value.date_milliseconds, format);
        }
        const isOnlyTime = !this.reportDate.isDateFormat && this.reportDate.isTimeFormat && !this.reportDate.isYearFormat;
        const ms = isOnlyTime ? transformTimeValue2DateMs(widgetValue, this.reportDate) : transformDateValue2DateMs(widgetValue);
        const timeStr = transformDateMs2String(ms, format);
        if (returnDate) {
            return {
                __time__: new ReportDate(timeStr, format).getTime(),
            };
        }
        return timeStr;
    }
    preGetValidation() {
        const { allowBlank, value, errorMsg } = this.options;
        if (allowBlank || !BI.isEmpty(value)) {
            return { result: true };
        }
        return {
            result: false,
            errorMsg,
        };
    }
    postGetValidation() {
        const { allowBlank, errorMsg } = this.options;
        const value = this.model.value;
        if (BI.isNull(value) || BI.isEmptyString(value)) {
            return !!allowBlank === true ? {
                result: true,
            } : {
                result: false,
                errorMsg,
            };
        }
        return this.model.valid ? {
            result: true,
        } : {
            result: false,
            errorMsg: BI.i18nText('Fine-Report_Preview_Input_Error'),
        };
    }
    postValidateAndToast() {
        const validation = this.getValidation();
        if (validation.result) {
            return true;
        }
        this.showBubble(validation.errorMsg);
        return false;
    }
    emitManualStopEditEvent() {
        this.fireEvent('stopedit');
    }
    async setControllerValue(v) {
        const { startDate, endDate, format } = this.options;
        const value = BI.isDate(v) ? { date_milliseconds: v.getTime() } : v;
        const reportDate = new ReportDate(value, format);
        const comboValue = transform2DateComboValue(reportDate, format, startDate, endDate);
        this.store.setValue(comboValue);
        this.combo.setValue(comboValue);
    }
    // 类似日期这种需要异步更新数据的控件都返回Promise
    async setInteractValue(v) {
        this.reset();
        const { widgetName, getWidgetDependenceValueByWidget, getDependenceByWidget, extraOptsGetter, controlAttrFetcher } = this.options;
        const dependences = getWidgetDependenceValueByWidget(this);
        if (BI.size(Object.keys(dependences))) {
            const dateRanges = await controlAttrFetcher(widgetName, Object.assign({ dependence: dependences, reload: BI.isNotEmptyArray(getDependenceByWidget(this)) }, extraOptsGetter()));
            const { startDate, endDate } = BI.first(dateRanges);
            this.setMaxAndMinDate({ min: startDate, max: endDate });
            return this.setControllerValue(`${v}`);
        }
    }
    reset() {
        this.combo.setValue();
    }
    resize(width, height) {
        const restoreValue = this.combo.getValue();
        super.resize(width, height);
        this.store.setValue(restoreValue);
        this.combo.setValue(restoreValue);
    }
    getAdapter() {
        return this.combo;
    }
    setStyle(styles) {
        this.combo.element.addClass(setDatetimeComboStyle(styles));
    }
    setPopupStyle(styles) {
        this.combo.element.addClass(setDatetimeComboPopupStyle(styles));
    }
    setWaterMark(v) {
        this.options.watermark = v;
        this.combo.setWaterMark(v);
    }
    setMaxAndMinDate({ max: endDate, min: startDate }) {
        const { format } = this.options;
        /**
         * 修正 https://work.fineres.com/browse/REPORT-79714 引入
         * 应对纯时间型控件不支持setMinDate、setMaxDate方法，简化一下写法
         */
        const { minDate, maxDate } = getDateRangeByFormat(startDate, endDate, format);
        this.combo.setMinDate && this.combo.setMinDate(this.options.startDate = minDate || MIN_DATE);
        this.combo.setMaxDate && this.combo.setMaxDate(this.options.endDate = maxDate || MAX_DATE);
    }
    getText() {
        const value = this.getValue();
        if (BI.isNull(value)) {
            return '';
        }
        if (BI.isNumber(value)) {
            return `${value}`;
        }
        if (BI.isString(value)) {
            return value;
        }
        return new Date(value.__time__).toString();
    }
    focus() {
        this.combo.focus();
    }
    blur() {
        this.combo.blur();
    }
};
ParameterDatetime.xtype = 'report.main.parameter_container.controller.datetime';
ParameterDatetime.BASE_CLS = 'report-main-parameter-container-controller-datetime';
ParameterDatetime = ParameterDatetime_1 = __decorate([
    shortcut(),
    store(ParameterDatetimeModel, {
        props() {
            return {
                value: this.options.value,
            };
        },
    })
], ParameterDatetime);
export { ParameterDatetime };
//# sourceMappingURL=datetime.js.map