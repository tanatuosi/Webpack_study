import { Loading } from '@engine/utils';
import axios from 'axios';
import { AbstractParameterControllerWidget } from '../controller.abstract';
import { getSingleTreeParentValueByValue, getSingleTreePathByValue, getSingleTreeTextByValue, multiAsyncTreeItemsCreator, rebuildAsyncTree, rebuildSyncTree, replaceRedMarkTag, ROOT, singleAsyncTreeItemsCreator, syncTreeItemsCreator, transform2DistinctTreeValues, transformDataItems, transformDoubleArray2SingleArray, transformMultiTree2FormatStringValue, transformMultiTreeInsertComboValue, transformMultiTreeItem2TextValueMap, transformSingleTreeInsertComboValue, transformString2Array, transformString2DoubleArray, transformTreeControlAttr2Items, transformTreeDefaultValue, trasnformTreeControlAttr2TextValueMap, traverseValue, TREE_VIEW_TYPE } from './tree_like.service';
export class ParameterTreeLike extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        /**
         * 单选树自定义的新增值
         */
        this.singleTreeUnexpectedNodes = [];
        this.nodes = [];
        this.textValueMap = {};
        this.singleTreeNotSelectedValue = BI.UUID();
        this.singleTreeNotSelectedNode = {
            checked: false,
            half: false,
            isParent: false,
            halfCheck: false,
            id: BI.UUID(),
            open: false,
            pId: ROOT,
            text: BI.i18nText('BI-Basic_No_Select'),
            times: 0,
            title: BI.i18nText('BI-Basic_No_Select'),
            value: this.singleTreeNotSelectedValue,
            originValue: this.singleTreeNotSelectedValue,
        };
        this.cancelTokenSourceDict = new Map();
    }
    async mounted() {
        super.mounted();
    }
    async updateControllAttr() {
        return this.singleAsyncTreeItemCreator({});
    }
    /**
     * 根据items更新缓存结构
     * @param items ParamMultiTreeItem[]
     */
    updateCacheByItems(items) {
        this.textValueMap = Object.assign(Object.assign({}, this.textValueMap), transformMultiTreeItem2TextValueMap(items));
        this.nodes = this.nodes.concat(items.map(item => {
            return Object.assign(Object.assign({}, item), { text: replaceRedMarkTag(item.text) });
        }));
        items.forEach(item => {
            item.$testId = 'report-main-parameter-container-controller-tree-item';
            item.$value = `${item.pId}`;
        });
    }
    /**
     * 根据数据字典data更新缓存结构
     * @param data 数据字典data
     */
    updateCacheByControlAttrData(data) {
        const { mutiSelection: multiSelection } = this.options;
        this.nodes = [...this.nodes, ...transformDataItems(transformTreeControlAttr2Items(data || [], {
                prefix: multiSelection ? false : '',
            })).map(item => {
                return Object.assign(Object.assign({}, item), { text: replaceRedMarkTag(item.text) });
            })];
        this.textValueMap = Object.assign(Object.assign({}, this.textValueMap), trasnformTreeControlAttr2TextValueMap(data || [], multiSelection ? false : ''));
    }
    /**
     * 根据值计算出数据字典
     * @param value 值
     */
    async updateCacheByValue(value) {
        const data = await this.getInfoByValue(value);
        if (data === null || data === void 0 ? void 0 : data.nodes) {
            this.updateCacheByControlAttrData(data.nodes);
        }
    }
    /**
     * 根据值计算数据字典和 controlData
     * @param value 值
     */
    async getInfoByValue(value) {
        const { mutiSelection: multiSelection } = this.options;
        if (this.isEmptyValue(value)) {
            return;
        }
        const controlData = [];
        const nodes = [];
        if (multiSelection) {
            const values = BI.isString(value)
                ? transformString2DoubleArray(value)
                : BI.isArray(value)
                    ? value
                    : [];
            for (const leaves of values) {
                await this.getOneBranchInfo(leaves)
                    .then(info => {
                    controlData.push(...(info === null || info === void 0 ? void 0 : info.controlData) || []);
                    nodes.push(...(info === null || info === void 0 ? void 0 : info.resultNodes) || []);
                });
            }
        }
        else {
            const val = BI.isString(value)
                ? transformString2Array(value)
                : BI.isArray(value)
                    ? value
                    : [];
            await this.getOneBranchInfo(val)
                .then(info => {
                controlData.push(...(info === null || info === void 0 ? void 0 : info.controlData) || []);
                nodes.push(...(info === null || info === void 0 ? void 0 : info.resultNodes) || []);
            });
        }
        return {
            controlData,
            nodes,
        };
    }
    /**
     * 根据值计算树一个分支的数据字典和controlData
     * @param values 值
     * @returns 数组字典和controlData
     */
    async getOneBranchInfo(values) {
        const { oldTreeControlAttrFetcher, widgetName } = this.options;
        if (this.isEmptyValue(values)) {
            return;
        }
        const controlData = [];
        const resultNodes = [];
        let childNodes = controlData;
        const parentValues = [];
        let parentValue = '', pId = '';
        const setParentState = (targetNode, layerNodes) => {
            parentValue = `${targetNode.value}`;
            pId = `${targetNode.id}`;
            parentValues.push(targetNode.value);
            childNodes.push(...layerNodes);
            targetNode.ChildNodes = [];
            childNodes = targetNode.ChildNodes;
            resultNodes.push(...layerNodes);
        };
        for (const $leaf of values) {
            const leaf = `${$leaf}`;
            const nodes = await oldTreeControlAttrFetcher(widgetName, Object.assign(Object.assign({}, BI.size(parentValues) > 0
                ? {
                    id: pId,
                    value: parentValue,
                    parent_values: parentValues,
                }
                : {}), this.getTreeOptions()));
            const node = nodes.find(node => `${node.value}` === leaf);
            if (!node)
                break;
            setParentState(node, nodes);
        }
        return {
            controlData,
            resultNodes,
        };
    }
    async setControllerValue(v, data = []) {
        const updateData = data;
        await this.getInfoByValue(v)
            .then(info => {
            updateData.push(...(info === null || info === void 0 ? void 0 : info.nodes) || []);
        });
        this.updateCacheByControlAttrData(updateData);
        this.value = transformTreeDefaultValue(v, this.options.mutiSelection, this.options.selectLeafOnly, {
            textValueMap: this.textValueMap,
            nodes: this.nodes,
        });
        this.completeMultiTreeValue = this.value;
        this.setTreeValue(this.value);
    }
    async setValue(v, data) {
        data
            ? this.updateCacheByControlAttrData(data)
            : await this.updateCacheByValue(v);
        this.setControllerValue(v, data);
        this.fireEvent('EVENT_SET_VALUE');
    }
    setTreeValue(v) {
        this.tree.setValue(v);
    }
    getValue() {
        let value = this.completeMultiTreeValue || this.tree.getValue();
        const { mutiSelection: multiSelection, selectLeafOnly, returnFullPath, returnArray, startSymbol = '', endSymbol = '', delimiter } = this.options;
        if (this.isEmptyValue(value)) {
            return '';
        }
        if (BI.isString(value) && !multiSelection) {
            value = [value];
        }
        if (BI.isString(value) || BI.isNull(value)) {
            return value || '';
        }
        if (multiSelection) {
            if (selectLeafOnly) {
                return returnArray ? transformMultiTreeInsertComboValue(value, returnFullPath) : transformMultiTree2FormatStringValue(value, delimiter, startSymbol, endSymbol);
            }
            return returnFullPath ? value : transformDoubleArray2SingleArray(value);
        }
        return transformSingleTreeInsertComboValue(value, returnFullPath);
    }
    async setInteractValue(v) {
        await this.setControllerValue(`${BI.isArray(v.value)
            ? BI.isString(v.value[0])
                ? v.value.join(',')
                : v.value.map(value => value.join(',')).join(';')
            : v.value}`, v.data);
    }
    /**
     * 发送EVENT_CHANGE事件
     */
    fireEventChange() {
        this.fireEvent('EVENT_CHANGE', this.getValue());
    }
    /**
     * 完善异步多选树返回值
     */
    async rebuildAsyncMultiTree(value, fireEvent) {
        this.setShowMask(true);
        const promises = [];
        traverseValue(value)
            .forEach(valueDicts => {
            /**
             * 隐藏bug，如果value有重复，实际上是找不到正确的node的，node还是得根据整体路径去找
             * valueDict里还得扔个路径出来
             * FIXME: 以后有时间再改
             */
            const node = this.nodes
                .slice(0)
                .reverse()
                .find(node => node.value === valueDicts.value);
            if (!node) {
                return;
            }
            promises.push(rebuildAsyncTree(this.options.widgetName, this.options.newTreeStructureFetcher, Object.assign({ value: valueDicts.value, id: node.id }, this.getTreeOptions()), valueDicts.reference));
        });
        return Promise.all(promises)
            .then(data => {
            data.forEach(treeData => this.updateCacheByControlAttrData(treeData.data));
            this.completeMultiTreeValue = value;
            fireEvent && this.fireEventChange();
        })
            .then(() => {
            this.setShowMask(false);
        });
    }
    /**
     * 完善同步多选树返回值
     */
    async rebuildSyncMultiTree(value, fireEvent) {
        this.setShowMask(true);
        await rebuildSyncTree(value, this.options.widgetName, this.options.oldTreeControlAttrFetcher, this.getTreeOptions())
            .then(() => {
            this.completeMultiTreeValue = value;
            fireEvent && this.fireEventChange();
        })
            .then(() => {
            this.setShowMask(false);
        });
    }
    /**
     * rebuildMultiTree前置判断
     * @param v 控件值
     */
    rebuildMultiTreeValidator(v) {
        const { selectLeafOnly, mutiSelection: multiSelection } = this.options;
        if (!selectLeafOnly || !multiSelection) {
            return false;
        }
        if (BI.isEmptyObject(v) || BI.isNull(v) || v === '') {
            this.completeMultiTreeValue = undefined;
            return false;
        }
        return true;
    }
    /**
     * 完善多选树返回值
     * @param v 返回值
     * @param fireEvent 是否发送事件
     */
    async rebuildMultiTree(_v = this.tree.getValue(), fireEvent) {
        const v = BI.deepClone(_v);
        if (!this.rebuildMultiTreeValidator(v)) {
            // REPORT-44591 如果不需要rebuild值，则使用tree的getValue值，所以需要置空completeMultiTreeValue
            this.completeMultiTreeValue = undefined;
            fireEvent && this.fireEventChange();
            return;
        }
        this.isAsyncTree() ? await this.rebuildAsyncMultiTree(v, fireEvent) : await this.rebuildSyncMultiTree(v, fireEvent);
    }
    /**
     * 同步树的itemCreator
     */
    syncTreeItemCreator() {
        const { mutiSelection: multiSelection } = this.options;
        return multiSelection ? this.multiSyncTreeItemCreator() : this.singleSyncTreeItemCreator();
    }
    /**
     * 多选异步树的itemCreator
     * @param op options
     */
    async multiAsyncTreeItemCreator(op) {
        const { widgetName, newTreeControlAttrFetcher } = this.options;
        const treeViewType = op.type || TREE_VIEW_TYPE;
        // 合并值的返回请求
        if (treeViewType === BI.TreeView.REQ_TYPE_ADJUST_DATA || treeViewType === BI.TreeView.REQ_TYPE_SELECT_DATA) {
            this.setShowMask(true);
        }
        const cancelTokenSource = this.cancelTokenSourceDict.get(treeViewType);
        if (cancelTokenSource) {
            cancelTokenSource.cancel();
            this.cancelTokenSourceDict.delete(treeViewType);
        }
        return multiAsyncTreeItemsCreator(newTreeControlAttrFetcher, Object.assign(Object.assign(Object.assign({}, op), { widgetName }), this.getTreeOptions(treeViewType)))
            .then(data => {
            this.setShowMask(false);
            if (Array.isArray(data.items)) {
                this.updateCacheByItems(data.items);
                return data;
            }
            this.cancelTokenSourceDict.delete(treeViewType);
            return data.items;
        });
    }
    /**
     * 单选同步树的itemCreator
     */
    async singleSyncTreeItemCreator() {
        const { widgetName, oldTreeControlAttrFetcher, allowBlank } = this.options;
        return syncTreeItemsCreator(oldTreeControlAttrFetcher, Object.assign(Object.assign({ widgetName }, this.getTreeOptions()), { prefix: '' }))
            .then(data => {
            data.items = transform2DistinctTreeValues(transformDataItems(data.items, {}));
            if (!this.isTreeWidget() && allowBlank) {
                data.items.unshift(this.singleTreeNotSelectedNode);
            }
            data.items.push(...this.singleTreeUnexpectedNodes);
            this.updateCacheByItems(data.items);
            return data;
        });
    }
    /**
     * 多选同步树的itemCreator
     */
    async multiSyncTreeItemCreator() {
        const { widgetName, oldTreeControlAttrFetcher } = this.options;
        return syncTreeItemsCreator(oldTreeControlAttrFetcher, Object.assign({ widgetName }, this.getTreeOptions()))
            .then(data => {
            data.items = transform2DistinctTreeValues(transformDataItems(data.items, {}));
            this.updateCacheByItems(data.items);
            return data;
        });
    }
    /**
     * 单选异步树的itemCreator
     * @param op options
     */
    async singleAsyncTreeItemCreator(op) {
        const { widgetName, oldTreeControlAttrFetcher, allowBlank } = this.options;
        const treeViewType = op.type || TREE_VIEW_TYPE;
        const cancelTokenSource = this.cancelTokenSourceDict.get(treeViewType);
        if (cancelTokenSource) {
            cancelTokenSource.cancel();
            this.cancelTokenSourceDict.delete(treeViewType);
        }
        return singleAsyncTreeItemsCreator(oldTreeControlAttrFetcher, Object.assign(Object.assign(Object.assign({}, op), { widgetName }), this.getTreeOptions(treeViewType)))
            .then(data => {
            data.items = transformDataItems(data.items, op);
            const pId = BI.get(op, 'node.id', ROOT);
            this.singleTreeUnexpectedNodes.forEach(singleTreeDefaultNode => {
                if (pId === singleTreeDefaultNode.pId) {
                    data.items.push(singleTreeDefaultNode);
                }
            });
            if (!this.isTreeWidget() && !BI.get(op, 'node') && !BI.get(op, 'keyword') && allowBlank) {
                data.items.unshift(this.singleTreeNotSelectedNode);
            }
            this.updateCacheByItems(data.items);
            this.cancelTokenSourceDict.delete(treeViewType);
            return data;
        });
    }
    /**
     * 获取树请求属性
     */
    getTreeOptions(treeViewType = TREE_VIEW_TYPE) {
        var _a;
        const { getWidgetDependenceValueByWidget, getDependenceByWidget, extraOptsGetter } = this.options;
        const dependence = getWidgetDependenceValueByWidget(this);
        const reload = BI.isNotEmptyArray(getDependenceByWidget(this));
        this.cancelTokenSourceDict.set(treeViewType, axios.CancelToken.source());
        return Object.assign(Object.assign({ dependence,
            reload }, extraOptsGetter()), { cancelToken: (_a = this.cancelTokenSourceDict.get(treeViewType)) === null || _a === void 0 ? void 0 : _a.token });
    }
    preGetValidation() {
        const { allowBlank, value, errorMsg } = this.options;
        return allowBlank || !BI.isEmpty(value) ? {
            result: true,
        } : {
            result: false,
            errorMsg,
        };
    }
    /**
     * 处理单选下的同步树
     */
    transformSyncSingleTreeItem(items) {
        if (!this.isAsyncTree() && !this.options.mutiSelection && this.options.async) {
            const path = getSingleTreePathByValue(this.value);
            items.forEach(item => {
                if (path.includes(item.value)) {
                    item.open = true;
                }
            });
        }
        return items;
    }
    postGetValidation(value = this.tree.getValue()) {
        const { allowBlank, errorMsg, customData, needCheckCustomData } = this.options;
        if (this.isEmptyValue(value)) {
            return allowBlank ? {
                result: true,
            } : {
                result: false,
                errorMsg,
            };
        }
        return !customData && needCheckCustomData
            ? this.validateCustomData(value)
            : { result: true };
    }
    postValidateAndToast() {
        const validation = this.getValidation();
        if (validation.result) {
            return true;
        }
        this.showBubble(validation.errorMsg);
        return false;
    }
    /**
     * 校验新增值，不包括校验为空，需要保证传值不能为空
     * @param value
     */
    validateCustomData(value) {
        const { mutiSelection: multiSelection, selectLeafOnly } = this.options;
        const leaves = [];
        if (!multiSelection) {
            // 单选只有一个值
            leaves.push(BI.isString(value) ? value : BI.first(value));
        }
        else {
            const arr = selectLeafOnly
                ? transformMultiTreeInsertComboValue(value, true)
                : value;
            arr.forEach(path => {
                path.forEach(leaf => {
                    leaves.push(leaf);
                });
            });
        }
        const validation = leaves.every(leaf => leaf in this.textValueMap);
        return validation
            ? { result: true }
            : { result: false, errorMsg: BI.i18nText('Fine-Report_Preview_Not_In_List') };
    }
    /**
     * 值是否为空
     * @param value
     */
    isEmptyValue(value) {
        // value可能值为 {} undefined []
        if (BI.isEmpty(value)) {
            return true;
        }
        // 单选树空值情况
        // REPORT-44191不选时有可能返回[undefined]和[null]和['']
        // TODO 后面要在看看这个问题
        if (BI.isEqual(value, [this.singleTreeNotSelectedValue]) ||
            BI.isEqual(value, [undefined]) ||
            BI.isEqual(value, [null]) ||
            BI.isEqual(value, [''])) {
            return true;
        }
        return false;
    }
    /**
     * 是否是异步构建的树
     */
    isAsyncTree() {
        const { async, isLayerBuild } = this.options;
        /**
         * Tips: isLayerBuild是单独为极速分层构建做的一个标识
         * 后端逻辑目前是只有极速分层构建树是特殊的
         */
        return !isLayerBuild && async;
    }
    reset() {
        const { mutiSelection: multiSelection, selectLeafOnly } = this.options;
        // reset之后提交，不置空的话会出现异常
        this.completeMultiTreeValue = undefined;
        multiSelection
            ? selectLeafOnly
                ? this.setTreeValue({})
                : this.setTreeValue([])
            : this.setTreeValue(['']);
    }
    /**
     * 展示loading遮罩
     * @param showMask 是否展示loading遮罩
     */
    setShowMask(showMask) {
        if (!showMask) {
            this.mask && this.mask.invisible();
            return;
        }
        if (!this.mask) {
            BI.createWidget({
                type: BI.AbsoluteLayout.xtype,
                element: 'body',
                items: [{
                        el: {
                            type: Loading.xtype,
                            cls: 'transparent mask',
                            ref: (_ref) => {
                                this.mask = _ref;
                            },
                            listeners: [{
                                    eventName: BI.Events.MOUNT,
                                    action: () => {
                                        this.mask.element.mousedown((e) => {
                                            e.stopEvent();
                                        });
                                    },
                                }],
                        },
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                    }],
            });
        }
        this.mask.visible();
    }
    /**
     * 转换单选树的值，不存在的话添加到node中
     * @param defaultValue 默认值
     * @param isParent 是否是父节点
     */
    transformSingleTreeValue2Node(defaultValue, isParent = false) {
        const node = this.nodes.find(node => node.value === defaultValue);
        // 找得到该节点的话就不需要额外操作
        if (node) {
            return node;
        }
        const text = getSingleTreeTextByValue(defaultValue);
        const parentValue = getSingleTreeParentValueByValue(defaultValue);
        const pId = BI.isEmptyString(parentValue) ? ROOT : this.transformSingleTreeValue2Node(parentValue, true).id;
        const unexpectedNode = {
            checked: false,
            half: false,
            halfCheck: false,
            id: BI.UUID(),
            isParent,
            open: false,
            pId,
            text,
            times: 0,
            title: text,
            value: defaultValue,
            originValue: defaultValue,
        };
        this.nodes.push(unexpectedNode);
        this.singleTreeUnexpectedNodes.push(unexpectedNode);
        return unexpectedNode;
    }
    resize(width, height) {
        const restoreValue = this.tree.getValue();
        const state = this.isEnabled();
        if (this.preResize(width, height)) {
            this.tree.setValue(restoreValue);
            /**
             * REPORT-77208 下拉同步树的mounted时会拿value去setValue
             */
            this.value = restoreValue;
            this.setEnable(state);
        }
    }
}
//# sourceMappingURL=tree_like.js.map