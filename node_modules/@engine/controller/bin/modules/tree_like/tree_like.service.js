var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { transform2DistinctValueByValues } from '../controller.service';
import { SyncTree } from './tree/sync_tree/sync_tree';
import { ListSyncTree } from './tree/sync_tree/list_sync_tree';
export const ROOT = '__root__';
export const TREE_VIEW_TYPE = 'PULL_DATA';
const SPLITOR = '__splitor__';
const LAYER_SPLITOR = /;|；/g;
const LEAF_SPLITOR = /,|，/g;
/**
 * 多选树控件的itemCreator
 * @param op ootions
 */
export async function multiAsyncTreeItemsCreator(requestor, op) {
    const { reload, widgetName, dependence, checkState, id, parentValues = [], selectedValues, keyword, type, floors, notSelectedValue, cancelToken } = op, opts = __rest(op, ["reload", "widgetName", "dependence", "checkState", "id", "parentValues", "selectedValues", "keyword", "type", "floors", "notSelectedValue", "cancelToken"]);
    return requestor(widgetName, Object.assign({ dependence,
        reload,
        id, value: BI.last(parentValues), parent_values: parentValues, notSelectedValue,
        selectedValues,
        type,
        parentValues, filter: keyword, checkState,
        floors }, opts), cancelToken)
        .then(data => data[0] || {
        items: [],
        resultType: '',
        hasNext: false,
    });
}
/**
 * 单选树控件的itemCreator
 * @param op ootions
 */
export async function singleAsyncTreeItemsCreator(requestor, op) {
    const { reload, widgetName, dependence, node = {}, keyword, cancelToken } = op, opts = __rest(op, ["reload", "widgetName", "dependence", "node", "keyword", "cancelToken"]);
    return requestor(widgetName, Object.assign({ id: node.id, value: getSingleTreeTextByValue(node.value || ''), filter: keyword, dataFilter: keyword, fine_outlet_widget: keyword ? 'nx' : undefined, dependence, parent_values: node.value ? transformString2Array(node.value) : undefined, reload }, opts), cancelToken)
        .then(data => {
        const items = transformTreeControlAttr2Items(data, {
            pId: node.id,
            // 搜索时，获取到的是整棵树的items且node属性为空，这时需要区别化节点值，所以要加上prefix
            prefix: keyword ? '' : false,
        });
        return {
            items,
            hasNext: false,
        };
    });
}
/**
 * 同步树控件的itemCreator
 * @param op ootions
 */
export async function syncTreeItemsCreator(requestor, op) {
    const { reload, widgetName, dependence, keyword, prefix } = op, opts = __rest(op, ["reload", "widgetName", "dependence", "keyword", "prefix"]);
    return requestor(widgetName, Object.assign({ filter: keyword, dependence,
        reload }, opts))
        .then(data => {
        const items = transformTreeControlAttr2Items(data, {
            prefix,
        });
        return {
            items,
            hasNext: false,
        };
    });
}
/**
 * 获取渲染的layout
 * @param multiSelection 是否多选
 * @param selectLeafOnly 叶子节点与子节点是否互相影响
 * @param async 是否同步
 */
export function getParamTreeComboBoxLayout(multiSelection, selectLeafOnly, async, customData) {
    return multiSelection
        ? async
            ? selectLeafOnly
                ? customData
                    ? BI.MultiTreeInsertCombo.xtype
                    : BI.MultiTreeCombo.xtype
                : BI.MultiTreeListCombo.xtype
            : selectLeafOnly
                ? customData
                    ? BI.TreeValueChooserInsertCombo.xtype
                    : BI.TreeValueChooserCombo.xtype
                : BI.ListTreeValueChooserInsertCombo.xtype
        : selectLeafOnly
            ? BI.MultiLayerSingleTreeCombo.xtype
            : BI.MultiLayerSelectTreeCombo.xtype;
}
/**
 * 获取树控件渲染的layout
 * @param multiSelection 是否多选
 * @param selectLeafOnly 叶子节点与子节点是否互相影响
 * @param async 是否异步
 */
export function getParamTreeLayout(multiSelection, selectLeafOnly, async) {
    return multiSelection
        ? selectLeafOnly
            ? async ? BI.AsyncTree.xtype : SyncTree.xtype
            : async ? BI.ListAsyncTree.xtype : ListSyncTree.xtype
        : selectLeafOnly
            ? BI.MultiLayerSingleTreePopup.xtype
            : BI.MultiLayerSelectTreePopup.xtype;
}
/**
 * 将树的data转换为渲染的items
 * @param data 树的data
 * @param opt 额外属性
 * @param opt.pId 父级pId
 * @param opt.times 分层页数
 */
export function transformTreeControlAttr2Items(data = [], opts = {}) {
    const { pId = ROOT, times = 0, prefix = false, } = opts;
    const items = [];
    (data || []).forEach(dataItem => {
        const item = {
            checked: dataItem.checkstate === 1,
            half: false,
            halfCheck: false,
            id: dataItem.id,
            isParent: dataItem.hasChildren,
            open: dataItem.isexpand,
            pId,
            // 传''的时候会去显示实际值
            text: dataItem.text || '\u200b',
            times,
            // 传''的时候会去显示实际值
            title: dataItem.text || '\u200b',
            value: prefix ? `${prefix}${SPLITOR}${dataItem.value}` : dataItem.value,
        };
        items.push(item);
        if (dataItem.ChildNodes && dataItem.ChildNodes.length > 0) {
            items.push(...transformTreeControlAttr2Items(dataItem.ChildNodes, Object.assign(Object.assign({}, opts), { pId: dataItem.id, prefix: prefix === false ? false : item.value })));
        }
    });
    return items;
}
/**
 * 填满树，将Fineui控件中的树结构拓展至叶节点
 * @param value 多选树控件值
 */
export async function rebuildAsyncTree(widgetName, requestor, op, valueReference = {}) {
    return requestor(widgetName, op)
        .then(data => {
        traverseFillValue(data, valueReference);
        return {
            valueReference,
            data,
        };
    });
}
/**
 * 根据值遍历填充树
 * @param data data数组
 * @param valueReference 值引用
 */
export function traverseFillValue(data, valueReference) {
    (data || [])
        .forEach(item => {
        valueReference[item.value] = {};
        if (item.hasChildren) {
            traverseFillValue(item.ChildNodes, valueReference[item.value]);
        }
    });
}
/**
 * 找到需要format的value值
 * @param value 树控件类型值
 * @param path 值路径
 */
export function traverseValue(value, path = [ROOT]) {
    return Object.keys(value)
        .reduce((result, v) => {
        if (BI.isEmptyObject(value[v])) {
            result.push({
                value: v,
                reference: value[v],
                path,
            });
        }
        else {
            result.push(...traverseValue(value[v], path.concat(v)));
        }
        return result;
    }, []);
}
/**
 * 填满树，将Fineui控件中的树结构拓展至叶节点
 * @param value 多选树控件值
 * @widgeName 控件名
 * @op 查询参数
 * @_data 子节点们
 */
export async function rebuildSyncTree(value, widgetName, requestor, op, _data) {
    const data = !_data ? await requestor(widgetName, op) : _data;
    const valueKeys = Object.keys(value);
    if (valueKeys.length === 0) {
        for (const item of data) {
            value[item.value] = {};
            if (item.hasChildren) {
                await rebuildSyncTree(value[item.value], widgetName, requestor, op, item.ChildNodes);
            }
        }
    }
    for (const item of data) {
        if (!valueKeys.includes(item.value)) {
            continue;
        }
        if (item.hasChildren) {
            await rebuildSyncTree(value[item.value], widgetName, requestor, op, item.ChildNodes);
        }
    }
    return value;
}
export function transformMultiTreeInsertComboValue(v, returnFullPath) {
    return returnFullPath
        ? transformMultiTreeValue2DoubleArray(v)
        : transformMultiTreeValue2SingleArray(v);
}
/**
 * 将多选树的值转换成用特定分割符起始符的字符串
 * @param v 树控件值
 * @param delimiter
 * @param startSymbol
 * @param endSymbol
 * @returns
 */
export function transformMultiTree2FormatStringValue(v, delimiter, startSymbol, endSymbol) {
    const value = transformDoubleArray2SingleArray(transformMultiTreeValue2DoubleArray(v));
    return `${startSymbol}${value.join(delimiter)}${endSymbol}`;
}
/**
 * 转换单选树控件输出值
 * @param v 树控件值
 * @param returnFullPath 返回完整路径
 */
export function transformSingleTreeInsertComboValue(v, returnFullPath) {
    const value = completeSingleTreeValue(v);
    return returnFullPath
        ? value
        : [BI.last(value || [])];
}
/**
 * 根据值取得完整路径
 * @param v 单选树的值
 */
export function completeSingleTreeValue(v) {
    if (BI.isEmptyArray(v)) {
        return undefined;
    }
    const nodeValue = BI.last(v);
    if (!nodeValue) {
        return undefined;
    }
    return transformString2Array(nodeValue);
}
/**
 * 根据op转换值，值上拼上全路径
 * @param item 树item
 * @param op options
 */
function modifySingleTreeItemValue(item, op) {
    if (!op.node) {
        return item.value;
    }
    let value = item.value;
    let parentNode = op.node;
    while (parentNode) {
        value = `${parentNode.originValue}${SPLITOR}${value}`;
        parentNode = parentNode.pNode;
    }
    return value;
}
/**
 * 将树结构转换为二维数组
 * @param v 树结构
 * @param parentValues 祖先数组
 */
export function transformMultiTreeValue2DoubleArray(v, parentValues = []) {
    return Object.keys(v)
        .reduce((prev, key) => {
        if (Object.keys(v[key]).length === 0) {
            prev.push([...parentValues, key]);
            return prev;
        }
        return prev.concat(transformMultiTreeValue2DoubleArray(v[key], [...parentValues, key]));
    }, []);
}
/**
 * 将树结构转换为一维数组
 * @param v 树结构
 */
export function transformMultiTreeValue2SingleArray(v) {
    return transformDoubleArray2SingleArray(transformMultiTreeValue2DoubleArray(v));
}
/**
 * 取二维数组的最后一位拼成新数组
 * @param arr 二维数组
 */
export function transformDoubleArray2SingleArray(arr) {
    return arr.map(arr => arr[arr.length - 1]);
}
/**
 * string转二维数组
 * @param str 字符串
 */
export function transformString2DoubleArray(str) {
    return str.split(LAYER_SPLITOR)
        .map(leaves => leaves.split(LEAF_SPLITOR));
}
/**
* string转一维数组
* @param str 字符串
*/
export function transformString2Array(str) {
    return str.split(SPLITOR);
}
export function transformTreeDefaultValue($v, multiSelection, selectLeafOnly, opts) {
    const v = BI.isNumber($v) ? `${$v}` : $v;
    if (v === '' || BI.isNull(v) || BI.isEmptyObject(v)) {
        return undefined;
    }
    if (BI.isString(v)) {
        return multiSelection
            ? selectLeafOnly
                ? transformMultiTreeDefaultValue(v, opts.textValueMap)
                : transformMultiLeafTreeDefaultValue(v, opts.textValueMap)
            : transformSingleTreeDefaultValue(v, opts.nodes);
    }
    if (!multiSelection) {
        return transformTreeDefaultValue(v.join(SPLITOR), multiSelection, selectLeafOnly, opts);
    }
    if (!selectLeafOnly) {
        return v.reduce((result, value) => {
            result.push(...transformTreeDefaultValue(`${value}`, multiSelection, selectLeafOnly, opts));
            return result;
        }, []);
    }
    return v.reduce((result, value) => BI.deepExtend({}, result, transformTreeDefaultValue(`${value}`, multiSelection, selectLeafOnly, opts)), {});
}
/**
 * 转换string类型成多选树控件类型
 * @param v 默认值
 * @param valueTextMap key为默认值/实际值
 */
export function transformMultiTreeDefaultValue(v, textValueMap = {}) {
    // 分层
    const layers = splitValue(v);
    return layers.reduce((result, layer) => {
        let current = result;
        layer
            .split(LEAF_SPLITOR)
            .forEach(_leaf => {
            const leaf = _leaf in textValueMap ? textValueMap[_leaf] : _leaf;
            if (!current[leaf]) {
                current[leaf] = {};
            }
            current = current[leaf];
        });
        return result;
    }, {});
}
/**
 * 转换string类型成多选树（叶子）控件类型
 * @param v 默认值
 * @param valueTextMap key为默认值/实际值
 */
function transformMultiLeafTreeDefaultValue(v, textValueMap = {}) {
    // 分层
    const layers = splitValue(v);
    return layers.reduce((result, layer) => {
        result.push(layer.split(LEAF_SPLITOR).map(leaf => leaf in textValueMap ? textValueMap[leaf] : leaf));
        return result;
    }, []);
}
/**
 * 转换string类型成单选控件类型
 * @param v 默认值
 */
function transformSingleTreeDefaultValue(v, nodes) {
    // 分层
    const layer = v.split(LAYER_SPLITOR)[0];
    let result = [];
    layer
        .split(',')
        .reduce((pId, leaf) => {
        const node = nodes.find(node => node.pId === pId && (node.value === leaf || node.text === leaf));
        if (node) {
            result = [node.value];
        }
        else {
            result.push(leaf);
        }
        return node === null || node === void 0 ? void 0 : node.id;
    }, ROOT);
    return result.join(SPLITOR);
}
/**
 * 转换树控件item的value
 * @param items 树控件的items
 */
export function transformDataItems(items, op = {}) {
    items.forEach(item => {
        item.originValue = item.value;
        item.value = modifySingleTreeItemValue(item, op);
    });
    return items;
}
/**
 * 转树的数据字典到map
 * @param data 树的数据字典
 */
export function trasnformTreeControlAttr2TextValueMap(data, prefix) {
    return (data || []).reduce((map, item) => {
        const text = replaceRedMarkTag(`${item.text}`);
        const value = prefix ? `${prefix}${SPLITOR}${item.value}` : `${item.value}`;
        if (!(text in map)) {
            map[text] = value;
        }
        map[value] = value;
        if (item.hasChildren) {
            return Object.assign(Object.assign({}, map), trasnformTreeControlAttr2TextValueMap(item.ChildNodes, prefix === false ? false : value));
        }
        return map;
    }, {});
}
/**
 * 转换fineui的tree items成textValueMap
 * @param items fineui的tree items
 */
export function transformMultiTreeItem2TextValueMap(items) {
    return items.reduce((map, item) => {
        const text = replaceRedMarkTag(`${item.text}`);
        const value = `${item.value}`;
        if (!(text in map)) {
            map[text] = value;
        }
        map[value] = value;
        return map;
    }, {});
}
/**
 * 校验是否有额外的值传入
 * @param value 值
 * @param valueTextMap 字典
 */
export function validateTreeCustomData(controlAttr, prefix) {
    if (controlAttr.value === '') {
        return true;
    }
    const textValueMap = trasnformTreeControlAttr2TextValueMap(controlAttr.data, prefix);
    const leaves = splitValue(`${controlAttr.value}`)
        .reduce((result, layer) => {
        result.push(...layer.split(LEAF_SPLITOR));
        return result;
    }, []);
    const validation = BI.isNotNull(controlAttr.data)
        && leaves.every(leaf => leaf in textValueMap);
    if (!validation) {
        BI.Msg.toast(BI.i18nText('Fine-Report_Preview_Not_In_List'), { level: 'error' });
    }
    return validation;
}
/**
 * 去掉text中的标红span标签
 * @param text 文字
 */
export function replaceRedMarkTag(text) {
    // 只转化span标签而非替换全部 <>
    return BI.replaceAll(`${text}`.replace(/<\/?span.*?>/g, ''), '&nbsp;', ' ');
}
/**
 * 根据；切割值
 * @param value 值
 */
function splitValue(value) {
    const layers = value.split(LAYER_SPLITOR);
    // 去掉多余的空白
    if (BI.size(layers) > 1 && BI.last(layers) === '') {
        layers.pop();
    }
    return layers;
}
/**
 * 根据现在单选树的值获取其父亲的值
 * @param value 当前值
 */
export function getSingleTreeParentValueByValue(value) {
    return value
        .split(SPLITOR)
        .slice(0, -1)
        .join(SPLITOR);
}
/**
 * 根据现在单选树的值获取其显示值
 * @param value 当前值
 * @param nodes 单选树nodeList
 */
export function getSingleTreeTextByValue(value, nodes) {
    if (!value) {
        return '';
    }
    const leaf = BI.last(transformString2Array(value));
    const node = nodes === null || nodes === void 0 ? void 0 : nodes.find(node => BI.last(transformString2Array(node.value)) === leaf);
    return (node === null || node === void 0 ? void 0 : node.text) || leaf;
}
/**
 * 根据值获取单选树的完整路径，比如A_spilitor_B_spilitor_C，返回[A, A_spilitor_B, A_spilitor_B_spilitor_C]
 * @param value 控件值
 */
export function getSingleTreePathByValue(value) {
    if (!value) {
        return [];
    }
    return transformString2Array(value)
        .reduce((result, current) => {
        result.push(result.length === 0 ? current : `${BI.last(result)}${SPLITOR}${current}`);
        return result;
    }, []);
}
/**
 * 将已有值转换为唯一值
 * @param items 已有值
 */
export function transform2DistinctTreeValues(items) {
    const values = {};
    return items.map(item => {
        if (!values[item.pId]) {
            values[item.pId] = [];
        }
        const value = transform2DistinctValueByValues(item.value, values[item.pId]);
        values[item.pId].push(value);
        return Object.assign(Object.assign({}, item), { value });
    });
}
//# sourceMappingURL=tree_like.service.js.map