var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { WIDTH, HEIGHT } from '../controller.constants';
import { setStyles, transform2KeyCode } from './button.service';
import { shortcut, getIconCls } from '@engine/core';
import { AbstractParameterControllerWidget } from '../controller.abstract';
let ParameterButton = class ParameterButton extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        this.btnCls = `report-main-parameter-container-controller-button-${BI.UUID()}`;
        this.props = {
            baseCls: 'report-main-parameter-container-controller-button',
            width: WIDTH,
            height: HEIGHT,
            text: '',
            value: '',
            xtype: 'button',
            hotkeys: '',
            isToggle: false,
            isCustomStyle: false,
            icon: '',
            initial: undefined,
            over: undefined,
            click: undefined,
            disabled: false,
            invisible: false,
            needSubmit: false,
            fontSize: 12,
            color: '',
            fontweight: '',
            fontfamily: '',
            decoration: '',
            fontstyle: undefined,
            $testId: 'report-main-parameter-container-controller-button',
            widgetName: '',
            allowBg: true,
        };
    }
    mounted() {
        var _a;
        const { hotkeys: $hotkeys } = this.options;
        !this.silence && this.fireEvent('afterinit');
        this.button.text.setStyle({
            'text-overflow': 'clip',
        });
        const hotkeys = $hotkeys.trim().split('+');
        (_a = this.keydownListener) === null || _a === void 0 ? void 0 : _a.remove();
        this.keydownListener = BI.EventListener.listen(document, 'keydown', BI.debounce((evt) => {
            // 非组合键
            // 屏蔽操作放在其它控件中，本地监控全局
            /* if (evt.target !== document.body) {
                return;
            } */
            if (BI.isEmptyString($hotkeys)) {
                return;
            }
            if (BI.size(hotkeys) === 1) {
                const code = transform2KeyCode(BI.first(hotkeys));
                (BI.isArray(code) && code.indexOf(evt.keyCode) !== -1
                    || evt.keyCode === code) && this.doClick();
                return;
            }
            // 组合键
            const keys = [evt.keyCode];
            evt.ctrlKey || evt.metaKey
                ? keys.unshift('ctrl')
                : evt.altKey
                    ? keys.unshift('alt')
                    : evt.shiftKey
                        ? keys.unshift('shift')
                        : null;
            if (keys.length === 1) {
                return;
            }
            // 暂时不支持组合键里面带数字的情况，后续拓展的话这里也要适配
            BI.isEqual([hotkeys[0], transform2KeyCode(hotkeys[1])], keys) && this.doClick();
        }, 300));
    }
    render() {
        const { iconInfo, fontSize, fontweight, fontfamily, width, height, text, color, decoration, initial, click, over, fontstyle, xtype, widgetName } = this.options;
        const btnCls = this.btnCls;
        if (xtype === 'freebutton') {
            setStyles({
                fontSize,
                color,
                fontWeight: fontweight,
                fontFamily: fontfamily,
                decoration,
                initial,
                click,
                hover: over,
                fontStyle: fontstyle,
            }, btnCls);
        }
        else {
            setStyles({
                fontSize,
                initial: {
                    background: 'inhreit',
                },
            }, btnCls);
        }
        const iconAttrs = !iconInfo
            ? {}
            : {
                iconCls: getIconCls(iconInfo),
                iconWidth: 16,
            };
        return Object.assign(Object.assign({ type: BI.Button.xtype, ref: (_ref) => {
                this.button = _ref;
            }, cls: `button ${btnCls}`, attributes: {
                id: `fr-btn-${widgetName}`,
            } }, iconAttrs), { level: 'common', width, textWidth: width, height,
            text, minWidth: 0, block: xtype === 'freebutton', listeners: [{
                    eventName: BI.Button.EVENT_CHANGE,
                    action: () => {
                        !this.silence && this.fireEvent('click');
                    },
                }] });
    }
    preGetValidation() {
        return {
            result: true,
        };
    }
    postGetValidation() {
        return {
            result: true,
        };
    }
    postValidateAndToast() {
        return true;
    }
    getValue() {
        return this.button.getText();
    }
    getText() {
        return this.button.getText();
    }
    reset() {
        this.button.setText(this.options.text);
    }
    /**
     * 公开对外接口，使可触发button的click
     */
    doClick() {
        BI.delay(() => {
            this.button.doClick();
        }, BI.EVENT_RESPONSE_TIME * 2);
    }
    async setControllerValue(v) {
        if (BI.isNull(v) || BI.isEmptyString(v)) {
            return;
        }
        this.button.setText(v);
    }
    setInteractValue(v) {
        this.setControllerValue(v);
    }
    setFontSize(fontSize) {
        this.options.fontSize = fontSize;
    }
    setStyle(styles) {
        setStyles(styles, this.btnCls);
    }
};
ParameterButton.xtype = 'report.main.parameter_container.controller.button';
ParameterButton = __decorate([
    shortcut()
], ParameterButton);
export { ParameterButton };
//# sourceMappingURL=button.js.map