var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ParameterCheckboxGroup_1;
import { WIDTH, HEIGHT } from '../controller.constants';
import { getWidthPropByAdaptive, setFontSize, transformControlAttrData } from '../controller.service';
import { transformValue2CheckGroupValue, transformItems2Selected, setCheckboxGroupStyle } from './check_group.service';
import { shortcut } from '@engine/core';
import { ReportMultiSelectItem } from '../components/multiselect_item/multiselect_item';
import { AbstractParameterControllerWidget } from '../controller.abstract';
import { fetchParamControlAttr } from '../controller.crud';
let ParameterCheckboxGroup = ParameterCheckboxGroup_1 = class ParameterCheckboxGroup extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        this.selectedAllValue = BI.UUID();
        this.selectedAllItem = {
            text: BI.i18nText('BI-Select_All'),
            value: this.selectedAllValue,
        };
        this.props = {
            baseCls: ParameterCheckboxGroup_1.BASE_CLS,
            $testId: ParameterCheckboxGroup_1.BASE_CLS,
            widgetName: '',
            width: WIDTH,
            height: HEIGHT,
            adaptive: false,
            columnsInRow: 1,
            controlAttr: {
                data: [],
                value: '',
            },
            customData: true,
            directEdit: true,
            autoMode: true,
            mode: 'remote',
            searchTime: 200,
            chooseAll: false,
            noRepeat: true,
            needSubmit: false,
            disabled: false,
            invisible: false,
            fontSize: 12,
            value: '',
            delimiter: ',',
            startSymbol: '',
            endSymbol: '',
            returnArray: false,
            allowBlank: true,
            errorMsg: BI.i18nText('Fine-Report_Preview_Can_Not_Null'),
            controlAttrFetcher: fetchParamControlAttr,
            extraOptsGetter: () => {
                return {};
            },
            getDependenceByWidget: () => [],
            getWidgetDependenceValueByWidget: () => {
                return {};
            },
            allowBg: true,
        };
    }
    render() {
        const { width, height } = this.options;
        return {
            type: BI.ButtonGroup.xtype,
            cls: 'report-hide-scrollbar',
            ref: (_ref) => {
                this.lists = _ref;
            },
            chooseType: BI.ButtonGroup.CHOOSE_TYPE_MULTI,
            items: this.items,
            layouts: [{
                    type: BI.FloatLeftLayout.xtype,
                    width,
                    height,
                    scrolly: true,
                }],
        };
    }
    mounted() {
        super.mounted();
        this.checkAllSelected();
    }
    /**
     * 校验是否全选
     */
    checkAllSelected() {
        if (!this.options.chooseAll) {
            return;
        }
        let count = 0;
        const btns = this.lists.getAllButtons();
        btns.forEach((btn, index) => {
            if (index === btns.length - 1) {
                return;
            }
            btn.isSelected() && (count += 1);
        });
        BI.last(btns).setSelected(count === btns.length - 1);
    }
    getValue() {
        const { delimiter, returnArray, startSymbol, endSymbol } = this.options;
        const value = this.lists.getAllButtons()
            .filter(btn => btn.isSelected())
            .map(btn => btn.getValue());
        BI.remove(value, this.selectedAllValue);
        return transformValue2CheckGroupValue(value, { delimiter, returnArray, startSymbol, endSymbol });
    }
    preGetValidation() {
        const { allowBlank, value, errorMsg, controlAttr, delimiter, startSymbol, endSymbol } = this.options;
        if (allowBlank || transformItems2Selected(transformControlAttrData(controlAttr.data), value, delimiter, startSymbol, endSymbol).some(item => item.selected)) {
            return { result: true };
        }
        return {
            result: false,
            errorMsg,
        };
    }
    postGetValidation() {
        const { allowBlank, errorMsg } = this.options;
        if (allowBlank || this.lists.getValue().length > 0) {
            return { result: true };
        }
        return {
            result: false,
            errorMsg,
        };
    }
    postValidateAndToast() {
        const validation = this.getValidation();
        if (validation.result) {
            return true;
        }
        this.showBubble(validation.errorMsg);
        return false;
    }
    async setControllerValue(v) {
        this.reset();
        if (BI.isNull(v)) {
            return;
        }
        const btns = this.lists.getAllButtons();
        const { delimiter, startSymbol, endSymbol } = this.options;
        transformItems2Selected(btns.map(btn => {
            return {
                text: btn.attr('text'),
                value: btn.getValue(),
            };
        }), v, delimiter, startSymbol, endSymbol)
            .forEach((item, index) => {
            btns[index].setSelected(item.selected || false);
        });
        this.checkAllSelected();
    }
    reset() {
        this.lists.getAllButtons()
            .forEach(btn => {
            btn.setSelected(false);
        });
    }
    setInteractValue(v) {
        this.options.controlAttr = v;
        this.options.value = v.value;
        this.lists.populate(this.items);
    }
    resize(width, height) {
        const restoreValue = this.lists.getValue();
        super.resize(width, height);
        this.lists.setValue(restoreValue);
    }
    get items() {
        const { fontSize, columnsInRow, adaptive, chooseAll, controlAttr, value, delimiter, startSymbol, endSymbol } = this.options;
        const extraCls = setFontSize(ParameterCheckboxGroup_1.BASE_CLS, fontSize);
        return transformItems2Selected(transformControlAttrData(controlAttr.data), value, delimiter, startSymbol, endSymbol)
            .concat(chooseAll ? [this.selectedAllItem] : [])
            .map(({ text, value, selected = false }) => {
            return Object.assign(Object.assign({ type: ReportMultiSelectItem.xtype, width: null, scale: fontSize / 12, cls: `${extraCls} bi-list-item-active`, $testId: 'report-main-parameter-container-controller-checkbox-group-item', text,
                value,
                selected, logic: {
                    dynamic: adaptive,
                } }, getWidthPropByAdaptive(adaptive, columnsInRow)), { listeners: [{
                        eventName: BI.MultiSelectItem.EVENT_CHANGE,
                        action: (v, multiSelectItem) => {
                            if (!chooseAll) {
                                return;
                            }
                            const isSelected = multiSelectItem.isSelected();
                            if (v !== this.selectedAllValue) {
                                this.checkAllSelected();
                                return;
                            }
                            const btns = this.lists.getAllButtons();
                            btns.forEach(btn => {
                                btn.setSelected(isSelected);
                            });
                        },
                    }, {
                        eventName: BI.MultiSelectItem.EVENT_CHANGE,
                        action: () => {
                            this.hideBubble();
                            !this.silence && this.fireEvent('statechange');
                            this.fireEvent('EVENT_CHANGE');
                        },
                    }] });
        });
    }
    async updateControlAttr() {
        const { widgetName, controlAttrFetcher } = this.options;
        return controlAttrFetcher(widgetName, this.getRequestOpts())
            .then(res => {
            this.options.controlAttr = {
                data: res,
                value: this.options.value,
            };
        });
    }
    reloadControlAttr() {
        this.reset();
        this.updateControlAttr()
            .then(() => {
            this.lists.populate(this.items);
        });
    }
    getRequestOpts() {
        const { getWidgetDependenceValueByWidget, getDependenceByWidget, extraOptsGetter } = this.options;
        const dependences = getWidgetDependenceValueByWidget(this);
        return Object.assign({ dependence: dependences, reload: BI.isNotEmptyArray(getDependenceByWidget(this)) }, extraOptsGetter());
    }
    setStyle(styles) {
        this.lists.element.addClass(setCheckboxGroupStyle(styles));
    }
    getText() {
        const text = this.lists.getAllButtons()
            .filter(btn => btn.isSelected())
            .map(btn => btn.getText());
        BI.remove(text, this.selectedAllItem.text);
        return `${text}`;
    }
};
ParameterCheckboxGroup.xtype = 'report.main.parameter_container.controller.checkbox_group';
ParameterCheckboxGroup.BASE_CLS = 'report-main-parameter-container-controller-checkbox-group';
ParameterCheckboxGroup = ParameterCheckboxGroup_1 = __decorate([
    shortcut()
], ParameterCheckboxGroup);
export { ParameterCheckboxGroup };
//# sourceMappingURL=checkbox_group.js.map