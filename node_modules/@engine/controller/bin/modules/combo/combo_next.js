var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ParameterComboNext_1;
import { WIDTH, HEIGHT } from '../controller.constants';
import { LimitCount, transformControlAttrData, setComboFontSize, fetchParamViewValue } from '../controller.service';
import { fetchParamControlAttr, fetchWidgetViewValue } from '../controller.crud';
import { shortcut } from '@engine/core';
import { AbstractParameterControllerWidget } from '../controller.abstract';
import { ParameterSingleSelectCombo } from './singleselectcombo/singleselectcombo';
import { transformValue2ComboNextValue, preTransformValue2ComboNextValue, setComboStyle, setComboPopupStyle } from './combo.service';
import './combo.less';
let ParameterComboNext = ParameterComboNext_1 = class ParameterComboNext extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        this.props = {
            baseCls: `${ParameterComboNext_1.BASE_CLS} bi-border-radius`,
            $testId: 'report-main-parameter-container-controller-combo',
            width: WIDTH,
            height: HEIGHT,
            watermark: '',
            value: '',
            fontSize: 12,
            needSubmit: false,
            disabled: false,
            invisible: false,
            allowBlank: true,
            errorMsg: BI.i18nText('Fine-Report_Preview_Can_Not_Null'),
            controlAttr: {
                data: [],
                value: '',
            },
            customData: false,
            directEdit: true,
            noRepeat: true,
            autoMode: true,
            mode: 'remote',
            searchTime: 200,
            widgetName: '',
            getDependenceByWidget: () => [],
            getWidgetDependenceValueByWidget: () => {
                return {};
            },
            add2WaitingQueue: () => '',
            removeFromWaitingQueue: () => { },
            name4Empty: '',
            sonHeight: 24,
            maxCount: 0,
            controlAttrFetcher: fetchParamControlAttr,
            extraOptsGetter: () => {
                return {};
            },
            viewValueFetcher: fetchWidgetViewValue,
            allowBg: true,
            needCheckCustomData: true,
        };
        // 12px配24px的行高
        this.ratio = 2;
    }
    get editComp() {
        return this.combo;
    }
    /**
     * 公开接口，修改下拉框控件的默认文字“不选”
     * @param name 名称
     */
    setName4Empty(name) {
        var _a;
        this.options.name4Empty = name;
        (_a = this.combo) === null || _a === void 0 ? void 0 : _a.updateName4Empty();
    }
    render() {
        const { width, height, watermark, fontSize, widgetName, value, controlAttr, customData, directEdit, allowBlank, controlAttrFetcher, allowBg } = this.options;
        return {
            type: ParameterSingleSelectCombo.xtype,
            cls: `${setComboFontSize(ParameterComboNext_1.BASE_CLS, {
                fontSize, width, height,
            })} ${allowBg ? 'bi-card' : ''}`,
            ref: (_ref) => {
                this.combo = _ref;
            },
            customData,
            allowEdit: directEdit,
            allowNoSelect: allowBlank,
            value: transformValue2ComboNextValue(value, transformControlAttrData(controlAttr.data)),
            controlDataGetter: () => transformControlAttrData(this.options.controlAttr.data),
            name4EmptyGetter: () => this.options.name4Empty,
            itemHeightGetter: () => this.options.sonHeight,
            maxCountGetter: () => this.options.maxCount,
            itemsCreator: (options, callback) => {
                controlAttrFetcher(widgetName, Object.assign(Object.assign({ startIndex: LimitCount * (options.times - 1), limitIndex: LimitCount * options.times }, options.keyword ? { filter: options.keyword } : {}), this.getRequestOpts()))
                    .then(items => {
                    this.options.controlAttr.data = (this.options.controlAttr.data || []).concat(items);
                    callback({
                        items: transformControlAttrData(items),
                        hasNext: items.length >= LimitCount,
                    });
                });
            },
            width,
            height,
            // itemHeight: Math.max(this.ratio * fontSize, 24),
            // 屏蔽弹出框的自动调整行高
            watermark,
            listeners: [{
                    eventName: ParameterSingleSelectCombo.EVENT_CONFIRM,
                    action: () => {
                        const result = !this.silence && this.fireEvent('stopedit');
                        result !== false && this.fireEvent('EVENT_CHANGE');
                    },
                }, {
                    eventName: ParameterSingleSelectCombo.EVENT_BEFORE_EDIT,
                    action: () => {
                        this.hideBubble();
                        !this.silence && this.fireEvent('beforeedit');
                    },
                }, {
                    eventName: ParameterSingleSelectCombo.EVENT_AFTER_EDIT,
                    action: () => {
                        !this.silence && this.fireEvent('afteredit');
                    },
                }, {
                    eventName: ParameterSingleSelectCombo.EVENT_CLICK_ITEM,
                    action: () => {
                        this.hideBubble();
                        !this.silence && this.fireEvent('click');
                    },
                }],
        };
    }
    mounted() {
        super.mounted();
        // TODO 要优化一下，并不一定每次mounted都要设置popup，看能不能根据popup打开时机判断
        const { fontSize } = this.options;
        this.setPopupStyle({
            fontSize: `${fontSize}px`,
            itemHeight: `${fontSize * this.ratio}px`,
        });
    }
    preGetValidation() {
        const { errorMsg, value, allowBlank } = this.options;
        const validation = this.options.customData || this.combo.validateData();
        if (!validation) {
            return {
                result: false,
                errorMsg: BI.i18nText('Fine-Report_Preview_Not_In_List'),
            };
        }
        if (allowBlank || !BI.isEmpty(value)) {
            return { result: true };
        }
        return {
            result: false,
            errorMsg,
        };
    }
    postGetValidation() {
        const { allowBlank, errorMsg, customData, needCheckCustomData } = this.options;
        const value = `${this.getValue()}` || '';
        const validation = customData || !needCheckCustomData || this.combo.validateData();
        if (!validation) {
            return {
                result: false,
                errorMsg: BI.i18nText('Fine-Report_Preview_Not_In_List'),
            };
        }
        if (allowBlank || BI.isNotEmptyString(value)) {
            return { result: true };
        }
        return {
            result: false,
            errorMsg,
        };
    }
    postValidateAndToast() {
        const validation = this.getValidation();
        if (validation.result) {
            return true;
        }
        this.showBubble(validation.errorMsg);
        return false;
    }
    emitManualStopEditEvent() {
        this.fireEvent('stopedit');
    }
    getValue() {
        const value = this.combo.getValue();
        return BI.isNull(value)
            ? ''
            : value.value;
    }
    async updateControllAttrByValue(v, controlData) {
        const { add2WaitingQueue, removeFromWaitingQueue, widgetName, customData, viewValueFetcher } = this.options;
        if (!controlData || BI.isEmptyArray(controlData)) {
            const value = preTransformValue2ComboNextValue(v);
            if (BI.isNull(value)) {
                return value;
            }
            const id = add2WaitingQueue();
            const re = await fetchParamViewValue(widgetName, customData, viewValueFetcher, Object.assign({ __text__: value }, this.getRequestOpts()));
            this.options.controlAttr = re
                ? { data: (this.options.controlAttr.data || []).concat([re]), value }
                : this.options.controlAttr;
            removeFromWaitingQueue(id);
            return re;
        }
        this.options.controlAttr = { data: (this.options.controlAttr.data || []).concat(controlData), value: v };
        return transformValue2ComboNextValue(v, controlData || []);
    }
    async setControllerValue(v, controlData) {
        this.combo.setValue(await this.updateControllAttrByValue(v, controlData));
    }
    setValue(v, controlData) {
        this.setControllerValue(v, controlData)
            .then(() => {
            this.fireEvent('EVENT_SET_VALUE');
            !this.silence && controlData && this.fireEvent('afteredit');
        });
    }
    reset() {
        this.setControllerValue('', []);
    }
    reloadControlAttr() {
        this.reset();
        this.combo.setRepopulate(true);
    }
    setInteractValue(v) {
        this.combo.setRepopulate(true);
        this.setControllerValue(v.value, v.data);
    }
    resize(width, height) {
        const restoreValue = this.combo.getValue();
        super.resize(width, height);
        this.combo.setValue(restoreValue);
    }
    getRequestOpts() {
        const { getWidgetDependenceValueByWidget, getDependenceByWidget, extraOptsGetter } = this.options;
        const dependences = getWidgetDependenceValueByWidget(this);
        return Object.assign({ dependence: dependences, reload: BI.isNotEmptyArray(getDependenceByWidget(this)) }, extraOptsGetter());
    }
    getText() {
        var _a;
        return (_a = this.combo.getValue()) === null || _a === void 0 ? void 0 : _a.text;
    }
    getAdapter() {
        return this.combo.getAdapter();
    }
    setStyle(styles) {
        this.combo.element.addClass(setComboStyle(styles));
    }
    setPopupStyle(styles) {
        this.options.sonHeight = parseInt(styles.itemHeight, 10);
        this.combo.element.addClass(setComboPopupStyle(styles));
    }
    setWaterMark(v) {
        this.options.watermark = v;
        this.combo.setWaterMark(v);
    }
    focus() {
        this.combo.focus();
    }
    blur() {
        this.combo.blur();
    }
};
ParameterComboNext.xtype = 'report.main.parameter_container.controller_next.combo';
ParameterComboNext.BASE_CLS = 'report-main-parameter-container-controller-combo';
ParameterComboNext = ParameterComboNext_1 = __decorate([
    shortcut()
], ParameterComboNext);
export { ParameterComboNext };
//# sourceMappingURL=combo_next.js.map