var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ParameterRadioGroup_1;
import { WIDTH, HEIGHT } from '../controller.constants';
import { setFontSize, getWidthPropByAdaptive, transformControlAttrData } from '../controller.service';
import { shortcut } from '@engine/core';
import { ParameterRadioGroupSingleSelectRadioItem } from './radio_group.single_select_radio_item';
import { AbstractParameterControllerWidget } from '../controller.abstract';
import { fetchParamControlAttr } from '../controller.crud';
import { setRadioGroupStyle } from './radio_group.service';
export const ParameterRadioGroupXtype = 'report.main.parameter_container.controller.radio_group';
let ParameterRadioGroup = ParameterRadioGroup_1 = class ParameterRadioGroup extends AbstractParameterControllerWidget {
    constructor() {
        super(...arguments);
        this.props = {
            baseCls: ParameterRadioGroup_1.BASE_CLS,
            $testId: ParameterRadioGroup_1.BASE_CLS,
            widgetName: '',
            width: WIDTH,
            height: HEIGHT,
            adaptive: false,
            columnsInRow: 1,
            controlAttr: {
                data: [],
                value: '',
            },
            needSubmit: false,
            disabled: false,
            invisible: false,
            fontSize: 12,
            value: '',
            allowBlank: true,
            errorMsg: BI.i18nText('Fine-Report_Preview_Can_Not_Null'),
            norepeat: true,
            controlAttrFetcher: fetchParamControlAttr,
            extraOptsGetter: () => {
                return {};
            },
            getDependenceByWidget: () => [],
            getWidgetDependenceValueByWidget: () => {
                return {};
            },
            allowBg: true,
        };
    }
    render() {
        const { width, height, fontSize } = this.options;
        return {
            type: BI.ButtonGroup.xtype,
            cls: 'report-hide-scrollbar',
            ref: (_ref) => {
                this.radioGroups = _ref;
                this.$container = _ref.element;
            },
            items: this.items,
            chooseType: BI.ButtonGroup.CHOOSE_TYPE_MULTI,
            layouts: [{
                    type: BI.FloatLeftLayout.xtype,
                    width,
                    height,
                    tgap: 3 * fontSize / 12,
                    scrolly: true,
                }],
        };
    }
    async setControllerValue(v) {
        this.options.value = v;
        this.radioGroups.populate(this.items);
    }
    setInteractValue(controlAttr) {
        this.options.controlAttr = controlAttr;
        this.options.value = controlAttr.value;
        this.radioGroups.populate(this.items);
        this.setControllerValue(controlAttr.value);
    }
    preGetValidation() {
        const { errorMsg, allowBlank, value } = this.options;
        if (allowBlank || !BI.isEmpty(value)) {
            return { result: true };
        }
        return {
            result: false,
            errorMsg,
        };
    }
    postGetValidation() {
        const { allowBlank, errorMsg } = this.options;
        if (allowBlank) {
            return { result: true };
        }
        return !!this.getValue() === true ? {
            result: true,
        } : {
            result: false,
            errorMsg,
        };
    }
    postValidateAndToast() {
        const validation = this.getValidation();
        if (validation.result) {
            return true;
        }
        this.showBubble(validation.errorMsg);
        return false;
    }
    getValue() {
        const value = BI.first(this.radioGroups.getAllButtons()
            .filter(btn => btn.isSelected())
            .map(btn => btn.getValue()));
        if (!value) {
            return '';
        }
        return value;
    }
    /**
     * 将controlData转换成fineui的items
     */
    get items() {
        const { adaptive, columnsInRow, controlAttr, fontSize, value: v, disabled } = this.options;
        const items = transformControlAttrData(controlAttr.data);
        const extraCls = setFontSize(ParameterRadioGroup_1.BASE_CLS, BI.isIE() ? Math.floor(fontSize) : fontSize);
        const value = BI.isNull(v) || BI.isEmptyString(v)
            ? undefined
            : BI.isArray(v) ? `${BI.first(v)}` : `${v}`;
        let isMatched = false;
        // 匹配实际值
        items.some(item => {
            isMatched = item.value === value;
            if (isMatched) {
                item.selected = true;
            }
            return isMatched;
        });
        // 匹配显示值
        if (!isMatched) {
            items.some(item => {
                isMatched = item.text === value;
                if (isMatched) {
                    item.selected = true;
                }
                return isMatched;
            });
        }
        return items.map(item => {
            const { text, value, selected = false } = item;
            return Object.assign(Object.assign({ type: ParameterRadioGroupSingleSelectRadioItem.xtype, disabled, scale: fontSize / 12, cls: `${extraCls}`, text, title: text, adaptive,
                selected,
                value }, getWidthPropByAdaptive(adaptive, columnsInRow)), { listeners: [{
                        eventName: ParameterRadioGroupSingleSelectRadioItem.EVENT_CHANGE,
                        action: (isSelected, _value, btn) => {
                            if (isSelected) {
                                this.radioGroups.getAllButtons()
                                    .forEach($btn => {
                                    $btn !== btn && $btn.setSelected(false);
                                });
                            }
                            this.hideBubble();
                            !this.silence && this.fireEvent('statechange');
                            this.fireEvent('EVENT_CHANGE');
                        },
                    }] });
        });
    }
    reset() {
        this.radioGroups.setValue();
    }
    resize(width, height) {
        this.options.value = this.getValue();
        super.resize(width, height);
    }
    async updateControlAttr() {
        const { widgetName, controlAttrFetcher } = this.options;
        return controlAttrFetcher(widgetName, this.getRequestOpts())
            .then(res => {
            this.options.controlAttr = {
                data: res,
                value: this.options.value,
            };
        });
    }
    reloadControlAttr() {
        this.reset();
        this.updateControlAttr()
            .then(() => {
            this.radioGroups.populate(this.items);
        });
    }
    getRequestOpts() {
        const { getWidgetDependenceValueByWidget, getDependenceByWidget, extraOptsGetter } = this.options;
        const dependences = getWidgetDependenceValueByWidget(this);
        return Object.assign({ dependence: dependences, reload: BI.isNotEmptyArray(getDependenceByWidget(this)) }, extraOptsGetter());
    }
    setStyle(styles) {
        this.radioGroups.element.addClass(setRadioGroupStyle(styles));
    }
    getText() {
        const value = BI.first(this.radioGroups.getAllButtons()
            .filter(btn => btn.isSelected())
            .map(btn => btn.attr('text')));
        if (!value) {
            return '';
        }
        return value;
    }
};
ParameterRadioGroup.xtype = 'report.main.parameter_container.controller.radio_group';
ParameterRadioGroup.BASE_CLS = 'report-main-parameter-container-controller-radio-group';
ParameterRadioGroup = ParameterRadioGroup_1 = __decorate([
    shortcut()
], ParameterRadioGroup);
export { ParameterRadioGroup };
//# sourceMappingURL=radio_group.js.map