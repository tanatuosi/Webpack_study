import { expandHtml } from '../table.service';
import { fontScaleAttributeName, resizeStickerExtension } from './resizer.service';
export class AbstractResizer {
    constructor(opts = {}) {
        this.isAdaptive = true;
        this.minResizeScale = 0.4;
        this.widthResizeScale = 1;
        this.heightResizeScale = 1;
        const { minFontSize = 8 } = opts;
        this.minFontSize = minFontSize;
    }
    resizeWidth(cols, width = document.body.clientWidth, rate = 0) {
        let widthRate = rate;
        cols[cols.length - 1] = 0;
        cols[cols.length - 2] = 0;
        cols[0] = 0;
        // 如果开了自适应，则需要让边距 = 0；
        const screenWidth = width - 3;
        const cellCols = [...cols];
        cellCols.pop();
        if (!rate) {
            const sumWidth = cellCols.reduce((total, num) => total + num);
            widthRate = Math.max(screenWidth / sumWidth, this.minResizeScale);
        }
        for (let index = 0; index < cellCols.length; index++) {
            cols[index] *= widthRate;
        }
        // 防止边框和浏览器边框重叠，留1px间距
        cols[cols.length - 1] = 1;
        cols[0] = 1;
        return widthRate;
    }
    resizeHeight(rows, height, rate = 0) {
        let heightRate = rate;
        rows[0] = 0;
        rows[rows.length - 3] = 0;
        rows[rows.length - 2] = 0;
        rows[rows.length - 1] = 0;
        // 如果开了自适应，则需要让边距 = 0；
        const cellRows = [...rows];
        cellRows.pop();
        if (!rate) {
            const screenHeight = height - 2;
            const sumHeight = cellRows.reduce((total, num) => total + num);
            heightRate = Math.max(screenHeight / sumHeight, this.minResizeScale);
        }
        for (let index = 0; index < cellRows.length; index++) {
            rows[index] *= heightRate;
        }
        // 防止边框和浏览器边框重叠，留1px间距
        rows[rows.length - 1] = 1;
        return heightRate;
    }
    resizeFont(rate, cells) {
        cells && BI.each(cells, (_index, item) => {
            BI.each(item, (_dataIndex, data) => {
                BI.each(BI.get(data, 'items'), (_labelIndex, label) => {
                    if (label && label.el && label.el.style) {
                        // html最小显示12px的文字，但是会随着屏幕缩放而变化，比如缩放到200%，最小就可显示6px
                        // 而新引擎是用canvas绘制的，而且js无法拿到浏览器缩放比例，所以无法实现和老引擎同样的效果
                        // 所以目前设置新引擎最小显示8px大小的文字
                        // 后面看看是否有更加完美的做法
                        const defaultFontSize = parseInt(label.el.style.defaultFontSize, 10);
                        const newFontSize = Math.max(defaultFontSize * rate, this.minFontSize);
                        label.el.style.lineHeight = label.el.style.defaultLineHeight * newFontSize / defaultFontSize;
                        label.el.style.fontSize = `${newFontSize}px`;
                    }
                });
            });
        });
    }
    resizeSticker(rate, sheet) {
        (sheet.stickers || []).forEach((sticker) => {
            sticker.el = sticker.extension ? this.expandHtml(resizeStickerExtension(rate, sticker.extension).el, sticker.extension.style, rate).el : sticker.el;
        });
    }
    expandHtml(el, style, fontScale) {
        return BI.isNotNull(style)
            ? expandHtml(el, Object.assign(Object.assign({}, style), { lineHeight: style.lineHeight * fontScale, paddingLeft: style.paddingLeft * this.widthResizeScale, paddingRight: style.paddingRight * this.widthResizeScale, spacingAfter: style.spacingAfter * this.heightResizeScale, spacingBefore: style.spacingBefore * this.heightResizeScale }), fontScale)
            : { el, style, initial: el };
    }
    /**
     * 通过font-scale属性进行字体自适应
     * @param element 父级元素
     */
    resizeFontByFontScaleAttr(element) {
        Array.from(element.find(`*[${fontScaleAttributeName}]`))
            .forEach((el) => {
            const fontSize = window.getComputedStyle(el, null).getPropertyValue('font-size');
            const fontScale = el.getAttribute(fontScaleAttributeName);
            el.style.fontSize = `calc(${fontScale} * ${fontSize})`;
        });
    }
}
//# sourceMappingURL=resizer.abstract.js.map