import { CellCacheManager } from '../../table.cell_value_manager';
import { getCellValue } from '../../table.service';
import { NormalCellValueTransformer } from './transformer.normal';
import { TextCellValueTransformer } from './transformer.text';
export class TableCellValueTransformerProvider {
    constructor() {
        this.cellDict = new Map([
            ['text', TextCellValueTransformer],
        ]);
    }
    setValue(cellData, value, externalContext, opt = {}) {
        const { cv, cellhyperlink } = value;
        const currentValue = getCellValue(cellData.value) || { type: 'text', value: '' };
        if (!currentValue) {
            return new Promise(resolve => {
                resolve(false);
            });
        }
        if (BI.isNull(cellhyperlink) && BI.isEqual(currentValue.cv, cv)) {
            return new Promise(resolve => {
                resolve(false);
            });
        }
        cellData.edited = true;
        cellData.transformed = true;
        cellData.cellstyle = cellData.cellstyle || {
            fontStyle: {
                color: -16777216,
                fontFamily: 'SimSun',
                fontSize: 12,
                underLine: {
                    width: 0,
                    style: '',
                    color: -16777216,
                },
            },
        };
        cellData.cellhyperlink = cellhyperlink;
        const controller = externalContext.getWidgetByCell(cellData.position.y, cellData.position.x);
        if (controller && opt.soft !== true) {
            controller.setValue(cv);
        }
        const Transformer = this.cellDict.get(currentValue.type) || NormalCellValueTransformer;
        return new Transformer(externalContext, cellData)
            .setValue(currentValue, value)
            .then(updatedCellValue => {
            const isUpdated = cellData.value !== updatedCellValue;
            cellData.value = updatedCellValue;
            if (isUpdated) {
                cellData.errorMsg = undefined;
                const cellCacheManager = (externalContext.getStickerManagers().get(CellCacheManager.NAME));
                cellCacheManager === null || cellCacheManager === void 0 ? void 0 : cellCacheManager.addCellCache(cellData);
            }
            return isUpdated;
        });
    }
    set(key, transformer) {
        this.cellDict.set(key, transformer);
    }
}
export const tableCellValueTransformerProvider = new TableCellValueTransformerProvider();
//# sourceMappingURL=transformer.js.map