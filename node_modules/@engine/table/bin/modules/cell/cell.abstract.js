import './cell.less';
import { cellControllerProvider } from './cell_controllers/cell_controller';
import { CellControllerManager } from '../table.cell_controller_manager';
import { transformPosition2Id } from '../table.service';
import { CellErrorTipManager } from '../table.cell_error_tip_manager';
import { transformCell2Widget } from './cell.widget';
import { CellCacheManager } from '../table.cell_value_manager';
import { transformCell2Filter } from './cell.filter';
export class AbstractTableCell {
    constructor(opts, external) {
        this.id = BI.UUID();
        this.options = opts;
        this.external = external;
        this.cellControllerManager = (this.external.getStickerManagers().get(CellControllerManager.NAME)) || new CellControllerManager();
        this.cellErrorTipManager = (this.external.getStickerManagers().get(CellErrorTipManager.NAME)) || new CellErrorTipManager();
        this.cellCacheManager = (this.external.getStickerManagers().get(CellCacheManager.NAME)) || new CellCacheManager();
        external.getStickerManagers().set(CellControllerManager.NAME, this.cellControllerManager);
        external.getStickerManagers().set(CellErrorTipManager.NAME, this.cellErrorTipManager);
        external.getStickerManagers().set(CellCacheManager.NAME, this.cellCacheManager);
        this.id = BI.isNotNull(opts.cell.id) ? `${opts.cell.id}` : transformPosition2Id(opts.cell.position.x, opts.cell.position.y);
    }
    getCellStickers() {
        return [
            this.toHtml(),
            this.toWidget(),
            this.toState(),
            this.toFilter(),
        ];
    }
    getTextByCellValue(value) {
        const { cell, widget } = this.options;
        const text = cellControllerProvider.getTextTransformer(widget === null || widget === void 0 ? void 0 : widget.type)(AbstractTableCell.transform2CellText(cell.text || value || cell.value));
        return BI.isNull(cell.cv) || BI.isNull(cell.transformed) ? text : BI.contentFormat(text, cell.fmt);
    }
    isDirectWidget() {
        const { cell, widget } = this.options;
        return !!((cell.isShowWidgets || cellControllerProvider.isDirect(widget === null || widget === void 0 ? void 0 : widget.type)) && widget);
    }
    toCell() {
        return this.isDirectWidget()
            ? this.toEmptyCell()
            : this.toFullCell();
    }
    toHtml() {
        return undefined;
    }
    static transform2CellText(text) {
        return BI.isObject(text)
            ? JSON.stringify(text)
            : BI.isNull(text)
                ? ''
                : `${text}`;
    }
    static transform2String(v) {
        return `${BI.isNull(v) ? '' : v}`;
    }
    fireEvent(eventName, args) {
        const promises = [];
        this.options.listeners
            .forEach(listener => {
            if (listener.eventName === eventName && listener.action) {
                promises.push(Promise.resolve(listener.action(args)));
            }
        });
        return promises;
    }
    toEmptyCell() {
        const { cell, celladvancedattr, style } = this.options;
        const { borderStyle, backgroundStyle } = style;
        return {
            type: BI.AbsoluteLayout.xtype,
            listeners: [
                {
                    eventName: 'CELL_DOUBLE_CLICK',
                    action: (e, x, y, cell) => {
                        this.fireEvent('CELL_DOUBLE_CLICK', { e, x, y, cell, hyperLinks: [], id: this.id });
                        return true;
                    },
                },
                {
                    eventName: 'CELL_CLICK',
                    action: (e, x, y, cell) => {
                        this.fireEvent('CELL_CLICK', { e, x, y, cell, hyperLinks: [], id: this.id });
                        return true;
                    },
                },
                {
                    eventName: 'CELL_MOUSE_LEAVE',
                    action: (e, x, y, cell) => {
                        this.fireEvent('CELL_MOUSE_LEAVE', { e, x, y, cell });
                    },
                },
                {
                    eventName: 'CELL_MOUSE_DOWN',
                    action: (e, x, y, cell) => {
                        this.fireEvent('CELL_MOUSE_DOWN', { e, x, y, cell });
                    },
                },
                {
                    eventName: 'CELL_HOVER',
                    action: (e, x, y, cell) => {
                        this.fireEvent('CELL_HOVER', { e, x, y, cell });
                    },
                },
            ],
            borderStyle,
            backgroundStyle,
            canCopy: true,
            cursor: undefined,
            valid: cell.valid,
            title: celladvancedattr === null || celladvancedattr === void 0 ? void 0 : celladvancedattr.tooltipText,
            position: cell.position,
        };
    }
    toWidget() {
        return transformCell2Widget.apply(this);
    }
    /**
     * 创建状态标记
     */
    toState() {
        if (this.options.widget) {
            return undefined;
        }
        const { edited, errorMsg } = this.options.cell;
        if (!edited && !errorMsg) {
            return undefined;
        }
        return {
            id: `${this.id}_state`,
            init: (e, width, height) => {
                const wraffleWidth = width - 1;
                const wraffleHeight = height - 1;
                const items = this.getStateWidgetJson(wraffleWidth, wraffleHeight);
                if (BI.size(items) > 0) {
                    e.css('overflow', 'visible');
                    BI.createWidget({
                        type: BI.DefaultLayout.xtype,
                        element: e.el,
                        items: [{
                                type: BI.AbsoluteLayout.xtype,
                                width: wraffleWidth,
                                height: wraffleHeight,
                                items,
                            }],
                    });
                }
            },
            value: '',
        };
    }
    getStateWidgetJson(wraffleWidth, _wraffleHeight) {
        const { edited, errorMsg } = this.options.cell;
        const cellCls = this;
        const result = [];
        if (edited) {
            result.push({
                el: {
                    type: BI.Icon.xtype,
                    height: 10,
                    width: 10,
                    cls: 'cell-edited-tip',
                },
                top: 0,
                left: 0,
            });
        }
        if (errorMsg) {
            result.push({
                el: {
                    type: BI.Icon.xtype,
                    height: 15,
                    width: 15,
                    cls: 'cell-warning-tip',
                    title: () => errorMsg,
                },
                left: 0,
                bottom: 0,
            }, {
                el: {
                    type: BI.Label.xtype,
                    invisible: true,
                    cls: 'report-cell-error-tip',
                    hgap: 5,
                    vgap: 5,
                    text: errorMsg,
                    created() {
                        cellCls.cellErrorTipManager.register(this, cellCls.id);
                    },
                },
                left: wraffleWidth + 1,
                top: 1,
            });
        }
        return result;
    }
    toFilter() {
        return transformCell2Filter.apply(this);
    }
}
//# sourceMappingURL=cell.abstract.js.map