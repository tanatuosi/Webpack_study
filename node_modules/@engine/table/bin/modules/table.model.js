var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { model, Model } from '@engine/core';
import { recordConsumption } from '@engine/crud';
import { resizerProvider } from './resizer/resizer';
import { adjustCols, adjustRows, createEmptyCell, fixFreezeMerge, fixRealCellPositionInMergeCell, getCell, getCellSize, getFreeze, getMerge, getSticker } from './table.service';
const ROW_CHUNKED_CELLS_COUNT = 20 * 78;
let TableModel = class TableModel extends Model {
    constructor() {
        super(...arguments);
        this.computed = {
            paperSetting: () => this.model.reportSettingDetail.paperSetting || {
                orientation: 0,
                paperWidth: 0,
                paperHeight: 0,
                marginLeft: 0,
                marginRight: 0,
                marginTop: 0,
                marginBottom: 0,
            },
            paperBackground: () => this.model.reportSettingDetail.background || {},
            footerHeight: () => this.model.reportSettingDetail.footerHeight || 0,
            headerHeight: () => this.model.reportSettingDetail.headerHeight || 0,
            // 页眉页脚背景待定
            headerBackground: () => '',
            footerBackground: () => '',
            paperWidth: () => this.model.paperSetting.orientation === 0
                ? this.model.paperSetting.paperWidth
                : this.model.paperSetting.paperHeight,
            paperHeight: () => this.model.paperSetting.orientation === 0
                ? this.model.paperSetting.paperHeight
                : this.model.paperSetting.paperWidth,
            resizeModel: () => resizerProvider.getResizer(this.model.reportFitAttr.fitStateInPC, { minFontSize: this.model.reportFitAttr.minFontSize }),
            isAdaptiveTable: () => this.model.reportFitAttr && this.model.resizeModel.isAdaptive,
            hasFrozen: () => this.model.frozen && (this.model.frozen.colTo > -1 || this.model.frozen.rowTo) > -1,
        };
        this.actions = {
            setTableLoading: (v) => {
                this.model.loading = v;
                v === false && recordConsumption();
            },
            setReportSetting: (v) => {
                this.model.reportSettingDetail = v;
            },
            setReportFitAttr: (v) => {
                this.model.reportFitAttr = v;
            },
            setViewAtCenter: (v) => {
                this.model.viewAtCenter = v;
            },
            setTableWidth: (width) => {
                this.model.tableWidth = width;
            },
            setTableHeight: (height) => {
                this.model.tableHeight = height;
            },
            setScreenWidth: (width) => {
                this.model.screenWidth = width;
            },
            setWebBackground: (webBackground) => {
                this.model.webBackground = webBackground;
            },
            prePopulate: (size, $data) => {
                // finesheet会清空数组
                this.options.tableData = this.transformTableData($data || []);
                const data = $data ? $data.slice() : $data;
                // 初始化时不需要去掉loading，所以加这个判断
                if (!data) {
                    return false;
                }
                if (!data.length) {
                    this.setTableLoading(false);
                    return false;
                }
                if (this.model.hasFrozen) {
                    fixFreezeMerge(data, this.model.frozen);
                }
                const start = BI.get(data, '[0][0].position') || {};
                let sy = start.y || 0, sx = start.x || 0;
                let rowCount = data.length;
                let columnCount = data.reduce((max, row) => Math.max(max, row[row.length - 1] ? row[row.length - 1].position.x + 1 : 0), 0) - sx;
                // fixData 之后会增加5行3列
                this.fixData(data, sx, sy, columnCount, rowCount);
                rowCount += 5;
                columnCount += 3;
                sy -= 2;
                sx -= 1;
                const sheetData = [], rows = BI.makeArray(rowCount, 0), cols = [], stickers = [], merges = [];
                return Object.assign({ sheetData,
                    rows,
                    cols,
                    stickers,
                    merges,
                    rowCount,
                    columnCount,
                    sx,
                    sy, tableData: data }, size);
            },
            getTableData: () => this.options.tableData || [],
            /**
             * 完整加载表格数据
             * @param opts 传入参数
             */
            completeLoadData: (opts) => {
                const { sheetData, cols, rows, tableData, stickers, merges, sx, sy, rowCount, columnCount, screenWidth, tableWidth, tableHeight } = opts;
                tableData.forEach(rowData => {
                    this.transformTableRowData2SheetRowData({
                        data: rowData,
                        rows,
                        cols,
                        stickers,
                        merges,
                        sx,
                        sy,
                        sheetData,
                    });
                });
                this.adjustAndLoadData({
                    sheetData,
                    cols,
                    columnCount,
                    rows,
                    rowCount,
                    stickers,
                    merges,
                    screenWidth,
                    tableWidth,
                    tableHeight,
                    sx,
                    sy,
                });
            },
            /**
             * 行分块加载数据
             * @param opts 传入参数
             */
            rowChunkLoadData: (opts) => {
                const { sheetData, cols, rows, tableData, stickers, merges, sx, sy, rowCount, columnCount, screenWidth, tableWidth, tableHeight } = opts;
                const chunkedRowCount = Math.floor(ROW_CHUNKED_CELLS_COUNT / columnCount);
                const chunkedData = tableData.splice(0, chunkedRowCount);
                chunkedData.forEach(rowData => {
                    this.transformTableRowData2SheetRowData({
                        data: rowData,
                        rows,
                        cols,
                        stickers,
                        merges,
                        sx,
                        sy,
                        sheetData,
                    });
                });
                const hasNext = BI.size(tableData) > 0;
                this.adjustAndLoadData({
                    sheetData,
                    cols,
                    columnCount,
                    rows,
                    rowCount,
                    stickers: hasNext ? [] : stickers,
                    merges,
                    screenWidth,
                    tableWidth,
                    tableHeight,
                    sx,
                    sy,
                });
                if (hasNext) {
                    setTimeout(() => {
                        this.rowChunkLoadData({ sheetData, cols, rows, tableData, stickers, merges, sx, sy, rowCount, columnCount, screenWidth, tableWidth, tableHeight });
                    }, 0);
                }
            },
            resize: (width, height, element, screenWidth) => {
                if (BI.isNull(this.data))
                    return;
                let refresh = this.adaptTable(width, height);
                if (this.model.viewAtCenter && this.data.sheet.cols && !refresh) {
                    // 这里的margin被adjustRowsAndCols居中改掉了，totalWidth就会跟resize之前的屏幕宽度一样大，所以算totalWidth时要算居中前的margin
                    const totalWidth = this.data.sheet.cols.reduce((sum, col) => sum + col, this.model.paperSetting.marginLeft + this.model.paperSetting.marginRight - this.data.sheet.cols[0] - this.data.sheet.cols[this.data.sheet.cols.length - 1]);
                    const restWidth = screenWidth - totalWidth + this.model.paperSetting.marginLeft + this.model.paperSetting.marginRight;
                    if (screenWidth < totalWidth || restWidth / 2 < this.model.paperSetting.marginLeft || restWidth / 2 < this.model.paperSetting.marginRight) {
                        this.data.sheet.cols[0] = this.model.paperSetting.marginLeft;
                        this.data.sheet.cols[this.data.sheet.cols.length - 1] = this.model.paperSetting.marginRight;
                    }
                    else {
                        this.data.sheet.cols[0] = restWidth / 2;
                        this.data.sheet.cols[this.data.sheet.cols.length - 1] = restWidth / 2;
                    }
                    refresh = true;
                }
                if (refresh) {
                    this.options.loadData(this.data);
                    this.model.resizeModel.resizeFontByFontScaleAttr(element);
                }
            },
            addHandler: (handler, config) => {
                this.options.tableCellGenerator.addHandler(handler, config);
            },
            setFrozen: (frozen) => {
                this.model.frozen = frozen;
            },
            setActiveBox: (activeBox) => {
                this.model.activeBox = activeBox;
            },
            setSelectedCell: (v) => {
                this.model.selectedCell = v;
            },
            refreshCellValues: (cells) => {
                cells.forEach(cell => {
                    const result = this.transformTableCellData2SheetCellArgs({
                        cellData: cell,
                        sheetData: this.data.sheet.data || [],
                        sx: this.data.sx,
                        sy: this.data.sy,
                    });
                    if (!result)
                        return;
                    if (!result.cell)
                        return;
                    result.cell.getCellStickers()
                        .forEach(cellSticker => {
                        if (!cellSticker)
                            return;
                        const sticker = getSticker(result.x, result.y, cellSticker, cell);
                        if (!this.data.sheet.stickers)
                            return;
                        const index = this.data.sheet.stickers.findIndex(sheetSticker => sheetSticker.id === sticker.id);
                        if (index === -1)
                            return;
                        this.data.sheet.stickers.splice(index, 1, sticker);
                    });
                });
                this.options.loadData(this.data);
            },
        };
    }
    state() {
        return {
            cellstyle: {},
            loading: false,
            reportSettingDetail: this.options.reportSettingDetail,
            reportFitAttr: this.options.reportFitAttr,
            activeBox: this.options.activeBox,
            frozen: this.options.frozen,
            viewAtCenter: this.options.viewAtCenter,
            selectedCell: undefined,
            tableWidth: this.options.tableWidth,
            tableHeight: this.options.tableHeight,
            screenWidth: this.options.screenWidth,
            webBackground: this.options.webBackground,
        };
    }
    setData(data) {
        this.data = data;
    }
    adaptTable(width, height) {
        if (this.model.reportFitAttr && width && height) {
            this.model.resizeModel.resize(this.data, {
                tableWidth: Math.round(width),
                tableHeight: Math.round(height),
                fitAttr: this.model.reportFitAttr,
                hasFrozen: this.model.hasFrozen,
                paperWidth: this.model.paperSetting.paperWidth,
                paperHeight: this.model.paperSetting.paperHeight,
            });
            return this.model.resizeModel.isAdaptive;
        }
        return false;
    }
    adjustAndLoadData(opts) {
        const { sheetData, rows, rowCount, cols, columnCount, merges, stickers, tableHeight, tableWidth, screenWidth, sx, sy } = opts;
        const { tableRows, tableCols } = this.adjustRowsAndCols(rows, cols, screenWidth);
        const data = {
            sheet: {
                rowc: rowCount,
                colc: columnCount,
                data: sheetData,
                rows: tableRows,
                cols: tableCols,
                initialRows: [...tableRows],
                initialCols: [...tableCols],
                merges,
                freeze: getFreeze(this.model.frozen),
                stickers,
            },
            topSequnce: {
                enable: false,
                size: 0,
            },
            leftSequnce: {
                enable: false,
                size: 0,
            },
            activeBox: this.model.activeBox,
            sx,
            sy,
        };
        this.setData(data);
        this.adaptTable(tableWidth, tableHeight);
        this.options.loadData(data);
        this.setTableLoading(false);
    }
    /**
     * 单元格填补空白
     */
    adjustRowsAndCols(rows, cols, screenWidth) {
        // 单元格填补空白
        const tableRows = adjustRows(rows, this.model.paperHeight, this.model.hasFrozen);
        const tableCols = adjustCols(cols, this.model.paperWidth, this.model.hasFrozen);
        const totalWidth = tableCols.reduce((sum, col) => sum + col, 0);
        const restWidth = screenWidth - totalWidth + tableCols[0] + tableCols[tableCols.length - 1];
        // 居中时两边margin部分的处理
        if (this.model.viewAtCenter) {
            if (screenWidth < totalWidth || restWidth / 2 < this.model.paperSetting.marginLeft || restWidth / 2 < this.model.paperSetting.marginRight) {
                tableCols[0] = this.model.paperSetting.marginLeft;
                tableCols[tableCols.length - 1] = this.model.paperSetting.marginRight;
            }
            else {
                tableCols[0] = restWidth / 2;
                tableCols[tableCols.length - 1] = restWidth / 2;
            }
        }
        return { tableRows, tableCols };
    }
    /**
     * 转换行为表格所需的行数据，直接修改引用
     */
    transformTableRowData2SheetRowData(opts) {
        const { data } = opts, args = __rest(opts, ["data"]);
        for (let j = 0; j < data.length; j++) {
            if (data[j]) {
                this.transformTableCellData2SheetCellData(Object.assign(Object.assign({}, args), { cellData: data[j] }));
            }
        }
    }
    /**
     * 转换行为表格所需的单元格数据，直接修改引用
     */
    transformTableCellData2SheetCellData(opts) {
        const { rows, cols, stickers, merges, sx, sy, sheetData, cellData, simple } = opts;
        const cellArgs = this.transformTableCellData2SheetCellArgs({
            cellData,
            sx,
            sy,
            sheetData,
        });
        if (!cellArgs)
            return;
        const { x, y, celldimension, cell, position } = cellArgs;
        const { col, row } = getCellSize(celldimension, cols[x], rows[y]);
        cols[x] = col;
        rows[y] = row;
        if (!cell || simple)
            return;
        cell.getCellStickers().forEach(cellSticker => {
            cellSticker && stickers.push(getSticker(x, y, cellSticker, cellData));
        });
        const { columnSpan = 1, rowSpan = 1 } = position;
        if (columnSpan > 1 || rowSpan > 1) {
            merges.push(getMerge(x, y, columnSpan, rowSpan));
        }
    }
    /**
     * 转换行为表格所需的单元格信息
     */
    transformTableCellData2SheetCellArgs(opts) {
        const { sx, sy, sheetData, cellData } = opts;
        if (cellData) {
            const { value, celldimension, position, } = cellData;
            let { x, y } = position;
            x -= sx;
            y -= sy;
            if (value) {
                sheetData[y] = sheetData[y] || [];
                const cell = getCell(cellData, this.options.tableCellGenerator);
                sheetData[y][x] = cell.toCell();
                return {
                    cell,
                    x,
                    y,
                    celldimension,
                    position,
                };
            }
            return {
                x,
                y,
                celldimension,
                position,
            };
        }
        return undefined;
    }
    /**
     * 把页面的布局信息转换成单元格
     */
    fixData(data, sx, sy, colc, rowc) {
        const { marginLeft, marginTop, marginRight, marginBottom, } = this.model.paperSetting;
        // pagesize补全
        data.push([createEmptyCell(sx + colc, sy + rowc, 0, 0, 1, 1)]);
        // header footer
        data.unshift([
            createEmptyCell(sx, sy - 1, 0, this.model.headerHeight, 1, colc + 1),
        ]);
        data.push([
            createEmptyCell(sx, sy + rowc + 1, 0, this.model.footerHeight, 1, colc + 1),
        ]);
        // margin
        data.unshift([
            createEmptyCell(sx - 1, sy - 2, marginLeft, marginTop, 1, colc + 3),
            createEmptyCell(sx + 1 + colc, sy - 2, marginRight, marginTop, 1, 1),
        ]);
        data.push([
            createEmptyCell(sx - 1, sy + rowc + 2, marginLeft, marginBottom, 1, colc + 3),
        ]);
        return data;
    }
    /**
     * 转化下tableData，填充合并真实单元格信息
     * @param data 表格数据
     * @returns 转化后的表格数据
     */
    transformTableData(tableData) {
        tableData.forEach((rowData, rowIndex) => {
            rowData.forEach((cell, colIndex) => {
                if (!BI.isNull(cell.merge)) {
                    return;
                }
                const { position: { rowSpan, columnSpan } } = cell;
                if (rowSpan && rowSpan > 1
                    || columnSpan && columnSpan > 1) {
                    fixRealCellPositionInMergeCell(tableData, {
                        rowSpan,
                        columnSpan,
                        x: colIndex,
                        y: rowIndex,
                    });
                }
            });
        });
        return tableData;
    }
};
TableModel.xtype = 'report.model.components.tool_bar.table';
TableModel = __decorate([
    model()
], TableModel);
export { TableModel };
//# sourceMappingURL=table.model.js.map