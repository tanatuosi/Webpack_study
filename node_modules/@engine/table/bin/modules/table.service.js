var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { envProvider, transformColor } from '@engine/core';
import jss from 'jss';
import jssGlobal from 'jss-plugin-global';
import jssNested from 'jss-plugin-nested';
import { DEFAULT_BACKGROUND, DEFAULT_INPUT_BORDER, DEFAULT_SHADOW, GRADIENT_BACKGROUND_LENGTH, SCROLLBAR_WIDTH } from './table.constants';
const HAIR_WIDTH = 0.5;
export function getBorderStyle({ width, style, color }) {
    let borderStyle = style.toLocaleLowerCase(), borderWidh = width, dash = [];
    switch (borderStyle) {
        case 'dashed':
            dash = borderWidh === 2 ? [8, 2] : [4, 2];
            break;
        case 'slim_solid':
            borderStyle = 'solid';
            borderWidh = HAIR_WIDTH;
            break;
        case 'hair':
            borderStyle = 'dashed';
            borderWidh = HAIR_WIDTH;
            dash = [2, 2];
            break;
        case 'hair2':
            borderStyle = 'dashed';
            borderWidh = HAIR_WIDTH;
            dash = [4, 4];
            break;
        case 'dash_dot':
            borderStyle = 'dashed';
            dash = [8, 2, 2, 2];
            break;
        case 'dash_dot_dot':
            borderStyle = 'dashed';
            dash = [8, 2, 2, 2, 2, 2];
            break;
        case 'slanted_dash_dot':
            borderStyle = 'dashed';
            dash = [8, 2, 2, 2];
            break;
        default:
    }
    return {
        color: transformColor(color),
        style: borderStyle,
        width: borderWidh,
        dash,
    };
}
export function getCellStyle(cellstyle, defaultStyle) {
    if (!cellstyle) {
        return {};
    }
    const { textAlign = 'left', cellJust = 'NONE' } = defaultStyle;
    const style = {};
    const { cellBackground, contentStyle, fontStyle, borderStyle } = cellstyle;
    style.backgroundStyle = Object.assign({}, DEFAULT_BACKGROUND);
    if (cellBackground) {
        const { background = {} } = cellBackground;
        const { color, imgUrl, layout = 0, backgroundType, startColor, endColor, begin = 0, finish = 0, direction, radiusConfig, } = background;
        const bgStyle = Object.assign({}, DEFAULT_BACKGROUND);
        bgStyle.radiusConfig = radiusConfig;
        switch (backgroundType) {
            case 'TextureBackground':
            case 'PatternBackground':
            case 'ImageBackground':
                bgStyle.backgroundImage = imgUrl;
                // 先默认'repeat'
                bgStyle.backgroundImageLayout = getImgLayout(layout);
                break;
            case 'ColorBackground':
                bgStyle.backgroundColor = transformColor(color);
                break;
            case 'GradientBackground':
                bgStyle.linearGradient = {
                    degree: direction === 1 ? 180 : 90,
                    stops: [
                        {
                            per: begin / GRADIENT_BACKGROUND_LENGTH,
                            color: transformColor(startColor),
                        },
                        {
                            per: finish === 0 ? 1 : finish / GRADIENT_BACKGROUND_LENGTH,
                            color: transformColor(endColor),
                        },
                    ],
                };
                break;
            default:
                break;
        }
        style.backgroundStyle = bgStyle;
    }
    if (borderStyle) {
        const { topBorder = DEFAULT_INPUT_BORDER, leftBorder = DEFAULT_INPUT_BORDER, rightBorder = DEFAULT_INPUT_BORDER, bottomBorder = DEFAULT_INPUT_BORDER, } = borderStyle;
        style.borderStyle = {
            borderTop: getBorderStyle(topBorder),
            borderBottom: getBorderStyle(bottomBorder),
            borderLeft: getBorderStyle(leftBorder),
            borderRight: getBorderStyle(rightBorder),
        };
    }
    style.contentStyle = {
        color: '',
        fontSize: '',
        defaultFontSize: '',
        fontWeight: 'normal',
        fontStyle: 'normal',
        fontFamily: '',
        textShadow: undefined,
        strikeThrough: 'none',
        underline: getBorderStyle({
            width: 0,
            color: 0,
            style: '',
        }),
        subscript: false,
        supscript: false,
        wrap: true,
        rotate: 0,
        newLine: '',
        verTextDirection: '',
        verticalText: '',
        textAlign: 'center',
        verticalAlign: 'middle',
        lineHeight: '',
    };
    if (fontStyle) {
        const fontSize = fontStyle.subscript || fontStyle.supscript
            ? fontStyle.fontSize * 5 / 6
            : fontStyle.fontSize;
        style.contentStyle = Object.assign(Object.assign({}, style.contentStyle), { color: transformColor(fontStyle.color), fontSize: `${fontSize}px`, defaultFontSize: `${fontSize}px`, fontWeight: transformFontWeight(fontStyle.bold), fontStyle: transformFontItalic(fontStyle.italic), fontFamily: fontStyle.fontFamily.toLocaleLowerCase(), textShadow: transformTextShadow(fontStyle.textShadow), strikeThrough: fontStyle.strikeThrough ? 'solid' : 'none', underline: getBorderStyle({
                width: fontStyle.underLine.width,
                color: fontStyle.underLine.color,
                style: fontStyle.underLine.style,
            }), subscript: fontStyle.subscript, supscript: fontStyle.supscript });
    }
    if (contentStyle) {
        style.contentStyle = Object.assign(Object.assign({}, style.contentStyle), { textAlign: contentStyle.textAlign.toLocaleLowerCase() === 'default'
                ? textAlign
                : contentStyle.textAlign.toLocaleLowerCase(), lineHeight: `${contentStyle.lineHeight}`, defaultLineHeight: `${contentStyle.lineHeight}`, wrap: contentStyle.newLine.toLocaleLowerCase() === 'auto_newline', rotate: contentStyle.rotate, newLine: contentStyle.newLine, verTextDirection: contentStyle.verTextDirection, verticalText: contentStyle.verticalText, cellJust, verticalAlign: fontStyle.subscript
                ? 'bottom'
                : fontStyle.supscript
                    ? 'top'
                    : contentStyle.verticalAlign.toLowerCase(), subscript: false, supscript: false });
        style.paddingLeft = contentStyle.paddingLeft;
        style.paddingRight = contentStyle.paddingRight;
        style.spacingAfter = contentStyle.spacingAfter;
        style.spacingBefore = contentStyle.spacingBefore;
    }
    return style;
}
export function createEmptyCell(x, y, width, height, rowSpan, columnSpan) {
    return {
        celldimension: {
            width,
            height,
        },
        position: {
            columnSpan,
            rowSpan,
            x,
            y,
        },
        value: '{"type": "text", "value": ""}',
        valid: false,
        cell: '',
        direction: 0,
        id: -1,
    };
}
export function getCompleteImageUrl(id, cache) {
    const cacheParam = cache ? '&cache=true' : '';
    return `${envProvider.ReqPrefix}/attach/image?id=${id}${cacheParam}`;
}
export function removeOldStyles(rule) {
    BI.keys(BI.get(rule, 'style')).forEach(key => {
        rule.prop(key, '');
    });
}
export function addNewStyles(rule, styles) {
    BI.keys(styles).forEach(key => {
        rule.prop(key, BI.get(styles, key));
    });
}
// 填补page和table之间的空白
// REPORT-24262 如果冻结了单元格则不填补空白
export function adjustRows(rows, paperHeight, isFrozen = false) {
    rows[rows.length - 3] = 0;
    // REPORT-70684 如果总行高未超过纸张高度，走此分支 会出现大段空白
    const totalHeight = rows.reduce((r, i) => r + i, 0);
    if (!isFrozen && totalHeight > paperHeight) {
        rows[rows.length - 3] = Math.max(paperHeight - totalHeight, 0);
    }
    else {
        rows[rows.length - 3] = SCROLLBAR_WIDTH;
    }
    return rows;
}
export function adjustCols(cols, paperWidth, isFrozen = false) {
    if (cols.length >= 2) {
        /** 如果列宽之和没有超过纸张宽度， 那么也不需要走此分支 */
        const totalWidth = cols.reduce((r, i) => r + i, 0);
        if (!isFrozen && totalWidth > paperWidth) {
            cols[cols.length - 2] = Math.max(paperWidth - totalWidth, 0);
        }
        else {
            cols[cols.length - 2] = 0;
            cols[cols.length - 1] = SCROLLBAR_WIDTH;
        }
    }
    return cols;
}
export function getCellSize(celldimension, colDefalut, rowDefault) {
    let col = 0, row = 0;
    if (celldimension) {
        const { width, height } = celldimension;
        col = Math.max(colDefalut || 0, width);
        row = Math.max(rowDefault || 0, height);
    }
    return {
        col,
        row,
    };
}
/**
 * 转换cell value值
 * @param value string类型
 * @returns object
 */
export function getCellValue(value) {
    try {
        return JSON.parse(value);
    }
    catch (e) {
        return undefined;
    }
}
/**
 * 根据cell值获取cell实际值
 * @param cell cell
 * @returns 实际值
 */
export function getCellValueByCell(cell) {
    var _a, _b, _c;
    if (cell === null || cell === void 0 ? void 0 : cell.value) {
        const value = getCellValue(cell.value);
        return (_c = (_b = (_a = value === null || value === void 0 ? void 0 : value.cv) !== null && _a !== void 0 ? _a : value === null || value === void 0 ? void 0 : value.value) !== null && _b !== void 0 ? _b : value === null || value === void 0 ? void 0 : value.text) !== null && _c !== void 0 ? _c : cell.value;
    }
    return undefined;
}
/**
 * 根据cell值获取cell显示值
 * @param cell cell
 * @returns 显示值
 */
export function getCellTextByCell(cell) {
    const cellValue = getCellValueByCell(cell);
    return transformCellCv(cellValue).text;
}
export function getCell(pageResult, tableCellGenerator) {
    const { value, cellhyperlink, celladvancedattr, cellstyle, celladjustattr, valid, widget, sortHeader } = pageResult, pageResultArgs = __rest(pageResult, ["value", "cellhyperlink", "celladvancedattr", "cellstyle", "celladjustattr", "valid", "widget", "sortHeader"]);
    const cellValue = getCellValue(value);
    return tableCellGenerator.generate({
        style: getCellStyle(cellstyle, {
            textAlign: (cellValue === null || cellValue === void 0 ? void 0 : cellValue.value) !== 'NaN' && BI.isNaN(cellValue === null || cellValue === void 0 ? void 0 : cellValue.value)
                ? 'left'
                : 'right',
            cellJust: (celladjustattr === null || celladjustattr === void 0 ? void 0 : celladjustattr.adjustStrategy) || 'HEIGHT',
        }),
        cell: Object.assign(Object.assign(Object.assign({}, pageResultArgs), cellValue), { valid: BI.isNull(valid) ? true : valid }),
        widget,
        cellhyperlink,
        celladvancedattr,
        sortHeader,
    });
}
export function expandHtml(html = '', style, fontScale = 1) {
    const defaultCellStyle = {
        paddingLeft: 0,
        paddingRight: 0,
        lineHeight: 0,
        spacingAfter: 0,
        spacingBefore: 0,
        verticalAlign: 'middle',
        textAlign: 'center',
        color: -16777216,
        bold: false,
        fontFamily: 'SimSun',
        fontSize: 12,
        italic: true,
        strikeThrough: false,
        textShadow: false,
        underLine: {
            width: 0,
            style: '',
            color: -16777216,
        },
        height: 'auto',
        cursor: '',
    };
    const cellStyle = Object.assign(Object.assign({}, defaultCellStyle), style);
    const { paddingLeft, paddingRight, lineHeight, spacingAfter, spacingBefore, verticalAlign, textAlign, color, bold, fontFamily, italic, strikeThrough, underLine, textShadow, fontSize, height, cursor } = cellStyle;
    const verticalTypes = new Map([['TOP', 0], ['MIDDLE', 50], ['BOTTOM', 100]]);
    const transform = `translateY(-${verticalTypes.get(verticalAlign)}%)`;
    const cls = `html-cell-${BI.UUID()}`;
    const textDecorations = [];
    if (strikeThrough) {
        textDecorations.push('line-through');
    }
    if (underLine.width) {
        textDecorations.push('underline');
    }
    jss.use(jssGlobal(), jssNested());
    const element = document.createElement('style');
    element.innerHTML = `.${cls} {
        box-sizing: border-box;
        width: 100%;
        height: ${height};
        text-align: ${textAlign.toLowerCase()};
        position: absolute;
        top: ${verticalTypes.get(verticalAlign)}%;
        -ms-transform: ${transform};
        -webkit-transform: ${transform};
        -o-transform: ${transform},
        transform: ${transform};
        line-height: ${lineHeight}px;
        padding: ${spacingBefore}px ${paddingRight}px ${spacingAfter}px ${paddingLeft}px;
        --font-scale: ${fontScale};
        color: ${transformColor(color)};
        font-weight: ${transformFontWeight(bold)};
        font-family: ${fontFamily};
        font-style: ${transformFontItalic(italic)};
        text-decoration: ${textDecorations.length > 0 ? textDecorations.join(' ') : 'normal'};
        text-shadow: ${BI.isNull(textShadow) ? 'none' : transformTextShadow2Css(textShadow)};
        font-size: ${fontSize * fontScale}px;
        ${cursor ? `cursor: ${cursor} !important;` : ''}
    }`;
    document.head.appendChild(element);
    const newHtml = `<div class="un-cssreset ${cls}">${html}</div>`;
    return {
        el: newHtml,
        initialEl: html,
        style: cellStyle,
    };
}
export function getMerge(x, y, columnSpan, rowSpan) {
    return [
        [x, y],
        [x + columnSpan - 1, y + rowSpan - 1],
    ];
}
export function getFreeze(frozen) {
    let freeze = [0, 0];
    if (frozen) {
        freeze = [frozen.colTo > -1 ? frozen.colTo + 2 : 0,
            frozen.rowTo > -1 ? frozen.rowTo + 3 : 0];
    }
    return freeze;
}
export function getImgLayout(type) {
    if (BI.isString(type)) {
        return type;
    }
    switch (type) {
        case 0:
            return 'repeat';
        case 1:
            return 'default';
        case 3:
            return 'center';
        case 2:
            return 'stretch';
        case 4:
            return 'adapt';
        default:
            return 'center';
    }
}
/**
 * 单元格地址转化为单元格位置
 * @param address 单元格地址
 */
export function address2Position(address) {
    const row = address.toLocaleUpperCase().replace(/[^a-zA-Z]/g, '');
    const col = address.replace(/[^\d]/g, '');
    if (row && col) {
        const x = row.split('')
            .reverse()
            .reduce((total, item, index) => total + (item.charCodeAt(0) - 64) * (index > 0 ? index * 25 : 1), 0) - 1;
        const y = parseInt(col.toString(), 10) - 1;
        return {
            x,
            y,
        };
    }
    return undefined;
}
/**
 * 修复冻结时合并单元格的问题
 */
export function fixFreezeMerge(data, frozen) {
    const { rowTo, colTo } = frozen || { rowTo: -1, colTo: -1 };
    for (let cy = 0; cy < data.length; cy++) {
        if (!data[cy]) {
            continue;
        }
        for (let cx = 0; cx < data[cy].length; cx++) {
            const cell = data[cy][cx];
            if (!cell) {
                continue;
            }
            const { rowSpan = 1, columnSpan = 1, x = 0, y = 0 } = cell.position;
            const cellValue = cell.value;
            let [newX, newY, needReplace] = [0, 0, false];
            if (rowSpan > 1 && rowTo >= y && y + rowSpan - 1 > rowTo) {
                newX = x;
                newY = y + rowTo + 1;
                data[newY][newX].position.rowSpan = rowSpan - rowTo - 1;
                cell.position.rowSpan = 1 + rowTo;
                needReplace = true;
                // 目前没想到什么时候会出现这种场景，先加上以防万一
                if (columnSpan > 1) {
                    data[newY][newX].position.columnSpan = columnSpan;
                }
            }
            else if (columnSpan > 1 && colTo >= x && x + columnSpan - 1 > colTo) {
                newX = x + colTo + 1;
                newY = cy;
                data[newY][newX].position.columnSpan = columnSpan - colTo - 1;
                cell.position.columnSpan = 1 + colTo;
                needReplace = true;
                if (rowSpan > 1) {
                    data[newY][newX].position.rowSpan = rowSpan;
                }
            }
            else {
                break;
            }
            if (needReplace) {
                data[newY][newX].value = cellValue;
                data[newY][newX].celladjustattr = cell.celladjustattr;
                data[newY][newX].cellstyle = cell.cellstyle;
                data[newY][newX].celladvancedattr = cell.celladvancedattr;
                data[newY][newX].cellhyperlink = cell.cellhyperlink;
                cell.value = JSON.stringify({
                    type: 'text',
                    value: '',
                });
            }
        }
    }
}
export function getSticker(x, y, cellHtml, cell) {
    var _a, _b;
    const extension = cellHtml.extended
        ? expandHtml(cellHtml.value, Object.assign(Object.assign(Object.assign(Object.assign({}, (_a = cell.cellstyle) === null || _a === void 0 ? void 0 : _a.contentStyle), (_b = cell.cellstyle) === null || _b === void 0 ? void 0 : _b.fontStyle), cellHtml.style), { cursor: cellHtml.cursor }))
        : cellHtml.value
            ? { el: cellHtml.value, style: undefined, initialEl: cellHtml.value }
            : undefined;
    return {
        id: cellHtml.id,
        position: {
            row: y,
            col: x,
        },
        el: extension === null || extension === void 0 ? void 0 : extension.el,
        extension,
        init: cellHtml.init,
        lazy: cellHtml.lazy,
    };
}
/**
 * cv转换为value
 * @param cv 实际设置值
 */
export function transformCellCv(cv) {
    let xtype = 'S', xcontent = `${cv}`;
    if (BI.isNull(cv)) {
        return { xtype, value: xcontent, text: xcontent };
    }
    if (BI.isNumber(cv)) {
        xcontent = `${cv}`;
        // 科学计数法
        if (/\./.test(xcontent) || (/e/i).test(xcontent)) {
            xtype = 'D';
        }
        else if (xcontent.length >= 10) {
            xtype = 'BigDecimal';
        }
        else {
            xtype = 'I';
        }
        return { xtype, value: xcontent, text: xcontent };
    }
    if (BI.isArray(cv)) {
        if (BI.size(cv) > 0 && BI.has(BI.first(cv), 'attach_id')) {
            xtype = 'Attachments';
            xcontent = cv.map((v) => v.attach_id).join(',');
            return { xtype, value: xcontent, text: cv.map((v) => v.filename).join(',') };
        }
        xtype = 'A';
        // REPORT-56760 二维数组第二层节点间使用分号
        if (BI.isArray(BI.first(cv))) {
            xtype = 'AA';
            xcontent = cv.map(leaves => `${leaves}`).join(';');
        }
        else {
            xcontent = `${cv}`;
        }
        return { xtype, value: xcontent, text: xcontent };
    }
    if (BI.isObject(cv)) {
        if (BI.isNotNull(cv.date_milliseconds)) {
            xtype = 'Date';
            xcontent = `${cv.date_milliseconds}`;
        }
        else if (BI.isNotNull(cv.__time__)) {
            xtype = 'Date';
            xcontent = `${cv.__time__}`;
            return { xtype, value: xcontent, text: `${new Date(cv.__time__)}` };
        }
        else if (BI.isNotNull(cv.attach_id)) {
            xtype = 'Attachments';
            xcontent = cv.attach_id;
            return { xtype, value: xcontent, text: cv.filename };
        }
        else if (BI.isEmptyObject(xcontent)) {
            xcontent = '';
        }
        return { xtype, value: xcontent, text: xcontent };
    }
    if (BI.isBoolean(cv)) {
        xtype = 'B';
        return { xtype, value: xcontent, text: xcontent };
    }
    return { xtype, value: xcontent, text: xcontent };
}
/**
 * 根据位置计算id
 * @param x 列
 * @param y 行
 * @returns 字符串
 */
export function transformPosition2Id(x, y) {
    return `${x}-${y}`;
}
export function transformFontWeight(fontWeight) {
    if (BI.isString(fontWeight)) {
        return fontWeight;
    }
    else if (BI.isNumber(fontWeight)) {
        return fontWeight > 400 ? 'bold' : 'normal';
    }
    return fontWeight ? 'bold' : 'normal';
}
function transformTextShadow(textShadow) {
    if (BI.isBoolean(textShadow)) {
        return textShadow ? DEFAULT_SHADOW : undefined;
    }
    return textShadow;
}
export function transformTextShadow2Css(textShadow) {
    if (BI.isBoolean(textShadow)) {
        return textShadow ? transformTextShadow2Css(DEFAULT_SHADOW) : 'none';
    }
    return `${textShadow.shadowOffsetX}px ${textShadow.shadowOffsetY}px ${textShadow.shadowBlur}px ${textShadow.shadowColor}`;
}
export function transformFontItalic(fontStyle) {
    if (BI.isString(fontStyle)) {
        return fontStyle;
    }
    return fontStyle ? 'italic' : 'normal';
}
/**
 * 选区内被合并的单元格填充真实单元格位置信息
 * @param tableData 表格数据
 * @param position 真实单元格位置
 */
export function fixRealCellPositionInMergeCell(tableData, position) {
    const { x, y, rowSpan = 1, columnSpan = 1 } = position;
    for (let startY = y; startY < y + rowSpan; startY++) {
        for (let startX = x; startX < x + columnSpan; startX++) {
            if (BI.isNull(tableData[startY][startX].merge))
                continue;
            tableData[startY][startX].sourceCellPosition = {
                x,
                y,
            };
        }
    }
}
//# sourceMappingURL=table.service.js.map