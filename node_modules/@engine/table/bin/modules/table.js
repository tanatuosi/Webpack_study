var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AxisSheet_1;
import { shortcut, store } from '@engine/core';
import finesheet from '@fui/sheet';
import { DEFAUTL_LINK_TYPE, linkHandlerProvider } from '@engine/link';
import { Loading } from '@engine/utils';
import jss from 'jss';
import { BackgroundColorHandler } from './handler/cell_style/handler.background_color';
import { FontStyleHandler } from './handler/cell_style/handler.font_style';
import { AbstractCellHandler } from './handler/handler.abstract';
import { PopupHandler } from './handler/handler.popup';
import { ChartNewLink } from './hyper_link/chart.link_new';
import { ChartRelateLink } from './hyper_link/chart_relate.link';
import { CellControllerManager } from './table.cell_controller_manager';
import { CellErrorTipManager } from './table.cell_error_tip_manager';
import { TableCellGenerator } from './table.cell_generator';
import { TableModel } from './table.model';
import { addNewStyles, address2Position, getCellValue, getCellValueByCell, removeOldStyles, transformPosition2Id } from './table.service';
import { TableCell } from './table_api/table.api_cell';
import { TableColumn } from './table_api/table.api_column';
import { TableRow } from './table_api/table.api_row';
// table内单元格自带的超链
linkHandlerProvider.setHandler(DEFAUTL_LINK_TYPE.CHART_POPUP, ChartNewLink);
linkHandlerProvider.setHandler(DEFAUTL_LINK_TYPE.CHART_RELATE, ChartRelateLink);
let AxisSheet = AxisSheet_1 = class AxisSheet extends BI.Widget {
    constructor() {
        super(...arguments);
        this.mouseInBounds = false;
        /**
         * 作用于sticker部分任意组件的管理器
         */
        this.stickerManagers = new Map();
        this.tableCellGenerator = new TableCellGenerator({
            attach: widget => BI.createWidget(Object.assign(Object.assign({}, widget), { element: this })),
            getTableData: () => this.store.getTableData(),
            populate: pageResults => this.populate(pageResults, {
                sync: true, silent: true, cache: true,
            }),
            partialPopulate: (cells) => {
                this.store.refreshCellValues(cells);
            },
            getWidgetName: () => this.options.widgetName,
            getStickerManagers: () => this.stickerManagers,
            getCellValueById: id => this.getCellValueById(id),
            getCellValueByWidgetName: widgetName => {
                const [controller] = this.getCellControllersByWidgetName(widgetName);
                if (BI.isNull(controller))
                    return undefined;
                const cellId = controller.attr('cellId');
                return this.getCellValueById(cellId);
            },
            getWidgetByCell: (row, col) => this.getWidgetByCell(row, col),
            setSelectCell: (info) => {
                this.store.setSelectedCell({ row: info.row, col: info.col });
                this.fireEvent(AxisSheet_1.EVENT_SELECT_CELL, info);
            },
            getDependenceValueById: (realId) => this.getDependenceValueById(realId),
            getFontResizable: () => this.model.reportFitAttr.fitFont,
        });
        /**
         * 暴露给api的方法
         */
        this.tableContext4Api = {
            addHandler: (handler, config) => this.addHandler(handler, config),
            emitCellEvent: (eventName, arg) => this.emitCellEvent(eventName, arg),
            getRow: (row) => this.getRow(row),
            getColumn: (col) => this.getColumn(col),
            getCell: (row, col) => this.getCell(row, col),
        };
        this.props = {
            baseCls: 'report-table',
            $testId: 'report-table',
            tableData: [],
            reportSettingDetail: {},
            reportFitAttr: {
                fitFont: false,
                fitStateInPC: 3,
            },
            viewAtCenter: false,
            frozen: undefined,
            browserBg: {},
            widgetName: '',
            activeBox: true,
            synchronize: false,
            /** 开启对css transform属性的支持，默认为false */
            supportCSSTransform: false,
            isDisableContextMenu: false,
        };
        this.watch = {
            reportSettingDetail: () => {
                this.reLayout();
            },
            loading: (loading) => {
                this.loading.setVisible(loading);
            },
            webBackground: () => {
                this.changeBackground('webBackground');
            },
        };
    }
    mounted() {
        !this.model.tableWidth && this.store.setTableWidth(this.table.element.width());
        !this.model.tableHeight && this.store.setTableHeight(this.table.element.height());
        !this.model.screenWidth && this.store.setScreenWidth(this.element.width());
        const tableData = this.store.getTableData();
        this.sheet = finesheet.createSheet(this.table.element[0], {
            tableWidth: this.model.tableWidth,
            tableHeight: this.model.tableHeight,
            options: {
                sheet: {
                    colc: 0,
                    rowc: 0,
                },
                contextMenuItems: [{
                        key: 'copy',
                        icon: '',
                        label: BI.i18nText('Fine-Report_Copy'),
                        accel: '',
                    }],
                sync: this.options.synchronize,
                supportCSSTransform: this.options.supportCSSTransform,
                disableContextMenu: () => this.isDisableContextMenu,
            },
        });
        const { sheet } = this.sheet;
        sheet.addEventListener('scroll', ({ x, y }) => {
            !this.model.isAdaptiveTable && this.background.element.css('transform', `translate(-${x}px, -${y}px)`);
        });
        this.populate(tableData);
        this.table.element.on('mouseenter', () => {
            this.mouseInBounds = true;
        });
        this.table.element.on('mouseleave', () => {
            this.mouseInBounds = false;
        });
    }
    render() {
        this.sheetStyles = jss
            .createStyleSheet({
            paperBackground: this.model.paperBackground,
            webBackground: this.model.webBackground,
        }, { link: true })
            .attach();
        return {
            type: BI.AbsoluteLayout.xtype,
            scrollable: false,
            cls: `${this.sheetStyles.classes.webBackground}`,
            items: [
                {
                    el: !this.model.isAdaptiveTable
                        ? {
                            type: BI.HorizontalLayout.xtype,
                            scrollx: false,
                            horizontalAlign: this.model.viewAtCenter ? BI.HorizontalAlign.Center : BI.HorizontalAlign.Left,
                            items: [{
                                    type: BI.Layout.xtype,
                                    invisible: true,
                                    cls: `${this.sheetStyles.classes.paperBackground}`,
                                    ref: (_ref) => {
                                        this.background = _ref;
                                    },
                                    // 测试发现65000时在windows上没有重影现象，但是也没有水印产生，25000可以在windows和Mac上正常显示水印
                                    // 查阅资料发现不同浏览器为了保证渲染性能，对canvas的最大宽高做了限定
                                    // 这里的限定只是暂时处理方案，保证Chrome正常，后续梳理resize相关逻辑写个最佳方案
                                    width: Math.min(this.model.paperWidth, 25000),
                                    height: Math.min(this.model.paperHeight, 25000),
                                }],
                        }
                        : {
                            type: BI.Layout.xtype,
                            invisible: true,
                            cls: `${this.sheetStyles.classes.paperBackground}`,
                            ref: (_ref) => {
                                this.background = _ref;
                            },
                        },
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                },
                {
                    el: {
                        type: BI.Layout.xtype,
                        ref: (_ref) => {
                            this.table = _ref;
                        },
                    },
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                },
                {
                    el: {
                        type: Loading.xtype,
                        ref: (_ref) => {
                            this.loading = _ref;
                        },
                        $testId: 'report-table-loading',
                        invisible: !this.model.loading,
                    },
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                },
            ],
        };
    }
    /**
     * 获取纸张所在实例
     */
    getPaperWidget() {
        return this.background;
    }
    /**
     * 根据位置获取id
     * @param col 列
     * @param row 行
     */
    getCellIdByPosition(row, col) {
        const cell = this.store.getTableData()[row][col];
        return `${cell.id}` || transformPosition2Id(col, row);
    }
    getWidgetByCell(p1, p2) {
        const { address, position } = BI.isString(p1)
            ? { address: p1, position: undefined }
            : BI.isNumber(p1) && BI.isNumber(p2)
                ? { address: undefined, position: { row: p1, col: p2 } }
                : { address: undefined, position: undefined };
        if (BI.isNull(address) && BI.isNull(position)) {
            return undefined;
        }
        const id = position ? this.getCellIdByPosition(position.row, position.col) : address;
        if (!id) {
            return undefined;
        }
        const cellControllerManager = (this.stickerManagers.get(CellControllerManager.NAME));
        if (!cellControllerManager)
            return undefined;
        cellControllerManager.initializeWidget(id);
        const widget = cellControllerManager.getWidgetByName(id);
        return widget;
    }
    /**
     * 取依赖值（与控件取值不同，若有控件值为数组，应返回最后数组最后一位，即为树结构的子节点）
     * @param realId 单元格id地址或控件id
     */
    getDependenceValueById(realId) {
        const widget = this.getWidgetByCell(realId);
        const cellValue = BI.isNull(widget) ? this.getCellValueById(realId) : widget.getDependenceValue();
        const [controller] = this.getCellControllersByWidgetName(realId);
        return BI.isNull(cellValue) ? (controller === null || controller === void 0 ? void 0 : controller.getDependenceValue()) || '' : cellValue;
    }
    /**
     * 根据控件名获取单元格控件数组
     * @param widgetName 控件名
     * @returns 单元格控件widget数组
     */
    getCellControllersByWidgetName(widgetName) {
        const cellControllerManager = (this.stickerManagers.get(CellControllerManager.NAME));
        if (!cellControllerManager)
            return [];
        cellControllerManager.getUninitializedWidgetsDict()
            .forEach(({ cellWidgetName }, id) => {
            if (cellWidgetName.toUpperCase() === widgetName.toUpperCase()) {
                cellControllerManager.initializeWidget(id);
            }
        });
        const controllers = cellControllerManager.getWidgets()
            .filter(widget => widget.attr('cellWidgetName') && widget.attr('cellWidgetName').toUpperCase() === widgetName.toUpperCase());
        return controllers;
    }
    selectCell(positionOrIdOrCell) {
        const { id, position, selectedCell } = BI.isString(positionOrIdOrCell)
            ? { id: positionOrIdOrCell, position: undefined, selectedCell: undefined }
            : BI.isNull(positionOrIdOrCell)
                ? { position: undefined, id: undefined, selectedCell: undefined }
                : 'row' in positionOrIdOrCell
                    ? { position: positionOrIdOrCell, id: undefined, selectedCell: undefined }
                    : { position: undefined, id: undefined, selectedCell: positionOrIdOrCell };
        let cell;
        const tableData = this.store.getTableData();
        if (selectedCell) {
            cell = selectedCell;
        }
        else if (id) {
            tableData.some(rowData => rowData.some(cellData => {
                if (cellData.id === id) {
                    cell = cellData;
                    return true;
                }
                return false;
            }));
        }
        else if (position) {
            cell = tableData[position.row][position.col];
        }
        else {
            tableData.some(rowData => rowData.some(cellData => {
                if (cellData.widget) {
                    cell = cellData;
                    return true;
                }
                return false;
            }));
        }
        if (cell) {
            const returnId = id || this.getCellIdByPosition(cell.position.y, cell.position.x);
            this.emitCellEvent('CELL_SELECT', { id: returnId, cell });
            return {
                id: returnId,
                cell,
            };
        }
        return undefined;
    }
    /**
     * 选中下一个单元格
     */
    selectNextCell() {
        const { row, col } = this.model.selectedCell || { row: 0, col: 0 };
        const tableData = this.store.getTableData();
        let cell;
        tableData.some(rowData => rowData.some(cellData => {
            // 当前行前，不处理
            if (cellData.position.y < row) {
                return false;
            }
            const hasWidget = !!cellData.widget;
            // 当前行的下一行
            if (cellData.position.y > row) {
                hasWidget && (cell = cellData);
                return hasWidget;
            }
            if (!!cellData.widget && cellData.position.x > col) {
                cell = cellData;
                return true;
            }
            return false;
        }));
        this.selectCell(cell);
    }
    /**
     * 通过手动调用的方式选中单元格(区别于在页面中通过点击等行为选中单元格)
     *   增加单元格状态统一的处理逻辑
     * @param positionOrIdOrCell
     * @returns
     */
    setSelectCell(positionOrIdOrCell) {
        /** 获得当前选中的Cell */
        const selectCell = this.getSelectedCell();
        /** 如果之前有选中的Cell且处于激活状态, 那么此Cell可能为脏数据，对其进行联动更新 */
        if (selectCell) {
            const widget = this.getWidgetByCell(selectCell.row, selectCell.col);
            (widget === null || widget === void 0 ? void 0 : widget.isActive()) && this.emitCellEvent('ACTIVE_CELL_FORCE_UPDATE', {});
        }
        return this.selectCell(positionOrIdOrCell);
    }
    /**
     * 获取当前选中单元格信息
     */
    getSelectedCell() {
        return this.model.selectedCell;
    }
    getTableData() {
        return this.store.getTableData();
    }
    populate(data, options) {
        const { sync = false, cache = false, silent = false } = options || {};
        const preResult = this.store.prePopulate({
            tableWidth: this.model.tableWidth,
            tableHeight: this.model.tableHeight,
            screenWidth: this.model.screenWidth,
        }, data);
        if (!preResult) {
            return;
        }
        cache ? this.updateInstances() : this.clearInstances();
        this.model.isAdaptiveTable || sync || this.options.synchronize
            ? this.store.completeLoadData(preResult)
            : this.store.rowChunkLoadData(preResult);
        !silent && this.fireEvent(AxisSheet_1.EVENT_LOADED, this);
        this.background.visible();
    }
    setLoading(loading) {
        this.store.setTableLoading(loading);
    }
    setReportSettingDetail(v) {
        this.store.setReportSetting(v);
    }
    setFrozen(frozen) {
        this.store.setFrozen(frozen);
    }
    setReportFitAttr(v) {
        this.store.setReportFitAttr(v);
        this.reset();
    }
    setViewAtCenter(viewAtCenter) {
        this.store.setViewAtCenter(viewAtCenter);
        this.reset();
    }
    setActiveBox(activeBox) {
        this.store.setActiveBox(activeBox);
        this.reset();
    }
    setTableWidth(width) {
        this.store.setTableWidth(width);
        this.reset();
    }
    setTableHeight(height) {
        this.store.setTableHeight(height);
        this.reset();
    }
    setScreenWidth(width) {
        this.store.setScreenWidth(width);
        this.reset();
    }
    setWebBackground(background) {
        this.store.setWebBackground(background);
    }
    /**
     * 自适应表格
     */
    resize(width, height) {
        this.store.setTableWidth(width);
        this.store.setTableHeight(height);
        this.store.setScreenWidth(this.element.width());
        this.updateInstances();
        this.store.resize(width, height, this.element, this.model.screenWidth);
        this.sheet.resize(width, height);
    }
    /**
     * 重绘前清除所有sticker对象
     */
    clearInstances() {
        this.stickerManagers.forEach(manager => {
            manager.destroy();
        });
    }
    /**
     * 重绘前更新所有sticker对象，可以控制不清除，manager内部处理
     */
    updateInstances() {
        this.stickerManagers.forEach(manager => {
            manager.update();
        });
    }
    /**
     * 根据单元格行列坐标获取位置，e2e对外公开接口
     * @param row 第n行，从1开始
     * @param col 第n列，从1开始
     */
    getCellPosition(row, col) {
        // 因为适配层第一行多加了一行作为边距，所以这边要row + 1
        return this.sheet.getCellPosition({
            row: row + 1,
            col,
        });
    }
    /**
     * 设置横向滚动条显隐
     */
    setHScrollBarVisible(visible) {
        this.sheet.sheet.setHScrollBarVisible(visible);
    }
    /**
     * 设置纵向滚动条显隐
     */
    setVScrollBarVisible(visible) {
        this.sheet.sheet.setVScrollBarVisible(visible);
    }
    /**
     * 开启跑马灯效果
     * @param offset 每次的滚动距离
     * @param interval 滚动间隔
     */
    startMarquee(opt) {
        const { offset = 5, interval = 0.1, stopOnHover = true, to = 'top' } = opt || {};
        const start = () => {
            const handleScroll = () => {
                /**
                 * REPORT-69352 插件-新自适应-客户环境，跑马灯的报表块，在平台上切换标签页就会出现卡顿阴影，直接预览时切换浏览器标签页没问题
                 * 加上判断，如果这个跑马灯表格的高度为0（即被隐藏了），那么跑马灯不移动
                 */
                const isHidden = this.table.element.width() === 0 || this.table.element.height() === 0;
                if (!(stopOnHover && this.mouseInBounds || isHidden)) {
                    to === 'left' || to === 'right' ?
                        this.whellScrollX(to === 'right' ? 0 - offset : offset) :
                        this.whellScrollY(to === 'bottom' ? 0 - offset : offset);
                }
                this.timer = window.setTimeout(handleScroll, interval * 1000);
            };
            !this.timer && (this.timer = window.setTimeout(handleScroll, interval * 1000));
        };
        start();
    }
    /**
     * 关闭跑马灯效果
     */
    stopMarquee() {
        window.clearTimeout(this.timer);
        this.timer = undefined;
    }
    /**
     * 改变背景色
     */
    addBackgroundColorHandler(config) {
        this.store.addHandler(BackgroundColorHandler, config);
    }
    addHighlightRowEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'line',
            trigger,
        });
    }
    addHighlightRowHoldEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'line',
            hold: 'row',
            trigger,
        });
    }
    addHighlightColEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'column',
            trigger,
        });
    }
    addHighlightColHoldEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'column',
            hold: 'column',
            trigger,
        });
    }
    addHighlightCrossEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'cross',
            trigger,
        });
    }
    addHighlightCrossHoldEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'cross',
            hold: 'cross',
            trigger,
        });
    }
    addHighlightCellEffect(color, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'cell',
            trigger,
        });
    }
    addHighlightCellHoldEffect(color, singleLine = false, trigger) {
        this.addBackgroundColorHandler({
            style: color,
            type: 'cell',
            hold: singleLine ? 'row' : 'all',
            trigger,
        });
    }
    /**
     * 改变字体样式
     */
    addFontStyleHandler(config) {
        this.store.addHandler(FontStyleHandler, config);
    }
    addSetCellFontEffect(fontConfig, trigger) {
        this.addFontStyleHandler({
            style: fontConfig,
            type: 'cell',
            trigger,
        });
    }
    addSetCellFontHoldEffect(fontConfig, singleLine = false, trigger) {
        this.addFontStyleHandler({
            style: fontConfig,
            type: 'cell',
            hold: singleLine ? 'row' : 'all',
            trigger,
        });
    }
    addSetRowFontEffect(fontConfig, trigger) {
        this.addFontStyleHandler({
            style: fontConfig,
            type: 'line',
            trigger,
        });
    }
    addSetRowFontHoldEffect(fontConfig, singleLine = false, trigger) {
        this.addFontStyleHandler({
            style: fontConfig,
            type: 'line',
            hold: singleLine ? 'row' : 'all',
            trigger,
        });
    }
    addPopoverEffect(address, opts) {
        this.store.addHandler(PopupHandler, {
            position: address2Position(address),
            scopeType: opts.type,
            body: opts.text,
            header: opts.header,
            image: opts.image,
            style: opts.style,
        });
    }
    addHandler(handler, config) {
        this.store.addHandler(handler, config);
    }
    /**
     * 单元格实现圆角
     * @param radius
     */
    setCellRadius(radius, range, single) {
        this.emitCellEvent('CELL_SET_RADIUS', {
            radius,
            range,
            single,
        });
    }
    /**
     * 改变单元格行高
     * @param row 行号
     * @param height 行高
     */
    setRowHeight(row, height) {
        const pageResults = this.store.getTableData();
        pageResults[row - 1].forEach(cell => {
            cell.celldimension.height = height;
        });
        this.populate(pageResults);
    }
    /**
     * 改变单元格列宽
     * @param col 列号
     * @param height 列宽
     */
    setColWidth(col, height) {
        const pageResults = this.store.getTableData();
        pageResults.forEach(rowCells => {
            rowCells[col - 1].celldimension.width = height;
        });
        this.populate(pageResults);
    }
    getCellValue(x, y) {
        return BI.isNumber(x) && BI.isNumber(y)
            ? this.getTableCellValueByPosition(y + 1, x + 1)
            : this.getTableCellValueByPosition(x, y);
    }
    getCellVal(x, y) {
        return this.getTableCellValueByPosition(x, y);
    }
    getTableCellValueByPosition(x, y) {
        const tableData = this.store.getTableData();
        const position = BI.isNumber(x) && BI.isNumber(y)
            ? { x: y - 1, y: x - 1 }
            : BI.isString(x)
                ? address2Position(x)
                : undefined;
        if (position && tableData) {
            const cell = tableData[position.y][position.x];
            return getCellValueByCell(cell);
        }
        return undefined;
    }
    /**
     * 校验单元格控件
     */
    verifyCellControllers() {
        const controllerManager = this.stickerManagers.get(CellControllerManager.NAME);
        if (!controllerManager) {
            return [];
        }
        const results = [];
        controllerManager.getWidgets()
            .forEach(widget => {
            const validation = widget.getValidation();
            if (validation.result) {
                return;
            }
            results.push({
                id: widget.attr('cellId'),
                message: validation.errorMsg,
            });
        });
        return results;
    }
    /**
     * 获取所有脏数据
     */
    getDirtyCells(clear = true) {
        const tableData = this.store.getTableData();
        const results = [];
        tableData.forEach(row => {
            row.forEach(cell => {
                if (cell.dirty) {
                    const { value, xtype = '' } = getCellValue(cell.value) || { value: '', xtype: '' };
                    results.push({
                        col: cell.position.x,
                        row: cell.position.y,
                        value,
                        xtype: xtype || 'S',
                        frs: !!cell.frs,
                    });
                }
            });
        });
        clear && this.clearDirtyCells();
        return results;
    }
    /**
     * 清空脏数据状态
     */
    clearDirtyCells() {
        const tableData = this.store.getTableData();
        tableData.forEach(row => {
            row.forEach(cell => {
                if (cell.dirty) {
                    cell.dirty = false;
                }
            });
        });
    }
    /**
     * 获取已编辑单元格
     */
    getEditedCells() {
        const editCells = [];
        const tableData = this.store.getTableData();
        tableData.forEach(row => {
            row.forEach(cell => {
                if (cell.edited) {
                    editCells.push(cell);
                }
            });
        });
        return editCells;
    }
    /**
     * 清空修改数据状态
     */
    clearEditedCells() {
        const tableData = this.store.getTableData();
        tableData.forEach(row => {
            row.forEach(cell => {
                if (cell.edited) {
                    cell.edited = false;
                }
            });
        });
    }
    /**
     * 设置错误单元格
     * @param cells 单元格信息
     */
    setErrorCells(cells) {
        const tableData = this.store.getTableData();
        const map = cells.reduce((result, { id, message }) => {
            result.set(id, message);
            return result;
        }, new Map());
        const results = [];
        tableData.forEach(row => {
            row.forEach(cell => {
                if (BI.isNull(cell.id))
                    return;
                const message = map.get(cell.id);
                if (!message)
                    return;
                cell.errorMsg = message;
            });
        });
        return results;
    }
    /**
     * 获取错误单元格
     */
    getErrorCells() {
        const tableData = this.store.getTableData();
        const errorCells = [];
        tableData.forEach(row => {
            row.forEach(cell => {
                if (BI.isNull(cell.id))
                    return;
                if (BI.isNotNull(cell.errorMsg)) {
                    errorCells.push(cell);
                }
            });
        });
        return errorCells;
    }
    /**
     * 清空修改数据状态
     */
    clearErrorCells() {
        const tableData = this.store.getTableData();
        const results = [];
        tableData.forEach(row => {
            row.forEach(cell => {
                if (cell.errorMsg) {
                    cell.errorMsg = undefined;
                }
            });
        });
        return results;
    }
    setCellValue(x, y, value) {
        return BI.isNumber(x) && BI.isNumber(y)
            ? this.setTableCellValueByPosition(y + 1, x + 1, value)
            : this.setTableCellValueByPosition(x, y, value);
    }
    setCellVal(x, y, value) {
        return this.setTableCellValueByPosition(x, y, value);
    }
    setTableCellValueByPosition(x, y, value) {
        const position = BI.isNumber(x) && BI.isNumber(y)
            ? { x: y - 1, y: x - 1 }
            : BI.isString(x)
                ? address2Position(x)
                : undefined;
        const $value = BI.isNaN(value)
            ? ''
            : BI.isNumber(x)
                ? value !== null && value !== void 0 ? value : ''
                : value !== null && value !== void 0 ? value : `${y !== null && y !== void 0 ? y : ''}`;
        return this.setCellValueByPosition($value, position);
    }
    /**
     * 设置指定单元格的值
     * @param value 单元格值
     * @param address 单元格位置
     */
    setCellValueByPosition(value, position) {
        if (!position) {
            return false;
        }
        this.emitCellEvent('CELL_SET_VALUE', {
            value,
            x: position.x,
            y: position.y,
        });
        return true;
    }
    beforeDestroy() {
        this.stopMarquee();
    }
    /**
     * 高亮错误单元格错误信息
     * @param id 错误单元格id
     */
    highlightErrorCell(id, messgae) {
        const cellErrorTipManager = (this.stickerManagers.get(CellErrorTipManager.NAME));
        cellErrorTipManager === null || cellErrorTipManager === void 0 ? void 0 : cellErrorTipManager.getWidgets().forEach(widget => {
            widget.invisible();
        });
        const widget = cellErrorTipManager === null || cellErrorTipManager === void 0 ? void 0 : cellErrorTipManager.getWidgetByName(id);
        messgae && (widget === null || widget === void 0 ? void 0 : widget.setText(messgae));
        widget === null || widget === void 0 ? void 0 : widget.visible();
    }
    reLayout() {
        this.changeSize();
        this.changeBackground('paperBackground');
    }
    changeSize() {
        this.background.setWidth(this.model.paperSetting.paperWidth);
        this.background.setHeight(this.model.paperSetting.paperHeight);
    }
    changeBackground(key) {
        const rule = this.sheetStyles.getRule(key);
        removeOldStyles(rule);
        addNewStyles(rule, this.model[key]);
    }
    emitCellEvent(eventName, arg) {
        var _a;
        return Promise.resolve((_a = this.tableCellGenerator.getListenerByName(eventName)) === null || _a === void 0 ? void 0 : _a.action(arg));
    }
    /**
     * 纵向滚动
     * @param offset 滚动距离
     * @param reverse 反向滚动
     */
    whellScrollY(offset) {
        // if (this.element.height() < Math.abs(offset)) {
        //     return;
        // }
        const { maxScrollY, scrollY } = this.sheet.sheet.whellScroll(0, offset);
        offset < 0 ?
            scrollY === 0 && this.sheet.sheet.whellScroll(0, maxScrollY) :
            scrollY >= Math.floor(maxScrollY) && this.sheet.sheet.whellScroll(0, 0 - maxScrollY);
    }
    /**
     * 根据单元格id将单元格的位置调整到可视范围内
     * @param id 单元格id
     * @returns
     */
    adjustCell2Visible(id) {
        const position = this.getCellPositionById(id);
        if (!position)
            return;
        /** 因为getCellPositionById的行列是从0开始的，所以需要加 1 */
        const cell = this.getCellPosition(position.row + 1, position.column + 1);
        this.sheet.sheet.whellByBounds(cell);
        const cellErrorTipManager = (this.stickerManagers.get(CellErrorTipManager.NAME));
        cellErrorTipManager === null || cellErrorTipManager === void 0 ? void 0 : cellErrorTipManager.adjustErrorTip(id, cell, this.sheet.sheet.getBounds());
    }
    /**
     * 横向滚动
     * @param offset 滚动距离
     */
    whellScrollX(offset) {
        // if (this.element.width() < Math.abs(offset)) {
        //     return;
        // }
        const { maxScrollX, scrollX } = this.sheet.sheet.whellScroll(offset, 0);
        offset < 0 ?
            scrollX === 0 && this.sheet.sheet.whellScroll(maxScrollX, 0) :
            scrollX >= Math.floor(maxScrollX) && this.sheet.sheet.whellScroll(0 - maxScrollX, 0);
    }
    /**
     * 通过单元格位置获取单元格的值
     * @param id 单元格位置 如：A1
     * @returns 单元格的值
     */
    getCellValueById(id) {
        const value = getCellValueByCell(this.getCellById(id));
        return value;
    }
    /**
     * 通过单元格位置获取单元格cell信息
     * @param id 单元格位置 如：A1
     * @returns 单元格cell信息
     */
    getCellById(id) {
        let targetCell = undefined;
        this.store.getTableData()
            .some(rowData => rowData.some(cell => {
            if (`${cell.id || ''}`.toUpperCase() === id.toUpperCase()) {
                targetCell = cell;
                return true;
            }
            return false;
        }));
        return targetCell;
    }
    /**
     * 通过单元格位置获取单元格所在行列信息
     * @param id 单元格位置 如：A1
     * @returns 单元格行列信息
     */
    getCellPositionById(id) {
        var _a;
        const positon = (_a = this.getCellById(id)) === null || _a === void 0 ? void 0 : _a.position;
        return positon ? { row: positon.y, column: positon.x } : undefined;
    }
    /**
     * 通过单元格id获得单元格所在行
     * @param id 单元格id
     * @returns 单元格所在行
     */
    getTDRow(id) {
        const position = this.getCellPositionById(id);
        return position === null || position === void 0 ? void 0 : position.row;
    }
    /**
     * 隐藏控件选中高亮提示
     */
    hideSelectFrame() {
        /**
         * 之前的改法为什么不对
         * 先达成一个共识，这个暴露出去的Api要做的事情是控制整个Sheet是否显示selectFrame
         *   1、之前的这种方法获得到的控件只能是显示在页面的控件，而系统中存在着还没有被mounted的控件
         *   2、就算是全部直接显示个控件，上面这样的改法也不对
         *      控制selectFrame显示应该是一个在设置selectCell时主动去取是否显示selectFrame的值，
         *      而不是调用这个Api的时候去将所有控件的selectFrame设置为不显示
         * 如果是通过调用此方法将控件的selectFrame隐藏掉，那么这只是一次性的，如果后续又有选择cell的动作就G了
         */
        const cellControllerManager = (this.stickerManagers.get(CellControllerManager.NAME));
        if (!cellControllerManager)
            return;
        cellControllerManager === null || cellControllerManager === void 0 ? void 0 : cellControllerManager.setHideSelectFrameSign(true);
    }
    /**
     * 获取第col列，第row行的单元格对象，合并非首行的返回undefined
     * @param col 列
     * @param row 行
     * @returns 单元格对象
     */
    getCell(row, col) {
        const tableData = this.store.getTableData();
        const cell = tableData[+row - 1].find(cell => cell.position.x === +col - 1 && cell.value);
        return BI.isNull(cell)
            ? undefined
            : new TableCell(this.tableContext4Api, cell);
    }
    /**
     * 获取指定行对象
     * @param row 索引
     * @returns 行对象
     */
    getRow(row) {
        const tableData = this.store.getTableData();
        if (BI.isNull(tableData[row - 1])) {
            return;
        }
        const validRowCells = tableData[row - 1].filter(cell => cell.value);
        return BI.size(validRowCells)
            ? new TableRow(this.tableContext4Api, {
                index: row,
                size: validRowCells[0].celldimension.height,
                unifiedPosition: validRowCells[0].position.y,
            })
            : undefined;
    }
    /**
     * 获取指定列对象
     * @param col 索引
     * @returns 列对象
     */
    getColumn(col) {
        const tableData = this.store.getTableData();
        const validColumnCells = tableData.reduce((total, rowCells) => {
            const cell = rowCells.find(cell => cell.value && cell.position.x === col - 1);
            !BI.isNull(cell) && total.push(cell);
            return total;
        }, []);
        return BI.size(validColumnCells)
            ? new TableColumn(this.tableContext4Api, {
                index: col,
                size: validColumnCells[0].celldimension.width,
                unifiedPosition: validColumnCells[0].position.x,
            })
            : undefined;
    }
    /**
     * 获取行数
     * @returns 行数
     */
    getRowCount() {
        const tableData = this.store.getTableData();
        const rowCount = tableData.reduce((total, rowCells) => total + (BI.isNull(rowCells.some(cell => cell.value)) ? 0 : 1), 0);
        return rowCount;
    }
    /**
     * 获取列数
     * @returns 列数
     */
    getColumnCount() {
        const tableData = this.store.getTableData();
        const columnCount = tableData.reduce((max, rowCells) => Math.max(max, rowCells.filter(cell => cell.value).length), 0);
        return columnCount;
    }
    /**
     * 创建自定义事件监听handler
     */
    createCustomEventHandler(actionType, callback) {
        const context = this;
        return class extends AbstractCellHandler {
            constructor() {
                super(...arguments);
                this.name = `${actionType}_CUSTOM_EVENT`;
                this.eventNames = [actionType];
                this.merger = '';
            }
            action(args) {
                const { e, cell } = args;
                if (!BI.isNull(cell)) {
                    const { x, y } = cell.position;
                    callback(e, context.getCell(y + 1, x + 1));
                }
            }
        };
    }
    /**
     * 添加事件监听
     * @param actionType 事件type
     * @param func 事件逻辑
     */
    addMouseEventHandler(actionType, callback) {
        this.store.addHandler(this.createCustomEventHandler(actionType, callback));
    }
    /**
     * 设置滚动位置
     * @param x 横坐标
     * @param y 纵坐标
     */
    scrollTo(x, y) {
        x && this.whellScrollX(x);
        y && this.whellScrollY(y);
    }
    /**
     * 获取滚动位置
     * @returns 位置
     */
    getScrollOffset() {
        const { left, top } = this.sheet.sheet.getBounds();
        return {
            x: left,
            y: top,
        };
    }
    destroyed() {
        var _a;
        (_a = this.sheet) === null || _a === void 0 ? void 0 : _a.tear();
    }
    /**
     * 是否禁用表格contextMenu
     * @param disable
     */
    disableContextMenu(disable) {
        this.isDisableContextMenu = disable;
    }
};
AxisSheet.xtype = 'report.table';
AxisSheet.EVENT_LOADED = 'EVENT_LOADED';
AxisSheet.EVENT_FETCH_DATA = 'EVENT_FETCH_DATA';
AxisSheet.EVENT_SELECT_CELL = 'EVENT_SELECT_CELL';
AxisSheet = AxisSheet_1 = __decorate([
    shortcut(),
    store(TableModel, {
        props() {
            return {
                reportSettingDetail: this.options.reportSettingDetail,
                reportFitAttr: this.options.reportFitAttr,
                tableData: this.options.tableData,
                frozen: this.options.frozen,
                viewAtCenter: this.options.viewAtCenter,
                activeBox: this.options.activeBox,
                loadData: (data) => {
                    var _a;
                    (_a = this.sheet) === null || _a === void 0 ? void 0 : _a.loadData(data);
                },
                tableCellGenerator: this.tableCellGenerator,
                tableWidth: this.options.tableWidth,
                tableHeight: this.options.tableHeight,
                screenWidth: this.options.screenWidth,
                webBackground: this.options.browserBg,
            };
        },
    })
], AxisSheet);
export { AxisSheet };
//# sourceMappingURL=table.js.map