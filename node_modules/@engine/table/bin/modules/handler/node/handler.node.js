import { Loading } from '@engine/utils';
import { AbstractCellHandler } from '../handler.abstract';
export class NodeCellClickHandler extends AbstractCellHandler {
    constructor(externalInterface, opt) {
        super(externalInterface);
        this.eventNames = ['CELL_NODE_CLICK'];
        this.name = 'NODE_CLICK';
        this.merger = 'uniqe';
        this.cache = new Map();
        this.effectEntryMap = new Map();
        this.nodeDataFetcher = async () => undefined;
        this.nodeDataFetcher = (opt === null || opt === void 0 ? void 0 : opt.nodeDataFetcher) || this.nodeDataFetcher;
    }
    /**
     * 设置effectEntryMap，测试用
     * @param v 值
     */
    setEffectEntryMap(v) {
        const values = BI.isArray(v) ? v : [v];
        values.forEach(({ key, value }) => {
            this.effectEntryMap.set(key, value);
        });
    }
    /**
     * 设置effectEntryMap，测试用
     * @param v 值
     */
    setCache(v) {
        const values = BI.isArray(v) ? v : [v];
        values.forEach(({ value, key }) => {
            this.cache.set(key, value);
        });
    }
    /**
     * 挂载不透明的loading
     */
    attach() {
        if (!this.loading) {
            this.externalContext.attach({
                type: BI.AbsoluteLayout.xtype,
                items: [{
                        el: {
                            type: Loading.xtype,
                            ref: (_ref) => {
                                this.loading = _ref;
                            },
                            cls: 'transparent',
                        },
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                    }],
            });
        }
    }
    async action({ open, id, eventName, layer }) {
        this.attach();
        let pageResults = this.externalContext.getTableData();
        if (!eventName) {
            // 单个节点展开或收起
            let pageCellData;
            pageResults.some(rowData => rowData.some(cellData => {
                if (cellData.id === id) {
                    pageCellData = cellData;
                    return true;
                }
                return false;
            }));
            if (!pageCellData) {
                return;
            }
            pageResults = await this.getPageResults(pageResults, pageCellData, open);
        }
        else if (eventName === 'NODE_COLLAPSE') {
            let startIndent = 0;
            pageResults.forEach(rowData => {
                rowData.forEach(({ indent }) => {
                    BI.isNotNull(indent) && (startIndent = Math.max(startIndent, indent));
                });
            });
            for (let indent = startIndent; indent >= Math.max(startIndent - layer, 0); indent--) {
                for (const rowData of pageResults) {
                    for (const cellData of rowData) {
                        if (cellData.id && cellData.indent === indent && cellData.open === open) {
                            pageResults = await this.getPageResults(pageResults, cellData, open);
                        }
                    }
                }
            }
        }
        else if (eventName === 'NODE_COLLAPSE_TO') {
            for (const rowData of pageResults) {
                for (const cellData of rowData) {
                    if (cellData.id && cellData.indent === layer && cellData.open === open) {
                        pageResults = await this.getPageResults(pageResults, cellData, open);
                    }
                }
            }
        }
        else {
            for (let indent = 0; indent < layer; indent++) {
                let shouldContinue = false;
                for (const rowData of pageResults) {
                    for (const cellData of rowData) {
                        if (cellData.id && cellData.indent === indent && cellData.open === open) {
                            pageResults = await this.getPageResults(pageResults, cellData, open);
                        }
                        shouldContinue = shouldContinue || (BI.isNotNull(cellData.indent) ? cellData.indent >= indent : false);
                    }
                }
                if (!shouldContinue) {
                    break;
                }
            }
        }
        this.externalContext.populate(pageResults);
        this.loading.invisible();
    }
    async getPageResults(pageResults, cellData, open) {
        let newPageResults;
        if (!cellData.id) {
            return pageResults;
        }
        // 需要展开
        if (!open) {
            newPageResults = await this.expandRow(pageResults, cellData.id);
        }
        else {
            newPageResults = this.collapseRow(pageResults, cellData.id);
        }
        cellData.open = !open;
        return newPageResults;
    }
    /**
     * 获取展开值
     * @param table table对象
     * @param id 点击节点的id
     */
    async getNodeData(id) {
        this.loading.visible();
        const data = this.cache.get(id);
        if (data) {
            this.cache.delete(id);
            return data;
        }
        const result = await this.nodeDataFetcher({
            layer: id,
        });
        if (!result) {
            return [];
        }
        if (result.effectEntries) {
            this.effectEntryMap.set(id, result.effectEntries);
        }
        return result.pageResult;
    }
    /**
     * 展开行
     * @param raw 原始数据
     * @param id 父节点id
     */
    async expandRow(raw, id) {
        const expandData = processRowExpandedData(raw, await this.getNodeData(id), id);
        const pageResults = expandRow(raw, expandData);
        const effectEntries = this.getEffectEntries(expandData, id);
        const targetIds = effectEntries.map(({ targetId }) => targetId);
        pageResults.forEach(rowData => {
            rowData.forEach(cellData => {
                if (cellData.id && targetIds.includes(cellData.id)) {
                    effectEntries.forEach(({ targetId, effectRows }) => {
                        if (cellData.id === targetId) {
                            cellData.position.rowSpan = (cellData.position.rowSpan || 1) + effectRows;
                        }
                    });
                }
            });
        });
        return pageResults;
    }
    /**
     * 收起行
     * @param raw 原始数据
     * @param pId 父节点id
     */
    collapseRow(raw, pId) {
        const { expanded, unexpanded } = splitPageResultsByRow(raw, pId);
        const maxY = minimize(expanded, 'y');
        unexpanded.forEach(row => {
            row.forEach(cellData => {
                const y = cellData.position.y;
                if (y >= maxY) {
                    cellData.position.y -= expanded.length;
                }
            });
        });
        this.cache.set(pId, expanded);
        const effectEntries = this.getEffectEntries(expanded, pId);
        const targetIds = effectEntries.map(({ targetId }) => targetId);
        unexpanded.forEach(rowData => {
            rowData.forEach(cellData => {
                if (cellData.id && targetIds.includes(cellData.id)) {
                    effectEntries.forEach(({ targetId, effectRows }) => {
                        if (cellData.id === targetId && cellData.position.rowSpan) {
                            cellData.position.rowSpan -= effectRows;
                        }
                    });
                }
            });
        });
        return unexpanded;
    }
    /**
     * 计算data内要收起的相关id
     * @param data 数据
     * @param id 默认id
     */
    getEffectEntries(data, id) {
        const relatedIds = [id];
        data.forEach(rowData => {
            rowData.forEach(cellData => {
                if (cellData.id && cellData.open) {
                    relatedIds.push(cellData.id);
                }
            });
        });
        const effectEntries = relatedIds.reduce((entry, id) => entry.concat(this.effectEntryMap.get(id) || []), []);
        return effectEntries;
    }
}
/**
 * 修正拓展行数据的y
 * @param raw 原始数据
 * @param expanded 推展数据
 * @param id 拓展节点id
 */
export function processRowExpandedData(raw, expanded, id) {
    const upperYs = new Set();
    const curRow = raw.find(rowData => rowData.map(cellData => cellData.id).includes(id));
    if (!curRow) {
        return expanded;
    }
    let highlight = false, curY = BI.first(curRow).position.y;
    curRow.forEach(cellData => {
        if (!highlight) {
            highlight = cellData.id === id;
        }
        if (highlight) {
            curY = Math.max(curY, cellData.position.y + (cellData.position.rowSpan || 1) - 1);
        }
    });
    raw.forEach(rowData => {
        const $curY = BI.first(rowData).position.y;
        if ($curY <= curY) {
            upperYs.add($curY);
        }
    });
    const gapY = minimize(expanded, 'y') - upperYs.size;
    expanded.forEach(rowData => {
        rowData.forEach(cellData => {
            cellData.position.y -= gapY;
        });
    });
    return expanded;
}
/**
 * 拓展行
 * @param raw 原始表格数据
 * @param expanded 新表格数据
 */
function expandRow(raw, expanded) {
    const minY = minimize(expanded, 'y');
    raw.forEach(row => {
        row.forEach(cellData => {
            const y = cellData.position.y;
            if (y >= minY) {
                cellData.position.y += expanded.length;
            }
        });
    });
    return raw.concat(expanded);
}
/**
 * 分离出和pId下的所有子节点
 * @param raw 原始数据
 * @param pId 父id
 * @param stay 父id所在行是否留下
 */
export function splitPageResultsByRow(raw, pId, stay = true) {
    let childrenIds = [], unexpanded = [], expanded = [];
    // 先找到id所在单元格信息
    let targetCell;
    raw.some(rowData => rowData.some(cellData => {
        if (cellData.id && cellData.id === pId) {
            targetCell = cellData;
            return true;
        }
        return false;
    }));
    if (!targetCell) {
        return { expanded: [], unexpanded: raw };
    }
    const mergedRowYs = new Set(), expandedRowYs = new Set();
    raw.forEach(rowData => {
        rowData.forEach(cellData => {
            if (targetCell.id && cellData.pId === targetCell.id) {
                expandedRowYs.add(cellData.pId);
            }
            if (cellData.position.y !== targetCell.position.y || cellData.position.x < targetCell.position.x) {
                return;
            }
            if (!cellData.position.rowSpan) {
                return;
            }
            for (let i = 1; i < cellData.position.rowSpan; i++) {
                mergedRowYs.add(targetCell.position.y + i);
            }
        });
    });
    raw.forEach(rowData => {
        const isTargetRow = rowData.some(cellData => cellData.id === pId);
        if (isTargetRow) {
            unexpanded.push(rowData);
            return;
        }
        const isExpandedRow = rowData.some(cellData => cellData.pId && expandedRowYs.has(cellData.pId));
        if (isExpandedRow) {
            rowData.some(cellData => {
                if (BI.isNotNull(cellData.id) && BI.isNotNull(cellData.pId)) {
                    childrenIds = BI.uniq(childrenIds.concat([cellData.id]));
                    return true;
                }
                return false;
            });
        }
        unexpanded.push(rowData);
    });
    // 处理子节点id
    childrenIds.forEach(id => {
        const result = splitPageResultsByRow(unexpanded, id, false);
        unexpanded = result.unexpanded;
        expanded = expanded.concat(result.expanded);
    });
    // 处理子节点，子节点应该全部收起
    unexpanded = unexpanded.filter(rowData => {
        const isChild = rowData.some(cellData => cellData.id && childrenIds.includes(cellData.id));
        if (isChild) {
            expanded.push(rowData);
        }
        return !isChild;
    });
    const unMerged = [];
    unexpanded.forEach(rowData => {
        const isMergedRow = rowData.some(cellData => mergedRowYs.has(cellData.position.y)) && !stay;
        if (isMergedRow) {
            expanded.push(rowData);
        }
        else {
            unMerged.push(rowData);
        }
    });
    return { unexpanded: unMerged, expanded };
}
/**
 * 找到表格数据中最小的X或Y
 * @param pageResults 表格数据
 */
function minimize(pageResults, key) {
    return pageResults.reduce((min, rowData) => Math.min(rowData.reduce(($min, cellData) => Math.min($min, cellData.position[key]), Infinity), min), Infinity);
}
//# sourceMappingURL=handler.node.js.map