import { transformColor } from '@engine/core';
import { DEFAULT_BORDER } from '../table.constants';
import { AbstractCellHandler } from './handler.abstract';
/**
 * 设置单元格样式，css属性
 */
export class CellSetStyleHandler extends AbstractCellHandler {
    constructor() {
        super(...arguments);
        this.eventNames = ['CELL_SET_STYLE'];
        this.name = 'CELL_SET_STYLE';
        this.merger = 'covered';
    }
    action(args) {
        var _a;
        const { x, y, style = {} } = args;
        const cellStyle = this.transformStyle2CellStyle(style);
        const pageResults = this.tableData;
        if (!BI.isNull(x) && !BI.isNull(y)) {
            BI.deepExtend((_a = pageResults[y].find(cell => cell.position.x === x)) === null || _a === void 0 ? void 0 : _a.cellstyle, cellStyle);
        }
        else if (BI.isNull(x)) {
            pageResults[y].forEach(cell => {
                BI.deepExtend(cell.cellstyle, cellStyle);
            });
        }
        else {
            pageResults.forEach(rowCells => {
                var _a;
                BI.deepExtend((_a = rowCells.find(cell => cell.position.x === x)) === null || _a === void 0 ? void 0 : _a.cellstyle, cellStyle);
            });
        }
        this.externalContext.populate(pageResults);
    }
    transformStyle2CellStyle(style) {
        const cellStyle = {
            cellBackground: {
                background: this.transformBackground(style),
            },
            borderStyle: this.transformBorderStyle(style),
            fontStyle: this.transFormFontStyle(style),
            contentStyle: this.transformContentStyle(style),
        };
        return cellStyle;
    }
    transFormFontStyle(style) {
        const { fontWeight = 'normal', fontStyle = 'normal', fontFamily = '', fontSize = 12, color = '#000', textDecorationColor = '', textDecorationLine = '', textDecorationStyle = '', textDecorationThickness = 0, // 这个只允许输入尺寸
        textShadow, } = style;
        const textShadowAttr = (textShadow === null || textShadow === void 0 ? void 0 : textShadow.split(' ')) || [];
        return {
            bold: fontWeight,
            italic: fontStyle,
            fontFamily,
            strikeThrough: textDecorationLine.indexOf('line-through') !== -1,
            fontSize: this.getIntValue(fontSize),
            color,
            underLine: {
                width: textDecorationLine.indexOf('underline') !== -1
                    ? this.getIntValue(textDecorationThickness)
                    : 0,
                style: textDecorationStyle,
                color: textDecorationColor,
            },
            textShadow: {
                shadowBlur: this.getIntValue(textShadowAttr[2]),
                shadowColor: textShadowAttr[3] || 'black',
                shadowOffsetX: this.getIntValue(textShadowAttr[0]),
                shadowOffsetY: this.getIntValue(textShadowAttr[1]),
            },
        };
    }
    transformContentStyle(style) {
        const { padding, paddingBottom, paddingLeft, paddingRight, paddingTop, lineHeight = 0, verticalAlign = '', textAlign = '', whiteSpace = '', } = style;
        const paddingArr = (padding === null || padding === void 0 ? void 0 : padding.split(' ')) || [];
        return {
            paddingLeft: this.getIntValue(paddingLeft || paddingArr[3]),
            paddingRight: this.getIntValue(paddingRight || paddingArr[1]),
            spacingAfter: this.getIntValue(paddingBottom || paddingArr[2]),
            spacingBefore: this.getIntValue(paddingTop || paddingArr[0]),
            lineHeight,
            verticalAlign,
            textAlign,
            newLine: whiteSpace, // 可选值 AUTO_NEWLINE, SINGLE_LINE, SINGLE_LINE_ADJUST_FONT, MULTI_LINE_ADJUST_FONT;
        };
    }
    transformBackground(style) {
        const { backgroundColor, backgroundImage, backgroundRepeat, // backgroundRepeat也只支持单值语法，可选值'repeat' | 'adapt' | 'stretch' | 'center' | 'default'
         } = style;
        return Object.assign(Object.assign(Object.assign({}, BI.isNull(backgroundImage)
            ? {}
            : this.transformBackgroundImage(backgroundImage)), BI.isNull(backgroundColor)
            ? {}
            : {
                backgroundType: 'ColorBackground',
                color: backgroundColor,
            }), { layout: backgroundRepeat });
    }
    transformBackgroundImage(backgroundImage) {
        const background = {};
        // 先替换里面的rgb，要不括号不好匹
        const commonBackgroundImage = this.transformRgb2Color(backgroundImage);
        const url = commonBackgroundImage.match(/url\((.+?)\)/g);
        const linearGradient = commonBackgroundImage.match(/linear-gradient\((.+?)\)/g);
        if (!BI.isNull(url)) {
            // 设置多背景图也只取首个
            background.imgUrl = url[0].replace(/"|'|url|\(|\)/g, '');
            background.backgroundType = 'ImageBackground';
        }
        else if (!BI.isNull(linearGradient)) {
            // 只支持最简单的横向或纵向渐变,不带方向默认按纵向
            const linearArr = linearGradient[0].replace(/"|'|linear-gradient|\(|\)/g, '').split(',');
            background.backgroundType = 'GradientBackground';
            const linearArrLength = BI.size(linearArr);
            background.direction = BI.size(linearArr[0].match(/left|right/g)) ? 0 : 1;
            background.startColor = linearArr[linearArrLength - 2];
            background.endColor = linearArr[linearArrLength - 1];
        }
        return background;
    }
    transformBorderStyle(style) {
        const { border = DEFAULT_BORDER, borderTop, borderBottom, borderLeft, borderRight, } = style;
        const defaultXborder = this.transformCssBorder2XBorder(border);
        const getXborder4Direction = (border) => BI.isNull(border)
            ? defaultXborder
            : this.transformCssBorder2XBorder(border);
        return {
            topBorder: getXborder4Direction(borderTop),
            bottomBorder: getXborder4Direction(borderBottom),
            leftBorder: getXborder4Direction(borderLeft),
            rightBorder: getXborder4Direction(borderRight),
        };
    }
    getIntValue(value = 0) {
        return parseInt(value.toString(), 10);
    }
    transformCssBorder2XBorder(border) {
        const borderArr = border.split(' ');
        return {
            width: this.getIntValue(borderArr[0]),
            style: borderArr[1] || 'solid',
            color: borderArr[2] || -1,
        };
    }
    transformRgb2Color(color) {
        var _a;
        let hexadecimalColor = color;
        (_a = color.match(/rgb\((.+?)\)/g)) === null || _a === void 0 ? void 0 : _a.forEach(rgbColor => {
            hexadecimalColor = hexadecimalColor.replace(rgbColor, transformColor(rgbColor));
        });
        return hexadecimalColor;
    }
}
//# sourceMappingURL=handler.set_cell_style.js.map