import { AbstractCellHandler } from '../handler.abstract';
import { alterRawTable, decodeCacheKey, encodeCacheKey, findValidCellData } from '../handler.service';
/**
 * 针对处理单元格的样式的handler基类
 */
export class AbstractCellStyleHandler extends AbstractCellHandler {
    constructor(externalInterface, opt) {
        super(externalInterface);
        this.eventNames = ['CELL_CLICK', 'CELL_HOVER'];
        this.merger = 'uniqe';
        this.clickCache = new Map();
        this.hoverCache = new Map();
        this.filterOperationMap = {
            line: (cell, position) => cell.position.y === position.y,
            column: (cell, position) => cell.position.x === position.x,
            cross: (cell, position) => cell.position.x === position.x || cell.position.y === position.y,
            cell: (cell, position) => cell.position.x === position.x && cell.position.y === position.y,
        };
        this.canCellResetMap = {
            row: (position, eventPosition) => position.y === eventPosition.y,
            column: (position, eventPosition) => position.x === eventPosition.x,
            all: (position, eventPosition) => position.y === eventPosition.y && position.x === eventPosition.x,
            cross: (position, eventPosition) => position.y === eventPosition.y || position.x === eventPosition.x,
            'default': () => true,
        };
        const { type, hold = 'default', trigger } = opt;
        this.filter = BI.isFunction(type) ? type : this.filterOperationMap[type];
        this.canCellReset = BI.isFunction(hold) ? hold : this.canCellResetMap[hold];
        this.trigger = trigger;
    }
    /**
     * 改变表格的值
     */
    alterTableCellStyle(cells) {
        alterRawTable(this.tableData, cells.map(({ x, y, style: alterer }) => {
            return { x, y, alterer };
        }), (raw, style) => {
            raw.cellstyle = BI.extend(raw.cellstyle || {}, style);
        });
    }
    action({ e, cell }) {
        const trigger = (e === null || e === void 0 ? void 0 : e.type) === 'mouseup' ? 'mousedown' : 'mouseover';
        this.eventTrigger = trigger;
        if (!cell) {
            if (this.eventTrigger === this.trigger) {
                this.resetTableCell();
                this.updateTable();
            }
            return;
        }
        const { x, y } = cell.position;
        const cellIsClicked = trigger === 'mousedown' && this.clickCache.has(encodeCacheKey(x, y));
        const cellIsHovered = trigger === 'mouseover' && this.hoverCache.has(encodeCacheKey(x, y));
        this.eventPosition = { x, y };
        this.resetTableCell();
        if (trigger === this.trigger || this.trigger === undefined) {
            // 如果点击的单元格已经改变，则恢复初始状态
            cellIsClicked || cellIsHovered ? this.updateTable() : this.doAction(x, y);
        }
    }
    doAction(x, y) {
        findValidCellData(this.tableData, { x, y }, this.filter)
            .forEach(cell => {
            this.alterCell(cell.position.x, cell.position.y);
        });
        this.updateTable();
    }
    updateTable() {
        this.externalContext.populate(this.tableData);
    }
    /**
     * 改变单个单元格的样式
     * @param x x坐标
     * @param y y坐标
     */
    alterCell(x, y) {
        alterRawTable(this.tableData, [{ x, y, alterer: this.cellStyle }], (raw, style) => {
            raw.value = raw.value || `{"type":"text","value":"","autoWrapInfo":"[]"}`;
            if (this.eventTrigger === 'mousedown') {
                const key = encodeCacheKey(x, y);
                this.clickCache.set(key, this.hoverCache.has(key)
                    ? this.hoverCache.get(key)
                    : this.transform2DeaultStyle(raw.cellstyle));
            }
            else if (this.eventTrigger === 'mouseover') {
                this.hoverCache.set(encodeCacheKey(x, y), this.transform2DeaultStyle(raw.cellstyle));
            }
            BI.deepExtend(raw, {
                cellstyle: style,
            });
        });
    }
    resetTableCell() {
        const cells = [];
        this.resetHoverCell(cells);
        this.resetClickCell(cells);
        this.alterTableCellStyle(cells);
    }
    resetHoverCell(cells) {
        if (this.eventTrigger === 'mousedown') {
            return;
        }
        this.hoverCache.forEach((value, key) => {
            const { x, y } = decodeCacheKey(key);
            if (this.canCellReset({ x, y }, this.eventPosition)) {
                // 还原所有未被点击到的cell样式
                !this.clickCache.has(key) && cells.push({
                    x,
                    y,
                    style: value,
                });
                this.hoverCache.delete(key);
            }
        });
    }
    resetClickCell(cells) {
        if (this.eventTrigger === 'mouseover') {
            return;
        }
        this.clickCache.forEach((value, key) => {
            const { x, y } = decodeCacheKey(key);
            // 判断当前cell是否可以还原到初始样式
            if (this.canCellReset({ x, y }, this.eventPosition)) {
                this.hoverCache.has(key) && this.hoverCache.delete(key);
                cells.push({
                    x,
                    y,
                    style: value,
                });
                this.clickCache.delete(key);
            }
        });
    }
}
//# sourceMappingURL=handler.abstract.cell_style.js.map