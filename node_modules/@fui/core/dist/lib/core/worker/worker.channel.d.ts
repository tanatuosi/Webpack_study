import { IWorkerController } from './worker.core';
/**
 * 通信通道
 */
export declare class WorkerChannel {
    /**
     * Web Worker 实例
     */
    private worker;
    /**
     * 上层通信控制器
     */
    private controller;
    /**
     * 会话响应器 Map
     */
    private sessionHandlerMap;
    constructor(worker: Worker, controller: IWorkerController);
    /**
     * 发送响应
     *
     * @param sessionId 会话 Id
     * @param payload 负载
     */
    response(sessionId: string, actionType: string, payload: any): void;
    /**
     * 发送请求, 不等待响应
     *
     * @param actionType 事务类型
     * @param payload 负载
     */
    request(actionType: string, payload: any): void;
    /**
     * 发送请求, 并等待响应
     *
     * @param actionType 事务类型
     * @param payload 负载
     * @param timeout 响应超时
     * @returns {Promise<IWorkerMessage>} 等待响应的 Promise
     */
    requestPromise<T>(actionType: string, payload: any, timeout?: number): Promise<T>;
    /**
     * 收到会话消息的处理函数
     *
     * 发现是请求, 调用通信控制器的事务处理器进行处理, 获取事务结果并响应;
     * 发现是响应，调用会话响应器
     * @param event worker 通信事件
     */
    private onmessage;
    /**
     * 封装的 worker 原生 postMessage 接口
     * 支持 structured clone 和 transfer 2种通信模式
     *
     * @param message 会话消息
     */
    private postMessage;
    /**
     * 添加会话响应器
     *
     * @param sessionId 会话 Id
     * @param handler 会话响应器
     */
    private addSessionHandler;
    /**
     * 移除会话响应器
     *
     * @param sessionId
     */
    private deleteSessionHandler;
    /**
     * 生成每次独立会话的 Id
     *
     * @returns 会话 Id
     */
    private generateSessionId;
    /**
     * 判断是否有指定会话的处理器
     *
     * @param sessionId 会话 Id
     * @returns {boolean} 判断结果
     */
    private hasSessionHandler;
}
