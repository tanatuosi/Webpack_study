import isEmpty from 'lodash-es/isEmpty';
import clamp from 'lodash-es/clamp';
import merge from 'lodash-es/merge';
import find from 'lodash-es/find';
import isEqual from 'lodash-es/isEqual';
import remove from 'lodash-es/remove';
import cloneDeep from 'lodash-es/cloneDeep';
import uuid from 'uuid/v4';
import debounce from 'lodash-es/debounce';
import inRange from 'lodash-es/inRange';
import isNumber from 'lodash-es/isNumber';
import isFunction from 'lodash-es/isFunction';
import isNil from 'lodash-es/isNil';
export function intersectRect(r1, r2) {
    return !(r2[0][1] > r1[1][1] || r2[1][1] < r1[0][1] || r2[0][0] > r1[1][0] || r2[1][0] < r1[0][0]);
}
export const emptyFn = () => { };
export function cArray(start = 0, end = 0) {
    return Array.from(new Array(end - start), (val, index) => index + start);
}
export function xTo26(n) {
    return parseInt(`${n}`, 10)
        .toString(26)
        .split('')
        .reduce((r, c) => r + String.fromCharCode(parseInt(parseInt(c, 26).toString(10), 10) + 65), '');
}
export function mergeRange(p, q) {
    const intersect = intersectRect(p, q);
    return intersect
        ? [
            [Math.min(p[0][0], q[0][0]), Math.min(p[0][1], q[0][1])],
            [Math.max(p[1][0], q[1][0]), Math.max(p[1][1], q[1][1])],
        ]
        : p;
}
export function divide(text) {
    if (text.length <= 1) {
        return [text];
    }
    const words = text.replace(new RegExp(/(\r\n|\\n)/g), '\n').split('\n');
    const divides = [];
    words.forEach(word => {
        while (word.length > 0) {
            const firstWorld = word.substring(0, 1);
            if (/[\d|A-Za-z|_]/.test(firstWorld)) {
                const tmp = word.replace(/^([\d|A-Za-z|_]+).*$/, '$1');
                word = word.replace(tmp, '');
                divides.push(tmp);
            }
            else {
                divides.push(firstWorld);
                word = word.length > 0 ? word.substring(1, word.length) : '';
            }
        }
        divides.push('\n');
    });
    divides.pop();
    return divides;
}
/**
 * 根据换行信息分割字符串
 * @param text 原字符串
 * @param autoWrapInfo 换行数据
 */
export function divideTextByWrapInfo(text, autoWrapInfo) {
    const texts = [];
    const wratLines = autoWrapInfo.map((item, index) => text.substring(index === 0 ? 0 : autoWrapInfo[index - 1], item));
    wratLines.push(text.substring(autoWrapInfo[autoWrapInfo.length - 1]));
    wratLines.forEach(line => {
        line.split('/n').forEach(item => {
            texts.push(item);
        });
    });
    return texts;
}
export function between(a, b, c) {
    return a >= b && a <= c || a >= c && a <= b;
}
export function getIEVersion() {
    let version = 0;
    const agent = navigator.userAgent.toLowerCase();
    const v1 = agent.match(/(?:msie\s([\w.]+))/);
    const v2 = agent.match(/(?:trident.*rv:([\w.]+))/);
    if (v1 && v2 && v1[1] && v2[1]) {
        version = Math.max(parseInt(v1[1], 10) * 1, parseInt(v2[1], 10) * 1);
    }
    else if (v1 && v1[1]) {
        version = parseInt(v1[1], 10) * 1;
    }
    else if (v2 && v2[1]) {
        version = ~~v2[1] * 1;
    }
    else {
        version = 0;
    }
    return version;
}
export function isIE() {
    return /(msie|trident)/i.test(navigator.userAgent.toLowerCase());
}
/**
 * 判断点p是否在矩形内
 * @param p p点
 * @param matrix 矩形
 */
function isPointInMatrix(p, matrix) {
    return p.x >= matrix.x && p.x <= matrix.x + matrix.width && p.y <= matrix.y + matrix.height && p.y >= matrix.y;
}
/**
 * 判断点是否在线段上
 * @param x0 线段起点x
 * @param y0 线段起点y
 * @param x1 线段终点x
 * @param y1 线段终点y
 * @param x2 测试点x
 * @param y2 测试点y
 * @returns boolean
 */
function isPointOnLine(x0, y0, x1, y1, x2, y2) {
    return ((x2 - x0) * (y1 - y0) === (x1 - x0) * (y2 - y0) &&
        Math.min(x0, x1) <= x2 &&
        x2 <= Math.max(x0, x1) &&
        Math.min(y0, y1) <= y2 &&
        y2 <= Math.max(y0, y1));
}
export { isEmpty, isEqual, merge, clamp, find, uuid, remove, cloneDeep, debounce, isPointInMatrix, isPointOnLine, inRange, isNumber, isFunction, isNil, };
//# sourceMappingURL=functions.js.map