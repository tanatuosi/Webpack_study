export function dpr() {
    const screen = window.screen;
    let pixelRatio = 1;
    if (window.devicePixelRatio) {
        pixelRatio = window.devicePixelRatio;
    }
    else if (screen.systemXDPI && screen.logicalXDPI) {
        pixelRatio = screen.systemXDPI / screen.logicalXDPI;
    }
    return pixelRatio > 1 ? Math.ceil(pixelRatio) : 1;
}
export function px(o) {
    return `${~~`${o}`}px`;
}
export function lineWidth() {
    return 1;
}
const heightCache = {};
export function determineFontHeight(fontStyle) {
    let result = heightCache[fontStyle];
    if (!result) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'white';
        ctx.font = fontStyle;
        ctx.fillText('gM', 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        let start = -1;
        let end = -1;
        for (let row = 0; row < canvas.height; row++) {
            for (let column = 0; column < canvas.width; column++) {
                const index = (row * canvas.width + column) * 4;
                if (imageData[index] === 0) {
                    if (column === canvas.width - 1 && start !== -1) {
                        end = row;
                        row = canvas.height;
                        break;
                    }
                    continue;
                }
                else {
                    if (start === -1) {
                        start = row;
                    }
                    break;
                }
            }
        }
        result = end - start;
        heightCache[fontStyle] = result;
    }
    return result;
}
export function measureText(text, font) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    ctx.font = font;
    return ctx.measureText(text);
}
export function setCtxFont(ctx, style) {
    const { fontStyle = '', fontWeight = '', fontSize = '', fontFamily = '' } = style;
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize} "Helvetica Neue"`; // 先设置一个默认字体，当fontFamily无效时使用此默认字体
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize} "${fontFamily}"`; // 设置字体样式大小和字体名称
}
export function measureTextByStyle(text, style) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    setCtxFont(ctx, style);
    return ctx.measureText(text);
}
const fontCache = {};
export function baselineRatio(font) {
    if (fontCache[font]) {
        return fontCache[font];
    }
    // Get the baseline in the context of whatever element is passed in.
    const elem = document.createElement('div');
    elem.style.font = font;
    document.body.appendChild(elem);
    // The container is a little defenseive.
    const container = document.createElement('div');
    container.style.display = 'block';
    container.style.position = 'absolute';
    container.style.bottom = '0';
    container.style.right = '0';
    container.style.width = '0px';
    container.style.height = '0px';
    container.style.margin = '0';
    container.style.padding = '0';
    container.style.visibility = 'hidden';
    container.style.overflow = 'hidden';
    // Intentionally unprotected style definition.
    const small = document.createElement('span');
    const large = document.createElement('span');
    // Large numbers help improve accuracy.
    small.style.fontSize = '0px';
    large.style.fontSize = '2000px';
    small.innerHTML = 'X';
    large.innerHTML = 'X';
    container.appendChild(small);
    container.appendChild(large);
    // Put the element in the DOM for a split second.
    elem.appendChild(container);
    const smalldims = small.getBoundingClientRect();
    const largedims = large.getBoundingClientRect();
    elem.removeChild(container);
    // Calculate where the baseline was, percentage-wise.
    const baselineposition = smalldims.top - largedims.top;
    const height = largedims.height;
    setTimeout(() => {
        document.body.removeChild(elem);
    });
    const result = 1 - baselineposition / height;
    fontCache[font] = result;
    return result;
}
function _parseMetrics(font) {
    const container = document.createElement('div');
    const img = document.createElement('img');
    const span = document.createElement('span');
    const body = document.body;
    if (!body) {
        throw new Error('');
    }
    container.style.visibility = 'hidden';
    container.style.fontFamily = font.fontFamily;
    container.style.fontSize = font.fontSize;
    container.style.margin = '0';
    container.style.padding = '0';
    container.appendChild(document.createTextNode('Hidden Text'));
    body.appendChild(container);
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    img.width = 1;
    img.height = Math.round(parseFloat(font.fontSize) / 10);
    img.style.margin = '0';
    img.style.padding = '0';
    img.style.verticalAlign = 'baseline';
    container.appendChild(span);
    container.appendChild(img);
    const baseline = Math.round(parseFloat(font.fontSize) / 3) + img.height + 1;
    container.style.lineHeight = 'normal';
    img.style.verticalAlign = 'super';
    const middle = img.offsetTop - container.offsetTop + img.height + 1;
    body.removeChild(container);
    return { baseline, middle };
}
const mCache = {};
export function getMetrics(font) {
    const key = `${font.fontFamily} ${font.fontSize}`;
    if (mCache[key] === undefined) {
        mCache[key] = _parseMetrics(font);
    }
    return mCache[key];
}
export function getBiasLines(x, y, width, height, backslash = false, nums) {
    const result = [];
    if (backslash === false) {
        // 两条线的时候会奇怪点
        if (nums === 1) {
            result.push([
                [x, y],
                [x + width, y + height],
            ]);
        }
        if (nums === 2) {
            result.push([
                [x, y],
                [x + width, y + height * 2 / 3],
            ]);
            result.push([
                [x, y],
                [x + width * 2 / 3, y + height],
            ]);
        }
        else if (nums > 1) {
            const criticalRadian = Math.atan(height / width);
            const radian = Math.PI / 2 / (nums + 1);
            let totalRadian = 0;
            for (let i = 0; i < nums; i++) {
                totalRadian += radian;
                if (totalRadian < criticalRadian) {
                    result.push([
                        [x, y],
                        [x + width, y + Math.ceil(Math.tan(totalRadian) * width)],
                    ]);
                }
                else {
                    result.push([
                        [x, y],
                        [x + Math.ceil(height * Math.tan(Math.PI / 2 - totalRadian)), y + height],
                    ]);
                }
            }
        }
    }
    else {
        if (nums === 1) {
            result.push([
                [x, y + height],
                [x + width, y],
            ]);
        }
        if (nums === 2) {
            result.push([
                [x, y + height],
                [x + width * 2 / 3, y],
            ]);
            result.push([
                [x, y + height],
                [x + width, y + height / 3],
            ]);
        }
        else if (nums > 1) {
            const criticalRadian = Math.atan(width / height);
            const radian = Math.PI / 2 / (nums + 1);
            let totalRadian = 0;
            for (let i = 0; i < nums; i++) {
                totalRadian += radian;
                if (totalRadian < criticalRadian) {
                    result.push([
                        [x, y + height],
                        [x + Math.ceil(Math.tan(totalRadian) * height), y],
                    ]);
                }
                else {
                    result.push([
                        [x, y + height],
                        [x + width, y + height - Math.ceil(Math.tan(Math.PI / 2 - totalRadian) * width)],
                    ]);
                }
            }
        }
    }
    return result;
}
export function getSelection() {
    if (window.getSelection) {
        return window.getSelection();
    }
    else if (document.getSelection) {
        return document.getSelection();
    }
    return document.selection;
}
export function copyAsHtml(_html) { }
export function transformCell2HTML(_cell) {
    return '';
}
//# sourceMappingURL=dom.js.map