import { h } from '../element';
import { Grid } from './grid';
import { uuid, isIE, getIEVersion, isFunction } from '../../utils';
import { OB } from '../../utils/OB';
let Waffle = /** @class */ (() => {
    class Waffle extends OB {
        constructor(props) {
            super();
            this.el = h('div', 'grid-container');
            // REPORT-37858 ie10及以下空白容器需要加一个background-image: url('about:blank');才能响应事件
            if (isIE() && getIEVersion() <= 10) {
                this.el.addClass('ie10-below');
            }
            this.stickers = {};
            this.digest(props);
            this.render();
        }
        render() {
            const restWidth = this.width - this.freezeWidth, restHeight = this.height - this.freezeHeight;
            this.tGrid = new Grid({ cls: 'grid-container-top t-grid', width: this.width, height: this.freezeHeight });
            this.bGrid = new Grid({
                cls: 'grid-container-bottom b-grid',
                width: this.width,
                height: restHeight,
                top: this.freezeHeight,
            });
            this.tlGrid = new Grid({ cls: 'inline-grid tl-grid', width: this.freezeWidth, height: this.freezeHeight });
            this.trGrid = new Grid({
                cls: 'inline-grid tr-grid',
                width: restWidth,
                height: this.freezeHeight,
                scrollLeft: -this.freezeWidth,
                totalWidth: this.totalWidth,
                totalHeight: this.freezeHeight,
                left: this.freezeWidth,
            });
            this.blGrid = new Grid({
                cls: 'inline-grid bl-grid',
                width: this.freezeWidth,
                height: restHeight,
                scrollTop: -this.freezeHeight,
                totalWidth: this.freezeWidth,
                totalHeight: this.totalHeight,
            });
            this.brGrid = new Grid({
                cls: 'inline-grid br-grid',
                width: restWidth,
                height: restHeight,
                scrollLeft: -this.freezeWidth,
                scrollTop: -this.freezeHeight,
                totalWidth: this.totalWidth,
                totalHeight: this.totalHeight,
                left: this.freezeWidth,
            });
            this.mountGrid();
            /**
             *  REPORT-69677【填报新前端】设置填报冻结，页面有横向滚动条时，拖动会使页面复位：三种单元格的scroll方式是不一样的，需要区别处理，类比下面的scroll函数
             *  类型为br时，x，y都要偏移；类型为tr时，x偏移，y不偏移；类型为bl时，x不偏移，y偏移
             */
            this.on('wheelMode', mode => {
                this.brGrid.emit('wheelMode', [mode]);
                this.blGrid.emit('wheelMode', [mode]);
                this.trGrid.emit('wheelMode', [mode]);
            });
            this.brGrid.on('focus', (offsetX, offsetY) => {
                this.emit('focus', [offsetX, offsetY]);
            });
            this.trGrid.on('focus', offsetX => {
                this.emit('focus', [offsetX]);
            });
            this.blGrid.on('focus', (offsetX, offsetY) => {
                this.emit('focus', [undefined, offsetY]);
            });
        }
        showSelectArea(bounds) {
            this.hideSelectArea();
            bounds.forEach(bound => {
                this.tlGrid.selectAreas([bound[0]]);
                this.trGrid.selectAreas([bound[1]]);
                this.blGrid.selectAreas([bound[2]]);
                this.brGrid.selectAreas([bound[3]]);
            });
        }
        hideSelectArea() {
            this.tlGrid.hideSelectAreas();
            this.trGrid.hideSelectAreas();
            this.blGrid.hideSelectAreas();
            this.brGrid.hideSelectAreas();
        }
        scroll(x, y) {
            this.trGrid.scroll(x, 0);
            this.blGrid.scroll(0, y);
            this.brGrid.scroll(x, y);
        }
        getGrids() {
            return [this.tlGrid, this.trGrid, this.blGrid, this.brGrid];
        }
        update(props) {
            this.digest(props);
            const restWidth = this.width - this.freezeWidth, restHeight = this.height - this.freezeHeight;
            this.tGrid.offset({
                width: this.width,
                height: this.freezeHeight,
            });
            this.bGrid.offset({
                width: this.width,
                height: restHeight,
                top: this.freezeHeight,
            });
            this.tlGrid.offset({
                width: this.freezeWidth,
                height: this.freezeHeight,
            });
            this.trGrid.updateScrollEl({
                totalWidth: this.totalWidth,
                totalHeight: this.freezeHeight,
                left: -this.freezeWidth,
            });
            this.trGrid.offset({
                width: restWidth,
                height: this.freezeHeight,
                left: this.freezeWidth,
            });
            this.blGrid.updateScrollEl({
                totalWidth: this.freezeWidth,
                totalHeight: this.totalHeight,
                top: -this.freezeHeight,
            });
            this.blGrid.offset({
                width: this.freezeWidth,
                height: restHeight,
            });
            this.brGrid.updateScrollEl({
                totalWidth: this.totalWidth,
                totalHeight: this.totalHeight,
                top: -this.freezeHeight,
                left: -this.freezeWidth,
            });
            this.brGrid.offset({
                width: restWidth,
                height: restHeight,
                left: this.freezeWidth,
            });
            this.mountGrid();
        }
        digest(props) {
            const { width, height, freezeWidth, freezeHeight, totalWidth, totalHeight } = props;
            this.width = width;
            this.height = height;
            this.freezeWidth = freezeWidth;
            this.freezeHeight = freezeHeight;
            this.totalWidth = totalWidth;
            this.totalHeight = totalHeight;
        }
        getResponseGrid(left, top) {
            let grid;
            if (left < this.freezeWidth && top < this.freezeHeight) {
                grid = this.tlGrid;
            }
            else if (left >= this.freezeWidth && top < this.freezeHeight) {
                grid = this.trGrid;
            }
            else if (left < this.freezeWidth && top >= this.freezeHeight) {
                grid = this.blGrid;
            }
            else {
                grid = this.brGrid;
            }
            return grid;
        }
        stick({ left, top, width, height, el, id = uuid(), lazy, }) {
            const grid = this.getResponseGrid(left, top);
            const container = h('div', Waffle.STICKER_CONTAINER_CLASS_NAME);
            container.offset({
                width,
                height,
            });
            this.stickers[id] = container;
            el && (isFunction(el) ? el.call(null, container) : container.html(el));
            const sticker = {
                id,
                left,
                top,
                width,
                height,
                el: container.el,
            };
            const isInRange = grid.isStickerInRange(sticker);
            function mount() {
                grid.stick(sticker);
            }
            !lazy && mount();
            return { id, mount: lazy ? mount : undefined, isInRange };
        }
        updateStick({ left, top, width, height, id }) {
            const grid = this.getResponseGrid(left, top);
            if (this.stickers[id]) {
                grid.stick({
                    id,
                    left,
                    top,
                    width,
                    height,
                    el: this.stickers[id].el,
                });
            }
            return '';
        }
        tear(id) {
            if (this.stickers[id]) {
                this.stickers[id].remove();
                delete this.stickers[id];
            }
        }
        getStick(id) {
            return this.stickers[id];
        }
        clean() {
            for (const [, sticker] of Object.entries(this.stickers)) {
                sticker.remove();
            }
            this.stickers = {};
        }
        mountGrid() {
            if (!this.freezeWidth && !this.freezeHeight) {
                this.bGrid.el.children(this.brGrid.el);
                this.el.children(this.bGrid.el);
            }
            else {
                this.tGrid.el.children(this.tlGrid.el, this.trGrid.el);
                this.bGrid.el.children(this.blGrid.el, this.brGrid.el);
                this.el.children(this.tGrid.el, this.bGrid.el);
            }
        }
    }
    Waffle.STICKER_CONTAINER_CLASS_NAME = 'waffle-borderless-sticker';
    return Waffle;
})();
export { Waffle };
//# sourceMappingURL=waffle.js.map