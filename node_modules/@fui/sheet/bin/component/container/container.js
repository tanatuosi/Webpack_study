import { h } from '../element';
import { Waffle } from './waffle';
import { bindClickoutside, clamp, intersectRect, isEqual, isNumber, isFunction } from '../../utils';
import { ScrollBar } from '../scrollbar';
import { Resizer } from '../resizer';
import { ToolTip } from '../tooltip';
import { OB } from '../../utils/OB';
import { WheelMode } from '../../utils/wheelMode';
const MAX_SCROLL_DELTA = 100;
// 所有sheet上的额外div都会创建到这里
export class Container extends OB {
    constructor(data, options) {
        super();
        this.stickerTimeouts = [];
        // scroll
        this.deltaXCache = 0;
        this.deltaYCache = 0;
        this.sync = false;
        this.getPointByClient = (clientX, clientY) => {
            return {
                x: clientX,
                y: clientY,
            };
        };
        this.previousPosition = null;
        this.onMouseDown = (e) => {
            // e.preventDefault();
            const { x: offsetX, y: offsetY, clientX, clientY } = this.getPointInfo(e);
            const activeCell = this.getActiveCell(offsetX, offsetY);
            if (activeCell === null || activeCell.stopPropagation) {
                this.moving = 0;
                return;
            }
            const activeIndex = [activeCell.ci, activeCell.ri];
            this.moving = 1;
            if (e.shiftKey) {
                const [selectCell] = this.data.selection.getRange();
                this.emit('select', [
                    selectCell[1],
                    selectCell[0],
                    activeIndex[1],
                    activeIndex[0],
                    { x: offsetX, y: offsetY },
                ]);
                this.showSelectArea();
            }
            else {
                if (e.button === 2) {
                    window.setTimeout(() => {
                        this.emit('contextmenu', [clientX, clientY]);
                    }, 0);
                    this.moving = 0;
                    if (intersectRect([activeIndex, activeIndex], this.data.getSelectRange())) {
                        return;
                    }
                    this.emit('select', [activeIndex[1], activeIndex[0], undefined, undefined, { x: offsetX, y: offsetY }]);
                    this.showSelectArea();
                    return;
                }
                this.emit('select', [activeIndex[1], activeIndex[0], undefined, undefined, { x: offsetX, y: offsetY }]);
                this.data.view.doMouseDown(e, {
                    x: offsetX,
                    y: offsetY,
                    ri: activeCell.ri,
                    ci: activeCell.ci,
                }, this.data.getPositionByOffset(offsetX, offsetY));
            }
        };
        this.onMouseMove = (e) => {
            this.verticalScrollBar.scroll(this.data.scroll.y);
            this.horizontalScrollBar.scroll(this.data.scroll.x);
            const { x: offsetX, y: offsetY, clientX, clientY } = this.getPointInfo(e);
            if (clientX <= 0 && clientY <= 0) {
                this.data.view.disHover();
                return;
            }
            // 触发resizer
            if (offsetX < this.data.offset.offsetX || offsetY < this.data.offset.offsetY) {
                const resizerCell = this.data.getResizerCell(offsetX, offsetY);
                if (offsetY > this.data.offset.offsetY) {
                    this.verticalResizer.hide();
                    this.horizontalResizer.show(resizerCell, { width: this.data.width, height: 2 }, {
                        min: -resizerCell.height,
                    });
                }
                if (offsetX > this.data.offset.offsetX) {
                    this.verticalResizer.show(resizerCell, { width: 2, height: this.data.height }, {
                        min: -resizerCell.width,
                    });
                    this.horizontalResizer.hide();
                }
            }
            else {
                // 不清楚为什么有时候会null(没还原，保险起见)
                this.horizontalResizer && this.horizontalResizer.hide();
                this.verticalResizer && this.verticalResizer.hide();
                const activeCell = this.getActiveCell(offsetX, offsetY);
                const position = this.data.getPositionByOffset(offsetX, offsetY);
                if (activeCell === null) {
                    if (this.previousPosition !== null) {
                        this.data.view.doMouseLeave(e, {
                            x: offsetX,
                            y: offsetY,
                            ri: this.previousPosition.ri,
                            ci: this.previousPosition.ci,
                        }, position);
                        this.previousPosition = null;
                    }
                    this.toolTip.hide();
                    this.setMouseCursorByEvent(e, 'default');
                    this.data.view.disHover();
                    return;
                }
                const currentPosition = {
                    ri: activeCell.ri,
                    ci: activeCell.ci,
                };
                if (!isEqual(this.previousPosition, currentPosition) && this.previousPosition !== null) {
                    this.data.view.doMouseLeave(e, {
                        x: offsetX,
                        y: offsetY,
                        ri: this.previousPosition.ri,
                        ci: this.previousPosition.ci,
                    }, position);
                }
                this.previousPosition = currentPosition;
                if (this.moving) {
                    this.moving = 2;
                    const selectCell = this.data.selection.getCell();
                    this.emit('select', [
                        selectCell[1],
                        selectCell[0],
                        activeCell.ri,
                        activeCell.ci,
                        { x: offsetX, y: offsetY },
                    ]);
                    this.showSelectArea();
                }
                const cell = this.data.view.getMergeCell(activeCell.ri, activeCell.ci);
                this.data.view.doHover(e, {
                    x: offsetX,
                    y: offsetY,
                    ri: activeCell.ri,
                    ci: activeCell.ci,
                }, position);
                const { x: absoluteX, y: absoluteY } = this.data.offset2Absolute({ x: offsetX, y: offsetY }, cell);
                if (this.data.view.isHoverText(cell, absoluteX, absoluteY)) {
                    if (!cell.cursor || cell.cursor === 'default') {
                        this.setMouseCursorByEvent(e, 'text');
                    }
                    else {
                        this.setMouseCursorByEvent(e, cell.cursor);
                    }
                }
                if (cell.title) {
                    this.toolTip.show(cell.title, clientX, clientY);
                }
                else {
                    this.toolTip.hide();
                }
            }
            this.emit('hover', [offsetX, offsetY]);
        };
        this.onMouseleave = () => {
            this.toolTip.hide();
        };
        this.onDoubleClick = (e) => {
            this.setWheelMode(WheelMode.WHEELMODE_FOCUS);
            // const { clientX, clientY } = e;
            // const { left, top } = this.el.el.getBoundingClientRect();
            const { x: offsetX, y: offsetY } = this.getPointInfo(e);
            const activeCell = this.getActiveCell(offsetX, offsetY);
            const cell = this.data.getSelectCell();
            if (!this.isDoubleClickable(offsetX, offsetY, cell)) {
                this.emit('dblclick', [offsetX, offsetY]);
                this.data.view.doDbClick(e, {
                    x: offsetX,
                    y: offsetY,
                    ri: activeCell.ri,
                    ci: activeCell.ci,
                }, this.data.getPositionByOffset(offsetX, offsetY));
            }
        };
        this.onMouseUp = (e) => {
            this.setWheelMode(WheelMode.WHEELMODE_FOCUS);
            const { x: offsetX, y: offsetY } = this.getPointInfo(e);
            // 在window下的chrome上，onMouseMove也会触发，此时this.moving===2
            // 在mac下的chrome上，onMouseMove不会触发，此时this.moving===1
            const activeCell = this.getActiveCell(offsetX, offsetY);
            const selectCell = this.data.selection.getCell();
            if (activeCell &&
                (this.moving === 1 ||
                    this.moving === 2 && activeCell.ri === selectCell[1] && activeCell.ci === selectCell[0]) &&
                !e.shiftKey &&
                e.button !== 2) {
                if (activeCell === null || activeCell.stopPropagation) {
                    this.moving = 0;
                    return;
                }
                // moving为2时是选中状态下再次点击则取消选择
                this.moving !== 2 && this.hideSelectArea();
                this.data.view.doClick(e, {
                    x: offsetX,
                    y: offsetY,
                    ri: activeCell.ri,
                    ci: activeCell.ci,
                }, this.data.getPositionByOffset(offsetX, offsetY));
            }
            else if (this.moving === 0) {
                // 点击到无效区域隐藏掉选择
                if (e.currentTarget !== document && !activeCell) {
                    this.hideSelectArea();
                }
            }
            this.moving = 0;
        };
        this.resizeHandler = (rect, distance, direction) => {
            this.emit('resize', [rect, distance, direction]);
            this.resize();
        };
        this.scrollHandler = (deltaX, deltaY, options = { smooth: false, force: false }) => {
            if (deltaX === 0 && deltaY === 0 && !options.force) {
                return true;
            }
            this.hideSelectArea();
            if (this.scrollTimeout) {
                clearTimeout(this.scrollTimeout);
            }
            if (options.smooth) {
                deltaX = Math.min(deltaX, MAX_SCROLL_DELTA);
                deltaY = Math.min(deltaY, MAX_SCROLL_DELTA);
            }
            const { x, y } = this.data.getScroll();
            const originDeltaX = deltaX, originDeltaY = deltaY;
            deltaX += this.deltaXCache;
            deltaY += this.deltaYCache;
            let newDeltaX = this.data.correctDeltaX(deltaX);
            let newDeltaY = this.data.correctDeltaY(deltaY);
            newDeltaX = originDeltaX > 0 ? Math.max(0, newDeltaX) : Math.min(0, newDeltaX);
            newDeltaY = originDeltaY > 0 ? Math.max(0, newDeltaY) : Math.min(0, newDeltaY);
            this.deltaXCache = deltaX - newDeltaX;
            this.deltaYCache = deltaY - newDeltaY;
            this.scrollTimeout = setTimeout(() => {
                this.deltaXCache = 0;
                this.deltaYCache = 0;
                this.showSelectArea();
            }, 300);
            const newX = Math.round(clamp(x + newDeltaX, 0, this.data.maxScrollX));
            const newY = Math.round(clamp(y + newDeltaY, 0, this.data.maxScrollY));
            if (newX === this.data.maxScrollX && deltaX > 0 || newX === 0 && deltaX < 0) {
                this.deltaXCache = 0;
            }
            if (newY === this.data.maxScrollY && deltaY > 0 || newY === 0 && deltaY < 0) {
                this.deltaYCache = 0;
            }
            if (Math.abs(newDeltaX) > Math.abs(newDeltaY)) {
                this.emit('scroll', [newX, 'horizontal']);
            }
            else {
                this.emit('scroll', [newY, 'vertical']);
            }
            this.waffle.scroll(-newX, -newY);
            return (!(Math.abs(newDeltaX) > Math.abs(newDeltaY)
                ? newX <= 0 || newX >= this.data.maxScrollX
                : newY <= 0 || newY >= this.data.maxScrollY) ||
                this.deltaXCache !== 0 ||
                this.deltaYCache !== 0);
        };
        this.el = h('div', 'grid-container');
        this.data = data;
        this.cellCache = new Set();
        this.moving = 0;
        this.sync = options.sync || false;
        options.getPointByClient && (this.getPointByClient = options.getPointByClient);
        this.supportCSSTransform = options.supportCSSTransform;
        // init Resizer
        this.initResizer();
        // init Grid
        this.initWaffle();
        // init Scrollbar
        this.initScrollbar();
        // init tooltip
        this.initTootip();
        this.initEvent();
    }
    correctBounds(bounds) {
        return Object.assign(Object.assign({}, bounds), { x: bounds.x + this.data.offset.offsetX, y: bounds.y + this.data.offset.offsetY });
    }
    resize() {
        this.waffle.update({
            width: this.data.width + this.data.offset.offsetX,
            height: this.data.height + this.data.offset.offsetY,
            freezeWidth: this.data.view.freezeWidth + this.data.offset.offsetX,
            freezeHeight: this.data.view.freezeHeight + this.data.offset.offsetY,
            totalWidth: this.data.view.totalWidth,
            totalHeight: this.data.view.totalHeight,
        });
        this.showSelectArea();
        this.updateStickCells();
        this.updateScrollBar();
        // 矫正冻结+resize情况下scrollbar的位置
        this.whellScroll(0, 0);
    }
    reset() {
        this.resize();
        this.clean();
    }
    stick(stick, call) {
        const id = stick.id;
        if (this.cellCache.has(stick.id)) {
            this.waffle.updateStick(stick);
        }
        else if (stick.width > 0 && stick.height > 0) {
            stick.left = stick.left + this.data.offset.offsetX;
            stick.top = stick.top + this.data.offset.offsetY;
            const { id: stickerId, mount, isInRange } = this.waffle.stick(stick);
            this.cellCache.add(stickerId);
            if (isFunction(call)) {
                if (this.sync) {
                    call(this.waffle.getStick(stickerId), stick.width, stick.height, mount, isInRange);
                    return id;
                }
                const timeout = window.setTimeout(() => {
                    call(this.waffle.getStick(stickerId), stick.width, stick.height, mount, isInRange);
                });
                this.stickerTimeouts.push(timeout);
            }
        }
        return id;
    }
    tearSticker(id) {
        this.waffle.tear(id);
    }
    tear() {
        this.toolTip.tear();
    }
    // 以HTML的形式将单元格粘贴到canvas上层
    stickCell(ri, ci, call) {
        const id = `${ri}-${ci}`;
        const { el, width, height, x, y } = this.data.view.getMergeCell(ri, ci);
        this.stick({
            el,
            width,
            height,
            left: x,
            top: y,
            id,
        }, call);
        return id;
    }
    whellScroll(wheelDeltaX, wheelDeltaY) {
        const { x, y } = this.data.getScroll();
        const newX = Math.round(clamp(x + wheelDeltaX, 0, this.data.maxScrollX));
        const newY = Math.round(clamp(y + wheelDeltaY, 0, this.data.maxScrollY));
        this.scrollHandler(wheelDeltaX, wheelDeltaY, { smooth: false, force: false });
        this.verticalScrollBar.scroll(this.data.scroll.y, false);
        this.horizontalScrollBar.scroll(this.data.scroll.x, false);
        return {
            scrollX: newX,
            scrollY: newY,
            maxScrollX: this.data.maxScrollX,
            maxScrollY: this.data.maxScrollY,
        };
    }
    updateStickCells() {
        this.cellCache.forEach((cell) => {
            const [ri, ci] = cell.split('-');
            this.stickCell(~~ri, ~~ci);
        });
    }
    // 增加了一个设置滚动类型的函数，用于区别拖动滚动条和正常点击，为1时是滚动导致，为0时是点击导致
    setWheelMode(wheelMode) {
        this.waffle.emit('wheelMode', [wheelMode]);
    }
    initEvent() {
        this.waffle.el.on('mouseover', () => {
            this.mountResizer();
            this.mountScrollbar();
        });
        this.waffle.el.on('contextmenu', e => e.preventDefault());
        this.waffle.el.on('mousedown', this.onMouseDown);
        this.waffle.el.on('mouseup', this.onMouseUp);
        this.waffle.el.on('mousemove', this.onMouseMove);
        this.waffle.el.on('dblclick', this.onDoubleClick);
        this.waffle.el.on('mouseleave', this.onMouseleave);
        this.waffle.el.on('wheel', (e) => {
            let wheelDeltaX, wheelDeltaY;
            if (e.deltaMode === 1) {
                wheelDeltaX = e.deltaX * 20;
                wheelDeltaY = e.deltaY * 20;
            }
            else {
                wheelDeltaX = e.deltaX;
                wheelDeltaY = e.deltaY;
            }
            this.scrollHandler(wheelDeltaX, wheelDeltaY, { smooth: true, force: false }) && e.preventDefault();
            this.verticalScrollBar.scroll(this.data.scroll.y);
            this.horizontalScrollBar.scroll(this.data.scroll.x);
        });
        let mousePosition = [0, 0];
        this.waffle.el.on('touchstart', (e) => {
            const { x, y } = this.getPointInfo(e);
            mousePosition = [x, y];
        });
        this.waffle.el.on('touchmove', (e) => {
            const [mouseX, mouseY] = mousePosition;
            const { x, y } = this.getPointInfo(e);
            mousePosition = [x, y];
            this.scrollHandler(mouseX - x, mouseY - y, { smooth: true, force: false });
            this.verticalScrollBar.scroll(this.data.scroll.y);
            this.horizontalScrollBar.scroll(this.data.scroll.x);
        });
        this.waffle.el.on('mouseout', () => {
            this.data.view.disHover();
        });
        document.addEventListener('mouseup', this.onMouseUp);
        bindClickoutside(this.waffle.el, () => {
            this.hideSelectArea();
        }, false);
        /**
         * REPORT-64177【填报新前端】点击模板边缘位置，控件移动导致页面显示混乱
         * REPORT-69677【填报新前端】设置填报冻结，页面有横向滚动条时，拖动会使页面复位：三种单元格的scroll方式是不一样的，需要区别处理，类比waffle的scroll函数
         * 修复方式：元素scrollLeft\scrollTop发生改变时触发位移函数，添加一个防抖的机制，只有因为html元素的focus函数导致的异常位移时（设定阈值为1，可调整），才触发强制位移函数。
         * 类型为br时，x，y都要偏移；类型为tr时，x偏移，y不偏移；类型为bl时，x不偏移，y偏移
         */
        this.waffle.on('focus', (offsetX, offsetY) => {
            this.focusHandler(offsetX, offsetY);
        });
    }
    initResizer() {
        this.verticalResizer = new Resizer({ direction: 'vertical', onResize: this.resizeHandler });
        this.horizontalResizer = new Resizer({ direction: 'horizontal', onResize: this.resizeHandler });
    }
    initTootip() {
        this.toolTip = new ToolTip();
    }
    initScrollbar() {
        // init scrollbar
        const viewBounds = this.data.getViewBounds();
        this.verticalScrollBar = new ScrollBar({
            direction: 'vertical',
            size: viewBounds.height,
            scrollSize: this.data.maxScrollY,
            slider: {},
            onScoll: this.scrollHandler,
        });
        this.horizontalScrollBar = new ScrollBar({
            direction: 'horizontal',
            size: viewBounds.width,
            scrollSize: this.data.maxScrollX,
            slider: {},
            onScoll: this.scrollHandler,
        });
    }
    mountResizer() {
        if (this.el.hasChild(this.verticalResizer.el.el) || this.el.hasChild(this.horizontalResizer.el.el))
            return;
        this.el.children(this.verticalResizer.el, this.horizontalResizer.el);
    }
    mountScrollbar() {
        if (this.el.hasChild(this.verticalScrollBar.el.el) || this.el.hasChild(this.horizontalScrollBar.el.el))
            return;
        this.el.children(this.verticalScrollBar.el);
        this.el.children(this.horizontalScrollBar.el);
    }
    updateScrollBar() {
        const viewBounds = this.data.getViewBounds();
        this.verticalScrollBar.update({
            size: viewBounds.height,
            scrollSize: this.data.maxScrollY,
        });
        this.horizontalScrollBar.update({
            size: viewBounds.width,
            scrollSize: this.data.maxScrollX,
        });
    }
    initWaffle() {
        const width = this.data.width + this.data.offset.offsetX, height = this.data.height + this.data.offset.offsetY, freezeWidth = this.data.view.freezeWidth + this.data.offset.offsetX, freezeHeight = this.data.view.freezeHeight + this.data.offset.offsetY;
        this.waffle = new Waffle({
            width,
            height,
            freezeWidth,
            freezeHeight,
            totalWidth: this.data.view.totalWidth,
            totalHeight: this.data.view.totalHeight,
        });
        this.el.children(this.waffle.el);
    }
    isDoubleClickable(x, y, cell) {
        const { verticalFreezed, horizontalFreezed } = this.data.cellIsFreezed(cell);
        const offsetX = x + (verticalFreezed ? 0 : this.data.getScroll().x) - this.data.offset.offsetX;
        const offsetY = y + (horizontalFreezed ? 0 : this.data.getScroll().y) - this.data.offset.offsetY;
        if (cell.dblclick === false &&
            cell.left <= offsetX &&
            cell.left + cell.width >= offsetX &&
            cell.top <= offsetY &&
            cell.top + cell.height >= offsetY) {
            return true;
        }
        else if (cell.items) {
            return cell.items.some(item => this.isDoubleClickable(x, y, item.el));
        }
        else {
            return false;
        }
    }
    focusHandler(offsetX, offsetY) {
        const beforeX = offsetX;
        const afterX = this.data.scroll.x;
        const beforeY = offsetY;
        const afterY = this.data.scroll.y;
        if (Math.abs(beforeX - afterX) > 1 && isNumber(offsetX)) {
            this.whellScroll(beforeX - afterX, 0);
        }
        if (Math.abs(beforeY - afterY) > 1 && isNumber(offsetY)) {
            this.whellScroll(0, beforeY - afterY);
        }
    }
    showInputCell() {
        const cell = this.data.getSelectCell();
        cell.x = cell.x + this.data.offset.offsetX;
        cell.y = cell.y + this.data.offset.offsetY;
    }
    showSelectArea() {
        const bounds = this.data.getSelectBounds();
        this.waffle.showSelectArea(bounds);
    }
    hideSelectArea() {
        this.waffle.hideSelectArea();
        this.data.clearSelection();
    }
    clean() {
        this.cellCache = new Set();
        this.stickerTimeouts.forEach(timeout => {
            window.clearTimeout(timeout);
        });
        this.stickerTimeouts = [];
        this.waffle.clean();
    }
    getActiveCell(x, y) {
        const cell = this.data.getCellByOffset(x, y);
        if (!cell) {
            return null;
        }
        else {
            return cell.valid === false ? null : cell;
        }
    }
    /**
     * 根据MouseEvent给鼠标设置样式
     *
     * 有Sticker的缘故，直接给target设置鼠标样式的时候会出现target变来变去的情况，
     * 不好控制样式的还原与变化，因此固定到统一的DOM上去做这件事
     *
     * @param e
     * @param cursor
     */
    setMouseCursorByEvent(e, cursor) {
        const grids = this.waffle.getGrids().map(grid => grid.el.el);
        const root = this.waffle.el.el;
        let target = e.target;
        // 鼠标样式只管到grid块
        while (target && target !== root && !grids.includes(target)) {
            target = target.parentElement;
        }
        target && (target.style.cursor = cursor);
    }
    getActivePosition(x, y) {
        const { left, top } = this.el.el.getBoundingClientRect();
        const offsetX = x - left, offsetY = y - top;
        return [offsetX, offsetY];
    }
    /**
     * 根据事件获得坐标信息
     * @param ev
     * @returns
     */
    getPointInfo(ev) {
        const clientPoint = this.getClientByEvent(ev);
        const point = this.getPointByEvent(ev);
        return {
            x: point.x,
            y: point.y,
            clientX: clientPoint.x,
            clientY: clientPoint.y,
        };
    }
    /**
     * 根据事件获取窗口的坐标
     * @param event
     * @returns
     */
    getClientByEvent(event) {
        let clientInfo = event;
        if (window.TouchEvent && event instanceof TouchEvent) {
            if (event.type === 'touchend') {
                clientInfo = event.changedTouches[0];
            }
            else {
                clientInfo = event.targetTouches[0];
            }
        }
        return {
            x: clientInfo.clientX,
            y: clientInfo.clientY,
        };
    }
    /**
     * 根据事件获取画布坐标
     * @param event
     * @returns
     */
    getPointByEvent(event) {
        const grids = this.waffle.getGrids().map(grid => grid.el.el);
        const root = this.waffle.el.el;
        const stickerContainerClassName = Waffle.STICKER_CONTAINER_CLASS_NAME;
        function getOffsetX(offsetX, el) {
            let x = offsetX;
            let dom = el;
            while (dom && dom !== root && !grids.includes(dom)) {
                /**
                 * 重置一下target起点，屏蔽sticker内部dom的offset关系，确保offsetParent永远都是grid
                 */
                `${dom.className}`.includes(stickerContainerClassName)
                    ? x = offsetX + dom.offsetLeft
                    : x += dom.offsetLeft;
                dom = dom.parentElement;
            }
            // 处理一下grid块内部的offset关系
            dom && (x -= dom.scrollLeft - dom.offsetLeft);
            return x;
        }
        function getOffsetY(offsetY, el) {
            let y = offsetY;
            let dom = el;
            while (dom && dom !== root && !grids.includes(dom)) {
                /**
                 * 重置一下target起点，屏蔽sticker内部dom的offset关系，确保offsetParent永远都是grid
                 */
                `${dom.className}`.includes(stickerContainerClassName)
                    ? y = offsetY + dom.offsetTop
                    : y += dom.offsetTop;
                dom = dom.parentElement;
            }
            // 处理一下grid块内部的offset关系
            dom && dom.parentElement && (y -= dom.scrollTop - dom.parentElement.offsetTop);
            return y;
        }
        if (this.supportCSSTransform) {
            if (event instanceof MouseEvent) {
                return {
                    x: getOffsetX(event.offsetX, event.target),
                    y: getOffsetY(event.offsetY, event.target),
                };
            }
        }
        // TODO: 其他的Case还需要在想想办法计算
        const { x, y } = this.getClientByEvent(event);
        return this.getPointByClient(x, y);
    }
}
//# sourceMappingURL=container.js.map