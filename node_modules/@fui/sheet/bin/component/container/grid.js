import { h } from '../element';
import { inRange } from '../../utils';
import { OB } from '../../utils/OB';
import { WheelMode } from '../../utils/wheelMode';
const DEFAULT_BORDER_OPTIONS = {
    borderTop: false,
    borderBottom: false,
    borderLeft: false,
    borderRight: false,
};
export class Grid extends OB {
    // private eventMap: { [key in Event]?: Function[] };
    constructor(props) {
        super();
        this.focusMode = 0;
        this.activeAreas = new Set();
        this.width = 0;
        this.height = 0;
        const { width = 0, height = 0, scrollTop = 0, scrollLeft = 0, cls = '', totalWidth, totalHeight, top = 0, left = 0, } = props;
        this.el = h('div', `grid-container ${cls}`);
        this.scrollTopDelta = 0;
        this.scrollLeftDelta = 0;
        // this.eventMap = {};
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
        this.scrollEl = h('div', 'scrollable-grid');
        this.scrollEl.offset({
            top: scrollTop,
            left: scrollLeft,
            width: totalWidth || 0,
            height: totalHeight || 0,
        });
        this.width = width;
        this.height = height;
        this.el.offset({
            width,
            height,
            top,
            left,
        });
        this.on('wheelMode', mode => {
            this.focusMode = mode;
        });
        this.el.el.onscroll = () => {
            // 当元素没有高度的时候,scrolltop会被置为零，因此改为元素没有窗口时不触发，避免切tab带来的错误
            // 只有当是由于点击带来的focus异常位移导致（滚动模式为0），才触发强制位移，添加了双保险
            if (this.el.el.clientHeight > 0 && this.focusMode === WheelMode.WHEELMODE_FOCUS) {
                this.emit('focus', [this.el.el.scrollLeft, this.el.el.scrollTop]);
            }
        };
    }
    hideSelect() { }
    selectAreas(area, options) {
        this.checkScrollElMounted();
        (area || []).forEach(bounds => {
            this.selectArea(this.createActiveArea(), bounds, options);
        });
    }
    selectArea(activeArea, area, options) {
        const { p, c, t, b, l, r } = activeArea;
        const { borderLeft, borderTop, borderRight, borderBottom } = Object.assign(Object.assign({}, DEFAULT_BORDER_OPTIONS), options);
        if (!area || area.x < 0 || area.y < 0 || area.width <= 0 || area.height <= 0) {
            p.hide();
            return;
        }
        p.css({
            position: 'absolute',
            top: `${area.y}px`,
            left: `${area.x}px`,
            width: '0px',
            height: '0px',
        });
        c.offset({
            width: area.width,
            height: area.height,
        });
        t.offset({
            top: 0,
            left: 0,
            width: area.width,
        });
        t.css({ display: borderTop ? 'block' : 'none' });
        b.offset({
            top: area.height,
            left: 0,
            width: area.width,
        });
        b.css({ display: borderBottom ? 'block' : 'none' });
        l.offset({
            top: 0,
            left: 0,
            height: area.height,
        });
        l.css({ display: borderLeft ? 'block' : 'none' });
        r.offset({
            top: 0,
            left: area.width,
            height: area.height,
        });
        r.css({ display: borderRight ? 'block' : 'none' });
        p.show();
    }
    hideSelectAreas() {
        this.activeAreas.forEach(activeArea => {
            const { p, c, t, l, r, b } = activeArea;
            [p, c, t, l, r, b].forEach(el => {
                if (!el)
                    return;
                el.hide();
                el.remove();
            });
        });
        this.activeAreas.clear();
    }
    scroll(left = this.scrollLeftDelta, top = this.scrollTopDelta) {
        this.scrollTopDelta = top;
        this.scrollLeftDelta = left;
        this.el.scroll({
            top: Math.abs(top + this.scrollTop),
            left: Math.abs(left + this.scrollLeft),
        });
    }
    createActiveArea() {
        const p = h('div'), c = h('div', 'active-area'), t = h('div', 'range-border active-area-border'), l = h('div', 'range-border active-area-border'), r = h('div', 'range-border active-area-border'), b = h('div', 'range-border active-area-border');
        p.children(c, t, b, l, r);
        this.scrollEl.children(p);
        const activeArea = {
            p,
            c,
            t,
            l,
            r,
            b,
        };
        this.activeAreas.add(activeArea);
        return activeArea;
    }
    offset(bounds) {
        const { width = 0, height = 0, scrollTop = 0, scrollLeft = 0, left = 0, top = 0 } = bounds;
        this.width = width;
        this.height = height;
        this.el.offset({
            width,
            height,
            left,
            top,
        });
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
        this.scroll();
    }
    updateScrollEl(position) {
        const { totalWidth, totalHeight, top = 0, left = 0 } = position;
        this.scrollEl.offset({
            width: totalWidth,
            height: totalHeight,
            top,
            left,
        });
    }
    stick({ top, left, el }) {
        this.checkScrollElMounted();
        this.el.removeClass('empty');
        // 如果没有内容，ie10以下无法响应事件，所以加了个background,然后设置opacity: 0
        // 如果有html显示的内容，就去掉opacity: 0和background
        this.scrollEl.children(el);
        h(el).offset({
            top,
            left,
        });
    }
    isStickerInRange(stick) {
        const percentage = 0.25;
        const isInRange = inRange(stick.top - this.scrollTop, this.height * -percentage, this.height * (1 + percentage)) &&
            inRange(stick.left - this.scrollLeft, this.width * -percentage, this.width * (1 + percentage));
        return isInRange;
    }
    checkScrollElMounted() {
        if (this.el.hasChild(this.scrollEl.el))
            return;
        this.el.children(this.scrollEl);
        /**
         * 如果滚动后再创建，则需要修正位置
         */
        if (this.scrollLeftDelta !== 0 || this.scrollTopDelta !== 0) {
            this.scroll();
        }
    }
}
//# sourceMappingURL=grid.js.map