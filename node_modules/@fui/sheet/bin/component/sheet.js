import { DataProxy } from '../core';
import { Table } from './table';
import { h } from './element';
import { Container } from './container';
import { isEmpty, isFunction, remove } from '../utils';
import { HotkeysManager } from './hotkeys';
import { ContextMenu } from './memu';
import { InputBox } from './inputbox';
import { Clipboard } from './clipboard';
import { WheelMode } from '../utils/wheelMode';
export class Sheet {
    constructor(options, events = {}) {
        var _a, _b;
        this.scrollHandler = (position, direction) => {
            if (direction === 'vertical') {
                this.data.scrollY(position, this.scrollTable);
            }
            else {
                this.data.scrollX(position, this.scrollTable);
            }
        };
        this.resizeHandler = (rect, distance, direction) => {
            if (direction === 'vertical') {
                this.data.resizeCol(rect.ci, rect.width + distance);
            }
            else {
                this.data.resizeRow(rect.ri, rect.height + distance);
            }
            this.render();
        };
        this.scrollTable = (newScroll, oldScroll) => {
            this.container.setWheelMode(WheelMode.WHEELMODE_WHEEL);
            const deltaY = newScroll.y - oldScroll.y;
            const deltaX = newScroll.x - oldScroll.x;
            this.table.scroll(deltaX, deltaY);
            (this.eventsMap.scroll || []).forEach(callback => {
                callback.call(null, {
                    x: newScroll.x,
                    y: newScroll.y,
                    deltaX,
                    deltaY,
                });
            });
        };
        this.selectHandler = (sr, sc, er, ec, position) => {
            this.data.select(sr, sc, er, ec, position);
            this.table.renderSequnce();
        };
        this.showContextMenu = (x, y) => {
            /**
             * 修正 https://work.fineres.com/browse/REPORT-80404 加入
             * 可以根据配置是否使用 contextMenu
             */
            const disableContextMenu = isFunction(this.disableContextMenu)
                ? this.disableContextMenu()
                : this.disableContextMenu;
            if (disableContextMenu)
                return;
            /**
             * 修改 https://work.fineres.com/browse/REPORT-78399 引入
             * 更改了判断contextMenu是否可以复制的机制
             * 修改前：以选中的第一个单元格为准，如果这个单元格不允许复制，那么即使选了其他可选单元格，那么也不允许复制
             * 修改后：只要选中区域有单元格允许复制且有选中的文本，那么就允许复制
             */
            const cellRanges = this.data.getSelectRangeCells();
            let canCopy = false;
            for (const cells of cellRanges) {
                canCopy = cells.some(cell => !!cell.canCopy);
                if (canCopy)
                    break;
            }
            this.contextMenu.show(x, y, {
                copy: canCopy && !isEmpty(this.data.selection.getSelectedTexts()),
            });
        };
        this.contextMenuHandler = (key) => {
            switch (key) {
                case 'copy':
                default:
                    this.copy();
            }
        };
        this.render = () => {
            var _a, _b;
            this.table.render();
            (_b = (_a = this.events).render) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        this.copy = () => {
            this.clipboard.copyText(this.data.selection.getSelectedTexts());
        };
        this.events = events;
        this.el = h('div', 'sheet');
        this.el.offset({
            width: options.width,
            height: options.height,
        });
        // init Data
        this.data = new DataProxy('sheet', options);
        this.disableContextMenu = options.disableContextMenu;
        // init Container
        this.container = new Container(this.data, {
            sync: options.sync,
            getPointByClient: this.getPointByClient.bind(this),
            supportCSSTransform: options.supportCSSTransform,
        });
        // init table
        this.table = new Table(this.data, this.container);
        // bind el
        this.container.el.unshiftChildren(this.table.el);
        this.el.children(this.container.el);
        // init events
        this.initEvent();
        this.initHotKeys();
        // init contextMenu
        this.contextMenu = new ContextMenu(options.contextMenuItems);
        this.contextMenu.bindHandler(this.contextMenuHandler);
        // init inputBox
        this.inputBox = new InputBox({
            data: this.data,
        });
        (_b = (_a = this.events).created) === null || _b === void 0 ? void 0 : _b.call(_a);
        // render
        this.render();
    }
    initEvent() {
        this.eventsMap = {};
        this.container.on('scroll', this.scrollHandler);
        this.container.on('resize', this.resizeHandler);
        this.container.on('select', this.selectHandler);
        this.container.on('contextmenu', this.showContextMenu);
    }
    initHotKeys() {
        this.hotkeys = new HotkeysManager();
        this.initCopyEvent();
    }
    initCopyEvent() {
        this.clipboard = new Clipboard();
        this.hotkeys.bindHotkeys(HotkeysManager.KEY.COPY, this.copy);
    }
    resizeEl() {
        this.el.offset({
            width: this.data.width + this.data.offset.offsetX,
            height: this.data.height + this.data.offset.offsetY,
        });
    }
    // 对外接口
    addEventListener(event, callback) {
        this.eventsMap[event] = this.eventsMap[event] || [];
        if (!this.eventsMap[event].includes(callback)) {
            this.eventsMap[event].push(callback);
        }
    }
    removeEventListener(event, callback) {
        this.eventsMap[event] = this.eventsMap[event] || [];
        remove(this.eventsMap[event], callback);
    }
    loadData(d) {
        this.data.setData(d);
        this.reset();
    }
    /**
     * 更新单元格数据+重绘
     * @param cell 原cell
     * @param data 新data
     */
    updateCell(cell, data) {
        this.data.updateCell(cell.ri, cell.ci, data);
        this.table.renderCell(cell);
    }
    /**
     * 根据单元格坐标获取单元格位置
     * @param data
     */
    getCellPosition(data) {
        return this.data.getCellPosition(data, this.data.options.sheet.merges);
    }
    /**
     * 根据Bounds进行页面滚动，使其可见
     * @param cell 单元格的位置信息
     *
     * 修改 [REPORT-67635](https://work.fineres.com/browse/REPORT-67635) 引入
     */
    whellByBounds(cell) {
        /** 单元格在页面的坐标 */
        const { x = 0, y = 0, width: cellWidth, height: cellHeight } = cell;
        /** 计算出当前视窗的宽高以及页面的偏移量 */
        const { left, top, right: viewPortWidth, bottom: viewPortHeight } = this.getBounds();
        /** 用于记录滑块偏移的变量 */
        let deltaX = 0, deltaY = 0;
        if (x <= left || x + cellWidth >= viewPortWidth) {
            const isRight = x + cellWidth >= viewPortWidth;
            /** 乘2是希望调整格子与边界的距离，暂时预留一个格子的位置，后面可以定制其他的策略 */
            deltaX = x + cellWidth - (isRight ? viewPortWidth - cellWidth : left + 2 * cellWidth);
        }
        if (y <= top || y + cellHeight >= viewPortHeight) {
            const isBottom = y + cellHeight >= viewPortHeight;
            deltaY = y + cellHeight - (isBottom ? viewPortHeight - cellHeight : top + 2 * cellHeight);
        }
        this.whellScroll(deltaX, deltaY);
    }
    /**
     * 获得sheet的视图界限信息
     *
     * 修改 [REPORT-67635](https://work.fineres.com/browse/REPORT-67635) 引入
     */
    getBounds() {
        const { x, y } = this.data.getScroll();
        return {
            left: x,
            top: y,
            right: x + this.data.width,
            bottom: y + this.data.height,
            width: this.data.width,
            height: this.data.height,
        };
    }
    insertRows(ri, rowData, config) {
        this.data.insertRows(ri, rowData, config);
        this.render();
        this.container.resize();
    }
    insertCols(ri, colData, config) {
        this.data.insertCols(ri, colData, config);
        this.render();
        this.container.resize();
    }
    deleteRows(ri, rc) {
        this.data.deleteRows(ri, rc);
        this.render();
        this.container.resize();
    }
    deleteCols(ci, cc) {
        this.data.deleteCols(ci, cc);
        this.render();
        this.container.resize();
    }
    reset() {
        this.data.reset();
        this.container.reset();
        this.table.resize();
        this.render();
        this.resizeEl();
    }
    resize(width, height) {
        this.data.resize(width, height);
        this.container.resize();
        this.table.resize();
        this.render();
        this.resizeEl();
    }
    /**
     * 设置横向滚动条显隐
     */
    setHScrollBarVisible(visible) {
        this.container.horizontalScrollBar.setVisible(visible);
    }
    /**
     * 设置纵向滚动条显隐
     */
    setVScrollBarVisible(visible) {
        this.container.verticalScrollBar.setVisible(visible);
    }
    /**
     * 滚动页面
     * @param wheelDeltaX 横向滚动距离
     * @param wheelDeltaY 纵向滚动距离
     */
    whellScroll(wheelDeltaX, wheelDeltaY) {
        return this.container.whellScroll(wheelDeltaX, wheelDeltaY);
    }
    /**
     * 销毁dom元素
     */
    tear() {
        this.clipboard.tear();
        this.contextMenu.tear();
        this.inputBox.tear();
        this.container.tear();
    }
    /**
     * 通过clientX、clientY的坐标来获取画布坐标
     * @param clientX
     * @param clientY
     * @returns
     */
    getPointByClient(clientX, clientY) {
        const bbox = this.table.el.el.getBoundingClientRect();
        return {
            x: clientX - bbox.left,
            y: clientY - bbox.top,
        };
    }
}
//# sourceMappingURL=sheet.js.map