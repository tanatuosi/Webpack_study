import { h } from './element';
import { px, emptyFn } from '../utils';
export class ScrollBar {
    constructor(props) {
        this.isOver = false;
        this.autoShow = true;
        this.minScrollBarLength = 24;
        this.direction = props.direction;
        this.state = false;
        this.position = 0;
        this.startPosition = 0;
        this.size = props.size;
        this.scrollSize = props.scrollSize;
        this.sliderSize = this.getScrollBarLength();
        this.startTrigger = props.startScroll || emptyFn;
        this.scrollTrigger = props.onScoll || emptyFn;
        this.endTrigger = props.endScroll || emptyFn;
        this.el = h('div', `sheet-scrollbar sheet-scrollbar-${this.vertical() ? 'y' : 'x'}`);
        this.sliderEl = h('div', 'sheet-scrollbar-slider');
        this.el.css(this.vertical() ? 'height' : 'width', px(props.size));
        this.sliderEl.css(this.vertical() ? 'height' : 'width', px(this.sliderSize));
        this.el.children(this.sliderEl);
        this._initEvent();
        this.sliderEl.hide();
        this.checkScrollSize();
    }
    _initEvent() {
        this.el.on('mousedown', (e) => {
            e.preventDefault();
        });
        this.el.on('mouseover', () => {
            this.isOver = true;
            this.checkScrollSize();
            this.sliderEl.show();
        });
        this.el.on('mouseleave', () => {
            this.isOver = false;
            !this.state && this._resetTimeout();
        });
        // 点击slider，开始滑动
        this.sliderEl.on('mousedown', (e) => {
            this._startScroll(e);
            e.preventDefault();
        });
        this.sliderEl.on('touchstart', (e) => {
            this.state = true;
            this.sliderEl.show();
            this._startScroll(e.targetTouches[0]);
        });
        this.sliderEl.on('mousemove', (e) => {
            this._scroll(e);
        });
        this.sliderEl.on('touchmove', (e) => {
            this._scroll(e.targetTouches[0]);
        });
        this.sliderEl.on('touchend', () => {
            this.state = false;
            this._resetTimeout();
        });
        document.addEventListener('mousemove', (e) => {
            this._scroll(e);
        });
        this.sliderEl.on('mouseup', (e) => {
            this._endScroll(e);
        });
        document.addEventListener('mouseup', (e) => {
            this._endScroll(e);
        });
        // REPORT-31335 防止点击拖动时鼠标移出iframe会监听不到document的mousemove事件出现卡顿
        // REPORT-50429 因为跨域iframe下调用window.parent.xxx会报错，并且现在写法有内存泄露问题，这里先注释掉，卡顿的问题以后再找解决方法
        // try {
        //     window.parent.addEventListener(
        //         'mousemove',
        //         (e): void => {
        //             this._scroll(e as MouseEvent);
        //         }
        //     );
        //     window.parent.addEventListener(
        //         'mouseup',
        //         (e): void => {
        //             this._endScroll(e as MouseEvent);
        //         }
        //     );
        // } catch (err) {}
        document.addEventListener('mouseleave', (e) => {
            this._endScroll(e);
            // this.moveOutside = true;
            // this.cachePosition = this.vertical() ? e.clientY : e.clientX;
        });
        // document.addEventListener(
        //     'mouseenter',
        //     (e): void => {
        //         this.moveOutside = false;
        //         this.startPosition = this.vertical() ? e.clientY : e.clientX;
        //     }
        // );
    }
    _startScroll(e) {
        this.startPosition = this.vertical() ? e.clientY : e.clientX;
        this.state = true;
        this.el.addClass('active');
        this.startTrigger();
    }
    _scroll(e) {
        if (!this.state) {
            return;
        }
        if (this.moveOutside) {
            if (this.vertical()) {
                this.startPosition = this.startPosition + e.clientY - this.cachePosition;
            }
            else {
                this.startPosition = this.startPosition + e.clientX - this.cachePosition;
            }
            this.moveOutside = false;
        }
        let newX = 0, newY = 0;
        if (this.vertical()) {
            newY = e.clientY - this.startPosition + this.position;
            this.startPosition = e.clientY;
        }
        else {
            newX = e.clientX - this.startPosition + this.position;
            this.startPosition = e.clientX;
        }
        newX = Math.round(Math.max(0, Math.min(newX, this.size - this.sliderSize)));
        newY = Math.round(Math.max(0, Math.min(newY, this.size - this.sliderSize)));
        const origin = this.position;
        this.position = newX || newY;
        const delta = (this.position - origin) * this.scrollSize / (this.size - this.sliderSize);
        this._scrollTo(newX, newY);
        delta === 0 && this.adjustScroll(newX, newY);
        this.scrollTrigger(this.vertical() ? 0 : delta, this.vertical() ? delta : 0);
    }
    /**
     * 防止滚动条滚动到头时报表未能滚动到顶部
     */
    adjustScroll(newX, newY) {
        const adjustSize = 5;
        const position = this.vertical() ? newY : newX;
        const adjustX = this.vertical() ? 0 : adjustSize;
        const adjustY = this.vertical() ? adjustSize : 0;
        if (position === 0) {
            this.scrollTrigger(0 - adjustX, 0 - adjustY);
        }
        if (position === this.size - this.sliderSize) {
            this.scrollTrigger(adjustX, adjustY);
        }
    }
    _endScroll(e) {
        if (!this.state) {
            return;
        }
        this.state = false;
        this.el.removeClass('active');
        this._resetTimeout();
        this.endTrigger();
        e.preventDefault();
    }
    _scrollTo(x = 0, y = 0) {
        this.sliderEl.css({
            transform: `translate(${px(x)}, ${px(y)})`,
            '-webkit-transform': `translate(${px(x)}, ${px(y)})`,
            '-moz-transform': `translate(${px(x)}, ${px(y)})`,
            '-o-transform': `translate(${px(x)}, ${px(y)})`,
            '-ms-transform': `translate(${px(x)}, ${px(y)})`,
        });
    }
    checkScrollSize() {
        this.autoShow && (this.scrollSize <= 0 ? this.el.hide() : this.el.show());
    }
    vertical() {
        return this.direction === 'vertical';
    }
    inScrollBounds(e) {
        const startPosition = this.sliderSize / 2;
        const endPosition = this.size - this.sliderSize / 2;
        const position = this.vertical() ? e.clientY : e.clientX;
        return position >= startPosition && position <= endPosition;
    }
    _resetTimeout() {
        this.timer && window.clearTimeout(this.timer);
        this.timer = this.sliderElHide();
    }
    scroll(distance, showScrollBar = true) {
        if (!this.isOver && this.scrollSize > 0 && showScrollBar) {
            this.sliderEl.show();
            this._resetTimeout();
        }
        distance = distance * (this.size - this.sliderSize) / this.scrollSize;
        const x = this.vertical() ? 0 : distance;
        const y = this.vertical() ? distance : 0;
        this.position = distance;
        this._scrollTo(x, y);
    }
    update(props) {
        this.state = false;
        this.startPosition = 0;
        this.size = props.size;
        this.scrollSize = props.scrollSize;
        this.sliderSize = this.getScrollBarLength();
        const newX = this.vertical() ? 0 : Math.min(this.position, this.size - this.sliderSize);
        const newY = this.vertical() ? Math.min(this.position, this.size - this.sliderSize) : 0;
        this.position = newX || newY;
        this.el.css(this.vertical() ? 'height' : 'width', px(props.size));
        this.sliderEl.css(this.vertical() ? 'height' : 'width', px(this.sliderSize));
        this._scrollTo(newX, newY);
        this.scrollTrigger(0, 0, { force: true });
        this.checkScrollSize();
        this.sliderEl.hide();
    }
    getScrollBarLength() {
        const sliderSize = Math.round(Math.pow(this.size, 2) / (this.scrollSize + this.size));
        return this.size < this.minScrollBarLength ? sliderSize : Math.max(sliderSize, this.minScrollBarLength);
    }
    setVisible(visible) {
        visible ? this.el.show() : this.el.hide();
        visible ? this.sliderEl.show() : this.sliderEl.hide();
        this.autoShow = false;
    }
    sliderElHide() {
        return window.setTimeout(() => {
            !this.state && this.autoShow && this.sliderEl.hide();
            // REPORT-61933 修改为无操作5s后隐藏滚动条
        }, 5000);
    }
}
//# sourceMappingURL=scrollbar.js.map