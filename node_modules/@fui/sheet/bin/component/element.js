export class Element {
    constructor(tag, className = '') {
        if (typeof tag === 'string') {
            this.el = document.createElement(tag);
            this.el.className = className;
        }
        else {
            this.el = tag;
        }
    }
    on(method, handler) {
        this.el.addEventListener(method, handler);
        return this;
    }
    off(method, handler) {
        this.el.removeEventListener(method, handler);
        return this;
    }
    children(...children) {
        children.forEach((child) => {
            if (child instanceof Element) {
                this.el.appendChild(child.el);
            }
            else {
                this.el.appendChild(child);
            }
        });
        return this;
    }
    unshiftChildren(...children) {
        children.forEach((child) => {
            if (child instanceof Element) {
                this.el.insertBefore(child.el, this.el.firstChild);
            }
            else {
                this.el.insertBefore(child, this.el.firstChild);
            }
        });
        return this;
    }
    css(name, value) {
        if (value === undefined && typeof name === 'string') {
            return this.el.style[name];
        }
        if (typeof name === 'number' || typeof name === 'string') {
            this.el.style[name] = value;
        }
        else {
            Object.keys(name).forEach((k) => {
                this.el.style[k] = name[k];
            });
        }
        return this;
    }
    offset(value) {
        if (typeof value === 'undefined') {
            const { offsetTop, offsetLeft, offsetHeight, offsetWidth } = this.el;
            return {
                top: offsetTop,
                left: offsetLeft,
                height: offsetHeight - offsetTop,
                width: offsetWidth - offsetLeft,
            };
        }
        Object.keys(value).forEach((k) => {
            this.el.style[k] = `${value[k]}px`;
        });
        return this;
    }
    addClass(cls) {
        const clsReg = new RegExp(cls, 'ig');
        if (!clsReg.test(this.el.className)) {
            this.el.className = `${this.el.className} ${cls}`;
        }
        return this;
    }
    removeClass(cls) {
        const clsReg = new RegExp(cls, 'ig');
        if (clsReg.test(this.el.className)) {
            this.el.className = this.el.className.replace(cls, '');
        }
        return this;
    }
    html(html) {
        if (html !== undefined) {
            this.el.innerHTML = html;
            return this;
        }
        return this.el.innerHTML;
    }
    text(text) {
        if (text !== undefined) {
            this.el.innerText = text;
            return this;
        }
        return this.el.innerText;
    }
    attr(qualifiedName, value) {
        this.el.setAttribute(qualifiedName, value);
        return this;
    }
    contains(child) {
        return this.el.contains(child);
    }
    remove() {
        this.el.remove();
    }
    hide() {
        this.css('display', 'none');
        return this;
    }
    show() {
        this.css('display', 'block');
        return this;
    }
    focus() {
        this.el.focus();
        return this;
    }
    disableChild(key) {
        for (let index = 0; index < this.el.childNodes.length; index++) {
            const child = this.el.childNodes[index];
            /** 避免重复添加disable类 */
            if (child.className.includes(key) && !child.className.includes('disable')) {
                child.className = `${child.className} disable`;
            }
        }
    }
    childEnable(key) {
        for (let index = 0; index < this.el.childNodes.length; index++) {
            const child = this.el.childNodes[index];
            if (child.className.includes(key)) {
                child.className = child.className.replace(' disable', '');
            }
        }
    }
    hasChild(el) {
        let isMount = false;
        for (let index = 0; index < this.el.childNodes.length; index++) {
            const child = this.el.childNodes[index];
            isMount = el instanceof HTMLElement ? child === el : child === el.el;
            if (isMount)
                break;
        }
        return isMount;
    }
    scroll({ top, left }) {
        this.el.scrollLeft = left;
        this.el.scrollTop = top;
    }
}
export const h = (tag, className = '') => new Element(tag, className);
//# sourceMappingURL=element.js.map