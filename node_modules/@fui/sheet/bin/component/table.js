import { h } from './element';
import { initRenderer, renderComponent } from '../renderer';
import { clamp, isPointOnLine, loadImage, getImageData, debounce } from '../utils';
export class Table {
    constructor(data, container) {
        this.reRender = () => {
            this.renderGrid();
            this.renderSequnce();
            // REPORT-50075 如果冻结行滚动后，再点击收起/展开参数面板，render的时候冻结行边框会被遮挡，所以这里也做下renderFreeze
            this.renderFreeze();
        };
        this.render = () => {
            this.renderStickers();
            this.reRender();
        };
        this.refresh = () => {
            this.clear();
            this.renderGrid();
        };
        this.resize = () => {
            this.renderer.resize(this.data.width + this.data.offset.offsetX, this.data.height + this.data.offset.offsetY);
        };
        this.debounceRender = debounce(() => {
            this.render();
        }, 50);
        this.el = h('div', 'sheet-table');
        this.data = data;
        this.container = container;
        this.renderer = initRenderer(this.el, {
            width: data.width + data.offset.offsetX,
            height: data.height + data.offset.offsetY,
        });
    }
    renderSequnce() {
        const OffsetX = this.data.offset.offsetX, OffsetY = this.data.offset.offsetY;
        this.renderer.clear(0, 0, this.data.width + OffsetX, OffsetY);
        this.renderer.clear(0, 0, OffsetX, this.data.height + OffsetY);
        const cells = this.data.getSequnceCells();
        this.clearBorderSet();
        cells.forEach((cell) => {
            this.renderContent(cell);
            this.renderBorder(cell);
        });
        this.clearBorderSet();
    }
    scroll(scrollDeltaX, scrollDeltaY) {
        const deltaY = Math.ceil(isNaN(scrollDeltaY) ? 0 : scrollDeltaY), deltaX = Math.ceil(isNaN(scrollDeltaX) ? 0 : scrollDeltaX);
        /** 排除掉 deltaX、deltaY 都为 0 等情况 */
        if (!(deltaX || deltaY))
            return;
        /**
         * 如果是单方向滚动，在排除掉都为0的情况下，则有以下结论：
         *   1、 deltaX和deltaY必不想等
         *   2、其中一项必为0 => (deltaX === (deltaY || deltaX) || deltaY === (deltaX || deltaY))
         *      (deltaY || deltaX)和(deltaX || deltaY)中的或运算符当作设置默认值用
         */
        const isSingalDirection = deltaX !== deltaY && (deltaX === (deltaY || deltaX) || deltaY === (deltaX || deltaY));
        if (isSingalDirection) {
            const _bounds = this.data.getRenderBounds(deltaY ? 'vertical' : 'horizontal');
            const bounds = {
                x: Math.ceil(_bounds.x),
                y: Math.ceil(_bounds.y),
                width: Math.ceil(_bounds.width),
                height: Math.ceil(_bounds.height),
            };
            /** 计算能够复用、需要重新渲染等区域 */
            const { cacheBounds, canvasBounds, renderBounds } = this.getReRenderBounds(deltaX, deltaY, bounds);
            this.clip(bounds.x, bounds.y, bounds.width, bounds.height, () => {
                this.drawSelf(cacheBounds.x, cacheBounds.y, canvasBounds.x, canvasBounds.y, canvasBounds.width, canvasBounds.height);
                this.clip(renderBounds.x, renderBounds.y, renderBounds.width, renderBounds.height, () => {
                    this.clear();
                    this.rerenderBounds(renderBounds.x, renderBounds.y, renderBounds.width, renderBounds.height);
                });
            });
            this.renderSequnce();
            this.renderFreeze();
        }
        else {
            this.reRender();
        }
    }
    /**
     * 根据滚动信息计算出缓存区域、重新render的区域
     * @param deltaX 在x方向上的滚动距离
     * @param deltaY 在y方向上的滚动距离
     * @param bounds 当前渲染的区域
     * @returns
     */
    getReRenderBounds(deltaX, deltaY, bounds) {
        let cacheBounds, canvasBounds, renderBounds;
        if (deltaY < 0) {
            cacheBounds = {
                x: bounds.x,
                y: bounds.y,
                width: bounds.width,
                height: bounds.height + deltaY,
            };
            canvasBounds = {
                x: bounds.x,
                y: bounds.y - deltaY,
                width: bounds.width,
                height: bounds.height + deltaY,
            };
            renderBounds = {
                x: bounds.x,
                y: bounds.y,
                width: bounds.width,
                height: bounds.height - canvasBounds.height + 1,
            };
        }
        if (deltaY > 0) {
            const drawImageWidth = clamp(bounds.width - bounds.x, 0, bounds.width);
            const drawImageHeight = clamp(bounds.height - bounds.y - deltaY, 0, bounds.height);
            cacheBounds = {
                x: bounds.x,
                y: bounds.y + deltaY,
                width: drawImageWidth,
                height: drawImageHeight,
            };
            canvasBounds = {
                x: bounds.x,
                y: bounds.y,
                width: drawImageWidth,
                height: drawImageHeight,
            };
            renderBounds = {
                x: bounds.x,
                y: canvasBounds.y + canvasBounds.height,
                width: bounds.width,
                height: bounds.height - canvasBounds.height,
            };
        }
        if (deltaX < 0) {
            cacheBounds = {
                x: bounds.x,
                y: bounds.y,
                width: bounds.width + deltaX,
                height: bounds.height,
            };
            canvasBounds = {
                x: bounds.x - deltaX,
                y: bounds.y,
                width: bounds.width + deltaX,
                height: bounds.height,
            };
            renderBounds = {
                x: bounds.x,
                y: bounds.y,
                width: bounds.width - canvasBounds.width + 1,
                height: bounds.height,
            };
        }
        if (deltaX > 0) {
            const drawImageWidth = clamp(bounds.width - bounds.x - deltaX, 0, bounds.width);
            const drawImageHeight = clamp(bounds.height - bounds.y, 0, bounds.height);
            cacheBounds = {
                x: bounds.x + deltaX,
                y: bounds.y,
                width: drawImageWidth,
                height: drawImageHeight,
            };
            canvasBounds = {
                x: bounds.x,
                y: bounds.y,
                width: drawImageWidth,
                height: drawImageHeight,
            };
            renderBounds = {
                x: canvasBounds.x + canvasBounds.width,
                y: bounds.y,
                width: bounds.width - canvasBounds.width,
                height: bounds.height,
            };
        }
        return { cacheBounds, canvasBounds, renderBounds };
    }
    clip(x, y, width, height, cb) {
        const { offsetX, offsetY } = this.data.offset;
        this.renderer.clip(x + offsetX, y + offsetY, width, height, cb);
    }
    clear(x, y, width, height) {
        const { offsetX, offsetY } = this.data.offset;
        this.renderer.clear(x && x + offsetX, y && y + offsetY, width, height);
    }
    drawSelf(sx, sy, dx, dy, w, h) {
        const { offsetX, offsetY } = this.data.offset;
        this.renderer.drawSelf(sx + offsetX, sy + offsetY, dx + offsetX, dy + offsetY, w, h);
    }
    renderFreeze() {
        this.data.getFreezeBounds().forEach(({ x, y, width, height }) => {
            if (width > 0 && height > 0) {
                // 如果冻结区域区域不存在，则不处理
                // widht 和 height 可能为0 或 underfined
                const cells = this.data.getCellsInBounds(x, y, width, height);
                this.clip(x, y, width, height, () => {
                    this.clear();
                    cells.forEach((cell) => {
                        this.renderContent(cell);
                    });
                });
                this.clip(x, y, width + 1, height + 1, () => {
                    this.clearBorderSet();
                    cells.forEach((cell) => {
                        this.renderBorder(cell);
                    });
                });
            }
        });
    }
    rerenderBounds(x, y, width, height) {
        // TODO: 避免重复画线的，需要考虑去掉的方法
        this.data.spliteBounds(x, y, x + width, y + height).forEach(({ x, y, width, height }) => {
            if (width <= 0 || height <= 0) {
                return;
            }
            this.clip(x, y, width, height, () => {
                const cells = this.data.getCellsInBounds(x, y, width, height);
                cells.forEach((cell) => {
                    this.renderContent(cell);
                });
                this.clearBorderSet();
                cells.forEach((cell) => {
                    this.renderBorder(cell);
                });
            });
        });
        this.clearBorderSet();
    }
    clearBorderSet() {
        this.cacheBorderSet = new Set();
        this.cacheBorderPosition = new Set();
    }
    renderGrid() {
        // REPORT-44227 display:none时，canvas宽高取不到导致clear失败,所以手动传入宽高
        this.clear(0, 0, this.data.width, this.data.height);
        this.rerenderBounds(0, 0, this.data.width, this.data.height);
    }
    renderContent(cell) {
        if (cell.ci < this.data.view.colc && cell.ri < this.data.view.rowc) {
            this.renderCellComponent(cell);
        }
    }
    /**
     * 渲染单个单元格
     * @param quadrantBounds 所在象限的bounds
     * @param cells 单元格对象们
     */
    renderCell(cell) {
        const targetCell = Object.assign(Object.assign({}, cell), this.data.correctBounds(cell));
        const quadrantBounds = this.data.getQuadrantBounds(cell.x, cell.y);
        let belowCell = this.data.getCell(cell.ri + cell.rp + 1, cell.ci);
        belowCell = Object.assign(Object.assign(Object.assign({}, belowCell), this.data.correctBounds(belowCell)), { borderStyle: belowCell.borderStyle ? { borderTop: belowCell.borderStyle.borderTop } : {} });
        let rightCell = this.data.getCell(cell.ri, cell.ci + cell.cp + 1);
        rightCell = Object.assign(Object.assign(Object.assign({}, rightCell), this.data.correctBounds(rightCell)), { borderStyle: rightCell.borderStyle ? { borderTop: rightCell.borderStyle.borderLeft } : {} });
        this.clip(quadrantBounds.x, quadrantBounds.y, quadrantBounds.width, quadrantBounds.height, () => {
            this.clear(targetCell.x, targetCell.y, targetCell.width, targetCell.height);
            this.renderContent(targetCell);
            this.renderCellBorder(targetCell);
            this.renderCellBorder(belowCell);
            this.renderCellBorder(rightCell);
        });
    }
    renderBorder(cell) {
        if (cell.ci < this.data.view.colc && cell.ri < this.data.view.rowc) {
            this.renderCellBorder(cell);
        }
    }
    renderCellComponent(component) {
        const { width, height } = component;
        if (width === 0 || height === 0) {
            return;
        }
        component.x += this.data.offset.offsetX;
        component.y += this.data.offset.offsetY;
        const optTextArea = [];
        this.renderCellBg(component);
        if (component.stick) {
            this.container.stickCell(component.ri, component.ci, component.init);
        }
        else {
            renderComponent(component, this.renderer, this.debounceRender, opt => {
                const viewData = this.data.view.getViewData();
                if (viewData[component.ri] && viewData[component.ri][component.ci]) {
                    const cell = viewData[component.ri][component.ci];
                    const textArea = Object.assign(Object.assign({}, opt), { x: opt.x - component.x, y: opt.y - component.y });
                    // 原来的逻辑是逐层比较写入，文字多的时候，效率很低
                    // if (cell.textArea && cell.textArea.length > 0) {
                    //     // !cell.textArea.some(
                    //     //     item =>
                    //     //         Math.abs(item.x - textArea.x) <= 10e-3 &&
                    //     //         Math.abs(item.y - textArea.y) <= 10e-3 &&
                    //     //         item.height === textArea.height &&
                    //     //         item.width === textArea.width &&
                    //     //         item.text === textArea.text
                    //     // ) &&
                    //     optTextArea.push(textArea);
                    // } else {
                    //     cell.textArea = [textArea];
                    // }
                    // 现在修改为一次性写入，效率明显提升
                    optTextArea.push(textArea);
                    cell.textArea = optTextArea;
                }
            });
        }
    }
    renderCellBorder(cell) {
        var _a;
        const { borderStyle = {} } = cell;
        const backgroundColor = (_a = cell === null || cell === void 0 ? void 0 : cell.backgroundStyle) === null || _a === void 0 ? void 0 : _a.backgroundColor;
        const { x, y, width: cellWidth, height: cellHeight } = cell;
        if (cellWidth <= 0 || cellHeight <= 0) {
            return;
        }
        const { borderTop, borderLeft, borderBottom, borderRight } = borderStyle;
        this.renderCellBorderLine(x, y, x + cellWidth, y, borderTop, backgroundColor);
        this.renderCellBorderLine(x, y + cellHeight, x + cellWidth, y + cellHeight, borderBottom, backgroundColor);
        this.renderCellBorderLine(x, y, x, y + cellHeight, borderLeft, backgroundColor);
        this.renderCellBorderLine(x + cellWidth, y, x + cellWidth, y + cellHeight, borderRight, backgroundColor);
    }
    renderCellBorderLine(x, y, x1, y1, border, backgroundColor) {
        const positionKey = `${x}-${y}-${x1}-${y1}`;
        if ((border === null || border === void 0 ? void 0 : border.width) > 0) {
            const key = `${x}-${y}-${x1}-${y1}-${border.width}-${border.color}`;
            if (!this.cacheBorderSet.has(key)) {
                this.renderer.drawLine(x, y, x1, y1, {
                    color: border.color,
                    lineWidth: border.width,
                    lineStyle: border.style,
                    lineDash: border.dash,
                });
                this.cacheBorderSet.add(key);
                this.cacheBorderPosition.add(positionKey);
            }
            return;
        }
        // REPORT-34884 如果单元格设置了背景色但是没设置边框，则自动将边框色设置为和背景色相同的颜色
        if (backgroundColor && !this.cacheBorderSet.has(positionKey)) {
            // 判断是否有合并单元格的单元格边框已经存在
            let hasCoveredLine = false;
            let width = 0;
            this.cacheBorderSet.forEach(v => {
                if (hasCoveredLine)
                    return;
                const [$sx, $sy, $ex, $ey, $width] = v.split('-');
                // TODO 后面重构把保留4位小数部分干掉
                // 暂时先优化下性能,缓解单元格多时的性能问题
                const PRECISION = 10000;
                const sx = Math.floor(Number($sx) * PRECISION) / PRECISION, sy = Math.floor(Number($sy) * PRECISION) / PRECISION, ex = Math.floor(Number($ex) * PRECISION) / PRECISION, ey = Math.floor(Number($ey) * PRECISION) / PRECISION, precisionX = Math.floor(x * PRECISION) / PRECISION, precisionY = Math.floor(y * PRECISION) / PRECISION, precisionX1 = Math.floor(x1 * PRECISION) / PRECISION, precisionY1 = Math.floor(y1 * PRECISION) / PRECISION;
                hasCoveredLine =
                    isPointOnLine(sx, sy, ex, ey, precisionX, precisionY) &&
                        isPointOnLine(sx, sy, ex, ey, precisionX1, precisionY1) ||
                        isPointOnLine(x, y, x1, y1, sx, sy) && isPointOnLine(x, y, x1, y1, ex, ey);
                const isStartOnline = isPointOnLine(sx, sy, ex, ey, precisionX, precisionY);
                const isEndOnline = isPointOnLine(sx, sy, ex, ey, precisionX1, precisionY1);
                // REPORT-63753【填报新前端】模板中的分割线截断了
                // 起始点在线上，终点不在线上（横线）且不在延长线上（width可以设置一个系数用于防止溢出）
                if (isStartOnline && !isEndOnline && sy === ey && precisionY1 !== ey) {
                    width = ~~$width;
                    y = y + width;
                }
                // 终点在线上，起始点不在线上（横线）且不在延长线上（width可以设置一个系数用于防止溢出）
                if (!isStartOnline && isEndOnline && sy === ey && precisionY !== ey) {
                    width = ~~$width;
                    y1 = y1 - width;
                }
                // 起始点在线上，终点不在线上（直线）且不在延长线上（width可以设置一个系数用于防止溢出）
                if (isStartOnline && !isEndOnline && sx === ex && precisionX1 !== ex) {
                    width = ~~$width;
                    x = x + width;
                }
                // 终点在线上，起始点不在线上（直线）且不在延长线上（width可以设置一个系数用于防止溢出）
                if (!isStartOnline && isEndOnline && sx === ex && precisionX !== ex) {
                    width = ~~$width;
                    x1 = x1 - width;
                }
            });
            // 只有要画的线不与已有的线不相交或者包含时，才不用画线
            if (!hasCoveredLine) {
                this.renderer.drawLine(x, y, x1, y1, {
                    color: backgroundColor,
                    lineWidth: 1,
                    lineStyle: 'solid',
                    lineDash: [],
                });
            }
        }
    }
    renderCellBg(cell) {
        const { bias, style = {}, backgroundStyle = {}, currencyLineAttr, value } = cell;
        const { x, y, width: cellWidth, height: cellHeight } = cell;
        if (cellWidth <= 0 || cellHeight <= 0) {
            return;
        }
        const { backgroundColor, backgroundImage, linearGradient, backgroundImageLayout } = backgroundStyle;
        if (linearGradient) {
            this.renderer.drawRect(x, y, cellWidth, cellHeight, {
                linearGradient,
                radiusConfig: backgroundStyle.radiusConfig,
            });
        }
        else if (backgroundImage) {
            const image = getImageData(backgroundImage);
            if (image) {
                this.renderer.drawImage(image, x, y, cellWidth, cellHeight, backgroundImageLayout, {
                    radiusConfig: backgroundStyle.radiusConfig,
                });
            }
            else {
                loadImage(backgroundImage).then(this.debounceRender);
            }
        }
        else if (backgroundColor) {
            this.renderer.drawRect(x, y, cellWidth, cellHeight, {
                fillColor: backgroundColor,
                radiusConfig: backgroundStyle.radiusConfig,
            });
        }
        if (bias) {
            this.renderer.drawBias(x, y, cellWidth, cellHeight, bias.backslash, bias.texts, style);
        }
        if (currencyLineAttr) {
            this.renderer.drawCurrencyLine(x, y, cellWidth, cellHeight, currencyLineAttr, value, style);
        }
    }
    renderStickers() {
        this.data.getStickers().forEach(sticker => {
            if (sticker.tag === 'delete') {
                this.container.tearSticker(sticker.id);
            }
            else {
                this.container.stick(sticker, sticker.init);
            }
        });
    }
}
//# sourceMappingURL=table.js.map