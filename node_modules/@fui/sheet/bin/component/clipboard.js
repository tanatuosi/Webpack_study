import { getSelection, copyAsHtml, transformCell2HTML } from '../utils';
export class Clipboard {
    constructor() {
        this.texts = [];
        this.cells = null;
        this.trigger = document.createElement('textarea');
        this.trigger.className = 'trix-offscreen';
        // Safari: https://bugs.webkit.org/show_bug.cgi?id=156529
        this.trigger.innerText = ' ';
        this.trigger.addEventListener('copy', e => {
            this.setClipboardData(e);
        });
        document.body.appendChild(this.trigger);
    }
    copy(cells) {
        this.cells = cells;
        if (this.isImage()) {
            this.downloadImage();
        }
        else {
            this.dispatchCopy();
        }
    }
    copyText(texts) {
        if (texts.length === 0) {
            return;
        }
        this.texts = texts;
        this.dispatchCopy();
    }
    clear() {
        this.cells = null;
    }
    tear() {
        document.body.removeChild(this.trigger);
    }
    isImage() {
        return this.cells.length >= 1 && this.cells[0].length >= 1 && this.cells[0][0].image;
    }
    // 保存图片到本地，不很太好，要寻找一个更好的方法
    downloadImage() {
        const image = document.createElement('a');
        image.href = this.cells[0][0].image;
        image.download = 'image.png';
        document.body.appendChild(image);
        image.click();
        document.body.removeChild(image);
    }
    dispatchCopy() {
        const selection = getSelection();
        const range = document.createRange();
        selection.removeAllRanges();
        range.selectNodeContents(this.trigger);
        selection.addRange(range);
        this.trigger.setSelectionRange(0, 99999);
        this.trigger.focus();
        // 这里会继续走构造函数里面的 this.trigger.addEventListener
        document.execCommand('copy');
        this.trigger.blur();
    }
    /**
     * 将单元格转换成HTML
     *
     * @private
     * @returns {string}
     * @memberof Clipboard
     */
    transform2HTML() {
        if (!this.cells) {
            return '';
        }
        const result = '';
        const cells = {};
        const ws = [];
        const hs = [];
        this.cells.forEach(cs => {
            cs.forEach(c => {
                const { ri, ci, width, height } = c;
                if (ws[ci] !== width) {
                    if (!ws[ci] && ws[ci] !== 0) {
                        ws[ci] = width;
                    }
                    else {
                        ws[ci] = Math.min(ws[ci], width);
                        ws[ci + 1] = Math.max(ws[ci], width) - ws[ci];
                    }
                }
                if (hs[ri] !== height) {
                    if (!hs[ri] && hs[ri] !== 0) {
                        hs[ri] = height;
                    }
                    else {
                        hs[ri] = Math.min(hs[ri], height);
                        hs[ri + 1] = Math.max(hs[ri], height) - hs[ri];
                    }
                }
                cells[`${c.ci}-${c.ri}`] = transformCell2HTML(c);
            });
        });
        return result;
    }
    /**
     * 复制单元格Text
     *
     * @private
     * @returns {string}
     * @memberof Clipboard
     */
    transform2Text() {
        return this.texts.map(item => item.join('\t')).join('\n');
    }
    setClipboardData(e) {
        var _a;
        // TODO: 复制html的形式
        if (e.clipboardData) {
            e.clipboardData.setData('text/html', this.transform2HTML());
            e.clipboardData.setData('text/plain', this.transform2Text());
        }
        else {
            const html = this.transform2HTML();
            copyAsHtml(html);
            (_a = window.clipboardData) === null || _a === void 0 ? void 0 : _a.setData('text', this.transform2Text());
            // TODO: IE需要借助html实现copyHtml
        }
        e.preventDefault();
    }
}
//# sourceMappingURL=clipboard.js.map