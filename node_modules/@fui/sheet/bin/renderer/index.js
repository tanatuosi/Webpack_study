import { canvas } from './canvas';
import { createWidget } from '../widgets';
import { getImageData, loadImage, debounce } from '../utils';
export function initRenderer(rootEl, options = {}) {
    return canvas(rootEl, options);
}
function drawBackground(style, renderer, forceCallback) {
    const hasColorBackground = style.backgroundColor && !style.backgroundColor.isTransparent();
    const hasImageBackground = style.backgroundImage && style.backgroundSize;
    let draw = {};
    if (hasColorBackground) {
        draw = {
            type: 'rect',
            x: style.left,
            y: style.top,
            width: style.width,
            height: style.height,
            options: {
                fillColor: style.backgroundColor.toString(),
            },
        };
    }
    if (hasImageBackground) {
        const imageData = getImageData(style.backgroundImage);
        if (imageData) {
            draw = {
                type: 'image',
                x: style.left,
                y: style.top,
                width: style.width,
                height: style.height,
                image: imageData,
                imageLayout: style.backgroundSize,
            };
        }
        else {
            loadImage(style.backgroundImage).then(debounce(() => {
                forceCallback();
            }));
        }
    }
    renderer.draw(draw);
}
function createBorder(x, y, x1, y1, style) {
    function rotate(x, y, xm, ym, a = 0) {
        a = a * Math.PI / 180;
        const cos = Math.cos, sin = Math.sin, xr = (x - xm) * cos(a) - (y - ym) * sin(a) + xm, yr = (x - xm) * sin(a) + (y - ym) * cos(a) + ym;
        return [xr, yr];
    }
    if (style.rotate) {
        const [xm, ym] = style.center;
        const start = rotate(x, y, xm, ym, style.rotate);
        const end = rotate(x1, y1, xm, ym, style.rotate);
        x = start[0];
        y = start[1];
        x1 = end[0];
        y1 = end[1];
    }
    return {
        type: 'line',
        x,
        y,
        x1,
        y1,
        options: style,
    };
}
function draweBorders(style, renderer) {
    // TODO: 考虑下圆角
    const { top, left, width, height } = style;
    const center = [left + width / 2, top + height / 2];
    const borders = [];
    if (style.borderTopStyle && !style.borderTopColor.isTransparent()) {
        borders.push(createBorder(left, top, left + width, top, {
            color: style.borderTopColor.toString(),
            lineWidth: style.borderTopWidth,
            lineStyle: style.borderTopStyle,
            rotate: style.rotate,
            center,
        }));
    }
    if (style.borderBottomStyle && !style.borderBottomColor.isTransparent()) {
        borders.push(createBorder(left, top + height, left + width, top + height, {
            color: style.borderBottomColor.toString(),
            lineWidth: style.borderBottomWidth,
            lineStyle: style.borderBottomStyle,
            rotate: style.rotate,
            center,
        }));
    }
    if (style.borderLeftStyle && !style.borderLeftColor.isTransparent()) {
        borders.push(createBorder(left, top, left, top + height, {
            color: style.borderLeftColor.toString(),
            lineWidth: style.borderLeftWidth,
            lineStyle: style.borderLeftStyle,
            rotate: style.rotate,
            center,
        }));
    }
    if (style.borderRightStyle && !style.borderRightColor.isTransparent()) {
        borders.push(createBorder(left + width, top, left + width, top + height, {
            color: style.borderRightColor.toString(),
            lineWidth: style.borderRightWidth,
            lineStyle: style.borderRightStyle,
            rotate: style.rotate,
            center,
        }));
    }
    borders.forEach((draw) => {
        draw && renderer.draw(draw);
    });
}
function drawBackgroundAndBorders(widget, renderer, forceCallback) {
    const style = widget.getStyle();
    drawBackground(style, renderer, forceCallback);
    draweBorders(style, renderer);
}
function getWidgetOverflowConfig(widget) {
    return widget.props ? widget.props.overflowConfig : {};
}
function drawConetent(widget, renderer, onDraw) {
    const text = widget.getText();
    if (text === null || text === undefined || text === '') {
        return;
    }
    const style = widget.getStyle();
    const { top, left, width, height, textAlign, verticalAlign, color } = style;
    renderer.draw({
        type: 'text',
        text: `${text}`,
        x: left,
        y: top,
        width,
        height,
        options: Object.assign(Object.assign(Object.assign({}, style), { wrap: 'wrap', textAlign: textAlign || 'center', verticalAlign: verticalAlign || 'middle', color: `${color}`, clip: true }), getWidgetOverflowConfig(widget)),
    }, onDraw);
}
export function renderComponent(config, renderer, forceCallback, onDraw) {
    let stack = [createWidget(config)];
    while (stack.length > 0) {
        const widget = stack.shift();
        if (widget) {
            drawBackgroundAndBorders(widget, renderer, forceCallback);
            drawConetent(widget, renderer, onDraw);
            stack = stack.concat(widget.getChildren() || []);
        }
    }
}
export * from './Renderer';
//# sourceMappingURL=index.js.map