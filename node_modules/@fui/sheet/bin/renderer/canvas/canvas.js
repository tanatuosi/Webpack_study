import { dpr, getMetrics, getFitGradient, getBiasLines, divide, divideTextByWrapInfo, setCtxFont, } from '../../utils';
import { h } from '../../component';
import { getRotatePosition } from './canvas.service';
function resizeCanvas(canvas, width, height) {
    const pixelRatio = dpr();
    canvas.width = Math.round(width * pixelRatio);
    canvas.height = Math.round(height * pixelRatio);
    h(canvas).offset({ width: canvas.width / pixelRatio, height: canvas.height / pixelRatio });
    canvas.getContext('2d').setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return canvas;
}
export class FineCanvas {
    constructor(canvas, _options) {
        const pixelRatio = dpr();
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d');
        this.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    }
    drawText(text, x, y, width, height, options) {
        this.text(text, x, y, width, height, options);
    }
    wrapText({ text, x, y, width: maxWidth, height: maxHeight, lineHeight, options, }, forceCallback) {
        this.ctx.save();
        const { verticalAlign, clip, fontStyle, fontWeight, fontFamily, verticalText, textAlign } = options;
        let { fontSize } = options;
        if (clip) {
            this.ctx.beginPath();
            this.ctx.rect(x, y, maxWidth, maxHeight);
            this.ctx.clip();
            this.ctx.beginPath();
        }
        setCtxFont(this.ctx, { fontFamily, fontSize, fontStyle, fontWeight });
        lineHeight = lineHeight || parseFloat(fontSize) * 1.2;
        let textOpts = [];
        const lineTextOpts = this.makeLineTextOpts(fontSize, text, x, y, maxWidth, maxHeight, lineHeight, options);
        textOpts = lineTextOpts.textOpts;
        fontSize = lineTextOpts.fontSize;
        lineHeight = lineTextOpts.lineHeight;
        if (verticalText === 'VERTICAL_TEXT') {
            // 如果是文字竖排
            const totalWidth = lineHeight * textOpts.length;
            textOpts.forEach((opt, index) => {
                const { text, width, height, options } = opt;
                let { x, y } = opt;
                switch (textAlign) {
                    case 'left':
                        break;
                    case 'center':
                        x = x + (maxWidth - totalWidth) / 2;
                        break;
                    case 'right':
                        x = x + (maxWidth - totalWidth);
                        break;
                    case 'distributed':
                        const offset = (maxWidth - totalWidth) / (textOpts.length - 1);
                        x = x + offset * index;
                        break;
                }
                const lineNum = Math.floor(height / lineHeight);
                switch (verticalAlign) {
                    case 'middle':
                        y = y + Math.floor((lineNum - text.length) / 2) * lineHeight;
                        break;
                    case 'bottom':
                        y = y + (lineNum - text.length) * lineHeight;
                        break;
                }
                this.textVertical(text, x, y, width, height, Object.assign(Object.assign({}, options), { verticalAlign,
                    fontFamily,
                    fontSize,
                    fontWeight,
                    fontStyle,
                    lineHeight, clip: false }), forceCallback);
                // 文字竖排绘制第一列时绘制下划线和删除线
                if (index === 0) {
                    const rowNumber = textOpts.reduce((rowNum, opt) => Math.max(rowNum, opt.text.length), 0);
                    const lineNumber = textOpts.length;
                    const { baseline } = getMetrics({
                        fontFamily,
                        fontSize,
                    });
                    y = lineNumber === 1 ? y : opt.y;
                    for (let i = 0; i < rowNumber; i++) {
                        y += lineHeight;
                        this.drawUnderline(x, y - lineHeight / 4 + parseFloat(baseline), x + width * lineNumber, y - lineHeight / 4 + parseFloat(baseline), options);
                        this.drawStrikeThrough(x, y - lineHeight / 4 + parseFloat(fontSize) / 10, x + width * lineNumber, y - lineHeight / 4 + parseFloat(fontSize) / 10, options);
                    }
                }
            });
        }
        else {
            const totalHeight = lineHeight * textOpts.length;
            textOpts.forEach((opt) => {
                const { text, x, width, height, options } = opt;
                let { y } = opt;
                switch (verticalAlign) {
                    case 'top':
                        break;
                    case 'middle':
                        if (maxHeight - totalHeight > 0) {
                            y = y + (maxHeight - totalHeight) / 2;
                        }
                        else {
                            // 如果所有文本的高度大于当前可以绘区域的高度,就从2开始画字符，保持和后端绘制一致
                            y += 2;
                        }
                        break;
                    case 'bottom':
                        if (maxHeight - totalHeight > 0) {
                            y = y + (maxHeight - totalHeight);
                        }
                        else {
                            y += 2;
                        }
                        break;
                }
                this.text(text, x, y, width, height, Object.assign(Object.assign({}, options), { verticalAlign: 'middle', fontFamily,
                    fontSize,
                    fontWeight,
                    fontStyle,
                    lineHeight, clip: false }), forceCallback);
            });
        }
        this.ctx.restore();
    }
    drawLine(x, y, x1, y1, options) {
        const { color, lineWidth, lineStyle, lineDash } = options;
        if (lineWidth === 0 || lineStyle === 'none') {
            return;
        }
        this.ctx.save();
        if (color) {
            this.ctx.strokeStyle = color;
        }
        if (lineWidth) {
            this.ctx.lineWidth = lineWidth;
        }
        switch (lineStyle) {
            case 'solid':
                break;
            case 'dashed':
                this.ctx.setLineDash(lineDash);
                break;
            case 'dotted':
                this.ctx.setLineDash([1, 1]);
                break;
            case 'double':
                this.ctx.lineWidth = lineWidth / 2;
                // REPORT-24214 调整绘制双线段的逻辑，之前的写法在与其他线段重合时显示会有问题。
                this.drawDoubleLine({ x, y, x1, y1 });
                this.ctx.restore();
                return;
        }
        this.ctx.beginPath();
        this.linePath([
            [x, y],
            [x1, y1],
        ]);
        this.ctx.restore();
    }
    drawDoubleLine({ x, y, x1, y1 }) {
        const distance = 1;
        const dx = x1 - x;
        const dy = y1 - y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const perpx = -dy * distance / len;
        const perpy = dx * distance / len;
        this.ctx.beginPath();
        this.linePath([
            [x + perpx, y + perpy],
            [x1 + perpx, y1 + perpy],
        ]);
        this.linePath([
            [x - perpx, y - perpy],
            [x1 - perpx, y1 - perpy],
        ]);
    }
    drawRect(x, y, width, height, options) {
        this.ctx.save();
        const { color = '#fff', fillColor, lineWidth = 0, linearGradient, radiusConfig } = options;
        const fillStyle = fillColor;
        this.ctx.beginPath();
        radiusConfig ? this.drawRadiusRect(x, y, width, height, radiusConfig) : this.ctx.rect(x, y, width, height);
        this.ctx.closePath();
        if (linearGradient) {
            const { degree, stops } = linearGradient;
            const [[sx, sy], [ex, ey]] = getFitGradient(degree, width, height);
            const gd = this.ctx.createLinearGradient(x + sx, y + sy, x + ex, y + ey);
            stops.forEach((stop) => {
                gd.addColorStop(stop.per, stop.color);
            });
            this.ctx.fillStyle = gd;
            this.ctx.fill();
            return this.ctx.restore();
        }
        if (fillStyle) {
            this.ctx.fillStyle = fillStyle;
            this.ctx.fill();
        }
        if (lineWidth) {
            this.ctx.strokeStyle = color;
            this.ctx.lineWidth = lineWidth;
            this.ctx.stroke();
        }
        this.ctx.restore();
    }
    /**
     * 生成一个圆角矩形的路径信息
     * @param x
     * @param y
     * @param width
     * @param height
     * @param radiusConfig
     */
    drawRadiusRect(x, y, width, height, radiusConfig) {
        const { radius, tlRadius, trRadius, blRadius, brRadius } = radiusConfig;
        /** 使用整数坐标避免发生子像素渲染 */
        const maxEffectHRadius = Math.floor(Math.min(height / 2, radius));
        const maxEffectWRadius = Math.floor(Math.min(width / 2, radius));
        /** 填充4个二阶贝塞尔曲线与边界线 */
        this.ctx.moveTo(x, y + maxEffectHRadius);
        tlRadius ? this.ctx.quadraticCurveTo(x, y, x + maxEffectWRadius, y) : this.ctx.lineTo(x, y);
        this.ctx.lineTo(x + width - maxEffectWRadius, y);
        trRadius
            ? this.ctx.quadraticCurveTo(x + width, y, x + width, y + maxEffectHRadius)
            : this.ctx.lineTo(x + width, y);
        this.ctx.lineTo(x + width, y + height - maxEffectHRadius);
        brRadius
            ? this.ctx.quadraticCurveTo(x + width, y + height, x + width - maxEffectWRadius, y + height)
            : this.ctx.lineTo(x + width, y + height);
        this.ctx.lineTo(x + maxEffectWRadius, y + height);
        blRadius
            ? this.ctx.quadraticCurveTo(x, y + height, x, y + height - maxEffectHRadius)
            : this.ctx.lineTo(x, y + height);
        this.ctx.lineTo(x, y + maxEffectHRadius);
    }
    drawBias(x, y, width, height, backslash, texts, options) {
        this.ctx.save();
        const { fontSize = '9px', color = '#000000', fontWeight = 400, fontFamily = 'sans-serif', fontStyle = 'normal', } = options;
        const fonts = {
            fontSize,
            color,
            fontWeight,
            fontFamily,
        };
        const lineHeight = parseFloat(fontSize) * 1.3;
        const lines = getBiasLines(x, y, width, height, backslash, texts.length - 1);
        this.ctx.beginPath();
        this.ctx.rect(x, y, width, height);
        this.ctx.clip();
        setCtxFont(this.ctx, { fontFamily, fontSize, fontStyle, fontWeight });
        // 先这样吧, 逻辑之后优化，脑壳疼
        lines.forEach((line, index) => {
            const [start, end] = line;
            this.drawLine(start[0], start[1], end[0], end[1], {
                color,
                lineWidth: 1,
            });
            // 第一个 (代码有点乱之后再整理)
            if (index === 0) {
                let h = lineHeight;
                const rects = [];
                if (h > height) {
                    return;
                }
                while (h <= height) {
                    let bounds = null;
                    if (backslash) {
                        const rw = Math.abs((end[0] - start[0]) / (end[1] - start[1])) * (height - h);
                        bounds = {
                            x,
                            y: y + h - lineHeight,
                            width: rw,
                            height: lineHeight,
                        };
                    }
                    else {
                        const rw = Math.abs((end[0] - start[0]) / (end[1] - start[1])) * h;
                        bounds = {
                            x: x + rw,
                            y: y + h - lineHeight,
                            width: width - rw,
                            height: lineHeight,
                        };
                    }
                    rects.push(bounds);
                    h += lineHeight;
                }
                const arrText = `${texts[0]}`.split('');
                let line = '', rectIndex = 0;
                const textOpts = [];
                for (let n = 0; n < arrText.length; n++) {
                    const testLine = line + arrText[n];
                    const metrics = this.ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (this.ctx.measureText(line).width > rects[rectIndex].width) {
                        break;
                    }
                    if (testWidth > rects[rectIndex].width) {
                        this.text(line, rects[rectIndex].x, rects[rectIndex].y, rects[rectIndex].width, rects[rectIndex].height, Object.assign(Object.assign({}, fonts), { textAlign: 'left', verticalAlign: 'middle' }));
                        textOpts.push(Object.assign(Object.assign({ x: rects[rectIndex].x, y: rects[rectIndex].y + rects[rectIndex].height / 2 }, rects[rectIndex]), { text: line, options }));
                        line = arrText[n];
                        rectIndex++;
                        if (!rects[rectIndex]) {
                            break;
                        }
                    }
                    else {
                        line = testLine;
                    }
                }
                if (line && rects[rectIndex] && this.ctx.measureText(line).width <= rects[rectIndex].width) {
                    this.text(line, rects[rectIndex].x, rects[rectIndex].y, rects[rectIndex].width, rects[rectIndex].height, Object.assign(Object.assign({}, fonts), { textAlign: 'left', verticalAlign: 'middle' }));
                }
            }
            // 最后一个 (代码有点乱之后再整理)
            if (index === lines.length - 1) {
                let h = height - lineHeight;
                const rects = [];
                while (h >= 0) {
                    let bounds = null;
                    if (backslash) {
                        const rw = Math.abs((end[0] - start[0]) / (end[1] - start[1])) * (h + y - end[1]);
                        bounds = {
                            x: x + width - rw,
                            y: y + h,
                            width: rw,
                            height: lineHeight,
                        };
                    }
                    else {
                        const rw = Math.abs((end[0] - start[0]) / (end[1] - start[1])) * h;
                        bounds = {
                            x,
                            y: y + h,
                            width: rw,
                            height: lineHeight,
                        };
                    }
                    rects.push(bounds);
                    h -= lineHeight;
                }
                const totalWidth = this.ctx.measureText(`${texts[texts.length - 1]}`).width;
                let minNums = Math.floor(rects.length / 2);
                let totalBoundsWidth = rects.length % 2 === 1
                    ? rects[minNums].width
                    : rects[minNums].width + rects[rects.length - minNums - 1].width;
                while (totalBoundsWidth < totalWidth && minNums < rects.length - 1) {
                    minNums++;
                    totalBoundsWidth += rects[minNums].width + rects[rects.length - minNums - 1].width;
                }
                let textOpts = [], flag = true;
                rects.reverse();
                while (flag) {
                    const arrText = `${texts[texts.length - 1]}`.split('');
                    let line = '', rectIndex = rects.length - minNums - 1;
                    textOpts = [];
                    for (let n = 0; n < arrText.length; n++) {
                        const testLine = line + arrText[n];
                        const metrics = this.ctx.measureText(testLine);
                        const testWidth = metrics.width;
                        if (testWidth > rects[rectIndex].width) {
                            textOpts.push({
                                text: line,
                                x: rects[rectIndex].x,
                                y: rects[rectIndex].y,
                                width: rects[rectIndex].width,
                                height: rects[rectIndex].height,
                                options: Object.assign(Object.assign({}, fonts), { textAlign: 'left', verticalAlign: 'middle' }),
                            });
                            line = arrText[n];
                            rectIndex++;
                            if (!rects[rectIndex]) {
                                break;
                            }
                        }
                        else {
                            line = testLine;
                        }
                    }
                    if (line && rectIndex < rects.length) {
                        textOpts.push({
                            text: line,
                            x: rects[rectIndex].x,
                            y: rects[rectIndex].y,
                            width: rects[rectIndex].width,
                            height: rects[rectIndex].height,
                            options: Object.assign(Object.assign({}, fonts), { textAlign: 'left', verticalAlign: 'middle' }),
                        });
                    }
                    if (line && rectIndex >= rects.length ||
                        line && this.ctx.measureText(line).width > rects[rectIndex].width) {
                        minNums++;
                    }
                    else {
                        flag = false;
                    }
                    if (minNums >= rects.length) {
                        flag = false;
                    }
                }
                textOpts.forEach(opt => {
                    const { text, x, y, width, height, options } = opt;
                    this.text(text, x, y, width, height, options);
                });
            }
            if (index !== 0 && texts.length > 2) {
                const preLine = lines[index - 1];
                if (backslash) {
                    const pAngle = Math.atan(Math.abs((preLine[1][1] - preLine[0][1]) / (preLine[1][0] - preLine[0][0])));
                    const cAngle = Math.atan(Math.abs((line[1][1] - line[0][1]) / (line[1][0] - line[0][0])));
                    const dist = Math.abs(lineHeight / 2 / Math.sin((cAngle - pAngle) / 2));
                    this.ctx.save();
                    this.ctx.translate(x + Math.cos(pAngle) * dist, y + height - Math.sin(pAngle) * dist);
                    this.ctx.rotate(-(pAngle + (cAngle - pAngle) / 2));
                    this.text(`${texts[index]}`, 0, 0, this.ctx.measureText(`${texts[index]}`).width, lineHeight, Object.assign(Object.assign({}, fonts), { textAlign: 'left', verticalAlign: 'middle' }));
                    this.ctx.restore();
                }
                else {
                    const pAngle = Math.atan((preLine[1][1] - preLine[0][1]) / (preLine[1][0] - preLine[0][0]));
                    const cAngle = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));
                    const dist = lineHeight / 2 / Math.sin((cAngle - pAngle) / 2);
                    this.ctx.save();
                    this.ctx.translate(x + Math.cos(pAngle) * dist, y + Math.sin(pAngle) * dist);
                    this.ctx.rotate(pAngle + (cAngle - pAngle) / 2);
                    this.text(`${texts[index]}`, 0, 0, this.ctx.measureText(`${texts[index]}`).width, lineHeight, Object.assign(Object.assign({}, fonts), { textAlign: 'left', verticalAlign: 'middle' }));
                    this.ctx.restore();
                }
            }
        });
        this.ctx.restore();
    }
    drawCurrencyLine(x, y, width, height, currencyLineAttr, value, options) {
        const { intPart, deciPart } = currencyLineAttr;
        const sum = intPart + deciPart;
        const averageWidth = width / sum;
        const lineColor = {
            'default': '#8e877e',
            greed: '#2df713',
            red: '#fe1713',
        };
        const drawLine = (color, x) => {
            this.drawLine(x + averageWidth, y, x + averageWidth, y + height, {
                color,
                lineWidth: 1,
            });
        };
        const intPartValue = value.split('.')[0];
        value = value.replace('.', '');
        const startIndex = intPartValue.length < intPart ? intPart - intPartValue.length : 0;
        for (let index = 0; index < sum; index++) {
            const textIndex = index - startIndex;
            if (textIndex >= 0 && value.length > textIndex) {
                const text = value.substring(textIndex, textIndex + 1);
                options.textAlign = 'center';
                this.text(text, x, y, averageWidth, height, options);
            }
            if (index + 1 !== sum) {
                if (index + 1 === intPart) {
                    drawLine(lineColor.red, x);
                }
                else if ((index + 1) % 3 === 0) {
                    drawLine(lineColor.greed, x);
                }
                else {
                    drawLine(lineColor.default, x);
                }
            }
            x = x + averageWidth;
        }
    }
    drawSelf(sx, sy, dx, dy, w, h) {
        if (w === 0 || h === 0) {
            return;
        }
        const pixelRatio = dpr();
        sx *= pixelRatio;
        sy *= pixelRatio;
        dx *= pixelRatio;
        dy *= pixelRatio;
        w *= pixelRatio;
        h *= pixelRatio;
        w = Math.min(w, this.canvas.width - dx, this.canvas.width - sx);
        h = Math.min(h, this.canvas.height - dy, this.canvas.height - sy);
        this.ctx.save();
        const cacheCanvas = this.getCacheCanvas();
        const cacheContext = this.getCacheContext();
        cacheContext.save();
        cacheContext.setTransform(1, 0, 0, 1, 0, 0);
        cacheContext.clearRect(0, 0, cacheCanvas.width, cacheCanvas.height);
        cacheContext.drawImage(this.canvas, sx, sy, w, h, dx, dy, w, h);
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(dx, dy, w, h);
        this.ctx.drawImage(cacheCanvas, dx, dy, w, h, dx, dy, w, h);
        cacheContext.restore();
        this.ctx.restore();
    }
    drawImage(image, x, y, width, height, type = 'center', options = {}) {
        this.ctx.save();
        this.ctx.beginPath();
        options.radiusConfig
            ? this.drawRadiusRect(x, y, width, height, options.radiusConfig)
            : this.ctx.rect(x, y, width, height);
        this.ctx.clip();
        // REPORT-23642 当现实方式为默认时，具体现实方式需要通过图片宽高和单元格宽高比较确定
        if (type === 'default') {
            type = image.width > width || image.height > height ? 'repeat' : 'center';
        }
        // REPORT-20044，TT-42573，REPORT-29103 普通的文字图片渲染时图片发虚，故设置为 imageSmoothingEnabled = false
        // REPORT-20966，REPORT-37636 但是如果图片过大再缩放，关闭抗锯齿会丢失像素，所以需要开启抗锯齿。
        // imageSmoothingEnabled 默认为true，如果图片大小和单元格大小相同，则没必要开启，开启之后会变模糊，故设置为false
        if (image.width === width && image.height === height) {
            this.ctx.imageSmoothingEnabled = false;
        }
        switch (type) {
            case 'center':
                this.ctx.drawImage(image, 0, 0, image.width, image.height, x + (width - image.width || 1) / 2, // REPORT-31883 如果图片大小恰好和单元格大小相同，则需要偏移0.5，否则会丢失图片边缘
                y + (height - image.height || 1) / 2, image.width, image.height);
                break;
            case 'stretch':
                this.ctx.drawImage(image, 0, 0, image.width, image.height, x, y, width, height);
                break;
            case 'adapt':
                const resizeWidth = height * (image.width / image.height);
                const resizeHeight = width * (image.height / image.width);
                if (resizeWidth <= width) {
                    this.ctx.drawImage(image, x + (width - resizeWidth) / 2, y, resizeWidth, height);
                }
                else if (resizeHeight <= height) {
                    this.ctx.drawImage(image, x, y + (height - resizeHeight) / 2, width, resizeHeight);
                }
                break;
            case 'repeat':
                const ptrn = this.ctx.createPattern(image, 'repeat');
                this.ctx.fillStyle = ptrn;
                this.ctx.translate(x, y);
                this.ctx.fillRect(0, 0, width, height);
                break;
        }
        this.ctx.restore();
    }
    draw(config, forceCallback) {
        const { type, x, y, x1, y1, text, width, height, image, imageLayout, options } = config;
        switch (type) {
            case 'text':
                const { wrap, lineHeight } = options;
                if (wrap === 'wrap') {
                    this.wrapText({ text, x, y, width, height, lineHeight: parseFloat(lineHeight), options }, forceCallback);
                }
                else {
                    this.drawText(text, x, y, width, height, options);
                }
                break;
            case 'rect':
                this.drawRect(x, y, width, height, options);
                break;
            case 'line':
                this.drawLine(x, y, x1, y1, options);
                break;
            case 'image':
                this.drawImage(image, x, y, width, height, imageLayout);
                break;
            default:
                break;
        }
    }
    clear(x = 0, y = 0, width = this.canvas.clientWidth, height = this.canvas.clientHeight) {
        this.ctx.clearRect(x, y, width, height);
    }
    clip(x, y, width, height, cb) {
        if (width === 0 || height === 0) {
            return cb && cb();
        }
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.rect(x, y, width, height);
        this.ctx.clip();
        cb && cb();
        this.ctx.restore();
    }
    getDefaultFont() {
        const style = window.getComputedStyle(this.canvas);
        return `${style.fontStyle} ${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
    }
    resize(width, height) {
        resizeCanvas(this.canvas, width, height);
        this.cacheCanvas && resizeCanvas(this.cacheCanvas, width, height);
    }
    linePath(points) {
        if (points.length > 1) {
            const [x, y] = points[0];
            this.ctx.moveTo(x, y);
            for (let i = 1; i < points.length; i++) {
                this.ctx.lineTo(points[i][0], points[i][1]);
            }
            this.ctx.stroke();
        }
    }
    text(text, x, y, width, height, options, forceCallback) {
        this.ctx.save();
        const initialY = y;
        const { clip, color = '', verticalAlign, textAlign, fontWeight = 400, fontSize = '12px', fontFamily = 'sans-serif', fontStyle = 'normal', textShadow, subscript, supscript, lineHeight, rotate, } = options;
        if (color) {
            this.ctx.fillStyle = color;
        }
        setCtxFont(this.ctx, { fontFamily, fontSize, fontStyle, fontWeight });
        if (clip) {
            this.ctx.beginPath();
            this.ctx.rect(x, y, width, height);
            this.ctx.clip();
        }
        if (textShadow) {
            this.ctx.shadowColor = textShadow.shadowColor;
            this.ctx.shadowOffsetX = textShadow.shadowOffsetX;
            this.ctx.shadowOffsetY = textShadow.shadowOffsetY;
            this.ctx.shadowBlur = textShadow.shadowBlur;
        }
        // 设置样式
        const bounds = this.ctx.measureText(text);
        const { baseline } = getMetrics({
            fontFamily,
            fontSize,
        });
        let lineLength = bounds.width;
        if (rotate) {
            const { baseX, baseY, textBaseline, textAlign: ctxTextAligh } = getRotatePosition({
                x,
                y,
                width,
                height,
                rotate,
                textAlign,
                boundsWidth: bounds.width,
                baseline,
            });
            this.ctx.textAlign = ctxTextAligh;
            this.ctx.translate(baseX, baseY);
            this.ctx.textBaseline = textBaseline;
            this.ctx.rotate(-(rotate * Math.PI) / 180);
            this.ctx.fillText(text, 0, 0);
        }
        else {
            if (supscript) {
                this.ctx.textBaseline = 'top';
                y = y - (height / 2 - baseline);
            }
            else if (subscript) {
                this.ctx.textBaseline = 'bottom';
                y = y + height + (height / 2 - baseline);
            }
            else {
                switch (verticalAlign) {
                    case 'top':
                        this.ctx.textBaseline = 'top';
                        break;
                    case 'middle':
                        this.ctx.textBaseline = 'middle';
                        y = y + height / 2;
                        break;
                    case 'bottom':
                        this.ctx.textBaseline = 'bottom';
                        y = y + height;
                        break;
                }
            }
            switch (textAlign) {
                case 'center':
                    x = x + width / 2 - bounds.width / 2;
                    break;
                case 'left':
                    x = x;
                    break;
                case 'right':
                    x = x + width - bounds.width;
                    break;
            }
            // 如果是分散对齐
            if (textAlign === 'distributed' && text.length > 1) {
                const offectX = (width - bounds.width) / (text.length - 1);
                let fontX = x;
                text.split('').forEach(word => {
                    this.ctx.fillText(word, fontX, y);
                    forceCallback &&
                        forceCallback({
                            text: word,
                            x: fontX,
                            y: initialY,
                            width: this.ctx.measureText(word).width,
                            height: lineHeight,
                        });
                    fontX = fontX + this.ctx.measureText(word).width + offectX;
                });
                lineLength = width;
            }
            else {
                let fontX = x;
                `${text}`.split('').forEach(word => {
                    forceCallback &&
                        forceCallback({
                            text: word,
                            x: fontX,
                            y: initialY,
                            width: this.ctx.measureText(word).width,
                            height: lineHeight,
                        });
                    fontX += this.ctx.measureText(word).width;
                });
                this.ctx.fillText(text, x, y);
            }
        }
        // TODO: 下划线和删除线位置先临时这样写，后期还要再调整
        this.drawUnderline(x, y + parseFloat(baseline), x + lineLength, y + parseFloat(baseline), options);
        this.drawStrikeThrough(x, y + parseFloat(fontSize) / 20, x + lineLength, y + parseFloat(fontSize) / 20, options);
        this.ctx.restore();
    }
    // 优化最长可视字符获取逻辑
    getVisualRangeText(text, cellWidth, tailString) {
        // 节省计算
        if (this.ctx.measureText(text).width < cellWidth) {
            return text;
        }
        const self = this;
        function dichotomy(start, end) {
            const mid = Math.floor((start + end) / 2);
            const nowText = text.substring(0, mid) + tailString;
            const nextText = text.substring(0, mid + 1) + tailString;
            if (self.ctx.measureText(nowText).width >= cellWidth) {
                end = mid - 1;
                return dichotomy(start, end);
            }
            else {
                // 当前小下个大就是找到了
                if (self.ctx.measureText(nextText).width >= cellWidth) {
                    return nowText;
                }
                start = mid + 1;
                return dichotomy(start, end);
            }
        }
        return dichotomy(0, text.length);
    }
    textVertical(text, x, y, width, height, options, forceCallback) {
        this.ctx.save();
        const { lineHeight, color, textShadow } = options;
        if (color) {
            this.ctx.fillStyle = color;
        }
        if (textShadow) {
            this.ctx.shadowColor = textShadow.shadowColor;
            this.ctx.shadowOffsetX = textShadow.shadowOffsetX;
            this.ctx.shadowOffsetY = textShadow.shadowOffsetY;
            this.ctx.shadowBlur = textShadow.shadowBlur;
        }
        text.split('').forEach(word => {
            const bounds = this.ctx.measureText(word);
            y = y + lineHeight;
            this.ctx.fillText(word, x + width / 2 - bounds.width / 2, y);
            forceCallback &&
                forceCallback({
                    word,
                    x: x + width / 2 - bounds.width / 2,
                    y: y - lineHeight * 2 / 3,
                    width: bounds.width,
                    height: lineHeight,
                });
        });
        this.ctx.restore();
    }
    drawUnderline(x, y, x1, y1, options) {
        const { underline } = options;
        if (underline && underline.width > 0) {
            this.drawLine(x, y, x1, y1, {
                lineWidth: underline.width,
                color: underline.color,
                lineDash: underline.dash,
                lineStyle: underline.style,
            });
        }
    }
    drawStrikeThrough(x, y, x1, y1, options) {
        const { strikeThrough, fontSize, color } = options;
        if (strikeThrough === 'solid') {
            this.drawLine(x, y, x1, y1, {
                lineWidth: parseFloat(fontSize) / 10,
                color,
            });
        }
    }
    getCacheCanvas() {
        if (!this.cacheCanvas) {
            const pixelRatio = dpr();
            this.cacheCanvas = document.createElement('canvas');
            this.cacheCanvas.width = this.canvas.width;
            this.cacheCanvas.height = this.canvas.height;
            const ctx = this.cacheCanvas.getContext('2d');
            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        }
        return this.cacheCanvas;
    }
    getCacheContext() {
        return this.getCacheCanvas().getContext('2d');
    }
    makeLineTextOpts(fontSize, text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { newLine } = options;
        let textOpts = [];
        let newFontSize = 0;
        const deafultPadding = 10;
        switch (newLine) {
            case 'SINGLE_LINE_ADJUST_FONT':
                newFontSize = maxWidth / this.ctx.measureText(text).width * parseFloat(fontSize);
                if (newFontSize * 1.2 + deafultPadding > maxHeight) {
                    newFontSize = (maxHeight - deafultPadding) / 1.2;
                }
                fontSize = `${newFontSize}px`;
                lineHeight = newFontSize * 1.2;
                textOpts = [
                    {
                        text,
                        x,
                        y,
                        width: maxWidth,
                        height: lineHeight,
                        options,
                    },
                ];
                break;
            case 'MULTI_LINE_ADJUST_FONT':
                const ratio = 128 / 72;
                newFontSize = parseFloat(fontSize) / ratio;
                const maxWidth4DivideWords = maxWidth * ratio;
                textOpts = this.makeTextOpts(text, x, y, maxWidth4DivideWords, maxHeight, lineHeight, options);
                lineHeight = maxHeight / textOpts.length;
                textOpts = this.makeTextOpts(text, x, y, maxWidth4DivideWords, maxHeight, lineHeight, options);
                /**
                 * TODO: 感觉这边需要重构一下
                 * textOpts中的width肯定是不能乘一个比例的，这个宽度就是单元格宽度，乘了之后超过单元格宽度会有以下问题
                 *   如果是居右的，那有部分内容是看不到的
                 *   一开始就不乘呢，分词分的就不对，居左的话右边就会有空白
                 * makeTextOpts这个方法返回值这块耦合性太强，宽度是宽度，根据fontSize改变如何分词用的宽度信息不能被设置成最后渲染的宽度才对
                 */
                textOpts.forEach(op => {
                    op.width = maxWidth;
                });
                fontSize = `${newFontSize}px`; // kerry 说后台就是这样算的
                break;
            default:
                textOpts = this.makeTextOpts(text, x, y, maxWidth, maxHeight, lineHeight, options);
        }
        return {
            textOpts,
            fontSize,
            lineHeight,
        };
    }
    makeVerticalWrap(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { newLine, verTextDirection, autoWrapInfo } = options;
        const wordWidth = lineHeight;
        const textOpts = [];
        if (newLine === 'SINGLE_LINE') {
            return [
                {
                    text: text.substring(0, autoWrapInfo[0]),
                    x,
                    y,
                    width: wordWidth,
                    height: maxHeight,
                    options,
                },
            ];
        }
        let lines = divideTextByWrapInfo(text, autoWrapInfo);
        if (verTextDirection === 'RIGHT_TO_LEFT') {
            lines = lines.reverse();
        }
        lines.forEach(item => {
            textOpts.push({
                text: item,
                x,
                y,
                width: wordWidth,
                height: maxHeight,
                options,
            });
            x += lineHeight;
        });
        return textOpts;
    }
    makeVerticalOpts(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { newLine, verTextDirection } = options;
        const lineNum = Math.floor(maxHeight / lineHeight);
        const textOpts = [];
        const wordWidth = lineHeight;
        if (newLine === 'SINGLE_LINE') {
            return [
                {
                    text: text.substring(lineNum),
                    x,
                    y,
                    width: wordWidth,
                    height: maxHeight,
                    options,
                },
            ];
        }
        let line = [];
        text.split('\n').forEach($word => {
            let word = $word;
            while (word !== '') {
                if (word.length > lineNum) {
                    line.push(word.substring(0, lineNum));
                    word = word.substring(lineNum);
                }
                else {
                    line.push(word);
                    word = '';
                }
            }
        });
        if (verTextDirection === 'RIGHT_TO_LEFT') {
            line = line.reverse();
        }
        line.forEach(item => {
            textOpts.push({
                text: item,
                x,
                y,
                width: wordWidth,
                height: maxHeight,
                options,
            });
            x += lineHeight;
        });
        return textOpts;
    }
    /**
     * 文字单行显示
     */
    makeSingleLineOpts(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { overflowHide, hideType, appendTailStr, hideStrLength } = options;
        // 存在换行符的时候只保留第一行文本
        let resultWord = text.split('\\n')[0];
        if (overflowHide) {
            switch (hideType) {
                case 'CHAR_LENGTH': // 保留指定字符长度
                    resultWord =
                        resultWord.length <= hideStrLength
                            ? resultWord
                            : resultWord.substring(0, hideStrLength) + appendTailStr;
                    break;
                case 'CELL_WIDTH': // 超出单元格省略
                    resultWord = this.getVisualRangeText(resultWord, maxWidth, appendTailStr);
                    break;
            }
        }
        else {
            // 没有设置文本省略就获取单元格长度的
            resultWord = this.getVisualRangeText(resultWord, maxWidth, '');
        }
        return [this.newLine(resultWord, x, y, maxWidth, maxHeight, lineHeight, options)];
    }
    newLine(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        return {
            text,
            x,
            y,
            width: maxWidth,
            height: lineHeight,
            options,
        };
    }
    makeTextOpts(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { autoWrapInfo } = options;
        return autoWrapInfo
            ? this.makeTextOptsByWrapInfo(text, x, y, maxWidth, maxHeight, lineHeight, options)
            : this.makeTextOptsByWrapAuto(text, x, y, maxWidth, maxHeight, lineHeight, options);
    }
    /**
     * 根据换行信息换行
     */
    makeTextOptsByWrapInfo(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { newLine, verticalText, cellJust, rotate, autoWrapInfo } = options;
        if (rotate !== 0) {
            return [this.newLine(text, x, y, maxWidth, maxHeight, lineHeight, options)];
        }
        if (newLine === 'SINGLE_LINE' || cellJust === 'NONE') {
            return [this.newLine(text.substring(0, autoWrapInfo[0]), x, y, maxWidth, maxHeight, lineHeight, options)];
        }
        if (verticalText === 'VERTICAL_TEXT') {
            return this.makeVerticalWrap(text, x, y, maxWidth, maxHeight, lineHeight, options);
        }
        const words = divideTextByWrapInfo(text, autoWrapInfo);
        const textOpts = [];
        words.forEach(word => {
            textOpts.push(this.newLine(word, x, y, maxWidth, maxHeight, lineHeight, options));
            y += lineHeight;
        });
        return textOpts;
    }
    /**
     * 自动根据行高列宽换行
     */
    makeTextOptsByWrapAuto(text, x, y, maxWidth, maxHeight, lineHeight, options) {
        const { newLine, verticalText, cellJust, rotate } = options;
        if (rotate !== 0) {
            return [this.newLine(text, x, y, maxWidth, maxHeight, lineHeight, options)];
        }
        if (newLine === 'SINGLE_LINE' || cellJust === 'NONE') {
            return this.makeSingleLineOpts(text, x, y, maxWidth, maxHeight, lineHeight, options);
        }
        if (verticalText === 'VERTICAL_TEXT') {
            return this.makeVerticalOpts(text, x, y, maxWidth, maxHeight, lineHeight, options);
        }
        const words = divide(text);
        let line = '';
        const textOpts = [];
        words.forEach(word => {
            const testLine = line + word;
            const testWidth = this.ctx.measureText(testLine).width;
            if (word === '\n') {
                // 如果是换行
                textOpts.push(this.newLine(line, x, y, maxWidth, maxHeight, lineHeight, options));
                line = '';
                y += lineHeight;
            }
            else if (testWidth <= maxWidth) {
                // 如果一行能够放得下
                line = testLine;
            }
            else {
                if (line !== '') {
                    textOpts.push(this.newLine(line, x, y, maxWidth, maxHeight, lineHeight, options));
                    line = '';
                    y += lineHeight;
                }
                if (this.ctx.measureText(word).width / maxWidth > 1) {
                    const arrText = `${word}`.split('');
                    for (let n = 0; n < arrText.length; n++) {
                        const testLine = line + arrText[n];
                        const testWidth = this.ctx.measureText(testLine).width;
                        if (testWidth >= maxWidth) {
                            // 跳过分词首个字符就过大的情况
                            if (line !== '') {
                                textOpts.push(this.newLine(line, x, y, maxWidth, maxHeight, lineHeight, options));
                                y += lineHeight;
                            }
                            line = arrText[n];
                        }
                        else {
                            line = testLine;
                        }
                    }
                }
                else {
                    line = word;
                }
            }
        });
        textOpts.push(this.newLine(line, x, y, maxWidth, maxHeight, lineHeight, options));
        return textOpts;
    }
}
//# sourceMappingURL=canvas.js.map