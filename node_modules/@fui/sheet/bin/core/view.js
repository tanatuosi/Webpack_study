import { createWidget } from '../widgets';
import { find, uuid, isNil } from '../utils';
const DefaultRowSize = 30;
const DefaultColumnSize = 80;
const borderWidth = 1;
// const restWidth = Math.floor(borderWidth / 2);
const lineWidth = borderWidth % 2 !== 0 ? 0.5 : 1;
export class View {
    constructor(props) {
        this.hoverCellX = -1;
        this.hoverCellY = -1;
        this.loadData(props);
        this.digest();
    }
    doMouseDown(e, ve, relativePosition) {
        const cell = this.getMergeCell(ve.ri, ve.ci);
        const widget = createWidget(cell);
        window.setTimeout(() => {
            widget.mouseDownHandler.call(null, e, ve.x, ve.y, cell, relativePosition);
        }, 0);
    }
    doMouseLeave(e, ve, relativePosition) {
        const cell = this.getMergeCell(ve.ri, ve.ci);
        const widget = createWidget(cell);
        window.setTimeout(() => {
            widget.mouseLeaveHandler.call(null, e, ve.x, ve.y, cell, relativePosition);
        }, 0);
    }
    doClick(e, ve, relativePosition) {
        const cell = this.getMergeCell(ve.ri, ve.ci);
        const widget = createWidget(cell);
        window.setTimeout(() => {
            widget.clickHandler.call(null, e, ve.x, ve.y, cell, relativePosition);
        }, 0);
    }
    doDbClick(e, ve, relativePosition) {
        const cell = this.getMergeCell(ve.ri, ve.ci);
        const widget = createWidget(cell);
        window.setTimeout(() => {
            widget.dbClickHandler && widget.dbClickHandler.call(null, e, ve.x, ve.y, cell, relativePosition);
        }, 0);
    }
    doHover(e, ve, relativePosition) {
        const cell = this.getMergeCell(ve.ri, ve.ci);
        if (this.hoverCellX === ve.ri && this.hoverCellY === ve.ci) {
            return;
        }
        this.hoverCellX = ve.ri;
        this.hoverCellY = ve.ci;
        const widget = createWidget(cell);
        window.setTimeout(() => {
            widget.hoverHandler && widget.hoverHandler.call(null, e, ve.x, ve.y, cell, relativePosition);
        }, 0);
    }
    disHover() {
        if (this.hoverCellX === -1 && this.hoverCellY === -1) {
            return;
        }
        const cell = this.getMergeCell(this.hoverCellX, this.hoverCellY);
        const widget = createWidget(cell);
        this.hoverCellX = -1;
        this.hoverCellY = -1;
        window.setTimeout(() => {
            widget.hoverHandler && widget.hoverHandler.call(null);
        }, 0);
    }
    getSumHeight(min = 0, max = this.rowc) {
        let sum = 0;
        min = Math.max(0, min);
        max = Math.min(max, this.rowc);
        for (let i = min; i < max; i++) {
            sum += this.getRowHeight(i);
        }
        return sum;
    }
    getSumWidth(min = 0, max = this.colc) {
        let sum = 0;
        min = Math.max(0, min);
        max = Math.min(max, this.colc);
        for (let i = min; i < max; i++) {
            sum += this.getColWidth(i);
        }
        return sum;
    }
    getRowHeight(i) {
        return isNil(this.rows[i]) ? DefaultRowSize : this.rows[i];
    }
    getColWidth(i) {
        return isNil(this.cols[i]) ? DefaultColumnSize : this.cols[i];
    }
    getCellsInRange(range) {
        const result = [];
        const [start, end] = range;
        // fr边框覆盖的原因
        for (let ri = start[1]; ri <= end[1]; ri++) {
            for (let ci = end[0]; ci >= start[0]; ci--) {
                const cell = this.getMergeCell(ri, ci);
                result.push(Object.assign(Object.assign({}, cell), { x: cell.x + lineWidth, y: cell.y + lineWidth }));
            }
        }
        return result;
    }
    getCellSquareInRange(range) {
        const result = [];
        const [start, end] = range;
        for (let ri = start[1]; ri <= end[1]; ri++) {
            const temp = [];
            for (let ci = start[0]; ci <= end[0]; ci++) {
                const cell = this.getMergeCell(ri, ci);
                temp.push(Object.assign(Object.assign({}, cell), { x: cell.x + lineWidth, y: cell.y + lineWidth }));
            }
            result.push(temp);
        }
        return result;
    }
    getRangeBounds(range) {
        let rowSum = 0, colSum = 0, startX = 0, startY = 0;
        const [start, end] = range;
        for (let i = 0; i <= end[1]; i++) {
            i === start[1] && (startY = rowSum);
            rowSum += this.getRowHeight(i);
        }
        for (let i = 0; i <= end[0]; i++) {
            i === start[0] && (startX = colSum);
            colSum += this.getColWidth(i);
        }
        return {
            x: startX,
            y: startY,
            width: colSum - startX,
            height: rowSum - startY,
        };
    }
    getCellIndexs(x, y) {
        let xSum = 0, ySum = 0, row = 0, col = 0;
        for (let index = 0; index < this.rowc; index++) {
            ySum += this.getRowHeight(index);
            if (y <= ySum) {
                row = index;
                break;
            }
            row = index;
        }
        for (let index = 0; index < this.colc; index++) {
            xSum += this.getColWidth(index);
            if (x <= xSum) {
                col = index;
                break;
            }
            col = index;
        }
        return [col, row];
    }
    getCellPoistion(row, col) {
        return {
            x: this.getSumWidth(0, col),
            y: this.getSumHeight(0, row),
        };
    }
    getCellBounds(row, col) {
        return {
            x: this.getSumWidth(0, col),
            y: this.getSumHeight(0, row),
            width: this.getColWidth(col),
            height: this.getRowHeight(row),
        };
    }
    findMergeRange(ri, ci) {
        return (find(this.merges, (range) => {
            const [start, end] = range;
            return ri >= start[1] && ri <= end[1] && ci >= start[0] && ci <= end[0];
        }) || [
            [ci, ri],
            [ci, ri],
        ]);
    }
    getCellArea(sr, sc, er, ec) {
        return [this.getMergeCell(sr, sc), this.getMergeCell(er, ec)];
    }
    getCell(ri, ci) {
        const cell = this.data[ri] ? this.data[ri][ci] || null : null;
        return Object.assign(Object.assign(Object.assign({ valid: cell !== null, x: 0, y: 0 }, cell), this.getCellBounds(ri, ci)), { ri,
            ci });
    }
    getViewData() {
        return this.data;
    }
    /**
     * 判断鼠标悬浮下面是否有文字
     */
    isHoverText(cell, clientX, clientY) {
        const textArea = (cell.textArea || []);
        return textArea.some(item => cell.x + item.x <= clientX &&
            cell.y + item.y <= clientY &&
            cell.x + item.x + item.width >= clientX &&
            cell.y + item.y + item.height >= clientY);
    }
    getMergeCell(ri, ci) {
        const [start, end] = this.findMergeRange(ri, ci);
        return Object.assign(Object.assign({}, this.getCell(start[1], start[0])), { ri: start[1], ci: start[0], width: this.getSumWidth(start[0], end[0] + 1), height: this.getSumHeight(start[1], end[1] + 1), rp: end[1] - start[1], cp: end[0] - start[0] });
    }
    /**
     * 更新cell数据
     * @param ri row
     * @param ci col
     * @param data 更新数据
     */
    updateCell(ri, ci, data) {
        this.data[ri] ? this.data[ri][ci] = data : null;
    }
    getStickers() {
        return this.stickers;
    }
    setRowHeight(ri, height) {
        this.rows[ri] = height;
        this.digest();
    }
    setColWidth(ci, width) {
        this.cols[ci] = width;
        this.digest();
    }
    insertRows(ri, rowData, config) {
        const { rows } = config;
        this.rowc += rowData.length;
        this.rows.splice(ri, 0, ...rows);
        this.data.splice(ri, 0, ...rowData);
        if (ri < this.freeze[1]) {
            this.freeze[1] += rowData.length;
        }
        this.updateMerges(ri, rowData.length, 0, 0);
        this.updateStickers(ri, rowData.length, 0, 0);
        this.digest();
    }
    deleteRows(ri, rc) {
        this.rowc = Math.max(ri, this.rowc - rc);
        this.rows.splice(ri, rc);
        this.data.splice(ri, rc);
        this.updateMerges(ri, -rc, 0, 0);
        this.updateStickers(ri, -rc, 0, 0);
        this.digest();
    }
    inserCols(ci, colData, config) {
        const { cols } = config;
        this.colc += colData.length;
        this.cols.splice(ci, 0, ...cols);
        this.data.forEach((row, i) => {
            row.splice(ci, 0, ...colData[i]);
        });
        if (ci < this.freeze[0]) {
            this.freeze[0] += colData.length;
        }
        this.updateMerges(0, 0, ci, colData.length);
        this.updateStickers(0, 0, ci, colData.length);
        this.digest();
    }
    deleteCols(ci, cc) {
        this.colc = Math.max(ci, this.colc - cc);
        this.cols.splice(ci, cc);
        this.data.forEach(row => {
            row.splice(ci, cc);
        });
        this.updateMerges(0, 0, ci, cc);
        this.updateStickers(0, 0, ci, cc);
        this.digest();
    }
    digest() {
        this.totalWidth = this.getSumWidth();
        this.totalHeight = this.getSumHeight();
        this.freezeWidth = this.getSumWidth(0, this.freeze[0]);
        this.freezeHeight = this.getSumHeight(0, this.freeze[1]);
    }
    loadData(props) {
        const { colc, rowc, cols, rows, data, freeze, merges, styles, stickers } = props;
        this.colc = colc;
        this.rowc = rowc;
        this.cols = cols || [];
        this.rows = rows || [];
        this.cols.length = colc;
        this.rows.length = rowc;
        this.freeze = freeze || [0, 0];
        this.data = data || [];
        this.merges = merges || [];
        this.styles = styles || [];
        this.stickers = (stickers || []).map(sticker => {
            sticker.id = sticker.id || uuid();
            return sticker;
        });
        this.digest();
    }
    updateMerges(ri, rc, ci, cc) {
        this.merges.forEach((merge) => {
            const [start, end] = merge;
            start[0] >= ci && (start[0] += cc);
            start[1] >= ri && (start[1] += rc);
            end[0] >= ci && (end[0] += cc);
            end[1] >= ri && (end[1] += rc);
        });
    }
    updateStickers(ri, rc, ci, cc) {
        this.stickers.forEach(sticker => {
            const { position } = sticker;
            if ('row' in position && 'col' in position) {
                if (position.row > ri && position.row <= ri - rc || position.col > ci && position.col <= ci - cc) {
                    sticker.tag = 'delete';
                }
                else {
                    sticker.tag = 'normal';
                }
                position.col >= ci && (position.col += cc);
                position.row >= ri && (position.row += rc);
            }
            if ('x' in position && 'y' in position) {
                position.x >= ci && (position.x += cc);
                position.y >= ri && (position.y += rc);
            }
        });
    }
    getSelctionRange(sc, sr, ec, er) {
        if (!this.data[0]) {
            return [];
        }
        const maxCol = this.data[0].length, cells = [];
        let row = sr, col = sc;
        while (row <= er && !(row === er && col > ec)) {
            const cell = this.getCell(row, col);
            if (cell) {
                cells.push(cell);
            }
            if (col === maxCol) {
                row++;
                col = 0;
            }
            else {
                col++;
            }
        }
        return cells;
    }
    reset() {
        this.getViewData().forEach(row => {
            row.forEach(cell => {
                if (!cell && !cell.textArea)
                    return;
                cell.textArea = [];
            });
        });
    }
}
//# sourceMappingURL=view.js.map