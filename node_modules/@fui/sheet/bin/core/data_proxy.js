import { View } from './view';
import { mergeRange, clamp, cArray, xTo26, isEqual, between, cloneDeep, isPointInMatrix } from '../utils';
import { DEFAULT_SHEET_OPTIONS } from './config';
import { Selection } from './selection';
export class DataProxy {
    constructor(name = 'sheet', options) {
        this.name = name;
        this.selection = new Selection();
        this.options = Object.assign(Object.assign({}, cloneDeep(DEFAULT_SHEET_OPTIONS)), options);
        this.view = new View(this.options.sheet);
        this.scroll = this.options.scroll;
        this.scroll.x = isNaN(this.scroll.x) ? 0 : this.scroll.x;
        this.scroll.y = isNaN(this.scroll.y) ? 0 : this.scroll.y;
        this.update();
    }
    // 获取除了冻结的区域
    getRenderBounds(direction) {
        const freezeWidth = this.view.freezeWidth;
        const freezeHeight = this.view.freezeHeight;
        if (direction === 'horizontal') {
            return {
                x: freezeWidth,
                y: 0,
                width: this.width - freezeWidth,
                height: this.options.height,
            };
        }
        else {
            return {
                x: 0,
                y: freezeHeight,
                width: this.width,
                height: this.options.height - freezeHeight,
            };
        }
    }
    // 可选范围和坐标
    select(a, b, c, d, position) {
        if (c !== undefined && d !== undefined) {
            // TODO: 观察了下，如果单一选区的话还是会有问题，最好要设计多选区
            const [[sc, sr], [ec, er]] = this.correctSelectRange(a, b, c, d);
            this.selection.selectRange(sr, sc, er, ec, position);
        }
        else {
            this.selection.selectCell(a, b, position);
        }
    }
    scrollTo(x, y, cb) {
        this.sc(x, y, cb);
    }
    scrollX(x, cb) {
        x = clamp(x, 0, this.maxScrollX);
        this.sc(x, this.scroll.y, cb);
    }
    scrollY(y, cb) {
        y = clamp(y, 0, this.maxScrollY);
        this.sc(this.scroll.x, y, cb);
    }
    getViewRange() {
        const start = this.view.getCellIndexs(this.scroll.x, this.scroll.y);
        const end = this.view.getCellIndexs(this.scroll.x + this.width, this.scroll.y + this.height);
        return [start, end];
    }
    getScrollRange() {
        const start = this.view.getCellIndexs(this.scroll.x + this.view.freezeWidth, this.scroll.y + this.view.freezeHeight);
        const end = this.view.getCellIndexs(this.scroll.x + this.width, this.scroll.y + this.height);
        return [start, end];
    }
    //
    getViewBounds() {
        return {
            width: this.width,
            height: this.height,
        };
    }
    getScroll() {
        return this.scroll;
    }
    getCellIndexs(x, y) {
        const freezeWidth = this.view.freezeWidth, freezeHeight = this.view.freezeHeight;
        x > freezeWidth && (x += this.scroll.x);
        y > freezeHeight && (y += this.scroll.y);
        const oCell = this.view.getCellIndexs(x, y);
        const mCell = this.view.getMergeCell(oCell[1], oCell[0]);
        return [mCell.ci, mCell.ri];
    }
    getCellByOffset(x, y) {
        if (x < this.offset.offsetX || y < this.offset.offsetY) {
            return null;
        }
        else {
            const { x: offsetX, y: offsetY } = this.getPositionByOffset(x, y);
            const oCell = this.view.getCellIndexs(offsetX, offsetY);
            return this.view.getMergeCell(oCell[1], oCell[0]);
        }
    }
    getPositionByOffset(x, y) {
        const freezeWidth = this.view.freezeWidth, freezeHeight = this.view.freezeHeight;
        x -= this.offset.offsetX;
        y -= this.offset.offsetY;
        x > freezeWidth && (x += this.scroll.x);
        y > freezeHeight && (y += this.scroll.y);
        return { x, y };
    }
    /**
     * 更新data数据
     * @param ri row
     * @param ci col
     * @param data 更新数据
     */
    updateCell(ri, ci, data) {
        this.view.updateCell(ri, ci, data);
    }
    getCellIndexsByOffset(x, y) {
        const { offsetX, offsetY } = this.offset;
        if (x >= offsetX && y >= offsetY) {
            x -= offsetX;
            y -= offsetY;
            if (x <= this.view.totalWidth && y <= this.view.totalHeight) {
                const [ci, ri] = this.getCellIndexs(x, y);
                return this.view.getCell(ri, ci).valid === false ? null : [ci, ri];
            }
        }
    }
    getFreezeBounds() {
        return [
            {
                x: this.view.freezeWidth,
                y: 0,
                width: this.width - this.view.freezeWidth,
                height: this.view.freezeHeight,
            },
            {
                x: 0,
                y: this.view.freezeHeight,
                width: this.view.freezeWidth,
                height: this.height - this.view.freezeHeight,
            },
            {
                x: 0,
                y: 0,
                width: this.view.freezeWidth,
                height: this.view.freezeHeight,
            },
        ];
    }
    cellIsFreezed(cell) {
        return {
            horizontalFreezed: cell.y + cell.height <= this.view.freezeHeight,
            verticalFreezed: cell.x + cell.width <= this.view.freezeWidth,
        };
    }
    // 目前只能一个区域一个区域地取
    getCellsInBounds(x, y, width, height) {
        let freezeCells = [], otherCells = [];
        x = Math.max(x, 0);
        y = Math.max(y, 0);
        width = Math.min(width, this.width - x);
        height = Math.min(height, this.height - y);
        if (x < this.view.freezeWidth && y < this.view.freezeHeight) {
            const topLeft = this.view.getCellsInRange([
                this.view.getCellIndexs(x, y),
                this.view.getCellIndexs(this.view.freezeWidth, this.view.freezeHeight),
            ]);
            // const trscell = this.view.getCellIndexs(this.view.freezeWidth + this.scroll.x, y);
            // const topRight = this.view.getCellsInRange([
            //     [trscell[0], trscell[1]],
            //     this.view.getCellIndexs(this.scroll.x + width, this.view.freezeHeight)
            // ]);
            // const blscell = this.view.getCellIndexs(x, this.view.freezeHeight + this.scroll.y);
            // const bottomLeft = this.view.getCellsInRange([
            //     [blscell[0], blscell[1]],
            //     this.view.getCellIndexs(this.view.freezeWidth, this.scroll.y + height)
            // ]);
            // freezeCells = Array.prototype.concat(bottomLeft, topRight, topLeft);
            freezeCells = topLeft;
            // const brscell = this.view.getCellIndexs(
            //     this.view.freezeWidth + this.scroll.x,
            //     this.view.freezeHeight + this.scroll.y
            // );
            // otherCells = this.view.getCellsInRange([
            //     [brscell[0], brscell[1]],
            //     this.view.getCellIndexs(this.scroll.x + width, this.scroll.y + height)
            // ]);
        }
        else if (x < this.view.freezeWidth) {
            freezeCells = this.view.getCellsInRange([
                this.view.getCellIndexs(x, y + this.scroll.y),
                this.view.getCellIndexs(this.view.freezeWidth, y + this.scroll.y + height),
            ]);
            // otherCells = this.view.getCellsInRange([
            //     this.view.getCellIndexs(this.view.freezeWidth + this.scroll.x, y + this.scroll.y),
            //     this.view.getCellIndexs(width + x + this.scroll.x, y + this.scroll.y + height)
            // ]);
        }
        else if (y < this.view.freezeHeight) {
            freezeCells = this.view.getCellsInRange([
                this.view.getCellIndexs(x + this.scroll.x, y),
                this.view.getCellIndexs(x + this.scroll.x + width, this.view.freezeHeight),
            ]);
            // otherCells = this.view.getCellsInRange([
            //     this.view.getCellIndexs(x + this.scroll.x, this.view.freezeHeight + this.scroll.y),
            //     this.view.getCellIndexs(x + this.scroll.x + width, height + y + this.scroll.y)
            // ]);
        }
        else {
            // freezeCells = [];
            otherCells = this.view.getCellsInRange([
                this.view.getCellIndexs(x + this.scroll.x, y + this.scroll.y),
                this.view.getCellIndexs(x + this.scroll.x + width, height + y + this.scroll.y),
            ]);
        }
        // return Array.prototype.concat(otherCells, freezeCells).reduce((result: { [key: string]: Cell }, cell: Cell): {
        //     [key: string]: Cell;
        // } => {
        //     result[`${cell.ci}-${cell.ri}`] = this._getCorrectBounds(cell) as Cell;
        //     return result;
        // }, {});
        const cacheSet = new Set();
        const result = [];
        Array.prototype.concat(otherCells, freezeCells).reduce((r, cell) => {
            const key = `${cell.ci}-${cell.ri}`;
            if (cacheSet.has(key)) {
                return r;
            }
            cacheSet.add(key);
            r.push(this.correctBounds(cell));
            return r;
        }, result);
        return result;
    }
    getCellBounds(row, column) {
        const freeze = this.view.freeze;
        const bounds = this.view.getCellBounds(row, column);
        if (row > freeze[1]) {
            bounds.y -= this.scroll.y;
        }
        if (column > freeze[0]) {
            bounds.x -= this.scroll.x;
        }
        return bounds;
    }
    getCell(row, column) {
        return Object.assign(Object.assign({}, this.getCellBounds(row, column)), { ri: row, ci: column });
    }
    getMergeCells() {
        return this.view.merges.map((merge) => {
            const [start] = merge;
            const bounds = this.view.getRangeBounds(merge);
            return this.correctBounds(Object.assign(Object.assign(Object.assign({}, this.view.getCell(start[1], start[0])), bounds), { x: bounds.x + 0.5, y: bounds.y + 0.5 }));
        });
    }
    getRangeBounds(merge) {
        return this.view.getRangeBounds(merge);
    }
    // 修正滚动的距离
    correctDeltaY(deltaY) {
        if (!deltaY) {
            return deltaY;
        }
        const scrollY = this.scroll.y + deltaY;
        if (scrollY <= 0) {
            return -this.scroll.y;
        }
        if (scrollY >= this.maxScrollY) {
            return this.maxScrollY - this.scroll.y;
        }
        if (!this.options.align) {
            return deltaY;
        }
        const totalHeight = scrollY + this.view.freezeHeight;
        let totalTop = this.view.freezeHeight;
        let lastScollTop = scrollY;
        for (let i = this.view.freeze[1]; i < this.view.rowc; i++) {
            const rowHeight = this.view.getRowHeight(i);
            if (totalHeight >= totalTop && totalHeight < totalTop + rowHeight) {
                lastScollTop = totalHeight > totalTop + rowHeight / 2 ? totalTop + rowHeight : totalTop;
                break;
            }
            totalTop += rowHeight;
        }
        return lastScollTop - this.scroll.y - this.view.freezeHeight;
    }
    // 修正滚动的距离
    correctDeltaX(deltaX) {
        if (!deltaX) {
            return deltaX;
        }
        const scrollX = this.scroll.x + deltaX;
        if (scrollX <= 0) {
            return -this.scroll.x;
        }
        if (scrollX >= this.maxScrollX) {
            return this.maxScrollX - this.scroll.x;
        }
        if (!this.options.align) {
            return deltaX;
        }
        const scrollLeft = scrollX + this.view.freezeWidth;
        let totalLeft = this.view.freezeWidth;
        let lastScollLeft = scrollX;
        for (let i = this.view.freeze[0]; i < this.view.colc; i++) {
            const colWidth = this.view.getColWidth(i);
            if (scrollLeft >= totalLeft && scrollLeft < totalLeft + colWidth) {
                lastScollLeft = scrollLeft > totalLeft + colWidth / 2 ? totalLeft + colWidth : totalLeft;
                break;
            }
            totalLeft += colWidth;
        }
        return lastScollLeft - this.scroll.x - this.view.freezeWidth;
    }
    // sequnce
    getSequnceCells() {
        const [[sc, sr], [ec, er]] = this.selection.getRange();
        let top = [], left = [];
        const [start, end] = this.view.getCellArea(sr, sc, er, ec);
        const startCI = Math.min(start.ci, end.ci), endCI = Math.max(start.ci + start.cp, end.ci + end.cp), startRI = Math.min(start.ri, end.ri), endRI = Math.max(start.ri + start.rp, end.ri + end.rp);
        if (this.options.topSequnce.enable) {
            top = Array.prototype
                .concat(cArray(this.scroll.sc, this.scroll.ec + 1), cArray(0, this.view.freeze[0]))
                .map((ci) => {
                const cellBounds = this.getCellBounds(0, ci);
                return Object.assign(Object.assign({}, cellBounds), { x: cellBounds.x + 0.5, y: cellBounds.y - this.offset.offsetY + 0.5, width: this.view.getColWidth(ci), height: this.offset.offsetY, type: 'bi.label', text: xTo26(ci), ri: -1, ci, style: {
                        color: '#5f6368',
                        backgroundColor: between(ci, startCI, endCI) ? '#e8eaed' : '#f8f9fa',
                    } });
            });
        }
        if (this.options.leftSequnce.enable) {
            left = Array.prototype
                .concat(cArray(this.scroll.sr, this.scroll.er + 1), cArray(0, this.view.freeze[1]))
                .map((ri) => {
                const cellBounds = this.getCellBounds(ri, 0);
                return Object.assign(Object.assign({}, cellBounds), { x: cellBounds.x - this.offset.offsetX + 0.5, y: cellBounds.y + 0.5, width: this.offset.offsetX - 0.5, height: this.view.getRowHeight(ri) - 0.5, type: 'bi.label', text: ri + 1, ci: -1, ri, style: {
                        color: '#5f6368',
                        backgroundColor: between(ri, startRI, endRI) ? '#e8eaed' : '#f8f9fa',
                    } });
            });
        }
        return Array.prototype.concat(top, left);
    }
    isInSticker(x, y) {
        return this.getStickers().some(item => item.left <= x && item.left + item.width >= x && item.top <= y && item.top + item.height >= y);
    }
    // stickers
    getStickers() {
        return this.view.getStickers().map(s => {
            const { el, position, id, tag, init, lazy } = s;
            let top = 0, left = 0, width = 0, height = 0;
            if ('x' in position) {
                left = position.x;
                top = position.y;
                width = position.width;
                height = position.height;
            }
            if ('col' in position && 'row' in position) {
                const [start, end] = this.view.findMergeRange(position.row, position.col);
                const b = this.getStickerBounds(position.row, position.col);
                left = b.x;
                top = b.y;
                width = this.view.getSumWidth(start[0], end[0] + 1);
                height = this.view.getSumHeight(start[1], end[1] + 1);
            }
            return {
                id,
                top,
                left,
                width,
                height,
                el,
                tag,
                init,
                lazy,
            };
        });
    }
    getStickerBounds(row, column) {
        return this.view.getCellBounds(row, column);
    }
    // resizer
    getResizerCell(x, y) {
        const vertical = x > this.offset.offsetX;
        const correctX = vertical ? x - this.offset.offsetX : x;
        const correctY = !vertical ? y - this.offset.offsetY : y;
        const indexs = this.getCellIndexs(correctX, correctY);
        const cellBounds = this.getCellBounds(indexs[1], indexs[0]);
        let resultIndexs, resultBounds;
        if (vertical) {
            if (correctX - cellBounds.x < cellBounds.x + cellBounds.width - correctX) {
                resultIndexs = [indexs[0], Math.max(indexs[1] - 1, 0)];
                resultBounds = this.getCellBounds(resultIndexs[1], resultIndexs[0]);
            }
            else {
                resultIndexs = indexs;
                resultBounds = cellBounds;
            }
        }
        else {
            if (correctY - cellBounds.y < cellBounds.y + cellBounds.height - correctY) {
                resultIndexs = [Math.max(indexs[0] - 1, 0), indexs[1]];
                resultBounds = this.getCellBounds(resultIndexs[1], resultIndexs[0]);
            }
            else {
                resultIndexs = indexs;
                resultBounds = cellBounds;
            }
        }
        return Object.assign(Object.assign({}, resultBounds), { ri: resultIndexs[1], ci: resultIndexs[0], left: vertical ? resultBounds.x + this.offset.offsetX : resultBounds.x, top: !vertical ? resultBounds.y + this.offset.offsetY : resultBounds.y, width: !vertical ? this.offset.offsetX : resultBounds.width, height: vertical ? this.offset.offsetY : resultBounds.height });
    }
    //
    getSelectCell() {
        const [ci, ri] = this.selection.getCell();
        return this.view.getMergeCell(ri, ci);
    }
    getSelectRangeCells() {
        return this.view.getCellSquareInRange(this.getSelectRange());
    }
    /**
     * getSelectRange
     */
    getSelectRange() {
        const [[sc, sr], [ec, er]] = this.selection.getRange();
        const start = this.view.getMergeCell(sr, sc), end = this.view.getMergeCell(er, ec);
        const startCI = Math.min(start.ci, end.ci), endCI = Math.max(start.ci + start.cp, end.ci + end.cp), startRI = Math.min(start.ri, end.ri), endRI = Math.max(start.ri + start.rp, end.ri + end.rp);
        return [
            [startCI, startRI],
            [endCI, endRI],
        ];
    }
    transformPosition(start, end, cell) {
        const [[sc, sr], [ec, er]] = this.selection.getRange();
        const isStartCell = cell.ci === sc && cell.ri === sr, isEndCell = cell.ci === ec && cell.ri === er;
        // 这里需要进行位置矫正，因为原来的位移逻辑没有考虑合并单元格的情况
        const correctCell = this.getCellPosition({ row: cell.ri, col: cell.ci }, this.view.merges);
        if (isStartCell && isEndCell) {
            const isInLine = (cell.textArea || []).some(t => cell.y + t.y <= start.y &&
                cell.y + t.y + t.height >= start.y &&
                cell.y + t.y <= end.y &&
                cell.y + t.y + t.height >= end.y);
            return isInLine && start.x > end.x ? [end, start] : [start, end];
        }
        if (isStartCell) {
            !isPointInMatrix(start, { x: cell.x, y: cell.y, width: correctCell.width, height: correctCell.height }) &&
                ([start, end] = [end, start]);
            return [start, { x: cell.x + correctCell.width, y: cell.y + cell.height }];
        }
        if (isEndCell) {
            !isPointInMatrix(end, { x: cell.x, y: cell.y, width: correctCell.width, height: correctCell.height }) &&
                ([start, end] = [end, start]);
            return [{ x: cell.x, y: cell.y }, end];
        }
        return [
            { x: cell.x, y: cell.y },
            { x: cell.x + correctCell.width, y: cell.y + correctCell.height },
        ];
    }
    // 获取选取范围
    getSelectBounds() {
        const [[sc, sr], [ec, er]] = this.selection.getRange();
        const { start, end } = this.selection.getPosition();
        const cells = this.view.getSelctionRange(sc, sr, ec, er);
        const bounds = [];
        const selectedTexts = new Map();
        cells.forEach(cell => {
            const isStartCell = cell.ci === sc && cell.ri === sr, isEndCell = cell.ci === ec && cell.ri === er;
            const isStartOrEnd = isStartCell || isEndCell;
            const absoluteStart = this.offset2Absolute(start, cell);
            const absoluteEnd = this.offset2Absolute(end, cell);
            const [$start, $end] = this.transformPosition(absoluteStart, absoluteEnd, cell);
            let cellTexts = '';
            (cell.textArea || []).forEach(({ x, y, width, height, text }) => {
                const hit = text &&
                    (!isStartOrEnd ||
                        // 非首尾单元格的话内容全部是选中的
                        (cell.y + y < $start.y ? cell.y + y + height > $start.y : cell.y + y < $end.y) &&
                            // 右上顶点在y小于$start.y的情况下，x需要大于$start.x
                            (cell.y + y < $start.y ? cell.x + x + width > $start.x : true) &&
                            // 左下顶点在y大于$end.y的情况下，x需要小与$end.x
                            (cell.y + y + height > $end.y ? cell.x + x < $end.x : true));
                if (hit) {
                    bounds.push(this.spliteBounds(x + cell.x, y + cell.y, x + cell.x + width, y + cell.y + height));
                    cellTexts += text;
                }
            });
            cellTexts && selectedTexts.set(cell.y, (selectedTexts.get(cell.y) || []).concat([cellTexts]));
        });
        this.selection.setSelectedTexts(Array.from(selectedTexts.values()));
        return bounds;
    }
    offset2Absolute({ x, y }, cell) {
        let [$x, $y] = [x, y];
        const { x: scrollX, y: scrollY } = this.getScroll();
        const { verticalFreezed, horizontalFreezed } = this.cellIsFreezed(cell);
        !horizontalFreezed && ($y += scrollY);
        !verticalFreezed && ($x += scrollX);
        return { x: $x, y: $y };
    }
    /**
     * 根据位置获得所在分区
     * @param positionX 横坐标
     * @param positionY 纵坐标
     */
    getQuadrantBounds(positionX, positionY) {
        // REPORT-22692 冻结单元格时显示交界时的边框，所以偏移1px
        const freezeWidth = this.view.freezeWidth + 1;
        const freezeHeight = this.view.freezeHeight + 1;
        const isUpperQuadrant = positionY < freezeHeight;
        const isLeftQuadrant = positionX < freezeWidth;
        return {
            x: isLeftQuadrant ? 0 : freezeWidth,
            y: isUpperQuadrant ? 0 : freezeHeight,
            width: isLeftQuadrant ? freezeWidth : this.width - freezeWidth,
            height: isUpperQuadrant ? freezeHeight : this.height - freezeHeight,
        };
    }
    spliteBounds(startX, startY, endX, endY) {
        const result = [];
        const freezeWidth = this.view.freezeWidth;
        const freezeHeight = this.view.freezeHeight;
        result.push({
            x: startX,
            y: startY,
            width: Math.min(freezeWidth - startX, endX - startX),
            height: Math.min(freezeHeight - startY, endY - startX),
        });
        result.push({
            x: Math.max(freezeWidth, startX),
            y: startY,
            width: endX - Math.max(freezeWidth, startX),
            height: Math.min(freezeHeight - startY, endY - startY),
        });
        result.push({
            x: startX,
            y: Math.max(freezeHeight, startY),
            width: Math.min(freezeWidth - startX, endX - startX),
            height: endY - Math.max(freezeHeight, startY),
        });
        result.push({
            x: Math.max(freezeWidth, startX),
            y: Math.max(freezeHeight, startY),
            width: endX - Math.max(freezeWidth, startX),
            height: endY - Math.max(freezeHeight, startY),
        });
        return result;
    }
    // set
    setOffset(offset) {
        const { offsetX, offsetY } = offset;
        this.offset = offset;
        this.width = this.width - offsetX;
        this.height = this.height - offsetY;
        this.update();
    }
    resizeRow(ri, height) {
        this.view.setRowHeight(ri, height);
        this.updateMaxScroll();
        this.updateScrollRange();
    }
    resizeCol(ci, width) {
        this.view.setColWidth(ci, width);
        this.updateMaxScroll();
        this.updateScrollRange();
    }
    insertRows(ri, rowData, config) {
        this.view.insertRows(ri, rowData, config);
        this.update();
    }
    insertCols(ci, colData, config) {
        this.view.inserCols(ci, colData, config);
        this.update();
    }
    deleteRows(ri, rc) {
        this.view.deleteRows(ri, rc);
        this.update();
    }
    deleteCols(ci, cc) {
        this.view.deleteCols(ci, cc);
        this.update();
    }
    setData(options) {
        this.options = Object.assign(Object.assign(Object.assign({}, DEFAULT_SHEET_OPTIONS), this.options), options);
        this.view.loadData(this.options.sheet);
        this.scroll = this.options.scroll;
        this.update();
    }
    resize(width, height) {
        this.options.width = width || this.options.width;
        this.options.height = height || this.options.height;
        this.view.reset();
        this.update();
    }
    reset() {
        this.clearSelection();
    }
    update() {
        this.updateOffset();
        this.updateMaxScroll();
        this.updateScrollRange();
    }
    correctBounds(bounds) {
        const { x, y } = bounds;
        const freezeWidth = this.view.freezeWidth, freezeHeight = this.view.freezeHeight;
        return Object.assign(Object.assign({}, bounds), { x: x >= freezeWidth ? x - this.scroll.x : x, y: y >= freezeHeight ? y - this.scroll.y : y, ox: x, oy: y });
    }
    clearSelection() {
        this.selection.reset();
    }
    sc(x, y, cb) {
        const old = Object.assign({}, this.scroll);
        this.scroll.x = x;
        this.scroll.y = y;
        this.updateScrollRange();
        cb && cb(this.scroll, old);
    }
    // update
    updateScrollRange() {
        this.scroll.x = Math.ceil(Math.min(this.scroll.x, this.maxScrollX));
        this.scroll.y = Math.ceil(Math.min(this.scroll.y, this.maxScrollY));
        const [start, end] = this.getScrollRange();
        this.scroll.sr = start[1];
        this.scroll.sc = start[0];
        this.scroll.er = end[1];
        this.scroll.ec = end[0];
    }
    updateOffset() {
        this.offset = {
            offsetX: (this.options.leftSequnce.enable ? this.options.leftSequnce.size : 0) + this.options.offsetX,
            offsetY: (this.options.topSequnce.enable ? this.options.topSequnce.size : 0) + this.options.offsetY,
        };
        this.width = this.options.width - this.offset.offsetX;
        this.height = this.options.height - this.offset.offsetY;
    }
    updateMaxScroll() {
        const { width, height } = this.getMaxScrollBounds();
        this.maxScrollX = Math.ceil(width);
        this.maxScrollY = Math.ceil(height);
    }
    getMaxScrollBounds() {
        let totalHeight = 0, totalWidth = 0;
        if (!this.options.align) {
            return {
                width: Math.max(this.view.totalWidth - this.width, 0),
                height: Math.max(this.view.totalHeight - this.height, 0),
            };
        }
        for (let i = this.view.rowc - 1; i >= 0; i--) {
            const rowHeight = this.view.getRowHeight(i);
            if (totalHeight + rowHeight > this.height - this.view.freezeHeight) {
                break;
            }
            totalHeight += rowHeight;
        }
        for (let i = this.view.colc - 1; i >= 0; i--) {
            const colWidth = this.view.getColWidth(i);
            if (totalWidth + colWidth > this.width - this.view.freezeWidth) {
                break;
            }
            totalWidth += colWidth;
        }
        return {
            width: Math.max(this.view.totalWidth - this.view.freezeWidth - totalWidth, 0),
            height: Math.max(this.view.totalHeight - this.view.freezeHeight - totalHeight, 0),
        };
    }
    // 修正选区范围(mergeCell引起)
    correctSelectRange(sr, sc, er, ec) {
        if (sr > er) {
            [sr, er] = [er, sr];
            [sc, ec] = [ec, sc];
        }
        if (sr === er && sc > ec) {
            [sc, ec] = [ec, sc];
        }
        let range = [
            [sc, sr],
            [ec, er],
        ], newRange = [
            [sc, sr],
            [ec, er],
        ];
        while (!isEqual(range, newRange)) {
            range = newRange;
            let mRange = newRange;
            this.view.merges.forEach(range => {
                mRange = mergeRange(mRange, range);
            });
            newRange = mRange;
        }
        return newRange;
    }
    /**
     * 根据单元格坐标获取单元格位置(用于存在合并单元格时进行位置矫正）
     * @param data
     * @param merges
     */
    getCellPosition(data, merges) {
        const merge = merges.find(merge => merge.findIndex(item => item.length === 2 && item[0] === data.col && item[1] === data.row) >= 0);
        if (merge) {
            return this.view.getRangeBounds(merge);
        }
        return this.view.getCellBounds(data.row, data.col);
    }
}
//# sourceMappingURL=data_proxy.js.map