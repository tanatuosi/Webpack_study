var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Color } from './base/color';
import { parseBorder } from '../utils';
import { widget } from './base';
function digestStyle(props) {
    const { x = 0, y = 0, top, left, width, height, style = {}, autoWrapInfo, } = props;
    const { backgroundSize, backgroundImage, backgroundColor = '', color = '', textAlign, fontWeight = 'normal', fontFamily = 'SimSun', fontSize = '9pt', fontStyle = 'normal', verticalAlign, border = '', borderTop = '', borderBottom = '', borderLeft = '', borderRight = '', rotate, textShadow, underline, strikeThrough, lineHeight, subscript, supscript, newLine, verticalText, verTextDirection, cellJust, } = style;
    const styles = {};
    // box
    styles.top = top || y;
    styles.left = left || x;
    styles.width = width;
    styles.height = height;
    // font
    styles.color = new Color(color);
    styles.textAlign = textAlign;
    styles.verticalAlign = verticalAlign;
    styles.fontWeight = fontWeight;
    styles.fontSize = fontSize;
    styles.fontFamily = fontFamily;
    styles.fontStyle = fontStyle;
    styles.textShadow = textShadow;
    styles.underline = underline;
    styles.strikeThrough = strikeThrough;
    styles.lineHeight = lineHeight;
    styles.subscript = subscript;
    styles.supscript = supscript;
    // background
    styles.backgroundColor = new Color(backgroundColor);
    styles.backgroundImage = backgroundImage;
    styles.backgroundSize = backgroundSize;
    // border
    if (border) {
        const { width, style, color } = parseBorder(border);
        styles.borderLeftWidth = styles.borderTopWidth = styles.borderBottomWidth = styles.borderRightWidth = width;
        styles.borderLeftStyle = styles.borderTopStyle = styles.borderBottomStyle = styles.borderRightStyle = style;
        styles.borderLeftColor = styles.borderTopColor = styles.borderBottomColor = styles.borderRightColor = new Color(color);
    }
    if (borderTop) {
        const { width, color, style } = parseBorder(borderTop);
        styles.borderTopWidth = width;
        styles.borderTopStyle = style;
        styles.borderTopColor = new Color(color);
    }
    if (borderBottom) {
        const { width, color, style } = parseBorder(borderBottom);
        styles.borderBottomWidth = width;
        styles.borderBottomStyle = style;
        styles.borderBottomColor = new Color(color);
    }
    if (borderLeft) {
        const { width, color, style } = parseBorder(borderLeft);
        styles.borderLeftWidth = width;
        styles.borderLeftStyle = style;
        styles.borderLeftColor = new Color(color);
    }
    if (borderRight) {
        const { width, color, style } = parseBorder(borderRight);
        styles.borderRightWidth = width;
        styles.borderRightStyle = style;
        styles.borderRightColor = new Color(color);
    }
    // other
    styles.rotate = rotate;
    styles.newLine = newLine;
    styles.verticalText = verticalText;
    styles.verTextDirection = verTextDirection;
    styles.cellJust = cellJust;
    styles.autoWrapInfo = autoWrapInfo && JSON.parse(`${autoWrapInfo}`);
    return styles;
}
let AbstractWidget = /** @class */ (() => {
    let AbstractWidget = class AbstractWidget {
        constructor(props) {
            this.mouseDownHandler = (e, x, y, click) => {
                if (this.props.listeners) {
                    this.props.listeners.forEach(listener => {
                        var _a;
                        if (listener.eventName === 'CELL_MOUSE_DOWN') {
                            (_a = listener.action) === null || _a === void 0 ? void 0 : _a.call(this, e, x, y, click);
                        }
                    });
                }
            };
            this.mouseLeaveHandler = (e, x, y, click) => {
                if (this.props.listeners) {
                    this.props.listeners.forEach(listener => {
                        var _a;
                        if (listener.eventName === 'CELL_MOUSE_LEAVE') {
                            (_a = listener.action) === null || _a === void 0 ? void 0 : _a.call(this, e, x, y, click);
                        }
                    });
                }
            };
            this.clickHandler = (e, x, y, click) => {
                // 是否跳过选中等事件
                let skip = false;
                if (this.props.listeners) {
                    this.props.listeners.forEach(listener => {
                        var _a;
                        if (listener.eventName === 'CELL_CLICK') {
                            skip = (_a = listener.action) === null || _a === void 0 ? void 0 : _a.call(this, e, x, y, click);
                        }
                    });
                }
                return skip;
            };
            this.hoverHandler = (e, x, y, cell) => {
                if (this.props.listeners) {
                    this.props.listeners.forEach(listener => {
                        var _a;
                        if (listener.eventName === 'CELL_HOVER') {
                            (_a = listener.action) === null || _a === void 0 ? void 0 : _a.call(this, e, x, y, cell);
                        }
                    });
                }
            };
            this.dbClickHandler = (e, x, y, cell) => {
                if (this.props.listeners) {
                    this.props.listeners.forEach(listener => {
                        var _a;
                        if (listener.eventName === 'CELL_DOUBLE_CLICK') {
                            (_a = listener.action) === null || _a === void 0 ? void 0 : _a.call(this, e, x, y, cell);
                        }
                    });
                }
            };
            this.props = props;
            const { x = 0, y = 0, width, height, top, left } = props;
            this.width = width;
            this.height = height;
            this.top = top || y;
            this.left = left || x;
            this.style = digestStyle(props);
        }
        getBounds() {
            return {
                left: this.left,
                top: this.top,
                right: this.left + this.width,
                bottom: this.top + this.height,
                width: this.width,
                height: this.height,
            };
        }
        getChildren() { }
        getStyle() {
            return this.style;
        }
        getText() { }
        getRealWidth() {
            return this.width;
        }
    };
    AbstractWidget = __decorate([
        widget('bi.widget')
    ], AbstractWidget);
    return AbstractWidget;
})();
export { AbstractWidget };
//# sourceMappingURL=widget.js.map