/*! time: 2022/11/29 14:07:13 */
/*! time: 2022/11/29 14:07:13 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 543);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.store = exports.shortcut = exports.model = exports.Model = void 0;
var _BI$Decorators = BI.Decorators,
    shortcut = _BI$Decorators.shortcut,
    Model = _BI$Decorators.Model,
    model = _BI$Decorators.model,
    store = _BI$Decorators.store;
exports.store = store;
exports.model = model;
exports.Model = Model;
exports.shortcut = shortcut;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSequenceProd = exports.isBranchingProd = exports.isOptionalProd = exports.getProductionDslName = exports.GAstVisitor = exports.serializeProduction = exports.serializeGrammar = exports.Alternative = exports.Alternation = exports.RepetitionWithSeparator = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Repetition = exports.Option = exports.NonTerminal = exports.Terminal = exports.Rule = void 0;

var model_1 = __webpack_require__(93);

Object.defineProperty(exports, "Rule", {
  enumerable: true,
  get: function get() {
    return model_1.Rule;
  }
});
Object.defineProperty(exports, "Terminal", {
  enumerable: true,
  get: function get() {
    return model_1.Terminal;
  }
});
Object.defineProperty(exports, "NonTerminal", {
  enumerable: true,
  get: function get() {
    return model_1.NonTerminal;
  }
});
Object.defineProperty(exports, "Option", {
  enumerable: true,
  get: function get() {
    return model_1.Option;
  }
});
Object.defineProperty(exports, "Repetition", {
  enumerable: true,
  get: function get() {
    return model_1.Repetition;
  }
});
Object.defineProperty(exports, "RepetitionMandatory", {
  enumerable: true,
  get: function get() {
    return model_1.RepetitionMandatory;
  }
});
Object.defineProperty(exports, "RepetitionMandatoryWithSeparator", {
  enumerable: true,
  get: function get() {
    return model_1.RepetitionMandatoryWithSeparator;
  }
});
Object.defineProperty(exports, "RepetitionWithSeparator", {
  enumerable: true,
  get: function get() {
    return model_1.RepetitionWithSeparator;
  }
});
Object.defineProperty(exports, "Alternation", {
  enumerable: true,
  get: function get() {
    return model_1.Alternation;
  }
});
Object.defineProperty(exports, "Alternative", {
  enumerable: true,
  get: function get() {
    return model_1.Alternative;
  }
});
Object.defineProperty(exports, "serializeGrammar", {
  enumerable: true,
  get: function get() {
    return model_1.serializeGrammar;
  }
});
Object.defineProperty(exports, "serializeProduction", {
  enumerable: true,
  get: function get() {
    return model_1.serializeProduction;
  }
});

var visitor_1 = __webpack_require__(490);

Object.defineProperty(exports, "GAstVisitor", {
  enumerable: true,
  get: function get() {
    return visitor_1.GAstVisitor;
  }
});

var helpers_1 = __webpack_require__(491);

Object.defineProperty(exports, "getProductionDslName", {
  enumerable: true,
  get: function get() {
    return helpers_1.getProductionDslName;
  }
});
Object.defineProperty(exports, "isOptionalProd", {
  enumerable: true,
  get: function get() {
    return helpers_1.isOptionalProd;
  }
});
Object.defineProperty(exports, "isBranchingProd", {
  enumerable: true,
  get: function get() {
    return helpers_1.isBranchingProd;
  }
});
Object.defineProperty(exports, "isSequenceProd", {
  enumerable: true,
  get: function get() {
    return helpers_1.isSequenceProd;
  }
});

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayEach = __webpack_require__(226),
    baseEach = __webpack_require__(21),
    castFunction = __webpack_require__(448),
    isArray = __webpack_require__(0);
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(32),
    baseIteratee = __webpack_require__(13),
    baseMap = __webpack_require__(443),
    isArray = __webpack_require__(0);
/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */


function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeKeys = __webpack_require__(220),
    baseKeys = __webpack_require__(73),
    isArrayLike = __webpack_require__(8);
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EmbeddedActionsParser = exports.CstParser = exports.Parser = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.DEFAULT_RULE_CONFIG = exports.DEFAULT_PARSER_CONFIG = exports.END_OF_FILE = void 0;

var isEmpty_1 = __importDefault(__webpack_require__(9));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var values_1 = __importDefault(__webpack_require__(15));

var has_1 = __importDefault(__webpack_require__(7));

var clone_1 = __importDefault(__webpack_require__(17));

var utils_1 = __webpack_require__(37);

var follow_1 = __webpack_require__(475);

var tokens_public_1 = __webpack_require__(26);

var errors_public_1 = __webpack_require__(65);

var gast_resolver_public_1 = __webpack_require__(509);

var recoverable_1 = __webpack_require__(245);

var looksahead_1 = __webpack_require__(515);

var tree_builder_1 = __webpack_require__(516);

var lexer_adapter_1 = __webpack_require__(520);

var recognizer_api_1 = __webpack_require__(521);

var recognizer_engine_1 = __webpack_require__(522);

var error_handler_1 = __webpack_require__(523);

var context_assist_1 = __webpack_require__(524);

var gast_recorder_1 = __webpack_require__(525);

var perf_tracer_1 = __webpack_require__(526);

var apply_mixins_1 = __webpack_require__(527);

exports.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(exports.END_OF_FILE);
exports.DEFAULT_PARSER_CONFIG = Object.freeze({
  recoveryEnabled: false,
  maxLookahead: 3,
  dynamicTokensEnabled: false,
  outputCst: true,
  errorMessageProvider: errors_public_1.defaultParserErrorProvider,
  nodeLocationTracking: "none",
  traceInitPerf: false,
  skipValidations: false
});
exports.DEFAULT_RULE_CONFIG = Object.freeze({
  recoveryValueFunc: function recoveryValueFunc() {
    return undefined;
  },
  resyncEnabled: true
});
var ParserDefinitionErrorType;

(function (ParserDefinitionErrorType) {
  ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
  ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
  ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
  ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
  ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
  ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
  ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
  ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
  ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
  ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
  ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
  ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
  ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
})(ParserDefinitionErrorType = exports.ParserDefinitionErrorType || (exports.ParserDefinitionErrorType = {}));

function EMPTY_ALT(value) {
  if (value === void 0) {
    value = undefined;
  }

  return function () {
    return value;
  };
}

exports.EMPTY_ALT = EMPTY_ALT;

var Parser =
/** @class */
function () {
  function Parser(tokenVocabulary, config) {
    this.definitionErrors = [];
    this.selfAnalysisDone = false;
    var that = this;
    that.initErrorHandler(config);
    that.initLexerAdapter();
    that.initLooksAhead(config);
    that.initRecognizerEngine(tokenVocabulary, config);
    that.initRecoverable(config);
    that.initTreeBuilder(config);
    that.initContentAssist();
    that.initGastRecorder(config);
    that.initPerformanceTracer(config);

    if ((0, has_1["default"])(config, "ignoredIssues")) {
      throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n\t" + "Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n\t" + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n\t" + "For further details.");
    }

    this.skipValidations = (0, has_1["default"])(config, "skipValidations") ? config.skipValidations // casting assumes the end user passing the correct type
    : exports.DEFAULT_PARSER_CONFIG.skipValidations;
  }
  /**
   *  @deprecated use the **instance** method with the same name instead
   */


  Parser.performSelfAnalysis = function (parserInstance) {
    throw Error("The **static** `performSelfAnalysis` method has been deprecated." + "\t\nUse the **instance** method with the same name instead.");
  };

  Parser.prototype.performSelfAnalysis = function () {
    var _this = this;

    this.TRACE_INIT("performSelfAnalysis", function () {
      var defErrorsMsgs;
      _this.selfAnalysisDone = true;
      var className = _this.className;

      _this.TRACE_INIT("toFastProps", function () {
        // Without this voodoo magic the parser would be x3-x4 slower
        // It seems it is better to invoke `toFastProperties` **before**
        // Any manipulations of the `this` object done during the recording phase.
        (0, utils_1.toFastProperties)(_this);
      });

      _this.TRACE_INIT("Grammar Recording", function () {
        try {
          _this.enableRecording(); // Building the GAST


          (0, forEach_1["default"])(_this.definedRulesNames, function (currRuleName) {
            var wrappedRule = _this[currRuleName];
            var originalGrammarAction = wrappedRule["originalGrammarAction"];
            var recordedRuleGast;

            _this.TRACE_INIT("".concat(currRuleName, " Rule"), function () {
              recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
            });

            _this.gastProductionsCache[currRuleName] = recordedRuleGast;
          });
        } finally {
          _this.disableRecording();
        }
      });

      var resolverErrors = [];

      _this.TRACE_INIT("Grammar Resolving", function () {
        resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
          rules: (0, values_1["default"])(_this.gastProductionsCache)
        });
        _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
      });

      _this.TRACE_INIT("Grammar Validations", function () {
        // only perform additional grammar validations IFF no resolving errors have occurred.
        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.
        if ((0, isEmpty_1["default"])(resolverErrors) && _this.skipValidations === false) {
          var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
            rules: (0, values_1["default"])(_this.gastProductionsCache),
            maxLookahead: _this.maxLookahead,
            tokenTypes: (0, values_1["default"])(_this.tokensMap),
            errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
            grammarName: className
          });
          _this.definitionErrors = _this.definitionErrors.concat(validationErrors);
        }
      }); // this analysis may fail if the grammar is not perfectly valid


      if ((0, isEmpty_1["default"])(_this.definitionErrors)) {
        // The results of these computations are not needed unless error recovery is enabled.
        if (_this.recoveryEnabled) {
          _this.TRACE_INIT("computeAllProdsFollows", function () {
            var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1["default"])(_this.gastProductionsCache));
            _this.resyncFollows = allFollows;
          });
        }

        _this.TRACE_INIT("ComputeLookaheadFunctions", function () {
          _this.preComputeLookaheadFunctions((0, values_1["default"])(_this.gastProductionsCache));
        });
      }

      if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1["default"])(_this.definitionErrors)) {
        defErrorsMsgs = (0, map_1["default"])(_this.definitionErrors, function (defError) {
          return defError.message;
        });
        throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
      }
    });
  }; // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.
  // (normally during the parser's constructor).
  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,
  // for example: duplicate rule names, referencing an unresolved subrule, ect...
  // This flag should not be enabled during normal usage, it is used in special situations, for example when
  // needing to display the parser definition errors in some GUI(online playground).


  Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
  return Parser;
}();

exports.Parser = Parser;
(0, apply_mixins_1.applyMixins)(Parser, [recoverable_1.Recoverable, looksahead_1.LooksAhead, tree_builder_1.TreeBuilder, lexer_adapter_1.LexerAdapter, recognizer_engine_1.RecognizerEngine, recognizer_api_1.RecognizerApi, error_handler_1.ErrorHandler, context_assist_1.ContentAssist, gast_recorder_1.GastRecorder, perf_tracer_1.PerformanceTracer]);

var CstParser =
/** @class */
function (_super) {
  __extends(CstParser, _super);

  function CstParser(tokenVocabulary, config) {
    if (config === void 0) {
      config = exports.DEFAULT_PARSER_CONFIG;
    }

    var configClone = (0, clone_1["default"])(config);
    configClone.outputCst = true;
    return _super.call(this, tokenVocabulary, configClone) || this;
  }

  return CstParser;
}(Parser);

exports.CstParser = CstParser;

var EmbeddedActionsParser =
/** @class */
function (_super) {
  __extends(EmbeddedActionsParser, _super);

  function EmbeddedActionsParser(tokenVocabulary, config) {
    if (config === void 0) {
      config = exports.DEFAULT_PARSER_CONFIG;
    }

    var configClone = (0, clone_1["default"])(config);
    configClone.outputCst = false;
    return _super.call(this, tokenVocabulary, configClone) || this;
  }

  return EmbeddedActionsParser;
}(Parser);

exports.EmbeddedActionsParser = EmbeddedActionsParser;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseHas = __webpack_require__(450),
    hasPath = __webpack_require__(224);
/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */


function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(30),
    isLength = __webpack_require__(75);
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseKeys = __webpack_require__(73),
    getTag = __webpack_require__(24),
    isArguments = __webpack_require__(48),
    isArray = __webpack_require__(0),
    isArrayLike = __webpack_require__(8),
    isBuffer = __webpack_require__(49),
    isPrototype = __webpack_require__(29),
    isTypedArray = __webpack_require__(76);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }

  var tag = getTag(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

module.exports = isEmpty;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var freeGlobal = __webpack_require__(210);
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var baseMatches = __webpack_require__(402),
    baseMatchesProperty = __webpack_require__(434),
    identity = __webpack_require__(35),
    isArray = __webpack_require__(0),
    property = __webpack_require__(441);
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInput = getInput;
exports.input = input;
var inputs = {};

function input(key) {
  return function (target) {
    inputs[key] = target;
  };
}

function getInput(type) {
  var inputWidget = inputs[type];

  if (BI.isNull(inputWidget)) {
    throw new TypeError();
  }

  return inputWidget.xtype;
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseValues = __webpack_require__(449),
    keys = __webpack_require__(5);
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */


function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFlatten = __webpack_require__(97);
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */


function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseClone = __webpack_require__(451);
/** Used to compose bitmasks for cloning. */


var CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIndexOf = __webpack_require__(96),
    isArrayLike = __webpack_require__(8),
    isString = __webpack_require__(39),
    toInteger = __webpack_require__(38),
    values = __webpack_require__(15);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */

function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike(collection) ? collection : values(collection);
  fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
  var length = collection.length;

  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }

  return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
}

module.exports = includes;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsNative = __webpack_require__(391),
    getValue = __webpack_require__(396);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(25),
    getRawTag = __webpack_require__(392),
    objectToString = __webpack_require__(393);
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseForOwn = __webpack_require__(444),
    createBaseEach = __webpack_require__(447);
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayReduce = __webpack_require__(506),
    baseEach = __webpack_require__(21),
    baseIteratee = __webpack_require__(13),
    baseReduce = __webpack_require__(507),
    isArray = __webpack_require__(0);
/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */


function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;
  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataView = __webpack_require__(390),
    Map = __webpack_require__(74),
    Promise = __webpack_require__(397),
    Set = __webpack_require__(212),
    WeakMap = __webpack_require__(398),
    baseGetTag = __webpack_require__(20),
    toSource = __webpack_require__(211);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(10);
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tokenMatcher = exports.createTokenInstance = exports.EOF = exports.createToken = exports.hasTokenLabel = exports.tokenName = exports.tokenLabel = void 0;

var isString_1 = __importDefault(__webpack_require__(39));

var has_1 = __importDefault(__webpack_require__(7));

var isUndefined_1 = __importDefault(__webpack_require__(22));

var lexer_public_1 = __webpack_require__(63);

var tokens_1 = __webpack_require__(27);

function tokenLabel(tokType) {
  if (hasTokenLabel(tokType)) {
    return tokType.LABEL;
  } else {
    return tokType.name;
  }
}

exports.tokenLabel = tokenLabel;

function tokenName(tokType) {
  return tokType.name;
}

exports.tokenName = tokenName;

function hasTokenLabel(obj) {
  return (0, isString_1["default"])(obj.LABEL) && obj.LABEL !== "";
}

exports.hasTokenLabel = hasTokenLabel;
var PARENT = "parent";
var CATEGORIES = "categories";
var LABEL = "label";
var GROUP = "group";
var PUSH_MODE = "push_mode";
var POP_MODE = "pop_mode";
var LONGER_ALT = "longer_alt";
var LINE_BREAKS = "line_breaks";
var START_CHARS_HINT = "start_chars_hint";

function createToken(config) {
  return createTokenInternal(config);
}

exports.createToken = createToken;

function createTokenInternal(config) {
  var pattern = config.pattern;
  var tokenType = {};
  tokenType.name = config.name;

  if (!(0, isUndefined_1["default"])(pattern)) {
    tokenType.PATTERN = pattern;
  }

  if ((0, has_1["default"])(config, PARENT)) {
    throw "The parent property is no longer supported.\n" + "See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
  }

  if ((0, has_1["default"])(config, CATEGORIES)) {
    // casting to ANY as this will be fixed inside `augmentTokenTypes``
    tokenType.CATEGORIES = config[CATEGORIES];
  }

  (0, tokens_1.augmentTokenTypes)([tokenType]);

  if ((0, has_1["default"])(config, LABEL)) {
    tokenType.LABEL = config[LABEL];
  }

  if ((0, has_1["default"])(config, GROUP)) {
    tokenType.GROUP = config[GROUP];
  }

  if ((0, has_1["default"])(config, POP_MODE)) {
    tokenType.POP_MODE = config[POP_MODE];
  }

  if ((0, has_1["default"])(config, PUSH_MODE)) {
    tokenType.PUSH_MODE = config[PUSH_MODE];
  }

  if ((0, has_1["default"])(config, LONGER_ALT)) {
    tokenType.LONGER_ALT = config[LONGER_ALT];
  }

  if ((0, has_1["default"])(config, LINE_BREAKS)) {
    tokenType.LINE_BREAKS = config[LINE_BREAKS];
  }

  if ((0, has_1["default"])(config, START_CHARS_HINT)) {
    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
  }

  return tokenType;
}

exports.EOF = createToken({
  name: "EOF",
  pattern: lexer_public_1.Lexer.NA
});
(0, tokens_1.augmentTokenTypes)([exports.EOF]);

function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
  return {
    image: image,
    startOffset: startOffset,
    endOffset: endOffset,
    startLine: startLine,
    endLine: endLine,
    startColumn: startColumn,
    endColumn: endColumn,
    tokenTypeIdx: tokType.tokenTypeIdx,
    tokenType: tokType
  };
}

exports.createTokenInstance = createTokenInstance;

function tokenMatcher(token, tokType) {
  return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
}

exports.tokenMatcher = tokenMatcher;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTokenType = exports.hasExtendingTokensTypesMapProperty = exports.hasExtendingTokensTypesProperty = exports.hasCategoriesProperty = exports.hasShortKeyProperty = exports.singleAssignCategoriesToksMap = exports.assignCategoriesMapProp = exports.assignCategoriesTokensProp = exports.assignTokenDefaultProps = exports.expandCategories = exports.augmentTokenTypes = exports.tokenIdxToClass = exports.tokenShortNameIdx = exports.tokenStructuredMatcherNoCategories = exports.tokenStructuredMatcher = void 0;

var isEmpty_1 = __importDefault(__webpack_require__(9));

var compact_1 = __importDefault(__webpack_require__(64));

var isArray_1 = __importDefault(__webpack_require__(0));

var flatten_1 = __importDefault(__webpack_require__(16));

var difference_1 = __importDefault(__webpack_require__(102));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var has_1 = __importDefault(__webpack_require__(7));

var includes_1 = __importDefault(__webpack_require__(18));

var clone_1 = __importDefault(__webpack_require__(17));

function tokenStructuredMatcher(tokInstance, tokConstructor) {
  var instanceType = tokInstance.tokenTypeIdx;

  if (instanceType === tokConstructor.tokenTypeIdx) {
    return true;
  } else {
    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
  }
}

exports.tokenStructuredMatcher = tokenStructuredMatcher; // Optimized tokenMatcher in case our grammar does not use token categories
// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead

function tokenStructuredMatcherNoCategories(token, tokType) {
  return token.tokenTypeIdx === tokType.tokenTypeIdx;
}

exports.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
exports.tokenShortNameIdx = 1;
exports.tokenIdxToClass = {};

function augmentTokenTypes(tokenTypes) {
  // collect the parent Token Types as well.
  var tokenTypesAndParents = expandCategories(tokenTypes); // add required tokenType and categoryMatches properties

  assignTokenDefaultProps(tokenTypesAndParents); // fill up the categoryMatches

  assignCategoriesMapProp(tokenTypesAndParents);
  assignCategoriesTokensProp(tokenTypesAndParents);
  (0, forEach_1["default"])(tokenTypesAndParents, function (tokType) {
    tokType.isParent = tokType.categoryMatches.length > 0;
  });
}

exports.augmentTokenTypes = augmentTokenTypes;

function expandCategories(tokenTypes) {
  var result = (0, clone_1["default"])(tokenTypes);
  var categories = tokenTypes;
  var searching = true;

  while (searching) {
    categories = (0, compact_1["default"])((0, flatten_1["default"])((0, map_1["default"])(categories, function (currTokType) {
      return currTokType.CATEGORIES;
    })));
    var newCategories = (0, difference_1["default"])(categories, result);
    result = result.concat(newCategories);

    if ((0, isEmpty_1["default"])(newCategories)) {
      searching = false;
    } else {
      categories = newCategories;
    }
  }

  return result;
}

exports.expandCategories = expandCategories;

function assignTokenDefaultProps(tokenTypes) {
  (0, forEach_1["default"])(tokenTypes, function (currTokType) {
    if (!hasShortKeyProperty(currTokType)) {
      exports.tokenIdxToClass[exports.tokenShortNameIdx] = currTokType;
      currTokType.tokenTypeIdx = exports.tokenShortNameIdx++;
    } // CATEGORIES? : TokenType | TokenType[]


    if (hasCategoriesProperty(currTokType) && !(0, isArray_1["default"])(currTokType.CATEGORIES) // &&
    // !isUndefined(currTokType.CATEGORIES.PATTERN)
    ) {
      currTokType.CATEGORIES = [currTokType.CATEGORIES];
    }

    if (!hasCategoriesProperty(currTokType)) {
      currTokType.CATEGORIES = [];
    }

    if (!hasExtendingTokensTypesProperty(currTokType)) {
      currTokType.categoryMatches = [];
    }

    if (!hasExtendingTokensTypesMapProperty(currTokType)) {
      currTokType.categoryMatchesMap = {};
    }
  });
}

exports.assignTokenDefaultProps = assignTokenDefaultProps;

function assignCategoriesTokensProp(tokenTypes) {
  (0, forEach_1["default"])(tokenTypes, function (currTokType) {
    // avoid duplications
    currTokType.categoryMatches = [];
    (0, forEach_1["default"])(currTokType.categoryMatchesMap, function (val, key) {
      currTokType.categoryMatches.push(exports.tokenIdxToClass[key].tokenTypeIdx);
    });
  });
}

exports.assignCategoriesTokensProp = assignCategoriesTokensProp;

function assignCategoriesMapProp(tokenTypes) {
  (0, forEach_1["default"])(tokenTypes, function (currTokType) {
    singleAssignCategoriesToksMap([], currTokType);
  });
}

exports.assignCategoriesMapProp = assignCategoriesMapProp;

function singleAssignCategoriesToksMap(path, nextNode) {
  (0, forEach_1["default"])(path, function (pathNode) {
    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
  });
  (0, forEach_1["default"])(nextNode.CATEGORIES, function (nextCategory) {
    var newPath = path.concat(nextNode); // avoids infinite loops due to cyclic categories.

    if (!(0, includes_1["default"])(newPath, nextCategory)) {
      singleAssignCategoriesToksMap(newPath, nextCategory);
    }
  });
}

exports.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;

function hasShortKeyProperty(tokType) {
  return (0, has_1["default"])(tokType, "tokenTypeIdx");
}

exports.hasShortKeyProperty = hasShortKeyProperty;

function hasCategoriesProperty(tokType) {
  return (0, has_1["default"])(tokType, "CATEGORIES");
}

exports.hasCategoriesProperty = hasCategoriesProperty;

function hasExtendingTokensTypesProperty(tokType) {
  return (0, has_1["default"])(tokType, "categoryMatches");
}

exports.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;

function hasExtendingTokensTypesMapProperty(tokType) {
  return (0, has_1["default"])(tokType, "categoryMatchesMap");
}

exports.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;

function isTokenType(tokType) {
  return (0, has_1["default"])(tokType, "tokenTypeIdx");
}

exports.isTokenType = isTokenType;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormulaInserter = void 0;

var _decorator = __webpack_require__(1);

var CodeMirror = _interopRequireWildcard(__webpack_require__(302));

var _formula = __webpack_require__(45);

var _dec, _class, _class2;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var paramRegex = /(\$[{][^}]*[}])/;
var FormulaInserter = (_dec = (0, _decorator.shortcut)(), _dec(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(FormulaInserter, _BI$Widget);

  function FormulaInserter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "formulaEditor", void 0);

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: {
        formula: ""
      }
    });

    return _this;
  }

  var _proto = FormulaInserter.prototype;

  _proto.getToolbarLayout = function getToolbarLayout() {
    return {
      type: BI.Layout.xtype
    };
  };

  _proto.render = function render() {
    var _this2 = this;

    return {
      type: BI.VTapeLayout.xtype,
      items: [{
        el: {
          type: BI.FormulaEditor.xtype,
          cls: "bi-border",
          ref: function ref(_ref) {
            _this2.formulaEditor = _ref;
          },
          watermark: BI.i18nText("BI-Basic_Formula_Watermark"),
          listeners: [{
            eventName: BI.FormulaEditor.EVENT_CHANGE,
            action: function action() {
              _this2.validate();
            }
          }, {
            eventName: "EVENT_SHOW_HINT",
            action: function action(list) {
              _this2.fireEvent("EVENT_SHOW_HINT", BI.first(list));
            }
          }, {
            eventName: "EVENT_SELECT_HINT",
            action: function action(hint) {
              _this2.fireEvent("EVENT_SELECT_HINT", hint);
            }
          }]
        },
        height: 155
      }, this.getToolbarLayout()]
    };
  };

  _proto.mounted = function mounted() {
    this.setValue(this.options.value.formula);
  }
  /**
   * 插入function
   * @param val function值
   */
  ;

  _proto.insertFunction = function insertFunction(val) {
    this.formulaEditor.insertFunction(val);
  }
  /**
   * 插入字段
   * @param val 字段值
   */
  ;

  _proto.insertField = function insertField(val) {
    this.formulaEditor.insertField(val, true);
  };

  _proto.getValue = function getValue() {
    return {
      formula: this.formulaEditor.getValue()
    };
  }
  /**
   * 校验
   */
  ;

  _proto.validate = function validate() {
    var val = this.formulaEditor.getValue();

    if (val === "") {
      this.formulaEditor.hideTip();
      return;
    }

    this.fireEvent("EVENT_VALIDATE");
  };

  _proto.setValidation = function setValidation(data) {
    data.validation ? this.formulaEditor.hideTip() : this.formulaEditor.showTip(BI.i18nText("BI-Basic_Formula_Invalid"));
  };

  _proto.setValue = function setValue(value) {
    this.formulaEditor.refresh();
    this.formulaEditor.setValue("");
    this.insertFormula(value);
    this.validate();
  }
  /**
   * 分割字符串
   * @param v 字符串
   */
  ;

  _proto.analyzeContent = function analyzeContent(v) {
    // \w*\w 这是干啥呢, 至少匹配一次\w ? 那可以用\w+
    var regx = /\$[{][^}]*[}]|\w+|\$\{[^$()+\-*/)$,]*\w\}|\$\{[^$()+\-*/]*\w\}|\$\{[^$()+\-*/]*[\u4e00-\u9fa5]\}|\w|(.)|\n/g;
    return v.match(regx);
  }
  /**
   * 参数转译为显示值
   * @param v 实际值
   */
  ;

  _proto.paramFormatter = function paramFormatter(v) {
    return (0, _formula.getVarDisplayNameByValue)(v);
  }
  /**
   * 插入公式
   * @param value 公式值
   * @param position 位置
   */
  ;

  _proto.insertFormula = function insertFormula() {
    var _this3 = this;

    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var result = this.analyzeContent(value) || [];
    var fieldArray = [],
        functionArray = [];
    var lineNum = 0,
        offset = 0,
        valueString = "";

    if (BI.isNotNull(position)) {
      lineNum = position.line;
      offset = position.ch;
    }

    var wrapChar = this.formulaEditor.getParamWrap();
    result.forEach(function (str) {
      if (paramRegex.test(str)) {
        // 是函数
        var fieldId = str.substring(2, str.length - 1);

        var formattedParam = _this3.paramFormatter(fieldId);

        var fieldName = wrapChar + formattedParam.replaceAll("^<!.*!>$", function (str) {
          return str.substring(2, str.length - 2);
        }) + wrapChar;
        var fromPos = CodeMirror.Pos(lineNum, offset);
        valueString += fieldName;
        offset += fieldName.length;
        var endPos = CodeMirror.Pos(lineNum, offset);
        fieldArray.push({
          from: fromPos,
          to: endPos,
          value: fieldId,
          invalid: /^<!.*!>$/.test(formattedParam),
          text: fieldName
        });
      } else {
        if (BI.isNotNull((0, _formula.isBelong2FormulaFunction)(str))) {
          var _fromPos = CodeMirror.Pos(lineNum, offset);

          var _endPos = CodeMirror.Pos(lineNum, offset + str.length);

          functionArray.push({
            from: _fromPos,
            to: _endPos,
            value: str
          });
        }

        if (str === "\n") {
          lineNum++;
          offset = 0;
        }

        valueString += str;
        str !== "\n" && (offset += str.length);
      }
    });
    this.formulaEditor.insertString(valueString);
    BI.each(fieldArray, function (_idx, field) {
      _this3.formulaEditor.markField(field);
    });
    BI.each(functionArray, function (_idx, field) {
      _this3.formulaEditor.markFunction(field);
    });
  };

  return FormulaInserter;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.formula_operating_panel.inserter"), _class2)) || _class);
exports.FormulaInserter = FormulaInserter;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(20),
    isObject = __webpack_require__(11);
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(57);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assignValue = __webpack_require__(58),
    baseAssignValue = __webpack_require__(88);
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFastProperties = exports.timer = exports.PRINT_ERROR = exports.PRINT_WARNING = void 0;

var print_1 = __webpack_require__(472);

Object.defineProperty(exports, "PRINT_WARNING", {
  enumerable: true,
  get: function get() {
    return print_1.PRINT_WARNING;
  }
});
Object.defineProperty(exports, "PRINT_ERROR", {
  enumerable: true,
  get: function get() {
    return print_1.PRINT_ERROR;
  }
});

var timer_1 = __webpack_require__(473);

Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function get() {
    return timer_1.timer;
  }
});

var to_fast_properties_1 = __webpack_require__(474);

Object.defineProperty(exports, "toFastProperties", {
  enumerable: true,
  get: function get() {
    return to_fast_properties_1.toFastProperties;
  }
});

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toFinite = __webpack_require__(476);
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */


function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}

module.exports = toInteger;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(20),
    isArray = __webpack_require__(0),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

module.exports = isString;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(500);

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EarlyExitException = exports.NotAllInputParsedException = exports.NoViableAltException = exports.MismatchedTokenException = exports.isRecognitionException = void 0;

var includes_1 = __importDefault(__webpack_require__(18));

var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
var EARLY_EXIT_EXCEPTION = "EarlyExitException";
var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
var RECOGNITION_EXCEPTION_NAMES = [MISMATCHED_TOKEN_EXCEPTION, NO_VIABLE_ALT_EXCEPTION, EARLY_EXIT_EXCEPTION, NOT_ALL_INPUT_PARSED_EXCEPTION];
Object.freeze(RECOGNITION_EXCEPTION_NAMES); // hacks to bypass no support for custom Errors in javascript/typescript

function isRecognitionException(error) {
  // can't do instanceof on hacked custom js exceptions
  return (0, includes_1["default"])(RECOGNITION_EXCEPTION_NAMES, error.name);
}

exports.isRecognitionException = isRecognitionException;

var RecognitionException =
/** @class */
function (_super) {
  __extends(RecognitionException, _super);

  function RecognitionException(message, token) {
    var _newTarget = this.constructor;

    var _this = _super.call(this, message) || this;

    _this.token = token;
    _this.resyncedTokens = []; // fix prototype chain when typescript target is ES5

    Object.setPrototypeOf(_this, _newTarget.prototype);
    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, _this.constructor);
    }

    return _this;
  }

  return RecognitionException;
}(Error);

var MismatchedTokenException =
/** @class */
function (_super) {
  __extends(MismatchedTokenException, _super);

  function MismatchedTokenException(message, token, previousToken) {
    var _this = _super.call(this, message, token) || this;

    _this.previousToken = previousToken;
    _this.name = MISMATCHED_TOKEN_EXCEPTION;
    return _this;
  }

  return MismatchedTokenException;
}(RecognitionException);

exports.MismatchedTokenException = MismatchedTokenException;

var NoViableAltException =
/** @class */
function (_super) {
  __extends(NoViableAltException, _super);

  function NoViableAltException(message, token, previousToken) {
    var _this = _super.call(this, message, token) || this;

    _this.previousToken = previousToken;
    _this.name = NO_VIABLE_ALT_EXCEPTION;
    return _this;
  }

  return NoViableAltException;
}(RecognitionException);

exports.NoViableAltException = NoViableAltException;

var NotAllInputParsedException =
/** @class */
function (_super) {
  __extends(NotAllInputParsedException, _super);

  function NotAllInputParsedException(message, token) {
    var _this = _super.call(this, message, token) || this;

    _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
    return _this;
  }

  return NotAllInputParsedException;
}(RecognitionException);

exports.NotAllInputParsedException = NotAllInputParsedException;

var EarlyExitException =
/** @class */
function (_super) {
  __extends(EarlyExitException, _super);

  function EarlyExitException(message, token, previousToken) {
    var _this = _super.call(this, message, token) || this;

    _this.previousToken = previousToken;
    _this.name = EARLY_EXIT_EXCEPTION;
    return _this;
  }

  return EarlyExitException;
}(RecognitionException);

exports.EarlyExitException = EarlyExitException;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_CONFIG = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @author guy
 * @version 2.0
 * Created by guy on 2022/9/25
 */
var DEFAULT_CONFIG = {
  type: "bi.pure_text",
  lineHeight: 30,
  textAlign: "left",
  whiteSpace: "normal",
  expandIcon: "expander-down-font",
  collapseIcon: "expander-right-font",
  sortableIcon: "text-align-center-font"
};
exports.DEFAULT_CONFIG = DEFAULT_CONFIG;
var StickyTableRow = BI.inherit(BI.Widget, {
  props: {
    baseCls: 'bi-sticky-table-row',
    tagName: "tr",
    id: "",
    dimension: DEFAULT_CONFIG,
    layer: 0,
    columnSize: [],
    minColumnSize: [],
    maxColumnSize: [],
    freezeCols: [],
    items: [],
    draggable: true,
    checkable: true,
    checked: false,
    half: false,
    prevComponent: null
  },
  render: function render() {
    var _this = this;

    return {
      type: 'bi.adaptive',
      cls: this.options.draggable ? "enabled" : "",
      ref: function ref(_ref) {
        _this.layout = _ref;
      },
      items: this.getItems()
    };
  },
  getItems: function getItems() {
    var _this2 = this;

    var self = this,
        o = this.options;

    var dimension = _objectSpread(_objectSpread({}, DEFAULT_CONFIG), o.dimension);

    this.text = BI.createWidget(dimension);
    return [{
      type: "bi.adaptive",
      tagName: "td",
      cls: "".concat(o.freezeCols.includes(0) ? "sticky-table-fix-first-col" : "", " first-col"),
      items: [{
        type: "bi.vertical_adapt",
        css: {
          minWidth: o.minColumnSize[0],
          maxWidth: o.maxColumnSize[0]
        },
        items: [o.prevComponent, o.draggable ? {
          type: "bi.icon_label",
          extraCls: "bi-sticky-table-draggable-handler",
          cls: dimension.sortableIcon,
          width: 30,
          height: 30
        } : null, o.isParent ? {
          _lgap: o.layer * 30,
          type: "bi.icon_change_button",
          ref: function ref(_ref) {
            _this2.arrow = _ref;
          },
          handler: function handler() {
            _this2.fireEvent(BI.Controller.EVENT_CHANGE, o.open ? BI.Events.COLLAPSE : BI.Events.EXPAND);
          },
          iconCls: this._getExpandIcon(),
          width: 30,
          height: 30
        } : null, o.checkable ? {
          _lgap: !o.isParent ? (o.layer + 0.5) * 30 : 0,
          type: "bi.multi_select_bar",
          ref: function ref(_ref) {
            _this2.checkbox = _ref;
          },
          selected: o.checked,
          halfSelected: o.half,
          width: 30,
          iconWrapperWidth: 30,
          height: 30,
          text: "",
          listeners: _defineProperty({}, BI.MultiSelectBar.EVENT_CHANGE, function (v) {
            self.fireEvent(BI.Controller.EVENT_CHANGE, BI.Events.CHANGE, v);
          })
        } : null, {
          _lgap: !o.checkable && !o.isParent ? o.layer * 30 : 0,
          width: "fill",
          el: this.text
        }]
      }]
    }].concat(BI.map(o.items, function (i, item) {
      var isFirstCols = o.freezeCols.includes(i + 1) && i < o.items.length - 1;
      var isLastCols = o.freezeCols.includes(i + 1) && i === o.items.length - 1;
      return {
        type: "bi.adaptive",
        extraCls: isLastCols ? "sticky-table-fix-last-col" : isFirstCols ? "sticky-table-fix-first-col" : "",
        cls: "sticky-table-fix-index-".concat(i + 1, "-col"),
        css: {
          // left: isFirstCols ? o.columnSize.slice(0, i + 1).reduce((item, sum) => sum + item, 0) : "",
          minWidth: o.minColumnSize[i + 1],
          maxWidth: o.maxColumnSize[i + 1]
        },
        tagName: "td",
        items: [_objectSpread(_objectSpread({}, DEFAULT_CONFIG), item)]
      };
    }));
  },
  _getExpandIcon: function _getExpandIcon() {
    var self = this,
        o = this.options;
    var dimension = BI.extend({}, DEFAULT_CONFIG, o.dimension);
    return o.open ? dimension.expandIcon : dimension.collapseIcon;
  },
  doRedMark: function doRedMark() {
    this.text.doRedMark.apply(this.text, arguments);
  },
  unRedMark: function unRedMark() {
    this.text.unRedMark.apply(this.text, arguments);
  },
  shouldUpdate: function shouldUpdate(opt) {
    var o = this.options;
    var keys = ["open", "layer", "pId", "id", "dimension", "items", "draggable", "prevComponent", "columnSize", "checked", "half", "cls"];
    return BI.some(keys, function (idx, key) {
      return opt[key] !== o[key];
    });
  },
  update: function update(opt) {
    var o = this.options;

    if (opt.prevComponent !== o.prevComponent) {
      o.prevComponent = opt.prevComponent;
    }

    if (opt.cls !== o.cls) {
      this.element.removeClass(o.cls).addClass(opt.cls);
      o.cls = opt.cls;
    }

    if (BI.isNotNull(opt.draggable) && opt.draggable !== o.draggable) {
      this.element[opt.draggable ? "addClass" : "removeClass"]("enabled");
    }

    if (opt.dimension !== o.dimension) {
      this.text.setText(opt.dimension.text || opt.dimension.value);
      o.dimension = opt.dimension;
    }

    if (opt.open !== o.open) {
      o.open = opt.open;
      this.arrow && this.arrow.setIcon(this._getExpandIcon());
    }

    if (opt.items !== o.items || BI.isNotNull(opt.draggable) && opt.draggable !== o.draggable) {
      o.items = opt.items;
      o.draggable = opt.draggable;
      this.layout.populate(this.getItems());
    }

    if (opt.checked !== o.checked || opt.half !== o.half) {
      o.checked = opt.checked;
      o.half = opt.half;
      this.checkbox && this.checkbox.setSelected(o.checked);
      this.checkbox && this.checkbox.setHalfSelected(o.half);
    }
  }
});
BI.shortcut("bi.sticky_table_row", StickyTableRow);

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.token = exports.allTokens = void 0;

var _chevrotain = __webpack_require__(47);

// Token 分组
var Unary = (0, _chevrotain.createToken)({
  name: "Unary",
  pattern: _chevrotain.Lexer.NA
});
var Addition = (0, _chevrotain.createToken)({
  name: "Addition",
  pattern: _chevrotain.Lexer.NA
});
var Multiplication = (0, _chevrotain.createToken)({
  name: "Multiplication",
  pattern: _chevrotain.Lexer.NA
});
var Equal = (0, _chevrotain.createToken)({
  name: "Equal",
  pattern: _chevrotain.Lexer.NA
});
var Compare = (0, _chevrotain.createToken)({
  name: "Compare",
  pattern: _chevrotain.Lexer.NA
});
var token = {
  WhiteSpace: (0, _chevrotain.createToken)({
    name: "WhiteSpace",
    pattern: /\s+/,
    group: _chevrotain.Lexer.SKIPPED
  }),
  // 基本类型
  String: (0, _chevrotain.createToken)({
    name: "String",
    pattern: /("(\\\\|\\"|[^"])*"|'(\\\\|\\'|[^'])*')/
  }),
  Number: (0, _chevrotain.createToken)({
    name: "Number",
    pattern: /[0-9]+(\.[0-9]+)?(e[+-]?[0-9]+)?/i
  }),
  Date: (0, _chevrotain.createToken)({
    name: "Date",
    pattern: /("bi-date-place-holder"|'bi-date-place-holder')/
  }),
  Boolean: (0, _chevrotain.createToken)({
    name: "Boolean",
    pattern: /(true|false)/i
  }),
  Empty: (0, _chevrotain.createToken)({
    name: "Empty",
    pattern: /(null|undefined)/i
  }),
  NaN: (0, _chevrotain.createToken)({
    name: "NaN",
    pattern: /NaN/
  }),
  // 运算符
  Comma: (0, _chevrotain.createToken)({
    name: "Comma",
    pattern: /,/
  }),
  Func: (0, _chevrotain.createToken)({
    name: "Func",
    pattern: /[A-Za-z0-9_.]+/
  }),
  LParen: (0, _chevrotain.createToken)({
    name: "LParen",
    pattern: /\(/
  }),
  RParen: (0, _chevrotain.createToken)({
    name: "RParen",
    pattern: /\)/
  }),
  LSquare: (0, _chevrotain.createToken)({
    name: "LSquare",
    pattern: /\[/
  }),
  RSquare: (0, _chevrotain.createToken)({
    name: "RSquare",
    pattern: /]/
  }),
  Plus: (0, _chevrotain.createToken)({
    name: "Plus",
    pattern: /\+(?!\+)/,
    categories: [Unary, Addition]
  }),
  Minus: (0, _chevrotain.createToken)({
    name: "Minus",
    pattern: /-(?!-)/,
    categories: [Unary, Addition]
  }),
  Unary: Unary,
  Addition: Addition,
  Multi: (0, _chevrotain.createToken)({
    name: "Multi",
    pattern: /\*/,
    categories: [Multiplication]
  }),
  Div: (0, _chevrotain.createToken)({
    name: "Div",
    pattern: /\//,
    categories: [Multiplication]
  }),
  Multiplication: Multiplication,
  LessOrEqual: (0, _chevrotain.createToken)({
    name: "LessOrEqual",
    pattern: /<=/,
    categories: [Compare]
  }),
  GreaterOrEqual: (0, _chevrotain.createToken)({
    name: "GreaterOrEqual",
    pattern: />=/,
    categories: [Compare]
  }),
  Less: (0, _chevrotain.createToken)({
    name: "Less",
    pattern: /</,
    categories: [Compare]
  }),
  Greater: (0, _chevrotain.createToken)({
    name: "Greater",
    pattern: />/,
    categories: [Compare]
  }),
  Compare: Compare,
  NotEqualStrict: (0, _chevrotain.createToken)({
    name: "NotEqualStrict",
    pattern: /!==/,
    categories: [Equal]
  }),
  EqualLoose: (0, _chevrotain.createToken)({
    name: "EqualLoose",
    pattern: /==/,
    categories: [Equal]
  }),
  NotEqualLoose: (0, _chevrotain.createToken)({
    name: "NotEqualLoose",
    pattern: /!=/,
    categories: [Equal]
  }),
  Equal: Equal,
  EqualStrict: (0, _chevrotain.createToken)({
    name: "EqualStrict",
    pattern: /=/,
    categories: [Equal]
  }),
  LogicNot: (0, _chevrotain.createToken)({
    name: "LogicNot",
    pattern: /!/,
    categories: [Unary]
  }),
  LogicAnd: (0, _chevrotain.createToken)({
    name: "LogicAnd",
    pattern: /&&/
  }),
  LogicOr: (0, _chevrotain.createToken)({
    name: "LogicOr",
    pattern: /\|\|/
  }),
  BitAnd: (0, _chevrotain.createToken)({
    name: "BitAnd",
    pattern: /&/
  }) // BitAnd: createToken({ name: "BitAnd", pattern: /&/ }),
  // BitOr: createToken({ name: "BitOr", pattern: /\|/ })

};
exports.token = token;
var allTokens = [token.WhiteSpace, token.Date, token.String, token.Number, token.NaN, token.Boolean, token.Empty, token.Func, token.LParen, token.RParen, token.LSquare, token.RSquare, token.Plus, token.Minus, token.Addition, token.Unary, token.Multi, token.Div, token.Multiplication, token.LessOrEqual, token.GreaterOrEqual, token.Less, token.Greater, token.Compare, token.NotEqualStrict, token.EqualLoose, token.NotEqualLoose, token.Equal, token.EqualStrict, token.LogicNot, token.LogicAnd, token.LogicOr, token.BitAnd, // token.BitOr,
token.Comma];
exports.allTokens = allTokens;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFunctionDescriptionByFunctionName = getFunctionDescriptionByFunctionName;
exports.getFunctionTypeByFunctionName = getFunctionTypeByFunctionName;
exports.getSearchedFunctionNames = getSearchedFunctionNames;
exports.getVarDescriptionByVarName = getVarDescriptionByVarName;
exports.getVarDisplayNameByValue = getVarDisplayNameByValue;
exports.isBelong2FormulaFunction = isBelong2FormulaFunction;
exports.isFormulaConfigCached = isFormulaConfigCached;
exports.setFormulaConfigCache = setFormulaConfigCache;
exports.transformFormulaJSONs2FunctionNames = transformFormulaJSONs2FunctionNames;
exports.transformFormulaJSONs2FunctionTypes = transformFormulaJSONs2FunctionTypes;
exports.transformFormulaVarItems = transformFormulaVarItems;

var _item = __webpack_require__(303);

var _formula = __webpack_require__(46);

var _item2 = __webpack_require__(304);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var isCached = false;
var formulaVarItemsCache = [];
var formulaJSONs = [];
/**
 * 查看是否已经缓存
 */

function isFormulaConfigCached() {
  return isCached;
}
/**
 * 获取公式参数显示值
 * @param v 参数实际值
 */


function getVarDisplayNameByValue(v) {
  var varItem = formulaVarItemsCache.find(function (varItem) {
    return varItem.value === v;
  });
  return varItem ? varItem.text : "undefined";
}
/**
 * 缓存配置
 * @param config 所需配置信息
 */


function setFormulaConfigCache(config) {
  isCached = true;
  formulaVarItemsCache = config.vars;
  BI.FormulaJSONs = config.JSONs;
  BI.FormulaCollections = config.JSONs.reduce(function (result, json) {
    result.push(json.name.toLowerCase(), json.name.toUpperCase());
    return result;
  }, []);
  formulaJSONs = config.JSONs;
}
/**
 * 获取所有FunctionTypes
 */


function transformFormulaJSONs2FunctionTypes() {
  return Object.keys(formulaJSONs.reduce(function (resultMap, formulaJSON) {
    if (!(formulaJSON.type in resultMap)) {
      resultMap[formulaJSON.type] = [];
    }

    return resultMap;
  }, {})).map(function (type) {
    return {
      text: type,
      title: type,
      value: type,
      cls: "bi-list-item-select",
      textAlign: "left",
      height: 20,
      hgap: 5
    };
  });
}
/**
 * 获取所有FunctionNames
 * @param functionType 方法类型
 */


function transformFormulaJSONs2FunctionNames(functionType) {
  return Object.keys(formulaJSONs.reduce(function (resultMap, formulaJSON) {
    if (!(formulaJSON.name in resultMap) && (!functionType || formulaJSON.type === functionType)) {
      resultMap[formulaJSON.name] = [];
    }

    return resultMap;
  }, {})).map(function (type) {
    return {
      type: _item.FormulaFunctionItem.xtype,
      text: type,
      title: type,
      value: type,
      height: 20
    };
  });
}
/**
 * 根据方法名获取方法类型
 * @param functionName 方法名
 */


function getFunctionTypeByFunctionName(functionName) {
  var formulaJSON = formulaJSONs.find(function (formulaJSON) {
    return formulaJSON.name === functionName;
  });

  if (BI.isNotNull(formulaJSON)) {
    return formulaJSON.type;
  }

  return null;
}
/**
 * 根据方法名获取方法类型
 * @param functionName 方法名
 */


function getFunctionDescriptionByFunctionName(functionName) {
  var formulaJSON = formulaJSONs.find(function (formulaJSON) {
    return formulaJSON.name === functionName;
  });
  return BI.isNotNull(formulaJSON) ? formulaJSON.def : "";
}
/**
 * 根据关键字搜索functionNames
 * @param keyword 关键字
 */


function getSearchedFunctionNames(keyword) {
  if (keyword === "") {
    return [];
  }

  var _BI$Func$getSearchRes = BI.Func.getSearchResult(transformFormulaJSONs2FunctionNames(), keyword, "val"),
      match = _BI$Func$getSearchRes.match,
      find = _BI$Func$getSearchRes.find;

  match.sort(function (a, b) {
    return a.value > b.value ? 1 : -1;
  });
  find.sort(function (a, b) {
    return a.value > b.value ? 1 : -1;
  });
  return [].concat(_toConsumableArray(match), _toConsumableArray(find));
}
/**
 * 获取公式框变量结构
 */


function transformFormulaVarItems() {
  if (!isCached) {
    return [];
  }

  var nodeLeavesMap = {},
      height = 25;
  var leaves = formulaVarItemsCache;
  leaves.forEach(function (leaf) {
    if (leaf.type in nodeLeavesMap) {
      nodeLeavesMap[leaf.type].push(leaf);
    } else {
      nodeLeavesMap[leaf.type] = [leaf];
    }
  });

  var items = _formula.FORMULA_VAR_NODES.map(function (node) {
    var size = BI.size(nodeLeavesMap[node.value]);
    return _objectSpread(_objectSpread({}, node), {}, {
      open: true,
      height: height,
      text: BI.i18nText(node.i18nText) + (size > 0 ? " - [".concat(size, "]") : "")
    });
  });

  Object.keys(nodeLeavesMap).forEach(function (nodeType) {
    var node = _formula.FORMULA_VAR_NODES.find(function (node) {
      return node.value === nodeType;
    });

    if (!node) {
      return;
    }

    var pId = node.id,
        nodeLeaves = nodeLeavesMap[nodeType],
        size = BI.size(nodeLeaves);
    items.push.apply(items, _toConsumableArray(nodeLeaves.map(function (leaf, index) {
      return {
        pId: pId,
        id: BI.UUID(),
        text: leaf.text,
        value: leaf.value,
        lgap: 16,
        layoutType: index === size - 1 ? BI.LastTreeLeafItem.xtype : BI.MidTreeLeafItem.xtype,
        type: _item2.FormulaVarItem.xtype,
        height: height
      };
    })));
  });
  return items;
}
/**
 * 根据变量名获取方法类型
 * @param varName 变量名
 */


function getVarDescriptionByVarName(varName) {
  var formulaVarItem = formulaVarItemsCache.find(function (formulaVarItem) {
    return formulaVarItem.value === varName;
  });
  return BI.isNotNull(formulaVarItem) ? formulaVarItem.def : "";
}
/**
 * 检查字符串是否是公式方法名
 * @param str 字符串
 */


function isBelong2FormulaFunction(str) {
  return transformFormulaJSONs2FunctionNames().find(function (item) {
    return item.text.toLowerCase() === str.toLowerCase();
  });
}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FORMULA_VAR_TYPES = exports.FORMULA_VAR_NODES = exports.DEFAULT_FUNCTION_TYPE = exports.DEFAULT_FUNCTION_NAME = void 0;
var DEFAULT_FUNCTION_NAME = "ABS";
exports.DEFAULT_FUNCTION_NAME = DEFAULT_FUNCTION_NAME;
var DEFAULT_FUNCTION_TYPE = "MATH";
exports.DEFAULT_FUNCTION_TYPE = DEFAULT_FUNCTION_TYPE;
var FORMULA_VAR_TYPES = {
  DATA_ITEMS: "DATA_ITEMS",
  VARS: "VARS",
  DATA_SET_VARS: "DATA_SET_VARS",
  REPORT_VARS: "REPORT_VARS",
  GLOBAL_VARS: "GLOBAL_VARS"
};
exports.FORMULA_VAR_TYPES = FORMULA_VAR_TYPES;
var FORMULA_VAR_NODES = [{
  id: "1",
  pId: "-1",
  i18nText: "BI-Basic_Formula_Data_Items",
  value: FORMULA_VAR_TYPES.DATA_ITEMS,
  type: BI.IconArrowNode.xtype,
  iconCls: "search-font"
}, {
  id: "2",
  pId: "-1",
  i18nText: "BI-Basic_Formula_Vars",
  value: FORMULA_VAR_TYPES.VARS,
  type: BI.IconArrowNode.xtype,
  iconCls: "search-font"
}, {
  id: "3",
  pId: "-1",
  i18nText: "BI-Basic_Formula_Data_Set_Vars",
  value: FORMULA_VAR_TYPES.DATA_SET_VARS,
  type: BI.IconArrowNode.xtype,
  iconCls: "search-font"
}, {
  id: "4",
  pId: "-1",
  i18nText: "BI-Basic_Formula_Report_Vars",
  value: FORMULA_VAR_TYPES.REPORT_VARS,
  type: BI.IconArrowNode.xtype,
  iconCls: "search-font"
}, {
  id: "5",
  pId: "-1",
  i18nText: "BI-Basic_Formula_Global_Vars",
  value: FORMULA_VAR_TYPES.GLOBAL_VARS,
  type: BI.IconArrowNode.xtype,
  iconCls: "search-font"
}];
exports.FORMULA_VAR_NODES = FORMULA_VAR_NODES;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* istanbul ignore file - tricky to import some things from this module during testing */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = exports.createSyntaxDiagramsCode = exports.clearCache = exports.generateCstDts = exports.GAstVisitor = exports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Rule = exports.RepetitionWithSeparator = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Repetition = exports.Option = exports.NonTerminal = exports.Alternative = exports.Alternation = exports.defaultLexerErrorProvider = exports.NoViableAltException = exports.NotAllInputParsedException = exports.MismatchedTokenException = exports.isRecognitionException = exports.EarlyExitException = exports.defaultParserErrorProvider = exports.tokenName = exports.tokenMatcher = exports.tokenLabel = exports.EOF = exports.createTokenInstance = exports.createToken = exports.LexerDefinitionErrorType = exports.Lexer = exports.EMPTY_ALT = exports.ParserDefinitionErrorType = exports.EmbeddedActionsParser = exports.CstParser = exports.VERSION = void 0; // semantic version

var version_1 = __webpack_require__(208);

Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function get() {
    return version_1.VERSION;
  }
});

var parser_1 = __webpack_require__(6);

Object.defineProperty(exports, "CstParser", {
  enumerable: true,
  get: function get() {
    return parser_1.CstParser;
  }
});
Object.defineProperty(exports, "EmbeddedActionsParser", {
  enumerable: true,
  get: function get() {
    return parser_1.EmbeddedActionsParser;
  }
});
Object.defineProperty(exports, "ParserDefinitionErrorType", {
  enumerable: true,
  get: function get() {
    return parser_1.ParserDefinitionErrorType;
  }
});
Object.defineProperty(exports, "EMPTY_ALT", {
  enumerable: true,
  get: function get() {
    return parser_1.EMPTY_ALT;
  }
});

var lexer_public_1 = __webpack_require__(63);

Object.defineProperty(exports, "Lexer", {
  enumerable: true,
  get: function get() {
    return lexer_public_1.Lexer;
  }
});
Object.defineProperty(exports, "LexerDefinitionErrorType", {
  enumerable: true,
  get: function get() {
    return lexer_public_1.LexerDefinitionErrorType;
  }
}); // Tokens utilities

var tokens_public_1 = __webpack_require__(26);

Object.defineProperty(exports, "createToken", {
  enumerable: true,
  get: function get() {
    return tokens_public_1.createToken;
  }
});
Object.defineProperty(exports, "createTokenInstance", {
  enumerable: true,
  get: function get() {
    return tokens_public_1.createTokenInstance;
  }
});
Object.defineProperty(exports, "EOF", {
  enumerable: true,
  get: function get() {
    return tokens_public_1.EOF;
  }
});
Object.defineProperty(exports, "tokenLabel", {
  enumerable: true,
  get: function get() {
    return tokens_public_1.tokenLabel;
  }
});
Object.defineProperty(exports, "tokenMatcher", {
  enumerable: true,
  get: function get() {
    return tokens_public_1.tokenMatcher;
  }
});
Object.defineProperty(exports, "tokenName", {
  enumerable: true,
  get: function get() {
    return tokens_public_1.tokenName;
  }
}); // Other Utilities

var errors_public_1 = __webpack_require__(65);

Object.defineProperty(exports, "defaultParserErrorProvider", {
  enumerable: true,
  get: function get() {
    return errors_public_1.defaultParserErrorProvider;
  }
});

var exceptions_public_1 = __webpack_require__(41);

Object.defineProperty(exports, "EarlyExitException", {
  enumerable: true,
  get: function get() {
    return exceptions_public_1.EarlyExitException;
  }
});
Object.defineProperty(exports, "isRecognitionException", {
  enumerable: true,
  get: function get() {
    return exceptions_public_1.isRecognitionException;
  }
});
Object.defineProperty(exports, "MismatchedTokenException", {
  enumerable: true,
  get: function get() {
    return exceptions_public_1.MismatchedTokenException;
  }
});
Object.defineProperty(exports, "NotAllInputParsedException", {
  enumerable: true,
  get: function get() {
    return exceptions_public_1.NotAllInputParsedException;
  }
});
Object.defineProperty(exports, "NoViableAltException", {
  enumerable: true,
  get: function get() {
    return exceptions_public_1.NoViableAltException;
  }
});

var lexer_errors_public_1 = __webpack_require__(242);

Object.defineProperty(exports, "defaultLexerErrorProvider", {
  enumerable: true,
  get: function get() {
    return lexer_errors_public_1.defaultLexerErrorProvider;
  }
}); // grammar reflection API

var gast_1 = __webpack_require__(2);

Object.defineProperty(exports, "Alternation", {
  enumerable: true,
  get: function get() {
    return gast_1.Alternation;
  }
});
Object.defineProperty(exports, "Alternative", {
  enumerable: true,
  get: function get() {
    return gast_1.Alternative;
  }
});
Object.defineProperty(exports, "NonTerminal", {
  enumerable: true,
  get: function get() {
    return gast_1.NonTerminal;
  }
});
Object.defineProperty(exports, "Option", {
  enumerable: true,
  get: function get() {
    return gast_1.Option;
  }
});
Object.defineProperty(exports, "Repetition", {
  enumerable: true,
  get: function get() {
    return gast_1.Repetition;
  }
});
Object.defineProperty(exports, "RepetitionMandatory", {
  enumerable: true,
  get: function get() {
    return gast_1.RepetitionMandatory;
  }
});
Object.defineProperty(exports, "RepetitionMandatoryWithSeparator", {
  enumerable: true,
  get: function get() {
    return gast_1.RepetitionMandatoryWithSeparator;
  }
});
Object.defineProperty(exports, "RepetitionWithSeparator", {
  enumerable: true,
  get: function get() {
    return gast_1.RepetitionWithSeparator;
  }
});
Object.defineProperty(exports, "Rule", {
  enumerable: true,
  get: function get() {
    return gast_1.Rule;
  }
});
Object.defineProperty(exports, "Terminal", {
  enumerable: true,
  get: function get() {
    return gast_1.Terminal;
  }
}); // GAST Utilities

var gast_2 = __webpack_require__(2);

Object.defineProperty(exports, "serializeGrammar", {
  enumerable: true,
  get: function get() {
    return gast_2.serializeGrammar;
  }
});
Object.defineProperty(exports, "serializeProduction", {
  enumerable: true,
  get: function get() {
    return gast_2.serializeProduction;
  }
});
Object.defineProperty(exports, "GAstVisitor", {
  enumerable: true,
  get: function get() {
    return gast_2.GAstVisitor;
  }
});

var cst_dts_gen_1 = __webpack_require__(528);

Object.defineProperty(exports, "generateCstDts", {
  enumerable: true,
  get: function get() {
    return cst_dts_gen_1.generateCstDts;
  }
});
/* istanbul ignore next */

function clearCache() {
  console.warn("The clearCache function was 'soft' removed from the Chevrotain API." + "\n\t It performs no action other than printing this message." + "\n\t Please avoid using it as it will be completely removed in the future");
}

exports.clearCache = clearCache;

var render_public_1 = __webpack_require__(537);

Object.defineProperty(exports, "createSyntaxDiagramsCode", {
  enumerable: true,
  get: function get() {
    return render_public_1.createSyntaxDiagramsCode;
  }
});

var Parser =
/** @class */
function () {
  function Parser() {
    throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\t\n" + "See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
  }

  return Parser;
}();

exports.Parser = Parser;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsArguments = __webpack_require__(399),
    isObjectLike = __webpack_require__(12);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var root = __webpack_require__(10),
    stubFalse = __webpack_require__(400);
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(44)(module)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var freeGlobal = __webpack_require__(210);
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(44)(module)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var listCacheClear = __webpack_require__(404),
    listCacheDelete = __webpack_require__(405),
    listCacheGet = __webpack_require__(406),
    listCacheHas = __webpack_require__(407),
    listCacheSet = __webpack_require__(408);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var eq = __webpack_require__(33);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19);
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isKeyable = __webpack_require__(422);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__(0),
    isKey = __webpack_require__(87),
    stringToPath = __webpack_require__(435),
    toString = __webpack_require__(223);
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var baseGetTag = __webpack_require__(20),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseAssignValue = __webpack_require__(88),
    eq = __webpack_require__(33);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeKeys = __webpack_require__(220),
    baseKeysIn = __webpack_require__(454),
    isArrayLike = __webpack_require__(8);
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assignValue = __webpack_require__(58),
    copyObject = __webpack_require__(36),
    createAssigner = __webpack_require__(483),
    isArrayLike = __webpack_require__(8),
    isPrototype = __webpack_require__(29),
    keys = __webpack_require__(5);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */

var assign = createAssigner(function (object, source) {
  if (isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }

  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});
module.exports = assign;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var eq = __webpack_require__(33),
    isArrayLike = __webpack_require__(8),
    isIndex = __webpack_require__(55),
    isObject = __webpack_require__(11);
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */


function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayEvery = __webpack_require__(493),
    baseEvery = __webpack_require__(494),
    baseIteratee = __webpack_require__(13),
    isArray = __webpack_require__(0),
    isIterateeCall = __webpack_require__(61);
/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * **Note:** This method returns `true` for
 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty collections.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */


function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;

  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }

  return func(collection, baseIteratee(predicate, 3));
}

module.exports = every;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Lexer = exports.LexerDefinitionErrorType = void 0;

var lexer_1 = __webpack_require__(238);

var noop_1 = __importDefault(__webpack_require__(99));

var isEmpty_1 = __importDefault(__webpack_require__(9));

var isArray_1 = __importDefault(__webpack_require__(0));

var last_1 = __importDefault(__webpack_require__(106));

var reject_1 = __importDefault(__webpack_require__(101));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var keys_1 = __importDefault(__webpack_require__(5));

var isUndefined_1 = __importDefault(__webpack_require__(22));

var identity_1 = __importDefault(__webpack_require__(35));

var assign_1 = __importDefault(__webpack_require__(60));

var reduce_1 = __importDefault(__webpack_require__(23));

var clone_1 = __importDefault(__webpack_require__(17));

var utils_1 = __webpack_require__(37);

var tokens_1 = __webpack_require__(27);

var lexer_errors_public_1 = __webpack_require__(242);

var reg_exp_parser_1 = __webpack_require__(105);

var LexerDefinitionErrorType;

(function (LexerDefinitionErrorType) {
  LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
  LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
  LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
  LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
  LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
  LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
  LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
  LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
  LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
  LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
  LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
  LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
  LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
  LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
  LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
  LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
  LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
  LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
})(LexerDefinitionErrorType = exports.LexerDefinitionErrorType || (exports.LexerDefinitionErrorType = {}));

var DEFAULT_LEXER_CONFIG = {
  deferDefinitionErrorsHandling: false,
  positionTracking: "full",
  lineTerminatorsPattern: /\n|\r\n?/g,
  lineTerminatorCharacters: ["\n", "\r"],
  ensureOptimizations: false,
  safeMode: false,
  errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
  traceInitPerf: false,
  skipValidations: false,
  recoveryEnabled: true
};
Object.freeze(DEFAULT_LEXER_CONFIG);

var Lexer =
/** @class */
function () {
  function Lexer(lexerDefinition, config) {
    if (config === void 0) {
      config = DEFAULT_LEXER_CONFIG;
    }

    var _this = this;

    this.lexerDefinition = lexerDefinition;
    this.lexerDefinitionErrors = [];
    this.lexerDefinitionWarning = [];
    this.patternIdxToConfig = {};
    this.charCodeToPatternIdxToConfig = {};
    this.modes = [];
    this.emptyGroups = {};
    this.trackStartLines = true;
    this.trackEndLines = true;
    this.hasCustom = false;
    this.canModeBeOptimized = {}; // Duplicated from the parser's perf trace trait to allow future extraction
    // of the lexer to a separate package.

    this.TRACE_INIT = function (phaseDesc, phaseImpl) {
      // No need to optimize this using NOOP pattern because
      // It is not called in a hot spot...
      if (_this.traceInitPerf === true) {
        _this.traceInitIndent++;
        var indent = new Array(_this.traceInitIndent + 1).join("\t");

        if (_this.traceInitIndent < _this.traceInitMaxIdent) {
          console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
        }

        var _a = (0, utils_1.timer)(phaseImpl),
            time = _a.time,
            value = _a.value;
        /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */


        var traceMethod = time > 10 ? console.warn : console.log;

        if (_this.traceInitIndent < _this.traceInitMaxIdent) {
          traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
        }

        _this.traceInitIndent--;
        return value;
      } else {
        return phaseImpl();
      }
    };

    if (typeof config === "boolean") {
      throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\n" + "a boolean 2nd argument is no longer supported");
    } // todo: defaults func?


    this.config = (0, assign_1["default"])({}, DEFAULT_LEXER_CONFIG, config);
    var traceInitVal = this.config.traceInitPerf;

    if (traceInitVal === true) {
      this.traceInitMaxIdent = Infinity;
      this.traceInitPerf = true;
    } else if (typeof traceInitVal === "number") {
      this.traceInitMaxIdent = traceInitVal;
      this.traceInitPerf = true;
    }

    this.traceInitIndent = -1;
    this.TRACE_INIT("Lexer Constructor", function () {
      var actualDefinition;
      var hasOnlySingleMode = true;

      _this.TRACE_INIT("Lexer Config handling", function () {
        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
          // optimized built-in implementation for the defaults definition of lineTerminators
          _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
        } else {
          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
            throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n" + "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
          }
        }

        if (config.safeMode && config.ensureOptimizations) {
          throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
        }

        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
        _this.trackEndLines = /full/i.test(_this.config.positionTracking); // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.

        if ((0, isArray_1["default"])(lexerDefinition)) {
          actualDefinition = {
            modes: {
              defaultMode: (0, clone_1["default"])(lexerDefinition)
            },
            defaultMode: lexer_1.DEFAULT_MODE
          };
        } else {
          // no conversion needed, input should already be a IMultiModeLexerDefinition
          hasOnlySingleMode = false;
          actualDefinition = (0, clone_1["default"])(lexerDefinition);
        }
      });

      if (_this.config.skipValidations === false) {
        _this.TRACE_INIT("performRuntimeChecks", function () {
          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
        });

        _this.TRACE_INIT("performWarningRuntimeChecks", function () {
          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
        });
      } // for extra robustness to avoid throwing an none informative error message


      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}; // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.
      // this transformation is to increase robustness in the case of partially invalid lexer definition.

      (0, forEach_1["default"])(actualDefinition.modes, function (currModeValue, currModeName) {
        actualDefinition.modes[currModeName] = (0, reject_1["default"])(currModeValue, function (currTokType) {
          return (0, isUndefined_1["default"])(currTokType);
        });
      });
      var allModeNames = (0, keys_1["default"])(actualDefinition.modes);
      (0, forEach_1["default"])(actualDefinition.modes, function (currModDef, currModName) {
        _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function () {
          _this.modes.push(currModName);

          if (_this.config.skipValidations === false) {
            _this.TRACE_INIT("validatePatterns", function () {
              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
            });
          } // If definition errors were encountered, the analysis phase may fail unexpectedly/
          // Considering a lexer with definition errors may never be used, there is no point
          // to performing the analysis anyhow...


          if ((0, isEmpty_1["default"])(_this.lexerDefinitionErrors)) {
            (0, tokens_1.augmentTokenTypes)(currModDef);
            var currAnalyzeResult_1;

            _this.TRACE_INIT("analyzeTokenTypes", function () {
              currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                positionTracking: config.positionTracking,
                ensureOptimizations: config.ensureOptimizations,
                safeMode: config.safeMode,
                tracer: _this.TRACE_INIT
              });
            });

            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
            _this.emptyGroups = (0, assign_1["default"])({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
          }
        });
      });
      _this.defaultMode = actualDefinition.defaultMode;

      if (!(0, isEmpty_1["default"])(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
        var allErrMessages = (0, map_1["default"])(_this.lexerDefinitionErrors, function (error) {
          return error.message;
        });
        var allErrMessagesString = allErrMessages.join("-----------------------\n");
        throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
      } // Only print warning if there are no errors, This will avoid pl


      (0, forEach_1["default"])(_this.lexerDefinitionWarning, function (warningDescriptor) {
        (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
      });

      _this.TRACE_INIT("Choosing sub-methods implementations", function () {
        // Choose the relevant internal implementations for this specific parser.
        // These implementations should be in-lined by the JavaScript engine
        // to provide optimal performance in each scenario.
        if (lexer_1.SUPPORT_STICKY) {
          _this.chopInput = identity_1["default"];
          _this.match = _this.matchWithTest;
        } else {
          _this.updateLastIndex = noop_1["default"];
          _this.match = _this.matchWithExec;
        }

        if (hasOnlySingleMode) {
          _this.handleModes = noop_1["default"];
        }

        if (_this.trackStartLines === false) {
          _this.computeNewColumn = identity_1["default"];
        }

        if (_this.trackEndLines === false) {
          _this.updateTokenEndLineColumnLocation = noop_1["default"];
        }

        if (/full/i.test(_this.config.positionTracking)) {
          _this.createTokenInstance = _this.createFullToken;
        } else if (/onlyStart/i.test(_this.config.positionTracking)) {
          _this.createTokenInstance = _this.createStartOnlyToken;
        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
          _this.createTokenInstance = _this.createOffsetOnlyToken;
        } else {
          throw Error("Invalid <positionTracking> config option: \"".concat(_this.config.positionTracking, "\""));
        }

        if (_this.hasCustom) {
          _this.addToken = _this.addTokenUsingPush;
          _this.handlePayload = _this.handlePayloadWithCustom;
        } else {
          _this.addToken = _this.addTokenUsingMemberAccess;
          _this.handlePayload = _this.handlePayloadNoCustom;
        }
      });

      _this.TRACE_INIT("Failed Optimization Warnings", function () {
        var unOptimizedModes = (0, reduce_1["default"])(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {
          if (canBeOptimized === false) {
            cannotBeOptimized.push(modeName);
          }

          return cannotBeOptimized;
        }, []);

        if (config.ensureOptimizations && !(0, isEmpty_1["default"])(unOptimizedModes)) {
          throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n' + "\t Or inspect the console log for details on how to resolve these issues.");
        }
      });

      _this.TRACE_INIT("clearRegExpParserCache", function () {
        (0, reg_exp_parser_1.clearRegExpParserCache)();
      });

      _this.TRACE_INIT("toFastProperties", function () {
        (0, utils_1.toFastProperties)(_this);
      });
    });
  }

  Lexer.prototype.tokenize = function (text, initialMode) {
    if (initialMode === void 0) {
      initialMode = this.defaultMode;
    }

    if (!(0, isEmpty_1["default"])(this.lexerDefinitionErrors)) {
      var allErrMessages = (0, map_1["default"])(this.lexerDefinitionErrors, function (error) {
        return error.message;
      });
      var allErrMessagesString = allErrMessages.join("-----------------------\n");
      throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
    }

    return this.tokenizeInternal(text, initialMode);
  }; // There is quite a bit of duplication between this and "tokenizeInternalLazy"
  // This is intentional due to performance considerations.
  // this method also used quite a bit of `!` none null assertions because it is too optimized
  // for `tsc` to always understand it is "safe"


  Lexer.prototype.tokenizeInternal = function (text, initialMode) {
    var _this = this;

    var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
    var orgText = text;
    var orgLength = orgText.length;
    var offset = 0;
    var matchedTokensIndex = 0; // initializing the tokensArray to the "guessed" size.
    // guessing too little will still reduce the number of array re-sizes on pushes.
    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory
    // but would still have a faster runtime by avoiding (All but one) array resizing.

    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.
    : Math.floor(text.length / 10);
    var matchedTokens = new Array(guessedNumberOfTokens);
    var errors = [];
    var line = this.trackStartLines ? 1 : undefined;
    var column = this.trackStartLines ? 1 : undefined;
    var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
    var trackLines = this.trackStartLines;
    var lineTerminatorPattern = this.config.lineTerminatorsPattern;
    var currModePatternsLength = 0;
    var patternIdxToConfig = [];
    var currCharCodeToPatternIdxToConfig = [];
    var modeStack = [];
    var emptyArray = [];
    Object.freeze(emptyArray);
    var getPossiblePatterns;

    function getPossiblePatternsSlow() {
      return patternIdxToConfig;
    }

    function getPossiblePatternsOptimized(charCode) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];

      if (possiblePatterns === undefined) {
        return emptyArray;
      } else {
        return possiblePatterns;
      }
    }

    var pop_mode = function pop_mode(popToken) {
      // TODO: perhaps avoid this error in the edge case there is no more input?
      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
      // So no error should occur.
      popToken.tokenType.PUSH_MODE === undefined) {
        // if we try to pop the last mode there lexer will no longer have ANY mode.
        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.
        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);

        errors.push({
          offset: popToken.startOffset,
          line: popToken.startLine,
          column: popToken.startColumn,
          length: popToken.image.length,
          message: msg_1
        });
      } else {
        modeStack.pop();
        var newMode = (0, last_1["default"])(modeStack);
        patternIdxToConfig = _this.patternIdxToConfig[newMode];
        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
        currModePatternsLength = patternIdxToConfig.length;
        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;

        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
          getPossiblePatterns = getPossiblePatternsOptimized;
        } else {
          getPossiblePatterns = getPossiblePatternsSlow;
        }
      }
    };

    function push_mode(newMode) {
      modeStack.push(newMode);
      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
      patternIdxToConfig = this.patternIdxToConfig[newMode];
      currModePatternsLength = patternIdxToConfig.length;
      currModePatternsLength = patternIdxToConfig.length;
      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;

      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
        getPossiblePatterns = getPossiblePatternsOptimized;
      } else {
        getPossiblePatterns = getPossiblePatternsSlow;
      }
    } // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not
    // seem to matter performance wise.


    push_mode.call(this, initialMode);
    var currConfig;
    var recoveryEnabled = this.config.recoveryEnabled;

    while (offset < orgLength) {
      matchedImage = null;
      var nextCharCode = orgText.charCodeAt(offset);
      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
      var chosenPatternsLength = chosenPatternIdxToConfig.length;

      for (i = 0; i < chosenPatternsLength; i++) {
        currConfig = chosenPatternIdxToConfig[i];
        var currPattern = currConfig.pattern;
        payload = null; // manually in-lined because > 600 chars won't be in-lined in V8

        var singleCharCode = currConfig["short"];

        if (singleCharCode !== false) {
          if (nextCharCode === singleCharCode) {
            // single character string
            matchedImage = currPattern;
          }
        } else if (currConfig.isCustom === true) {
          match = currPattern.exec(orgText, offset, matchedTokens, groups);

          if (match !== null) {
            matchedImage = match[0];

            if (match.payload !== undefined) {
              payload = match.payload;
            }
          } else {
            matchedImage = null;
          }
        } else {
          this.updateLastIndex(currPattern, offset);
          matchedImage = this.match(currPattern, text, offset);
        }

        if (matchedImage !== null) {
          // even though this pattern matched we must try a another longer alternative.
          // this can be used to prioritize keywords over identifiers
          longerAlt = currConfig.longerAlt;

          if (longerAlt !== undefined) {
            // TODO: micro optimize, avoid extra prop access
            // by saving/linking longerAlt on the original config?
            var longerAltLength = longerAlt.length;

            for (k = 0; k < longerAltLength; k++) {
              var longerAltConfig = patternIdxToConfig[longerAlt[k]];
              var longerAltPattern = longerAltConfig.pattern;
              altPayload = null; // single Char can never be a longer alt so no need to test it.
              // manually in-lined because > 600 chars won't be in-lined in V8

              if (longerAltConfig.isCustom === true) {
                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);

                if (match !== null) {
                  matchAltImage = match[0];

                  if (match.payload !== undefined) {
                    altPayload = match.payload;
                  }
                } else {
                  matchAltImage = null;
                }
              } else {
                this.updateLastIndex(longerAltPattern, offset);
                matchAltImage = this.match(longerAltPattern, text, offset);
              }

              if (matchAltImage && matchAltImage.length > matchedImage.length) {
                matchedImage = matchAltImage;
                payload = altPayload;
                currConfig = longerAltConfig; // Exit the loop early after matching one of the longer alternatives
                // The first matched alternative takes precedence

                break;
              }
            }
          }

          break;
        }
      } // successful match


      if (matchedImage !== null) {
        imageLength = matchedImage.length;
        group = currConfig.group;

        if (group !== undefined) {
          tokType = currConfig.tokenTypeIdx; // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside
          // createFullToken method

          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
          this.handlePayload(newToken, payload); // TODO: optimize NOOP in case there are no special groups?

          if (group === false) {
            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
          } else {
            groups[group].push(newToken);
          }
        }

        text = this.chopInput(text, imageLength);
        offset = offset + imageLength; // TODO: with newlines the column may be assigned twice

        column = this.computeNewColumn(column, imageLength);

        if (trackLines === true && currConfig.canLineTerminator === true) {
          var numOfLTsInMatch = 0;
          var foundTerminator = void 0;
          var lastLTEndOffset = void 0;
          lineTerminatorPattern.lastIndex = 0;

          do {
            foundTerminator = lineTerminatorPattern.test(matchedImage);

            if (foundTerminator === true) {
              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
              numOfLTsInMatch++;
            }
          } while (foundTerminator === true);

          if (numOfLTsInMatch !== 0) {
            line = line + numOfLTsInMatch;
            column = imageLength - lastLTEndOffset;
            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
          }
        } // will be NOOP if no modes present


        this.handleModes(currConfig, pop_mode, push_mode, newToken);
      } else {
        // error recovery, drop characters until we identify a valid token's start point
        var errorStartOffset = offset;
        var errorLine = line;
        var errorColumn = column;
        var foundResyncPoint = recoveryEnabled === false;

        while (foundResyncPoint === false && offset < orgLength) {
          // Identity Func (when sticky flag is enabled)
          text = this.chopInput(text, 1);
          offset++;

          for (j = 0; j < currModePatternsLength; j++) {
            var currConfig_1 = patternIdxToConfig[j];
            var currPattern = currConfig_1.pattern; // manually in-lined because > 600 chars won't be in-lined in V8

            var singleCharCode = currConfig_1["short"];

            if (singleCharCode !== false) {
              if (orgText.charCodeAt(offset) === singleCharCode) {
                // single character string
                foundResyncPoint = true;
              }
            } else if (currConfig_1.isCustom === true) {
              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
            } else {
              this.updateLastIndex(currPattern, offset);
              foundResyncPoint = currPattern.exec(text) !== null;
            }

            if (foundResyncPoint === true) {
              break;
            }
          }
        }

        errLength = offset - errorStartOffset; // at this point we either re-synced or reached the end of the input text

        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
        errors.push({
          offset: errorStartOffset,
          line: errorLine,
          column: errorColumn,
          length: errLength,
          message: msg
        });

        if (recoveryEnabled === false) {
          break;
        }
      }
    } // if we do have custom patterns which push directly into the
    // TODO: custom tokens should not push directly??


    if (!this.hasCustom) {
      // if we guessed a too large size for the tokens array this will shrink it to the right size.
      matchedTokens.length = matchedTokensIndex;
    }

    return {
      tokens: matchedTokens,
      groups: groups,
      errors: errors
    };
  };

  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {
    if (config.pop === true) {
      // need to save the PUSH_MODE property as if the mode is popped
      // patternIdxToPopMode is updated to reflect the new mode after popping the stack
      var pushMode = config.push;
      pop_mode(newToken);

      if (pushMode !== undefined) {
        push_mode.call(this, pushMode);
      }
    } else if (config.push !== undefined) {
      push_mode.call(this, config.push);
    }
  };

  Lexer.prototype.chopInput = function (text, length) {
    return text.substring(length);
  };

  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {
    regExp.lastIndex = newLastIndex;
  }; // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler


  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
    var lastCharIsLT, fixForEndingInLT;

    if (group !== undefined) {
      // a none skipped multi line Token, need to update endLine/endColumn
      lastCharIsLT = lastLTIdx === imageLength - 1;
      fixForEndingInLT = lastCharIsLT ? -1 : 0;

      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
        // if a token ends in a LT that last LT only affects the line numbering of following Tokens
        newToken.endLine = line + fixForEndingInLT; // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)
        // inclusive to exclusive range.

        newToken.endColumn = column - 1 + -fixForEndingInLT;
      } // else single LT in the last character of a token, no need to modify the endLine/EndColumn

    }
  };

  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {
    return oldColumn + imageLength;
  };

  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {
    return {
      image: image,
      startOffset: startOffset,
      tokenTypeIdx: tokenTypeIdx,
      tokenType: tokenType
    };
  };

  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
    return {
      image: image,
      startOffset: startOffset,
      startLine: startLine,
      startColumn: startColumn,
      tokenTypeIdx: tokenTypeIdx,
      tokenType: tokenType
    };
  };

  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
    return {
      image: image,
      startOffset: startOffset,
      endOffset: startOffset + imageLength - 1,
      startLine: startLine,
      endLine: startLine,
      startColumn: startColumn,
      endColumn: startColumn + imageLength - 1,
      tokenTypeIdx: tokenTypeIdx,
      tokenType: tokenType
    };
  };

  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {
    tokenVector.push(tokenToAdd);
    return index;
  };

  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {
    tokenVector[index] = tokenToAdd;
    index++;
    return index;
  };

  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};

  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {
    if (payload !== null) {
      token.payload = payload;
    }
  };

  Lexer.prototype.matchWithTest = function (pattern, text, offset) {
    var found = pattern.test(text);

    if (found === true) {
      return text.substring(offset, pattern.lastIndex);
    }

    return null;
  };

  Lexer.prototype.matchWithExec = function (pattern, text) {
    var regExpArray = pattern.exec(text);
    return regExpArray !== null ? regExpArray[0] : null;
  };

  Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it will" + "be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
  Lexer.NA = /NOT_APPLICABLE/;
  return Lexer;
}();

exports.Lexer = Lexer;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (value) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = compact;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;

var tokens_public_1 = __webpack_require__(26);

var first_1 = __importDefault(__webpack_require__(40));

var map_1 = __importDefault(__webpack_require__(4));

var reduce_1 = __importDefault(__webpack_require__(23));

var gast_1 = __webpack_require__(2);

var gast_2 = __webpack_require__(2);

exports.defaultParserErrorProvider = {
  buildMismatchTokenMessage: function buildMismatchTokenMessage(_a) {
    var expected = _a.expected,
        actual = _a.actual,
        previous = _a.previous,
        ruleName = _a.ruleName;
    var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
    var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
    var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
    return msg;
  },
  buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_a) {
    var firstRedundant = _a.firstRedundant,
        ruleName = _a.ruleName;
    return "Redundant input, expecting EOF but found: " + firstRedundant.image;
  },
  buildNoViableAltMessage: function buildNoViableAltMessage(_a) {
    var expectedPathsPerAlt = _a.expectedPathsPerAlt,
        actual = _a.actual,
        previous = _a.previous,
        customUserDescription = _a.customUserDescription,
        ruleName = _a.ruleName;
    var errPrefix = "Expecting: "; // TODO: issue: No Viable Alternative Error may have incomplete details. #502

    var actualText = (0, first_1["default"])(actual).image;
    var errSuffix = "\nbut found: '" + actualText + "'";

    if (customUserDescription) {
      return errPrefix + customUserDescription + errSuffix;
    } else {
      var allLookAheadPaths = (0, reduce_1["default"])(expectedPathsPerAlt, function (result, currAltPaths) {
        return result.concat(currAltPaths);
      }, []);
      var nextValidTokenSequences = (0, map_1["default"])(allLookAheadPaths, function (currPath) {
        return "[".concat((0, map_1["default"])(currPath, function (currTokenType) {
          return (0, tokens_public_1.tokenLabel)(currTokenType);
        }).join(", "), "]");
      });
      var nextValidSequenceItems = (0, map_1["default"])(nextValidTokenSequences, function (itemMsg, idx) {
        return "  ".concat(idx + 1, ". ").concat(itemMsg);
      });
      var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
      return errPrefix + calculatedDescription + errSuffix;
    }
  },
  buildEarlyExitMessage: function buildEarlyExitMessage(_a) {
    var expectedIterationPaths = _a.expectedIterationPaths,
        actual = _a.actual,
        customUserDescription = _a.customUserDescription,
        ruleName = _a.ruleName;
    var errPrefix = "Expecting: "; // TODO: issue: No Viable Alternative Error may have incomplete details. #502

    var actualText = (0, first_1["default"])(actual).image;
    var errSuffix = "\nbut found: '" + actualText + "'";

    if (customUserDescription) {
      return errPrefix + customUserDescription + errSuffix;
    } else {
      var nextValidTokenSequences = (0, map_1["default"])(expectedIterationPaths, function (currPath) {
        return "[".concat((0, map_1["default"])(currPath, function (currTokenType) {
          return (0, tokens_public_1.tokenLabel)(currTokenType);
        }).join(","), "]");
      });
      var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
      return errPrefix + calculatedDescription + errSuffix;
    }
  }
};
Object.freeze(exports.defaultParserErrorProvider);
exports.defaultGrammarResolverErrorProvider = {
  buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {
    var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\n" + "inside top level rule: ->" + topLevelRule.name + "<-";
    return msg;
  }
};
exports.defaultGrammarValidatorErrorProvider = {
  buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {
    function getExtraProductionArgument(prod) {
      if (prod instanceof gast_1.Terminal) {
        return prod.terminalType.name;
      } else if (prod instanceof gast_1.NonTerminal) {
        return prod.nonTerminalName;
      } else {
        return "";
      }
    }

    var topLevelName = topLevelRule.name;
    var duplicateProd = (0, first_1["default"])(duplicateProds);
    var index = duplicateProd.idx;
    var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
    var extraArgument = getExtraProductionArgument(duplicateProd);
    var hasExplicitIndex = index > 0;
    var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  "); // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...

    msg = msg.replace(/[ \t]+/g, " ");
    msg = msg.replace(/\s\s+/g, "\n");
    return msg;
  },
  buildNamespaceConflictError: function buildNamespaceConflictError(rule) {
    var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\n" + "This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\n" + "and Non-Terminal names start with a lower case letter.";
    return errMsg;
  },
  buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {
    var pathMsg = (0, map_1["default"])(options.prefixPath, function (currTok) {
      return (0, tokens_public_1.tokenLabel)(currTok);
    }).join(", ");
    var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
    var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\n" + "For Further details.";
    return errMsg;
  },
  buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {
    var pathMsg = (0, map_1["default"])(options.prefixPath, function (currtok) {
      return (0, tokens_public_1.tokenLabel)(currtok);
    }).join(", ");
    var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
    var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
    currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n" + "For Further details.";
    return currMessage;
  },
  buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {
    var dslName = (0, gast_2.getProductionDslName)(options.repetition);

    if (options.repetition.idx !== 0) {
      dslName += options.repetition.idx;
    }

    var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
    return errMsg;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildTokenNameError: function buildTokenNameError(options) {
    /* istanbul ignore next */
    return "deprecated";
  },
  buildEmptyAlternationError: function buildEmptyAlternationError(options) {
    var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
    return errMsg;
  },
  buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {
    var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
    return errMsg;
  },
  buildLeftRecursionError: function buildLeftRecursionError(options) {
    var ruleName = options.topLevelRule.name;
    var pathNames = (0, map_1["default"])(options.leftRecursionPath, function (currRule) {
      return currRule.name;
    });
    var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
    var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\n" + "see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
    return errMsg;
  },
  // TODO: remove - `errors_public` from nyc.config.js exclude
  //       once this method is fully removed from this file
  buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {
    /* istanbul ignore next */
    return "deprecated";
  },
  buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {
    var ruleName;

    if (options.topLevelRule instanceof gast_1.Rule) {
      ruleName = options.topLevelRule.name;
    } else {
      ruleName = options.topLevelRule;
    }

    var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
    return errMsg;
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getProdType = exports.PROD_TYPE = void 0;

var isEmpty_1 = __importDefault(__webpack_require__(9));

var flatten_1 = __importDefault(__webpack_require__(16));

var every_1 = __importDefault(__webpack_require__(62));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var has_1 = __importDefault(__webpack_require__(7));

var reduce_1 = __importDefault(__webpack_require__(23));

var interpreter_1 = __webpack_require__(67);

var rest_1 = __webpack_require__(90);

var tokens_1 = __webpack_require__(27);

var gast_1 = __webpack_require__(2);

var gast_2 = __webpack_require__(2);

var PROD_TYPE;

(function (PROD_TYPE) {
  PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";
  PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";
  PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
  PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
  PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
  PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";
})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));

function getProdType(prod) {
  /* istanbul ignore else */
  if (prod instanceof gast_1.Option) {
    return PROD_TYPE.OPTION;
  } else if (prod instanceof gast_1.Repetition) {
    return PROD_TYPE.REPETITION;
  } else if (prod instanceof gast_1.RepetitionMandatory) {
    return PROD_TYPE.REPETITION_MANDATORY;
  } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
  } else if (prod instanceof gast_1.RepetitionWithSeparator) {
    return PROD_TYPE.REPETITION_WITH_SEPARATOR;
  } else if (prod instanceof gast_1.Alternation) {
    return PROD_TYPE.ALTERNATION;
  } else {
    throw Error("non exhaustive match");
  }
}

exports.getProdType = getProdType;

function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
}

exports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
/**
 *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare
 *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).
 *
 *  Example: given a production:
 *  ABC(DE)?DF
 *
 *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two
 *  alternatives.
 *
 *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.
 */

function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
}

exports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;

function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
  var numOfAlts = alts.length;
  var areAllOneTokenLookahead = (0, every_1["default"])(alts, function (currAlt) {
    return (0, every_1["default"])(currAlt, function (currPath) {
      return currPath.length === 1;
    });
  }); // This version takes into account the predicates as well.

  if (hasPredicates) {
    /**
     * @returns {number} - The chosen alternative index
     */
    return function (orAlts) {
      // unfortunately the predicates must be extracted every single time
      // as they cannot be cached due to references to parameters(vars) which are no longer valid.
      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)
      var predicates = (0, map_1["default"])(orAlts, function (currAlt) {
        return currAlt.GATE;
      });

      for (var t = 0; t < numOfAlts; t++) {
        var currAlt = alts[t];
        var currNumOfPaths = currAlt.length;
        var currPredicate = predicates[t];

        if (currPredicate !== undefined && currPredicate.call(this) === false) {
          // if the predicate does not match there is no point in checking the paths
          continue;
        }

        nextPath: for (var j = 0; j < currNumOfPaths; j++) {
          var currPath = currAlt[j];
          var currPathLength = currPath.length;

          for (var i = 0; i < currPathLength; i++) {
            var nextToken = this.LA(i + 1);

            if (tokenMatcher(nextToken, currPath[i]) === false) {
              // mismatch in current path
              // try the next pth
              continue nextPath;
            }
          } // found a full path that matches.
          // this will also work for an empty ALT as the loop will be skipped


          return t;
        } // none of the paths for the current alternative matched
        // try the next alternative

      } // none of the alternatives could be matched


      return undefined;
    };
  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
    // optimized (common) case of all the lookaheads paths requiring only
    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.
    var singleTokenAlts = (0, map_1["default"])(alts, function (currAlt) {
      return (0, flatten_1["default"])(currAlt);
    });
    var choiceToAlt_1 = (0, reduce_1["default"])(singleTokenAlts, function (result, currAlt, idx) {
      (0, forEach_1["default"])(currAlt, function (currTokType) {
        if (!(0, has_1["default"])(result, currTokType.tokenTypeIdx)) {
          result[currTokType.tokenTypeIdx] = idx;
        }

        (0, forEach_1["default"])(currTokType.categoryMatches, function (currExtendingType) {
          if (!(0, has_1["default"])(result, currExtendingType)) {
            result[currExtendingType] = idx;
          }
        });
      });
      return result;
    }, {});
    /**
     * @returns {number} - The chosen alternative index
     */

    return function () {
      var nextToken = this.LA(1);
      return choiceToAlt_1[nextToken.tokenTypeIdx];
    };
  } else {
    // optimized lookahead without needing to check the predicates at all.
    // this causes code duplication which is intentional to improve performance.

    /**
     * @returns {number} - The chosen alternative index
     */
    return function () {
      for (var t = 0; t < numOfAlts; t++) {
        var currAlt = alts[t];
        var currNumOfPaths = currAlt.length;

        nextPath: for (var j = 0; j < currNumOfPaths; j++) {
          var currPath = currAlt[j];
          var currPathLength = currPath.length;

          for (var i = 0; i < currPathLength; i++) {
            var nextToken = this.LA(i + 1);

            if (tokenMatcher(nextToken, currPath[i]) === false) {
              // mismatch in current path
              // try the next pth
              continue nextPath;
            }
          } // found a full path that matches.
          // this will also work for an empty ALT as the loop will be skipped


          return t;
        } // none of the paths for the current alternative matched
        // try the next alternative

      } // none of the alternatives could be matched


      return undefined;
    };
  }
}

exports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;

function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
  var areAllOneTokenLookahead = (0, every_1["default"])(alt, function (currPath) {
    return currPath.length === 1;
  });
  var numOfPaths = alt.length; // optimized (common) case of all the lookaheads paths requiring only
  // a single token lookahead.

  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
    var singleTokensTypes = (0, flatten_1["default"])(alt);

    if (singleTokensTypes.length === 1 && (0, isEmpty_1["default"])(singleTokensTypes[0].categoryMatches)) {
      var expectedTokenType = singleTokensTypes[0];
      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
      return function () {
        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
      };
    } else {
      var choiceToAlt_2 = (0, reduce_1["default"])(singleTokensTypes, function (result, currTokType, idx) {
        result[currTokType.tokenTypeIdx] = true;
        (0, forEach_1["default"])(currTokType.categoryMatches, function (currExtendingType) {
          result[currExtendingType] = true;
        });
        return result;
      }, []);
      return function () {
        var nextToken = this.LA(1);
        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
      };
    }
  } else {
    return function () {
      nextPath: for (var j = 0; j < numOfPaths; j++) {
        var currPath = alt[j];
        var currPathLength = currPath.length;

        for (var i = 0; i < currPathLength; i++) {
          var nextToken = this.LA(i + 1);

          if (tokenMatcher(nextToken, currPath[i]) === false) {
            // mismatch in current path
            // try the next pth
            continue nextPath;
          }
        } // found a full path that matches.


        return true;
      } // none of the paths matched


      return false;
    };
  }
}

exports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;

var RestDefinitionFinderWalker =
/** @class */
function (_super) {
  __extends(RestDefinitionFinderWalker, _super);

  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {
    var _this = _super.call(this) || this;

    _this.topProd = topProd;
    _this.targetOccurrence = targetOccurrence;
    _this.targetProdType = targetProdType;
    return _this;
  }

  RestDefinitionFinderWalker.prototype.startWalking = function () {
    this.walk(this.topProd);
    return this.restDef;
  };

  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {
    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
      this.restDef = currRest.concat(prevRest);
      return true;
    } // performance optimization, do not iterate over the entire Grammar ast after we have found the target


    return false;
  };

  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
    }
  };

  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
    }
  };

  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
    }
  };

  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
    }
  };

  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
    }
  };

  return RestDefinitionFinderWalker;
}(rest_1.RestWalker);
/**
 * Returns the definition of a target production in a top level level rule.
 */


var InsideDefinitionFinderVisitor =
/** @class */
function (_super) {
  __extends(InsideDefinitionFinderVisitor, _super);

  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {
    var _this = _super.call(this) || this;

    _this.targetOccurrence = targetOccurrence;
    _this.targetProdType = targetProdType;
    _this.targetRef = targetRef;
    _this.result = [];
    return _this;
  }

  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {
    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {
      this.result = node.definition;
    }
  };

  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {
    this.checkIsTarget(node, PROD_TYPE.OPTION);
  };

  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {
    this.checkIsTarget(node, PROD_TYPE.REPETITION);
  };

  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {
    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
  };

  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
  };

  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {
    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
  };

  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {
    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
  };

  return InsideDefinitionFinderVisitor;
}(gast_2.GAstVisitor);

function initializeArrayOfArrays(size) {
  var result = new Array(size);

  for (var i = 0; i < size; i++) {
    result[i] = [];
  }

  return result;
}
/**
 * A sort of hash function between a Path in the grammar and a string.
 * Note that this returns multiple "hashes" to support the scenario of token categories.
 * -  A single path with categories may match multiple **actual** paths.
 */


function pathToHashKeys(path) {
  var keys = [""];

  for (var i = 0; i < path.length; i++) {
    var tokType = path[i];
    var longerKeys = [];

    for (var j = 0; j < keys.length; j++) {
      var currShorterKey = keys[j];
      longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);

      for (var t = 0; t < tokType.categoryMatches.length; t++) {
        var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
        longerKeys.push(currShorterKey + categoriesKeySuffix);
      }
    }

    keys = longerKeys;
  }

  return keys;
}
/**
 * Imperative style due to being called from a hot spot
 */


function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
    // We only want to test vs the other alternatives
    if (currAltIdx === idx) {
      continue;
    }

    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];

    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
      var searchKey = searchPathKeys[searchIdx];

      if (otherAltKnownPathsKeys[searchKey] === true) {
        return false;
      }
    }
  } // None of the SearchPathKeys were found in any of the other alternatives


  return true;
}

function lookAheadSequenceFromAlternatives(altsDefs, k) {
  var partialAlts = (0, map_1["default"])(altsDefs, function (currAlt) {
    return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
  });
  var finalResult = initializeArrayOfArrays(partialAlts.length);
  var altsHashes = (0, map_1["default"])(partialAlts, function (currAltPaths) {
    var dict = {};
    (0, forEach_1["default"])(currAltPaths, function (item) {
      var keys = pathToHashKeys(item.partialPath);
      (0, forEach_1["default"])(keys, function (currKey) {
        dict[currKey] = true;
      });
    });
    return dict;
  });
  var newData = partialAlts; // maxLookahead loop

  for (var pathLength = 1; pathLength <= k; pathLength++) {
    var currDataset = newData;
    newData = initializeArrayOfArrays(currDataset.length);

    var _loop_1 = function _loop_1(altIdx) {
      var currAltPathsAndSuffixes = currDataset[altIdx]; // paths in current alternative loop

      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
        var prefixKeys = pathToHashKeys(currPathPrefix);
        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx); // End of the line for this path.

        if (isUnique || (0, isEmpty_1["default"])(suffixDef) || currPathPrefix.length === k) {
          var currAltResult = finalResult[altIdx]; // TODO: Can we implement a containsPath using Maps/Dictionaries?

          if (containsPath(currAltResult, currPathPrefix) === false) {
            currAltResult.push(currPathPrefix); // Update all new  keys for the current path.

            for (var j = 0; j < prefixKeys.length; j++) {
              var currKey = prefixKeys[j];
              altsHashes[altIdx][currKey] = true;
            }
          }
        } // Expand longer paths
        else {
          var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes); // Update keys for new known paths

          (0, forEach_1["default"])(newPartialPathsAndSuffixes, function (item) {
            var prefixKeys = pathToHashKeys(item.partialPath);
            (0, forEach_1["default"])(prefixKeys, function (key) {
              altsHashes[altIdx][key] = true;
            });
          });
        }
      }
    }; // alternatives loop


    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
      _loop_1(altIdx);
    }
  }

  return finalResult;
}

exports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;

function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
  ruleGrammar.accept(visitor);
  return lookAheadSequenceFromAlternatives(visitor.result, k);
}

exports.getLookaheadPathsForOr = getLookaheadPathsForOr;

function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
  ruleGrammar.accept(insideDefVisitor);
  var insideDef = insideDefVisitor.result;
  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
  var afterDef = afterDefWalker.startWalking();
  var insideFlat = new gast_1.Alternative({
    definition: insideDef
  });
  var afterFlat = new gast_1.Alternative({
    definition: afterDef
  });
  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
}

exports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;

function containsPath(alternative, searchPath) {
  compareOtherPath: for (var i = 0; i < alternative.length; i++) {
    var otherPath = alternative[i];

    if (otherPath.length !== searchPath.length) {
      continue;
    }

    for (var j = 0; j < otherPath.length; j++) {
      var searchTok = searchPath[j];
      var otherTok = otherPath[j];
      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;

      if (matchingTokens === false) {
        continue compareOtherPath;
      }
    }

    return true;
  }

  return false;
}

exports.containsPath = containsPath;

function isStrictPrefixOfPath(prefix, other) {
  return prefix.length < other.length && (0, every_1["default"])(prefix, function (tokType, idx) {
    var otherTokType = other[idx];
    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
  });
}

exports.isStrictPrefixOfPath = isStrictPrefixOfPath;

function areTokenCategoriesNotUsed(lookAheadPaths) {
  return (0, every_1["default"])(lookAheadPaths, function (singleAltPaths) {
    return (0, every_1["default"])(singleAltPaths, function (singlePath) {
      return (0, every_1["default"])(singlePath, function (token) {
        return (0, isEmpty_1["default"])(token.categoryMatches);
      });
    });
  });
}

exports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;

var rest_1 = __webpack_require__(90);

var first_1 = __importDefault(__webpack_require__(40));

var isEmpty_1 = __importDefault(__webpack_require__(9));

var dropRight_1 = __importDefault(__webpack_require__(107));

var drop_1 = __importDefault(__webpack_require__(91));

var last_1 = __importDefault(__webpack_require__(106));

var forEach_1 = __importDefault(__webpack_require__(3));

var clone_1 = __importDefault(__webpack_require__(17));

var first_2 = __webpack_require__(234);

var gast_1 = __webpack_require__(2);

var AbstractNextPossibleTokensWalker =
/** @class */
function (_super) {
  __extends(AbstractNextPossibleTokensWalker, _super);

  function AbstractNextPossibleTokensWalker(topProd, path) {
    var _this = _super.call(this) || this;

    _this.topProd = topProd;
    _this.path = path;
    _this.possibleTokTypes = [];
    _this.nextProductionName = "";
    _this.nextProductionOccurrence = 0;
    _this.found = false;
    _this.isAtEndOfPath = false;
    return _this;
  }

  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {
    this.found = false;

    if (this.path.ruleStack[0] !== this.topProd.name) {
      throw Error("The path does not start with the walker's top Rule!");
    } // immutable for the win


    this.ruleStack = (0, clone_1["default"])(this.path.ruleStack).reverse(); // intelij bug requires assertion

    this.occurrenceStack = (0, clone_1["default"])(this.path.occurrenceStack).reverse(); // intelij bug requires assertion
    // already verified that the first production is valid, we now seek the 2nd production

    this.ruleStack.pop();
    this.occurrenceStack.pop();
    this.updateExpectedNext();
    this.walk(this.topProd);
    return this.possibleTokTypes;
  };

  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {
    if (prevRest === void 0) {
      prevRest = [];
    } // stop scanning once we found the path


    if (!this.found) {
      _super.prototype.walk.call(this, prod, prevRest);
    }
  };

  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
    // found the next production, need to keep walking in it
    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
      var fullRest = currRest.concat(prevRest);
      this.updateExpectedNext();
      this.walk(refProd.referencedRule, fullRest);
    }
  };

  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {
    // need to consume the Terminal
    if ((0, isEmpty_1["default"])(this.ruleStack)) {
      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are
      // really seeking is the last Terminal...
      this.nextProductionName = "";
      this.nextProductionOccurrence = 0;
      this.isAtEndOfPath = true;
    } else {
      this.nextProductionName = this.ruleStack.pop();
      this.nextProductionOccurrence = this.occurrenceStack.pop();
    }
  };

  return AbstractNextPossibleTokensWalker;
}(rest_1.RestWalker);

exports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;

var NextAfterTokenWalker =
/** @class */
function (_super) {
  __extends(NextAfterTokenWalker, _super);

  function NextAfterTokenWalker(topProd, path) {
    var _this = _super.call(this, topProd, path) || this;

    _this.path = path;
    _this.nextTerminalName = "";
    _this.nextTerminalOccurrence = 0;
    _this.nextTerminalName = _this.path.lastTok.name;
    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
    return _this;
  }

  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
      var fullRest = currRest.concat(prevRest);
      var restProd = new gast_1.Alternative({
        definition: fullRest
      });
      this.possibleTokTypes = (0, first_2.first)(restProd);
      this.found = true;
    }
  };

  return NextAfterTokenWalker;
}(AbstractNextPossibleTokensWalker);

exports.NextAfterTokenWalker = NextAfterTokenWalker;
/**
 * This walker only "walks" a single "TOP" level in the Grammar Ast, this means
 * it never "follows" production refs
 */

var AbstractNextTerminalAfterProductionWalker =
/** @class */
function (_super) {
  __extends(AbstractNextTerminalAfterProductionWalker, _super);

  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {
    var _this = _super.call(this) || this;

    _this.topRule = topRule;
    _this.occurrence = occurrence;
    _this.result = {
      token: undefined,
      occurrence: undefined,
      isEndOfRule: undefined
    };
    return _this;
  }

  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {
    this.walk(this.topRule);
    return this.result;
  };

  return AbstractNextTerminalAfterProductionWalker;
}(rest_1.RestWalker);

exports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;

var NextTerminalAfterManyWalker =
/** @class */
function (_super) {
  __extends(NextTerminalAfterManyWalker, _super);

  function NextTerminalAfterManyWalker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
    if (manyProd.idx === this.occurrence) {
      var firstAfterMany = (0, first_1["default"])(currRest.concat(prevRest));
      this.result.isEndOfRule = firstAfterMany === undefined;

      if (firstAfterMany instanceof gast_1.Terminal) {
        this.result.token = firstAfterMany.terminalType;
        this.result.occurrence = firstAfterMany.idx;
      }
    } else {
      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
    }
  };

  return NextTerminalAfterManyWalker;
}(AbstractNextTerminalAfterProductionWalker);

exports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;

var NextTerminalAfterManySepWalker =
/** @class */
function (_super) {
  __extends(NextTerminalAfterManySepWalker, _super);

  function NextTerminalAfterManySepWalker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
    if (manySepProd.idx === this.occurrence) {
      var firstAfterManySep = (0, first_1["default"])(currRest.concat(prevRest));
      this.result.isEndOfRule = firstAfterManySep === undefined;

      if (firstAfterManySep instanceof gast_1.Terminal) {
        this.result.token = firstAfterManySep.terminalType;
        this.result.occurrence = firstAfterManySep.idx;
      }
    } else {
      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
    }
  };

  return NextTerminalAfterManySepWalker;
}(AbstractNextTerminalAfterProductionWalker);

exports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;

var NextTerminalAfterAtLeastOneWalker =
/** @class */
function (_super) {
  __extends(NextTerminalAfterAtLeastOneWalker, _super);

  function NextTerminalAfterAtLeastOneWalker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
    if (atLeastOneProd.idx === this.occurrence) {
      var firstAfterAtLeastOne = (0, first_1["default"])(currRest.concat(prevRest));
      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;

      if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
        this.result.token = firstAfterAtLeastOne.terminalType;
        this.result.occurrence = firstAfterAtLeastOne.idx;
      }
    } else {
      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
    }
  };

  return NextTerminalAfterAtLeastOneWalker;
}(AbstractNextTerminalAfterProductionWalker);

exports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker; // TODO: reduce code duplication in the AfterWalkers

var NextTerminalAfterAtLeastOneSepWalker =
/** @class */
function (_super) {
  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);

  function NextTerminalAfterAtLeastOneSepWalker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {
    if (atleastOneSepProd.idx === this.occurrence) {
      var firstAfterfirstAfterAtLeastOneSep = (0, first_1["default"])(currRest.concat(prevRest));
      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;

      if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
      }
    } else {
      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
    }
  };

  return NextTerminalAfterAtLeastOneSepWalker;
}(AbstractNextTerminalAfterProductionWalker);

exports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;

function possiblePathsFrom(targetDef, maxLength, currPath) {
  if (currPath === void 0) {
    currPath = [];
  } // avoid side effects


  currPath = (0, clone_1["default"])(currPath);
  var result = [];
  var i = 0; // TODO: avoid inner funcs

  function remainingPathWith(nextDef) {
    return nextDef.concat((0, drop_1["default"])(targetDef, i + 1));
  } // TODO: avoid inner funcs


  function getAlternativesForProd(definition) {
    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
    return result.concat(alternatives);
  }
  /**
   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the
   * following (rest) of the targetDef.
   *
   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the
   * the optional production.
   */


  while (currPath.length < maxLength && i < targetDef.length) {
    var prod = targetDef[i];
    /* istanbul ignore else */

    if (prod instanceof gast_1.Alternative) {
      return getAlternativesForProd(prod.definition);
    } else if (prod instanceof gast_1.NonTerminal) {
      return getAlternativesForProd(prod.definition);
    } else if (prod instanceof gast_1.Option) {
      result = getAlternativesForProd(prod.definition);
    } else if (prod instanceof gast_1.RepetitionMandatory) {
      var newDef = prod.definition.concat([new gast_1.Repetition({
        definition: prod.definition
      })]);
      return getAlternativesForProd(newDef);
    } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
      var newDef = [new gast_1.Alternative({
        definition: prod.definition
      }), new gast_1.Repetition({
        definition: [new gast_1.Terminal({
          terminalType: prod.separator
        })].concat(prod.definition)
      })];
      return getAlternativesForProd(newDef);
    } else if (prod instanceof gast_1.RepetitionWithSeparator) {
      var newDef = prod.definition.concat([new gast_1.Repetition({
        definition: [new gast_1.Terminal({
          terminalType: prod.separator
        })].concat(prod.definition)
      })]);
      result = getAlternativesForProd(newDef);
    } else if (prod instanceof gast_1.Repetition) {
      var newDef = prod.definition.concat([new gast_1.Repetition({
        definition: prod.definition
      })]);
      result = getAlternativesForProd(newDef);
    } else if (prod instanceof gast_1.Alternation) {
      (0, forEach_1["default"])(prod.definition, function (currAlt) {
        // TODO: this is a limited check for empty alternatives
        //   It would prevent a common case of infinite loops during parser initialization.
        //   However **in-directly** empty alternatives may still cause issues.
        if ((0, isEmpty_1["default"])(currAlt.definition) === false) {
          result = getAlternativesForProd(currAlt.definition);
        }
      });
      return result;
    } else if (prod instanceof gast_1.Terminal) {
      currPath.push(prod.terminalType);
    } else {
      throw Error("non exhaustive match");
    }

    i++;
  }

  result.push({
    partialPath: currPath,
    suffixDef: (0, drop_1["default"])(targetDef, i)
  });
  return result;
}

exports.possiblePathsFrom = possiblePathsFrom;

function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
  var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL"; // to avoid creating a new Array each time.

  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
  var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
  var foundCompletePath = false;
  var tokenVectorLength = tokenVector.length;
  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
  var result = [];
  var possiblePaths = [];
  possiblePaths.push({
    idx: -1,
    def: initialDef,
    ruleStack: [],
    occurrenceStack: []
  });

  while (!(0, isEmpty_1["default"])(possiblePaths)) {
    var currPath = possiblePaths.pop(); // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)

    if (currPath === EXIT_ALTERNATIVE) {
      if (foundCompletePath && (0, last_1["default"])(possiblePaths).idx <= minimalAlternativesIndex) {
        // remove irrelevant alternative
        possiblePaths.pop();
      }

      continue;
    }

    var currDef = currPath.def;
    var currIdx = currPath.idx;
    var currRuleStack = currPath.ruleStack;
    var currOccurrenceStack = currPath.occurrenceStack; // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT

    if ((0, isEmpty_1["default"])(currDef)) {
      continue;
    }

    var prod = currDef[0];
    /* istanbul ignore else */

    if (prod === EXIT_NON_TERMINAL) {
      var nextPath = {
        idx: currIdx,
        def: (0, drop_1["default"])(currDef),
        ruleStack: (0, dropRight_1["default"])(currRuleStack),
        occurrenceStack: (0, dropRight_1["default"])(currOccurrenceStack)
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof gast_1.Terminal) {
      /* istanbul ignore else */
      if (currIdx < tokenVectorLength - 1) {
        var nextIdx = currIdx + 1;
        var actualToken = tokenVector[nextIdx];

        if (tokMatcher(actualToken, prod.terminalType)) {
          var nextPath = {
            idx: nextIdx,
            def: (0, drop_1["default"])(currDef),
            ruleStack: currRuleStack,
            occurrenceStack: currOccurrenceStack
          };
          possiblePaths.push(nextPath);
        } // end of the line

      } else if (currIdx === tokenVectorLength - 1) {
        // IGNORE ABOVE ELSE
        result.push({
          nextTokenType: prod.terminalType,
          nextTokenOccurrence: prod.idx,
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        });
        foundCompletePath = true;
      } else {
        throw Error("non exhaustive match");
      }
    } else if (prod instanceof gast_1.NonTerminal) {
      var newRuleStack = (0, clone_1["default"])(currRuleStack);
      newRuleStack.push(prod.nonTerminalName);
      var newOccurrenceStack = (0, clone_1["default"])(currOccurrenceStack);
      newOccurrenceStack.push(prod.idx);
      var nextPath = {
        idx: currIdx,
        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1["default"])(currDef)),
        ruleStack: newRuleStack,
        occurrenceStack: newOccurrenceStack
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof gast_1.Option) {
      // the order of alternatives is meaningful, FILO (Last path will be traversed first).
      var nextPathWithout = {
        idx: currIdx,
        def: (0, drop_1["default"])(currDef),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched

      possiblePaths.push(EXIT_ALTERNATIVE);
      var nextPathWith = {
        idx: currIdx,
        def: prod.definition.concat((0, drop_1["default"])(currDef)),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWith);
    } else if (prod instanceof gast_1.RepetitionMandatory) {
      // TODO:(THE NEW operators here take a while...) (convert once?)
      var secondIteration = new gast_1.Repetition({
        definition: prod.definition,
        idx: prod.idx
      });
      var nextDef = prod.definition.concat([secondIteration], (0, drop_1["default"])(currDef));
      var nextPath = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
      // TODO:(THE NEW operators here take a while...) (convert once?)
      var separatorGast = new gast_1.Terminal({
        terminalType: prod.separator
      });
      var secondIteration = new gast_1.Repetition({
        definition: [separatorGast].concat(prod.definition),
        idx: prod.idx
      });
      var nextDef = prod.definition.concat([secondIteration], (0, drop_1["default"])(currDef));
      var nextPath = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPath);
    } else if (prod instanceof gast_1.RepetitionWithSeparator) {
      // the order of alternatives is meaningful, FILO (Last path will be traversed first).
      var nextPathWithout = {
        idx: currIdx,
        def: (0, drop_1["default"])(currDef),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched

      possiblePaths.push(EXIT_ALTERNATIVE);
      var separatorGast = new gast_1.Terminal({
        terminalType: prod.separator
      });
      var nthRepetition = new gast_1.Repetition({
        definition: [separatorGast].concat(prod.definition),
        idx: prod.idx
      });
      var nextDef = prod.definition.concat([nthRepetition], (0, drop_1["default"])(currDef));
      var nextPathWith = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWith);
    } else if (prod instanceof gast_1.Repetition) {
      // the order of alternatives is meaningful, FILO (Last path will be traversed first).
      var nextPathWithout = {
        idx: currIdx,
        def: (0, drop_1["default"])(currDef),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched

      possiblePaths.push(EXIT_ALTERNATIVE); // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?

      var nthRepetition = new gast_1.Repetition({
        definition: prod.definition,
        idx: prod.idx
      });
      var nextDef = prod.definition.concat([nthRepetition], (0, drop_1["default"])(currDef));
      var nextPathWith = {
        idx: currIdx,
        def: nextDef,
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      };
      possiblePaths.push(nextPathWith);
    } else if (prod instanceof gast_1.Alternation) {
      // the order of alternatives is meaningful, FILO (Last path will be traversed first).
      for (var i = prod.definition.length - 1; i >= 0; i--) {
        var currAlt = prod.definition[i];
        var currAltPath = {
          idx: currIdx,
          def: currAlt.definition.concat((0, drop_1["default"])(currDef)),
          ruleStack: currRuleStack,
          occurrenceStack: currOccurrenceStack
        };
        possiblePaths.push(currAltPath);
        possiblePaths.push(EXIT_ALTERNATIVE);
      }
    } else if (prod instanceof gast_1.Alternative) {
      possiblePaths.push({
        idx: currIdx,
        def: prod.definition.concat((0, drop_1["default"])(currDef)),
        ruleStack: currRuleStack,
        occurrenceStack: currOccurrenceStack
      });
    } else if (prod instanceof gast_1.Rule) {
      // last because we should only encounter at most a single one of these per invocation.
      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
    } else {
      throw Error("non exhaustive match");
    }
  }

  return result;
}

exports.nextPossibleTokensAfter = nextPossibleTokensAfter;

function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
  var newRuleStack = (0, clone_1["default"])(currRuleStack);
  newRuleStack.push(topRule.name);
  var newCurrOccurrenceStack = (0, clone_1["default"])(currOccurrenceStack); // top rule is always assumed to have been called with occurrence index 1

  newCurrOccurrenceStack.push(1);
  return {
    idx: currIdx,
    def: topRule.definition,
    ruleStack: newRuleStack,
    occurrenceStack: newCurrOccurrenceStack
  };
}

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.FormulaParser = void 0;

var _chevrotain = __webpack_require__(47);

var _token = __webpack_require__(43);

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * 公式语法分析器
 */
var FormulaParser = /*#__PURE__*/function (_CstParser) {
  _inheritsLoose(FormulaParser, _CstParser);

  function FormulaParser() {
    var _this;

    _this = _CstParser.call(this, _token.allTokens) || this;

    _defineProperty(_assertThisInitialized(_this), "expr", _this.RULE("expr", function () {
      _this.SUBRULE(_this.commaExpression);
    }));

    _defineProperty(_assertThisInitialized(_this), "commaExpression", _this.RULE("commaExpression", function () {
      _this.SUBRULE(_this.binaryExpression);

      _this.MANY(function () {
        _this.CONSUME(_token.token.Comma);

        _this.SUBRULE2(_this.binaryExpression);
      });
    }));

    _defineProperty(_assertThisInitialized(_this), "binaryExpression", _this.RULE("binaryExpression", function () {
      _this.SUBRULE(_this.unaryExpression);

      _this.MANY(function () {
        _this.OR(_this.c1 || (_this.c1 = [{
          ALT: function ALT() {
            _this.CONSUME(_token.token.LogicOr);
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(_token.token.LogicAnd);
          }
        }, // {
        //   ALT: () => {
        //     this.CONSUME(token.BitOr);
        //   }
        // },
        {
          ALT: function ALT() {
            _this.CONSUME(_token.token.BitAnd);
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(_token.token.Equal);
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(_token.token.Compare);
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(_token.token.Addition);
          }
        }, {
          ALT: function ALT() {
            _this.CONSUME(_token.token.Multiplication);
          }
        }]));

        _this.SUBRULE2(_this.unaryExpression);
      });
    }));

    _defineProperty(_assertThisInitialized(_this), "unaryExpression", _this.RULE("unaryExpression", function () {
      _this.MANY(function () {
        _this.CONSUME(_token.token.Unary);
      });

      _this.SUBRULE(_this.atomicExpression);
    }));

    _defineProperty(_assertThisInitialized(_this), "atomicExpression", _this.RULE("atomicExpression", function () {
      _this.OR(_this.c2 || (_this.c2 = [{
        ALT: function ALT() {
          _this.SUBRULE(_this.array);
        }
      }, {
        ALT: function ALT() {
          _this.SUBRULE(_this.func);
        }
      }, {
        ALT: function ALT() {
          _this.SUBRULE(_this.group);
        }
      }, {
        ALT: function ALT() {
          _this.SUBRULE(_this.base);
        }
      }]));

      _this.MANY(function () {
        _this.CONSUME(_token.token.LSquare);

        _this.SUBRULE(_this.expr);

        _this.CONSUME(_token.token.RSquare);
      });
    }));

    _defineProperty(_assertThisInitialized(_this), "array", _this.RULE("array", function () {
      _this.CONSUME(_token.token.LSquare);

      _this.MANY_SEP({
        SEP: _token.token.Comma,
        DEF: function DEF() {
          _this.SUBRULE(_this.binaryExpression);
        }
      });

      _this.CONSUME(_token.token.RSquare);
    }));

    _defineProperty(_assertThisInitialized(_this), "func", _this.RULE("func", function () {
      _this.CONSUME(_token.token.Func);

      _this.CONSUME(_token.token.LParen);

      _this.OPTION(function () {
        // this.SUBRULE(this.binaryExpression);
        // this.MANY(() => {
        //   this.CONSUME(token.Comma);
        //   this.SUBRULE2(this.binaryExpression);
        // });
        // this.OPTION2(() => {
        //   this.CONSUME2(token.Comma);
        // });
        // 上面注释部分对于Func(字段1,)也能过语法检测，此处使用MANY_SEP
        _this.MANY_SEP({
          SEP: _token.token.Comma,
          DEF: function DEF() {
            _this.SUBRULE(_this.binaryExpression);
          }
        });
      });

      _this.CONSUME(_token.token.RParen);
    }));

    _defineProperty(_assertThisInitialized(_this), "group", _this.RULE("group", function () {
      _this.CONSUME(_token.token.LParen);

      _this.AT_LEAST_ONE_SEP({
        SEP: _token.token.Comma,
        DEF: function DEF() {
          _this.SUBRULE(_this.expr);
        }
      });

      _this.CONSUME(_token.token.RParen);
    }));

    _defineProperty(_assertThisInitialized(_this), "base", _this.RULE("base", function () {
      _this.OR(_this.c3 || (_this.c3 = [{
        ALT: function ALT() {
          _this.CONSUME(_token.token.String);
        }
      }, {
        ALT: function ALT() {
          _this.CONSUME(_token.token.Number);
        }
      }, {
        ALT: function ALT() {
          _this.CONSUME(_token.token.Date);
        }
      }, {
        ALT: function ALT() {
          _this.CONSUME(_token.token.Boolean);
        }
      }, {
        ALT: function ALT() {
          _this.CONSUME(_token.token.Empty);
        }
      }, {
        ALT: function ALT() {
          _this.CONSUME(_token.token.NaN);
        }
      }]));
    }));

    _this.performSelfAnalysis();

    return _this;
  }

  return FormulaParser;
}(_chevrotain.CstParser);
/**
 * 获取parser实例
 */


exports.FormulaParser = FormulaParser;

var getFormulaParser = function getFormulaParser() {
  return new FormulaParser();
};

var _default = getFormulaParser;
exports["default"] = _default;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStringType = exports.isNumberType = exports.isDateType = exports.isBooleanType = exports.isArrayType = exports.isAnyType = exports["default"] = void 0;

var _chevrotain = __webpack_require__(47);

var _token = __webpack_require__(43);

var _forEach = _interopRequireDefault(__webpack_require__(3));

var _isArray = _interopRequireDefault(__webpack_require__(0));

var _keys = _interopRequireDefault(__webpack_require__(5));

var _findIndex = _interopRequireDefault(__webpack_require__(240));

var _get = _interopRequireDefault(__webpack_require__(85));

var _FormulaParser = _interopRequireDefault(__webpack_require__(69));

var _this = void 0;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

// import FunctionCheck from "./FunctionCheck";

/**
 * 将多个Tokens按照顺序连接
 *
 * @param tokensList
 */
var concatTokens = function concatTokens() {
  var tokens = [];

  for (var _len = arguments.length, tokensList = new Array(_len), _key = 0; _key < _len; _key++) {
    tokensList[_key] = arguments[_key];
  }

  (0, _forEach["default"])(tokensList, function (item) {
    if (item) {
      tokens = tokens.concat(item);
    }
  });
  return tokens;
};
/**
 * 对tokens按照先后位置进行排序
 *
 * @param tokens
 */


var sortTokensByPosition = function sortTokensByPosition(tokens) {
  var result = [].concat(tokens);
  return result.sort(function (a, b) {
    return a.startOffset - b.startOffset;
  });
};
/**
 * 参数类型计算
 *
 * @param op
 * @param left
 * @param right
 */


var transformType = function transformType(op, left, right) {
  switch (op) {
    case "+":
      // 1、操作符两端有一个是文本类型，返回值就是文本类型
      // 2、操作符两端都不是文本类型，且操作符两端都不是数值类型，返回文本类型
      if (isStringType(left) || isStringType(right) || isAnyType(left) && !isNumberType(left) || isAnyType(right) && !isNumberType(right)) {
        return "string";
      }

      return "number";

    case "-":
      if ((!isNumberType(left) && !isDateType(left) || !isNumberType(right) && !isDateType(right)) && !isAnyType(left) && !isAnyType(right)) {
        throw new Error(JSON.stringify({
          type: "visit",
          token: op,
          errorType: "operation",
          errorText: BI.i18nText('BI-Conf_Formula_Valid')
        }));
      }

      return "number";

    case "*":
    case "/":
      if ((!isNumberType(left) || !isNumberType(right)) && !isAnyType(left) && !isAnyType(right)) {
        throw new Error(JSON.stringify({
          type: "visit",
          token: op,
          errorType: "operation",
          errorText: BI.i18nText('BI-Conf_Formula_Valid')
        }));
      }

      return "number";
  }
};
/**
 * 消费一个二元运算符token并计算结果
 *
 * @param sortedTokens
 * @param operands
 * @param consumeToken
 * @param sortedTokens
 * @param operands
 * @param consumeToken
 * @param sortedTokens
 * @param operands
 * @param consumeToken
 */


var consumeBinaryToken = function consumeBinaryToken(sortedTokens, operands, consumeToken) {
  var resultTokens = sortedTokens.slice();
  var resultOperands = operands.slice();
  var tokenNames = sortedTokens.map(function (token) {
    return token.image;
  });
  var index = tokenNames.indexOf(consumeToken.image);

  if (index > -1) {
    var tempOperands = resultOperands.slice().splice(index, 2);
    var left = tempOperands[0];
    var right = tempOperands[1];
    var result = "null";

    if ((0, _chevrotain.tokenMatcher)(consumeToken, _token.token.Addition) || (0, _chevrotain.tokenMatcher)(consumeToken, _token.token.Multiplication)) {
      result = transformType(consumeToken.image, left, right);
    } else if ((0, _chevrotain.tokenMatcher)(consumeToken, _token.token.Compare)) {
      if (left !== null && right !== null && getType(left) !== getType(right)) {
        throw new Error(JSON.stringify({
          type: "visit",
          token: consumeToken.image,
          errorType: "compare",
          errorText: BI.i18nText('BI-Basic_Formula_Invalid')
        }));
      }

      result = "boolean";
    } else if ((0, _chevrotain.tokenMatcher)(consumeToken, _token.token.Equal)) {
      result = "boolean";
    } else if ((0, _chevrotain.tokenMatcher)(consumeToken, _token.token.BitAnd)) {
      result = "string"; // } else if (tokenMatcher(consumeToken, tokenMap.BitOr)) {
      //   result = "number";
    } else if ((0, _chevrotain.tokenMatcher)(consumeToken, _token.token.LogicAnd) || (0, _chevrotain.tokenMatcher)(consumeToken, _token.token.LogicOr)) {
      if (!(isNumberType(left) && isNumberType(right) || isBooleanType(left) && isBooleanType(right))) {
        throw new Error(JSON.stringify({
          type: "visit",
          token: consumeToken.image,
          errorType: "logic",
          errorText: BI.i18nText('BI-Basic_Formula_Invalid')
        }));
      }

      result = left || right;
    }

    resultTokens.splice(index, 1);
    resultOperands.splice(index, 2, result);
  }

  return {
    resultTokens: resultTokens,
    resultOperands: resultOperands
  };
};
/**
 * 获取公式解释器实例
 */


var getFormulaInterpreter = function getFormulaInterpreter() {
  var parser = (0, _FormulaParser["default"])();
  var BaseCstVisitorConstructor = parser.getBaseCstVisitorConstructor();
  var formula;

  var setFormula = function setFormula(f) {
    formula = f;
  };

  var applyFunc = function applyFunc(func, args) {
    if (!formula) {
      throw new Error("Interpreter is not set formula");
    }

    var funcKeys = (0, _keys["default"])(formula);

    if ((0, _findIndex["default"])(funcKeys, function (k) {
      return k === func;
    }) > -1) {
      var f = (0, _get["default"])(formula, func);
      return f.apply(_this, args);
    }

    return null;
  };

  var FormulaVisitor = /*#__PURE__*/function (_BaseCstVisitorConstr) {
    _inheritsLoose(FormulaVisitor, _BaseCstVisitorConstr);

    function FormulaVisitor() {
      var _this2;

      _this2 = _BaseCstVisitorConstr.call(this) || this;

      _this2.validateVisitor();

      return _this2;
    }

    var _proto = FormulaVisitor.prototype;

    _proto.expr = function expr(ctx) {
      return this.visit(ctx.commaExpression);
    };

    _proto.commaExpression = function commaExpression(ctx) {
      var lastCstNode = ctx.binaryExpression.slice(-1)[0];
      return this.visit(lastCstNode);
    };

    _proto.binaryExpression = function binaryExpression(ctx) {
      var _this3 = this;

      var binaryTokens = concatTokens(ctx.Multiplication, ctx.Addition, ctx.Compare, ctx.Equal, ctx.BitAnd, // ctx.BitOr,
      ctx.LogicAnd, ctx.LogicOr);
      var tempTokens = sortTokensByPosition(binaryTokens);
      var tempOperands = [];
      (0, _forEach["default"])(ctx.unaryExpression, function (e) {
        tempOperands.push(_this3.visit(e));
      });
      (0, _forEach["default"])(binaryTokens, function (token) {
        var ret = consumeBinaryToken(tempTokens, tempOperands, token);
        tempTokens = ret.resultTokens;
        tempOperands = ret.resultOperands;
      });
      return tempOperands[0];
    };

    _proto.unaryExpression = function unaryExpression(ctx) {
      var result = this.visit(ctx.atomicExpression);

      if (!ctx.Unary) {
        return result;
      }

      var signs = ctx.Unary.slice().reverse();
      (0, _forEach["default"])(signs, function (sign) {
        if ((0, _chevrotain.tokenMatcher)(sign, _token.token.Minus)) {
          result = "number";
        } else if ((0, _chevrotain.tokenMatcher)(sign, _token.token.Plus)) {
          result = "number";
        } else {
          result = "boolean";
        }
      });
      return result;
    };

    _proto.atomicExpression = function atomicExpression(ctx) {
      var _this4 = this;

      var result;

      if (ctx.base) {
        result = this.visit(ctx.base);
      } else if (ctx.group) {
        result = this.visit(ctx.group);
      } else if (ctx.array) {
        result = this.visit(ctx.array);
      } else if (ctx.func) {
        result = this.visit(ctx.func);
      }

      if (!ctx.expr) {
        return result;
      } else {
        (0, _forEach["default"])(ctx.expr, function (e) {
          var index = _this4.visit(e);

          result = result[index];
        });
        return result;
      }
    };

    _proto.array = function array(ctx) {
      var _this5 = this;

      var result = [];
      (0, _forEach["default"])(ctx.binaryExpression, function (e) {
        result.push(_this5.visit(e));
      });
      return result;
    };

    _proto.func = function func(ctx) {
      var _this6 = this;

      var func = ctx.Func[0].image;
      var args = [];
      (0, _forEach["default"])(ctx.binaryExpression, function (e) {
        args.push(_this6.visit(e));
      });
      return applyFunc(func, args);
    };

    _proto.group = function group(ctx) {
      return this.visit(ctx.expr);
    };

    _proto.base = function base(ctx) {
      if (ctx.String) {
        // 把字符串作为参数返回
        var str = ctx.String[0].image;

        if (str !== null) {
          return "string:".concat(str);
        }

        return "string";
      }

      if (ctx.Number) {
        var num = ctx.Number[0].image;

        if (num !== null) {
          return "number:".concat(num);
        }

        return "number";
      }

      if (ctx.Date) {
        var date = ctx.Date[0].image;

        if (date !== null) {
          return "date:".concat(date);
        }

        return "date";
      }

      if (ctx.Boolean) {
        var bol = ctx.Boolean[0].image;

        if (bol !== null) {
          return "boolean:".concat(bol);
        }

        return "boolean";
      }

      if (ctx.Empty) {
        return "null";
      }

      if (ctx.NaN) {
        return "number";
      }
    };

    return FormulaVisitor;
  }(BaseCstVisitorConstructor);

  return {
    interpreter: new FormulaVisitor(),
    setFormula: setFormula
  };
};
/**
 * 参数是否为数值类型
 *
 * @param param
 * @returns {boolean}
 */


var isNumberType = function isNumberType(param) {
  return param === null || BI.startWith(param, "number") || BI.startWith(param, "boolean");
};
/**
 * 参数是否为字符串类型
 *
 * @param param
 * @returns {boolean}
 */


exports.isNumberType = isNumberType;

var isStringType = function isStringType(param) {
  return param === null || BI.startWith(param, "string");
};
/**
 * 参数是否为布尔类型
 *
 * @param param
 * @returns {boolean}
 */


exports.isStringType = isStringType;

var isBooleanType = function isBooleanType(param) {
  return param === null || BI.startWith(param, "boolean");
};
/**
 * 参数是否为数组类型
 *
 * @param param
 * @returns {boolean}
 */


exports.isBooleanType = isBooleanType;

var isArrayType = function isArrayType(param) {
  return (0, _isArray["default"])(param) || param === null;
};
/**
 * 是否是日期对象类型
 *
 * @param param
 * @returns {boolean}
 */


exports.isArrayType = isArrayType;

var isDateType = function isDateType(param) {
  return param === null || BI.startWith(param, "date");
};
/**
 * 参数是否为任意类型，用于不确定返回值的公式如IF
 * 2022-9-28补充，未定义的函数返回值都是null, 也应该让其通过四则运算
 *
 * @param param
 * @returns {boolean}
 */


exports.isDateType = isDateType;

var isAnyType = function isAnyType(param) {
  return param === "any" || param === null;
};

exports.isAnyType = isAnyType;

var getType = function getType(param) {
  if (isStringType(param)) {
    return 'string';
  }

  if (isNumberType(param)) {
    return 'number';
  }

  if (isDateType(param)) {
    return 'date';
  }

  if (isBooleanType(param)) {
    return 'boolean';
  }

  if (isArrayType(param)) {
    return 'array';
  }

  if (isAnyType(param)) {
    return 'any';
  }

  return undefined;
};

var _default = getFormulaInterpreter;
exports["default"] = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _stickytable = __webpack_require__(42);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @author guy
 * @version 2.0
 * Created by guy on 2022/9/25
 */
var StickyTableHeader = BI.inherit(BI.Widget, {
  props: {
    baseCls: 'bi-sticky-table-header',
    columnSize: [],
    minColumnSize: [],
    maxColumnSize: [],
    freezeCols: [],
    header: [],
    headerRowSize: "auto"
  },
  render: function render() {
    var _this = this;

    var self = this,
        o = this.options;
    this.tds = [];
    return {
      type: "bi.sticky_table_layout",
      sortable: false,
      ref: function ref(_ref) {
        _this.layout = _ref;
      },
      columnSize: o.columnSize,
      freezeCols: o.freezeCols,
      items: this._formatItems(o.header)
    };
  },
  _formatItems: function _formatItems(items) {
    var _this2 = this;

    var o = this.options;
    return items.map(function (tds) {
      return {
        type: "bi.adaptive",
        tagName: "tr",
        height: o.headerRowSize,
        items: tds.map(function (item, i) {
          return {
            type: "bi.default",
            tagName: "td",
            ref: function ref(_ref) {
              _this2.tds[i] = _ref;
            },
            extraCls: o.freezeCols.includes(i) ? i === tds.length - 1 ? "sticky-table-fix-last-col" : "sticky-table-fix-first-col" : "",
            cls: "sticky-table-fix-index-".concat(i, "-col first-row ").concat(i === 0 ? "first-col" : ""),
            css: {
              minWidth: o.minColumnSize[i],
              maxWidth: o.maxColumnSize[i]
            },
            items: [_objectSpread(_objectSpread({}, _stickytable.DEFAULT_CONFIG), item)]
          };
        })
      };
    });
  },
  _populate: function _populate(items) {
    this.layout.populate(this._formatItems(items));
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.layout.setColumnSize(columnSize);
  },
  populate: function populate(items) {
    this._populate(items);
  },
  getRealColumnSize: function getRealColumnSize() {
    return this.tds.map(function (td) {
      return td.element.width();
    });
  }
});
BI.shortcut("bi.sticky_table_header", StickyTableHeader);

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StickyTableLayout = void 0;

var _draggable = __webpack_require__(300);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @author guy
 * @version 2.0
 * Created by guy on 2022/9/25
 */
var StickyTableLayout = BI.inherit(BI.Widget, {
  props: {
    baseCls: 'bi-sticky-table-layout',
    sortable: true,
    checkable: true,
    columnSize: [],
    minColumnSize: [],
    maxColumnSize: [],
    freezeCols: [],
    mirror: {}
  },
  render: function render() {
    var _this = this;

    var self = this,
        o = this.options;
    return {
      type: "bi.default",
      items: [{
        type: 'bi.default',
        tagName: "table",
        ref: function ref(_ref) {
          _this.table = _ref;
        },
        width: BI.sum(o.columnSize),
        cls: "border-sizing",
        css: {
          border: 0,
          borderSpacing: 0,
          borderCollapse: "collapse",
          tableLayout: "fixed",
          minWidth: "100%"
        },
        items: [{
          type: "bi.default",
          ref: function ref(_ref) {
            _this.colgroup = _ref;
          },
          tagName: "colgroup",
          items: this._formatCol(o.columnSize)
        }, {
          type: "bi.default",
          tagName: "tbody",
          ref: function ref(_ref) {
            _this.layout = _ref;
          },
          items: this._formatItems(o.items)
        }]
      }]
    };
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.options.sortable) {
      var draggable = new _draggable.Draggable(this.table.element[0], {
        draggable: 'tr.enabled',
        handle: ".bi-sticky-table-draggable-handler",
        classes: {
          "draggable:over": ["bi-sticky-table-draggable-drag-over"],
          "mirror": ["bi-sticky-table-draggable-mirror"]
        },
        mirror: this.options.mirror
      });
      var lastDragElement;
      var lock = false;
      var lockFn = BI.debounce(function () {
        lock = false;
      }, 300);
      draggable.on("drag:start", function (e) {
        var source = e.data.source; // source.style.visibility = "hidden";

        source.style.transform = "";
        source.style.transitionDuration = "";

        _this2.fireEvent(StickyTableLayout.EVENT_START_DRAG, e.data.source.getAttribute("dataid"));
      });
      draggable.on('drag:stop', function (e) {
        var sourceId = e.data.source.getAttribute("dataid");
        var childNodes = e.data.source.parentElement.childNodes;
        childNodes.forEach(function (node) {
          node.style.visibility = "";
          node.style.transform = "";
          node.style.transitionDuration = ""; // node.style.pointerEvents = "";
        });

        if (!e.data.sourceContainer.contains(e.data.originalSource)) {
          e.data.originalSource.remove();
          e.data.source.remove();
        }

        if (lastDragElement) {
          _this2.fireEvent(StickyTableLayout.EVENT_STOP_DRAG, [sourceId, lastDragElement.getAttribute("dataid")]);
        }

        lastDragElement = null;
      });
      draggable.on("drag:over", function (e) {
        var over = e.data.over;
        var source = e.data.source;
        source.style.visibility = "hidden";

        if (over === source || over === e.data.originalSource) {
          return;
        }

        if (over === lastDragElement) {
          if (lock) {
            return;
          }
        }

        lock = true;
        lockFn();

        if (over.style.transform) {
          over.style.transform = "";

          var _filterNodes = getFilterNodes();

          if (lastDragElement === over) {
            if (_filterNodes[0] === over) {
              lastDragElement = over.nextSibling;
            } else {
              lastDragElement = over.previousSibling;
            }

            if (!lastDragElement) {
              lastDragElement = over;
            }

            return;
          }

          lastDragElement = over;
          return;
        }

        lastDragElement = over;

        function getFilterNodes() {
          var childNodes = over.parentElement.childNodes;
          var startPush = false; // source到over这一段的节点

          var filterNodes = [];
          childNodes.forEach(function (node) {
            if (startPush === true && (node === source || node === over)) {
              startPush = false;
              filterNodes.push(node);
              return;
            }

            if (node === source || node === over) {
              startPush = true;
            }

            if (startPush) {
              filterNodes.push(node);
            } else {
              node.style.transform = "";
            }
          });
          return filterNodes;
        }

        var filterNodes = getFilterNodes();
        var transform = "translateY(-100%)";

        if (filterNodes[0] === over) {
          transform = "translateY(100%)";
        }

        filterNodes.forEach(function (node) {
          if (node === source) {
            return;
          }

          node.style.transform = transform;
          node.style.transitionDuration = "300ms"; // node.style.pointerEvents = "none";
        });
      });
      draggable.on("mirror:created", function (e) {
        var o = _this2.options;
      });
    }
  },
  _formatCol: function _formatCol(columnSize) {
    return columnSize.map(function (width) {
      return {
        type: "bi.default",
        tagName: "col",
        width: width
      };
    });
  },
  _formatItems: function _formatItems(items) {
    var o = this.options;
    return items.map(function (item, i) {
      return _objectSpread(_objectSpread({
        isNeedFreeze: o.isNeedFreeze,
        draggable: o.sortable,
        checkable: o.checkable,
        freezeCols: o.freezeCols,
        columnSize: o.columnSize,
        minColumnSize: o.minColumnSize,
        maxColumnSize: o.maxColumnSize,
        attributes: {
          dataid: item.id
        }
      }, item), {}, {
        cls: "".concat(item.cls || "", " ").concat(i % 2 ? "even" : "odd")
      });
    });
  },
  _populate: function _populate(items) {
    this.layout.populate(this._formatItems(items));
  },
  setColumnSize: function setColumnSize(columnSize) {
    var o = this.options;
    o.columnSize = columnSize;
    this.colgroup.populate(this._formatCol(o.columnSize));
    this.table.setWidth(BI.sum(o.columnSize));
  },
  addItems: function addItems(items) {
    this.layout.addItems(this._formatItems(items));
  },
  populate: function populate(items) {
    this._populate(items);
  }
});
exports.StickyTableLayout = StickyTableLayout;
StickyTableLayout.EVENT_START_DRAG = "EVENT_START_DRAG";
StickyTableLayout.EVENT_STOP_DRAG = "EVENT_STOP_DRAG";
BI.shortcut("bi.sticky_table_layout", StickyTableLayout);

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(29),
    nativeKeys = __webpack_require__(389);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19),
    root = __webpack_require__(10);
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsTypedArray = __webpack_require__(401),
    baseUnary = __webpack_require__(31),
    nodeUtil = __webpack_require__(50);
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(51),
    stackClear = __webpack_require__(409),
    stackDelete = __webpack_require__(410),
    stackGet = __webpack_require__(411),
    stackHas = __webpack_require__(412),
    stackSet = __webpack_require__(413);
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var mapCacheClear = __webpack_require__(414),
    mapCacheDelete = __webpack_require__(421),
    mapCacheGet = __webpack_require__(423),
    mapCacheHas = __webpack_require__(424),
    mapCacheSet = __webpack_require__(425);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(78),
    setCacheAdd = __webpack_require__(427),
    setCacheHas = __webpack_require__(428);
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayFilter = __webpack_require__(84),
    stubArray = __webpack_require__(219);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(86);
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(56),
    toKey = __webpack_require__(34);
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var isArray = __webpack_require__(0),
    isSymbol = __webpack_require__(57);
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defineProperty = __webpack_require__(227);
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Uint8Array = __webpack_require__(216);
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestWalker = void 0;

var drop_1 = __importDefault(__webpack_require__(91));

var forEach_1 = __importDefault(__webpack_require__(3));

var gast_1 = __webpack_require__(2);
/**
 *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.
 */


var RestWalker =
/** @class */
function () {
  function RestWalker() {}

  RestWalker.prototype.walk = function (prod, prevRest) {
    var _this = this;

    if (prevRest === void 0) {
      prevRest = [];
    }

    (0, forEach_1["default"])(prod.definition, function (subProd, index) {
      var currRest = (0, drop_1["default"])(prod.definition, index + 1);
      /* istanbul ignore else */

      if (subProd instanceof gast_1.NonTerminal) {
        _this.walkProdRef(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.Terminal) {
        _this.walkTerminal(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.Alternative) {
        _this.walkFlat(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.Option) {
        _this.walkOption(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.RepetitionMandatory) {
        _this.walkAtLeastOne(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
        _this.walkAtLeastOneSep(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
        _this.walkManySep(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.Repetition) {
        _this.walkMany(subProd, currRest, prevRest);
      } else if (subProd instanceof gast_1.Alternation) {
        _this.walkOr(subProd, currRest, prevRest);
      } else {
        throw Error("non exhaustive match");
      }
    });
  };

  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};

  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};

  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {
    // ABCDEF => after the D the rest is EF
    var fullOrRest = currRest.concat(prevRest);
    this.walk(flatProd, fullOrRest);
  };

  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
    // ABC(DE)?F => after the (DE)? the rest is F
    var fullOrRest = currRest.concat(prevRest);
    this.walk(optionProd, fullOrRest);
  };

  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F
    var fullAtLeastOneRest = [new gast_1.Option({
      definition: atLeastOneProd.definition
    })].concat(currRest, prevRest);
    this.walk(atLeastOneProd, fullAtLeastOneRest);
  };

  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F
    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
  };

  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
    // ABC(DE)*F => after the (DE)* the rest is (DE)?F
    var fullManyRest = [new gast_1.Option({
      definition: manyProd.definition
    })].concat(currRest, prevRest);
    this.walk(manyProd, fullManyRest);
  };

  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F
    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
    this.walk(manySepProd, fullManySepRest);
  };

  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {
    var _this = this; // ABC(D|E|F)G => when finding the (D|E|F) the rest is G


    var fullOrRest = currRest.concat(prevRest); // walk all different alternatives

    (0, forEach_1["default"])(orProd.definition, function (alt) {
      // wrapping each alternative in a single definition wrapper
      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows
      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1
      var prodWrapper = new gast_1.Alternative({
        definition: [alt]
      });

      _this.walk(prodWrapper, fullOrRest);
    });
  };

  return RestWalker;
}();

exports.RestWalker = RestWalker;

function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
  var repSepRest = [new gast_1.Option({
    definition: [new gast_1.Terminal({
      terminalType: repSepProd.separator
    })].concat(repSepProd.definition)
  })];
  var fullRepSepRest = repSepRest.concat(currRest, prevRest);
  return fullRepSepRest;
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSlice = __webpack_require__(92),
    toInteger = __webpack_require__(38);
/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */


function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return [];
  }

  n = guard || n === undefined ? 1 : toInteger(n);
  return baseSlice(array, n < 0 ? 0 : n, length);
}

module.exports = drop;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }

  end = end > length ? length : end;

  if (end < 0) {
    end += length;
  }

  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);

  while (++index < length) {
    result[index] = array[index + start];
  }

  return result;
}

module.exports = baseSlice;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var isString_1 = __importDefault(__webpack_require__(39));

var isRegExp_1 = __importDefault(__webpack_require__(231));

var pickBy_1 = __importDefault(__webpack_require__(232));

var assign_1 = __importDefault(__webpack_require__(60)); // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?


function tokenLabel(tokType) {
  if (hasTokenLabel(tokType)) {
    return tokType.LABEL;
  } else {
    return tokType.name;
  }
} // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?


function hasTokenLabel(obj) {
  return (0, isString_1["default"])(obj.LABEL) && obj.LABEL !== "";
}

var AbstractProduction =
/** @class */
function () {
  function AbstractProduction(_definition) {
    this._definition = _definition;
  }

  Object.defineProperty(AbstractProduction.prototype, "definition", {
    get: function get() {
      return this._definition;
    },
    set: function set(value) {
      this._definition = value;
    },
    enumerable: false,
    configurable: true
  });

  AbstractProduction.prototype.accept = function (visitor) {
    visitor.visit(this);
    (0, forEach_1["default"])(this.definition, function (prod) {
      prod.accept(visitor);
    });
  };

  return AbstractProduction;
}();

exports.AbstractProduction = AbstractProduction;

var NonTerminal =
/** @class */
function (_super) {
  __extends(NonTerminal, _super);

  function NonTerminal(options) {
    var _this = _super.call(this, []) || this;

    _this.idx = 1;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  Object.defineProperty(NonTerminal.prototype, "definition", {
    get: function get() {
      if (this.referencedRule !== undefined) {
        return this.referencedRule.definition;
      }

      return [];
    },
    set: function set(definition) {// immutable
    },
    enumerable: false,
    configurable: true
  });

  NonTerminal.prototype.accept = function (visitor) {
    visitor.visit(this); // don't visit children of a reference, we will get cyclic infinite loops if we do so
  };

  return NonTerminal;
}(AbstractProduction);

exports.NonTerminal = NonTerminal;

var Rule =
/** @class */
function (_super) {
  __extends(Rule, _super);

  function Rule(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.orgText = "";
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return Rule;
}(AbstractProduction);

exports.Rule = Rule;

var Alternative =
/** @class */
function (_super) {
  __extends(Alternative, _super);

  function Alternative(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.ignoreAmbiguities = false;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return Alternative;
}(AbstractProduction);

exports.Alternative = Alternative;

var Option =
/** @class */
function (_super) {
  __extends(Option, _super);

  function Option(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.idx = 1;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return Option;
}(AbstractProduction);

exports.Option = Option;

var RepetitionMandatory =
/** @class */
function (_super) {
  __extends(RepetitionMandatory, _super);

  function RepetitionMandatory(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.idx = 1;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return RepetitionMandatory;
}(AbstractProduction);

exports.RepetitionMandatory = RepetitionMandatory;

var RepetitionMandatoryWithSeparator =
/** @class */
function (_super) {
  __extends(RepetitionMandatoryWithSeparator, _super);

  function RepetitionMandatoryWithSeparator(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.idx = 1;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return RepetitionMandatoryWithSeparator;
}(AbstractProduction);

exports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;

var Repetition =
/** @class */
function (_super) {
  __extends(Repetition, _super);

  function Repetition(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.idx = 1;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return Repetition;
}(AbstractProduction);

exports.Repetition = Repetition;

var RepetitionWithSeparator =
/** @class */
function (_super) {
  __extends(RepetitionWithSeparator, _super);

  function RepetitionWithSeparator(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.idx = 1;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  return RepetitionWithSeparator;
}(AbstractProduction);

exports.RepetitionWithSeparator = RepetitionWithSeparator;

var Alternation =
/** @class */
function (_super) {
  __extends(Alternation, _super);

  function Alternation(options) {
    var _this = _super.call(this, options.definition) || this;

    _this.idx = 1;
    _this.ignoreAmbiguities = false;
    _this.hasPredicates = false;
    (0, assign_1["default"])(_this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
    return _this;
  }

  Object.defineProperty(Alternation.prototype, "definition", {
    get: function get() {
      return this._definition;
    },
    set: function set(value) {
      this._definition = value;
    },
    enumerable: false,
    configurable: true
  });
  return Alternation;
}(AbstractProduction);

exports.Alternation = Alternation;

var Terminal =
/** @class */
function () {
  function Terminal(options) {
    this.idx = 1;
    (0, assign_1["default"])(this, (0, pickBy_1["default"])(options, function (v) {
      return v !== undefined;
    }));
  }

  Terminal.prototype.accept = function (visitor) {
    visitor.visit(this);
  };

  return Terminal;
}();

exports.Terminal = Terminal;

function serializeGrammar(topRules) {
  return (0, map_1["default"])(topRules, serializeProduction);
}

exports.serializeGrammar = serializeGrammar;

function serializeProduction(node) {
  function convertDefinition(definition) {
    return (0, map_1["default"])(definition, serializeProduction);
  }
  /* istanbul ignore else */


  if (node instanceof NonTerminal) {
    var serializedNonTerminal = {
      type: "NonTerminal",
      name: node.nonTerminalName,
      idx: node.idx
    };

    if ((0, isString_1["default"])(node.label)) {
      serializedNonTerminal.label = node.label;
    }

    return serializedNonTerminal;
  } else if (node instanceof Alternative) {
    return {
      type: "Alternative",
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Option) {
    return {
      type: "Option",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof RepetitionMandatory) {
    return {
      type: "RepetitionMandatory",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof RepetitionMandatoryWithSeparator) {
    return {
      type: "RepetitionMandatoryWithSeparator",
      idx: node.idx,
      separator: serializeProduction(new Terminal({
        terminalType: node.separator
      })),
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof RepetitionWithSeparator) {
    return {
      type: "RepetitionWithSeparator",
      idx: node.idx,
      separator: serializeProduction(new Terminal({
        terminalType: node.separator
      })),
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Repetition) {
    return {
      type: "Repetition",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Alternation) {
    return {
      type: "Alternation",
      idx: node.idx,
      definition: convertDefinition(node.definition)
    };
  } else if (node instanceof Terminal) {
    var serializedTerminal = {
      type: "Terminal",
      name: node.terminalType.name,
      label: tokenLabel(node.terminalType),
      idx: node.idx
    };

    if ((0, isString_1["default"])(node.label)) {
      serializedTerminal.terminalLabel = node.label;
    }

    var pattern = node.terminalType.PATTERN;

    if (node.terminalType.PATTERN) {
      serializedTerminal.pattern = (0, isRegExp_1["default"])(pattern) ? pattern.source : pattern;
    }

    return serializedTerminal;
  } else if (node instanceof Rule) {
    return {
      type: "Rule",
      name: node.name,
      orgText: node.orgText,
      definition: convertDefinition(node.definition)
    };
  } else {
    throw Error("non exhaustive match");
  }
}

exports.serializeProduction = serializeProduction;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(35),
    overRest = __webpack_require__(484),
    setToString = __webpack_require__(486);
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arraySome = __webpack_require__(215),
    baseIteratee = __webpack_require__(13),
    baseSome = __webpack_require__(492),
    isArray = __webpack_require__(0),
    isIterateeCall = __webpack_require__(61);
/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */


function some(collection, predicate, guard) {
  var func = isArray(collection) ? arraySome : baseSome;

  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }

  return func(collection, baseIteratee(predicate, 3));
}

module.exports = some;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFindIndex = __webpack_require__(233),
    baseIsNaN = __webpack_require__(495),
    strictIndexOf = __webpack_require__(496);
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(82),
    isFlattenable = __webpack_require__(497);
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseUniq = __webpack_require__(498);
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */


function uniq(array) {
  return array && array.length ? baseUniq(array) : [];
}

module.exports = uniq;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

;

(function (root, factory) {
  // istanbul ignore next
  if (true) {
    // istanbul ignore next
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(typeof self !== "undefined" ? // istanbul ignore next
self : void 0, function () {
  // references
  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983
  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern
  function RegExpParser() {}

  RegExpParser.prototype.saveState = function () {
    return {
      idx: this.idx,
      input: this.input,
      groupIdx: this.groupIdx
    };
  };

  RegExpParser.prototype.restoreState = function (newState) {
    this.idx = newState.idx;
    this.input = newState.input;
    this.groupIdx = newState.groupIdx;
  };

  RegExpParser.prototype.pattern = function (input) {
    // parser state
    this.idx = 0;
    this.input = input;
    this.groupIdx = 0;
    this.consumeChar("/");
    var value = this.disjunction();
    this.consumeChar("/");
    var flags = {
      type: "Flags",
      loc: {
        begin: this.idx,
        end: input.length
      },
      global: false,
      ignoreCase: false,
      multiLine: false,
      unicode: false,
      sticky: false
    };

    while (this.isRegExpFlag()) {
      switch (this.popChar()) {
        case "g":
          addFlag(flags, "global");
          break;

        case "i":
          addFlag(flags, "ignoreCase");
          break;

        case "m":
          addFlag(flags, "multiLine");
          break;

        case "u":
          addFlag(flags, "unicode");
          break;

        case "y":
          addFlag(flags, "sticky");
          break;
      }
    }

    if (this.idx !== this.input.length) {
      throw Error("Redundant input: " + this.input.substring(this.idx));
    }

    return {
      type: "Pattern",
      flags: flags,
      value: value,
      loc: this.loc(0)
    };
  };

  RegExpParser.prototype.disjunction = function () {
    var alts = [];
    var begin = this.idx;
    alts.push(this.alternative());

    while (this.peekChar() === "|") {
      this.consumeChar("|");
      alts.push(this.alternative());
    }

    return {
      type: "Disjunction",
      value: alts,
      loc: this.loc(begin)
    };
  };

  RegExpParser.prototype.alternative = function () {
    var terms = [];
    var begin = this.idx;

    while (this.isTerm()) {
      terms.push(this.term());
    }

    return {
      type: "Alternative",
      value: terms,
      loc: this.loc(begin)
    };
  };

  RegExpParser.prototype.term = function () {
    if (this.isAssertion()) {
      return this.assertion();
    } else {
      return this.atom();
    }
  };

  RegExpParser.prototype.assertion = function () {
    var begin = this.idx;

    switch (this.popChar()) {
      case "^":
        return {
          type: "StartAnchor",
          loc: this.loc(begin)
        };

      case "$":
        return {
          type: "EndAnchor",
          loc: this.loc(begin)
        };
      // '\b' or '\B'

      case "\\":
        switch (this.popChar()) {
          case "b":
            return {
              type: "WordBoundary",
              loc: this.loc(begin)
            };

          case "B":
            return {
              type: "NonWordBoundary",
              loc: this.loc(begin)
            };
        } // istanbul ignore next


        throw Error("Invalid Assertion Escape");
      // '(?=' or '(?!'

      case "(":
        this.consumeChar("?");
        var type;

        switch (this.popChar()) {
          case "=":
            type = "Lookahead";
            break;

          case "!":
            type = "NegativeLookahead";
            break;
        }

        ASSERT_EXISTS(type);
        var disjunction = this.disjunction();
        this.consumeChar(")");
        return {
          type: type,
          value: disjunction,
          loc: this.loc(begin)
        };
    } // istanbul ignore next


    ASSERT_NEVER_REACH_HERE();
  };

  RegExpParser.prototype.quantifier = function (isBacktracking) {
    var range;
    var begin = this.idx;

    switch (this.popChar()) {
      case "*":
        range = {
          atLeast: 0,
          atMost: Infinity
        };
        break;

      case "+":
        range = {
          atLeast: 1,
          atMost: Infinity
        };
        break;

      case "?":
        range = {
          atLeast: 0,
          atMost: 1
        };
        break;

      case "{":
        var atLeast = this.integerIncludingZero();

        switch (this.popChar()) {
          case "}":
            range = {
              atLeast: atLeast,
              atMost: atLeast
            };
            break;

          case ",":
            var atMost;

            if (this.isDigit()) {
              atMost = this.integerIncludingZero();
              range = {
                atLeast: atLeast,
                atMost: atMost
              };
            } else {
              range = {
                atLeast: atLeast,
                atMost: Infinity
              };
            }

            this.consumeChar("}");
            break;
        } // throwing exceptions from "ASSERT_EXISTS" during backtracking
        // causes severe performance degradations


        if (isBacktracking === true && range === undefined) {
          return undefined;
        }

        ASSERT_EXISTS(range);
        break;
    } // throwing exceptions from "ASSERT_EXISTS" during backtracking
    // causes severe performance degradations


    if (isBacktracking === true && range === undefined) {
      return undefined;
    }

    ASSERT_EXISTS(range);

    if (this.peekChar(0) === "?") {
      this.consumeChar("?");
      range.greedy = false;
    } else {
      range.greedy = true;
    }

    range.type = "Quantifier";
    range.loc = this.loc(begin);
    return range;
  };

  RegExpParser.prototype.atom = function () {
    var atom;
    var begin = this.idx;

    switch (this.peekChar()) {
      case ".":
        atom = this.dotAll();
        break;

      case "\\":
        atom = this.atomEscape();
        break;

      case "[":
        atom = this.characterClass();
        break;

      case "(":
        atom = this.group();
        break;
    }

    if (atom === undefined && this.isPatternCharacter()) {
      atom = this.patternCharacter();
    }

    ASSERT_EXISTS(atom);
    atom.loc = this.loc(begin);

    if (this.isQuantifier()) {
      atom.quantifier = this.quantifier();
    }

    return atom;
  };

  RegExpParser.prototype.dotAll = function () {
    this.consumeChar(".");
    return {
      type: "Set",
      complement: true,
      value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
    };
  };

  RegExpParser.prototype.atomEscape = function () {
    this.consumeChar("\\");

    switch (this.peekChar()) {
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        return this.decimalEscapeAtom();

      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();

      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();

      case "c":
        return this.controlLetterEscapeAtom();

      case "0":
        return this.nulCharacterAtom();

      case "x":
        return this.hexEscapeSequenceAtom();

      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();

      default:
        return this.identityEscapeAtom();
    }
  };

  RegExpParser.prototype.decimalEscapeAtom = function () {
    var value = this.positiveInteger();
    return {
      type: "GroupBackReference",
      value: value
    };
  };

  RegExpParser.prototype.characterClassEscape = function () {
    var set;
    var complement = false;

    switch (this.popChar()) {
      case "d":
        set = digitsCharCodes;
        break;

      case "D":
        set = digitsCharCodes;
        complement = true;
        break;

      case "s":
        set = whitespaceCodes;
        break;

      case "S":
        set = whitespaceCodes;
        complement = true;
        break;

      case "w":
        set = wordCharCodes;
        break;

      case "W":
        set = wordCharCodes;
        complement = true;
        break;
    }

    ASSERT_EXISTS(set);
    return {
      type: "Set",
      value: set,
      complement: complement
    };
  };

  RegExpParser.prototype.controlEscapeAtom = function () {
    var escapeCode;

    switch (this.popChar()) {
      case "f":
        escapeCode = cc("\f");
        break;

      case "n":
        escapeCode = cc("\n");
        break;

      case "r":
        escapeCode = cc("\r");
        break;

      case "t":
        escapeCode = cc("\t");
        break;

      case "v":
        escapeCode = cc("\v");
        break;
    }

    ASSERT_EXISTS(escapeCode);
    return {
      type: "Character",
      value: escapeCode
    };
  };

  RegExpParser.prototype.controlLetterEscapeAtom = function () {
    this.consumeChar("c");
    var letter = this.popChar();

    if (/[a-zA-Z]/.test(letter) === false) {
      throw Error("Invalid ");
    }

    var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
    return {
      type: "Character",
      value: letterCode
    };
  };

  RegExpParser.prototype.nulCharacterAtom = function () {
    // TODO implement '[lookahead ∉ DecimalDigit]'
    // TODO: for the deprecated octal escape sequence
    this.consumeChar("0");
    return {
      type: "Character",
      value: cc("\0")
    };
  };

  RegExpParser.prototype.hexEscapeSequenceAtom = function () {
    this.consumeChar("x");
    return this.parseHexDigits(2);
  };

  RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function () {
    this.consumeChar("u");
    return this.parseHexDigits(4);
  };

  RegExpParser.prototype.identityEscapeAtom = function () {
    // TODO: implement "SourceCharacter but not UnicodeIDContinue"
    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
    var escapedChar = this.popChar();
    return {
      type: "Character",
      value: cc(escapedChar)
    };
  };

  RegExpParser.prototype.classPatternCharacterAtom = function () {
    switch (this.peekChar()) {
      // istanbul ignore next
      case "\n": // istanbul ignore next

      case "\r": // istanbul ignore next

      case "\u2028": // istanbul ignore next

      case "\u2029": // istanbul ignore next

      case "\\": // istanbul ignore next

      case "]":
        throw Error("TBD");

      default:
        var nextChar = this.popChar();
        return {
          type: "Character",
          value: cc(nextChar)
        };
    }
  };

  RegExpParser.prototype.characterClass = function () {
    var set = [];
    var complement = false;
    this.consumeChar("[");

    if (this.peekChar(0) === "^") {
      this.consumeChar("^");
      complement = true;
    }

    while (this.isClassAtom()) {
      var from = this.classAtom();
      var isFromSingleChar = from.type === "Character";

      if (isFromSingleChar && this.isRangeDash()) {
        this.consumeChar("-");
        var to = this.classAtom();
        var isToSingleChar = to.type === "Character"; // a range can only be used when both sides are single characters

        if (isToSingleChar) {
          if (to.value < from.value) {
            throw Error("Range out of order in character class");
          }

          set.push({
            from: from.value,
            to: to.value
          });
        } else {
          // literal dash
          insertToSet(from.value, set);
          set.push(cc("-"));
          insertToSet(to.value, set);
        }
      } else {
        insertToSet(from.value, set);
      }
    }

    this.consumeChar("]");
    return {
      type: "Set",
      complement: complement,
      value: set
    };
  };

  RegExpParser.prototype.classAtom = function () {
    switch (this.peekChar()) {
      // istanbul ignore next
      case "]": // istanbul ignore next

      case "\n": // istanbul ignore next

      case "\r": // istanbul ignore next

      case "\u2028": // istanbul ignore next

      case "\u2029":
        throw Error("TBD");

      case "\\":
        return this.classEscape();

      default:
        return this.classPatternCharacterAtom();
    }
  };

  RegExpParser.prototype.classEscape = function () {
    this.consumeChar("\\");

    switch (this.peekChar()) {
      // Matches a backspace.
      // (Not to be confused with \b word boundary outside characterClass)
      case "b":
        this.consumeChar("b");
        return {
          type: "Character",
          value: cc("\b")
        };

      case "d":
      case "D":
      case "s":
      case "S":
      case "w":
      case "W":
        return this.characterClassEscape();

      case "f":
      case "n":
      case "r":
      case "t":
      case "v":
        return this.controlEscapeAtom();

      case "c":
        return this.controlLetterEscapeAtom();

      case "0":
        return this.nulCharacterAtom();

      case "x":
        return this.hexEscapeSequenceAtom();

      case "u":
        return this.regExpUnicodeEscapeSequenceAtom();

      default:
        return this.identityEscapeAtom();
    }
  };

  RegExpParser.prototype.group = function () {
    var capturing = true;
    this.consumeChar("(");

    switch (this.peekChar(0)) {
      case "?":
        this.consumeChar("?");
        this.consumeChar(":");
        capturing = false;
        break;

      default:
        this.groupIdx++;
        break;
    }

    var value = this.disjunction();
    this.consumeChar(")");
    var groupAst = {
      type: "Group",
      capturing: capturing,
      value: value
    };

    if (capturing) {
      groupAst.idx = this.groupIdx;
    }

    return groupAst;
  };

  RegExpParser.prototype.positiveInteger = function () {
    var number = this.popChar(); // istanbul ignore next - can't ever get here due to previous lookahead checks
    // still implementing this error checking in case this ever changes.

    if (decimalPatternNoZero.test(number) === false) {
      throw Error("Expecting a positive integer");
    }

    while (decimalPattern.test(this.peekChar(0))) {
      number += this.popChar();
    }

    return parseInt(number, 10);
  };

  RegExpParser.prototype.integerIncludingZero = function () {
    var number = this.popChar();

    if (decimalPattern.test(number) === false) {
      throw Error("Expecting an integer");
    }

    while (decimalPattern.test(this.peekChar(0))) {
      number += this.popChar();
    }

    return parseInt(number, 10);
  };

  RegExpParser.prototype.patternCharacter = function () {
    var nextChar = this.popChar();

    switch (nextChar) {
      // istanbul ignore next
      case "\n": // istanbul ignore next

      case "\r": // istanbul ignore next

      case "\u2028": // istanbul ignore next

      case "\u2029": // istanbul ignore next

      case "^": // istanbul ignore next

      case "$": // istanbul ignore next

      case "\\": // istanbul ignore next

      case ".": // istanbul ignore next

      case "*": // istanbul ignore next

      case "+": // istanbul ignore next

      case "?": // istanbul ignore next

      case "(": // istanbul ignore next

      case ")": // istanbul ignore next

      case "[": // istanbul ignore next

      case "|":
        // istanbul ignore next
        throw Error("TBD");

      default:
        return {
          type: "Character",
          value: cc(nextChar)
        };
    }
  };

  RegExpParser.prototype.isRegExpFlag = function () {
    switch (this.peekChar(0)) {
      case "g":
      case "i":
      case "m":
      case "u":
      case "y":
        return true;

      default:
        return false;
    }
  };

  RegExpParser.prototype.isRangeDash = function () {
    return this.peekChar() === "-" && this.isClassAtom(1);
  };

  RegExpParser.prototype.isDigit = function () {
    return decimalPattern.test(this.peekChar(0));
  };

  RegExpParser.prototype.isClassAtom = function (howMuch) {
    if (howMuch === undefined) {
      howMuch = 0;
    }

    switch (this.peekChar(howMuch)) {
      case "]":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        return false;

      default:
        return true;
    }
  };

  RegExpParser.prototype.isTerm = function () {
    return this.isAtom() || this.isAssertion();
  };

  RegExpParser.prototype.isAtom = function () {
    if (this.isPatternCharacter()) {
      return true;
    }

    switch (this.peekChar(0)) {
      case ".":
      case "\\": // atomEscape

      case "[": // characterClass
      // TODO: isAtom must be called before isAssertion - disambiguate

      case "(":
        // group
        return true;

      default:
        return false;
    }
  };

  RegExpParser.prototype.isAssertion = function () {
    switch (this.peekChar(0)) {
      case "^":
      case "$":
        return true;
      // '\b' or '\B'

      case "\\":
        switch (this.peekChar(1)) {
          case "b":
          case "B":
            return true;

          default:
            return false;
        }

      // '(?=' or '(?!'

      case "(":
        return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");

      default:
        return false;
    }
  };

  RegExpParser.prototype.isQuantifier = function () {
    var prevState = this.saveState();

    try {
      return this.quantifier(true) !== undefined;
    } catch (e) {
      return false;
    } finally {
      this.restoreState(prevState);
    }
  };

  RegExpParser.prototype.isPatternCharacter = function () {
    switch (this.peekChar()) {
      case "^":
      case "$":
      case "\\":
      case ".":
      case "*":
      case "+":
      case "?":
      case "(":
      case ")":
      case "[":
      case "|":
      case "/":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        return false;

      default:
        return true;
    }
  };

  RegExpParser.prototype.parseHexDigits = function (howMany) {
    var hexString = "";

    for (var i = 0; i < howMany; i++) {
      var hexChar = this.popChar();

      if (hexDigitPattern.test(hexChar) === false) {
        throw Error("Expecting a HexDecimal digits");
      }

      hexString += hexChar;
    }

    var charCode = parseInt(hexString, 16);
    return {
      type: "Character",
      value: charCode
    };
  };

  RegExpParser.prototype.peekChar = function (howMuch) {
    if (howMuch === undefined) {
      howMuch = 0;
    }

    return this.input[this.idx + howMuch];
  };

  RegExpParser.prototype.popChar = function () {
    var nextChar = this.peekChar(0);
    this.consumeChar();
    return nextChar;
  };

  RegExpParser.prototype.consumeChar = function (_char) {
    if (_char !== undefined && this.input[this.idx] !== _char) {
      throw Error("Expected: '" + _char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
    }

    if (this.idx >= this.input.length) {
      throw Error("Unexpected end of input");
    }

    this.idx++;
  };

  RegExpParser.prototype.loc = function (begin) {
    return {
      begin: begin,
      end: this.idx
    };
  }; // consts and utilities


  var hexDigitPattern = /[0-9a-fA-F]/;
  var decimalPattern = /[0-9]/;
  var decimalPatternNoZero = /[1-9]/;

  function cc(_char2) {
    return _char2.charCodeAt(0);
  }

  function insertToSet(item, set) {
    if (item.length !== undefined) {
      item.forEach(function (subItem) {
        set.push(subItem);
      });
    } else {
      set.push(item);
    }
  }

  function addFlag(flagObj, flagKey) {
    if (flagObj[flagKey] === true) {
      throw "duplicate flag " + flagKey;
    }

    flagObj[flagKey] = true;
  }

  function ASSERT_EXISTS(obj) {
    // istanbul ignore next
    if (obj === undefined) {
      throw Error("Internal Error - Should never get here!");
    }
  } // istanbul ignore next


  function ASSERT_NEVER_REACH_HERE() {
    throw Error("Internal Error - Should never get here!");
  }

  var i;
  var digitsCharCodes = [];

  for (i = cc("0"); i <= cc("9"); i++) {
    digitsCharCodes.push(i);
  }

  var wordCharCodes = [cc("_")].concat(digitsCharCodes);

  for (i = cc("a"); i <= cc("z"); i++) {
    wordCharCodes.push(i);
  }

  for (i = cc("A"); i <= cc("Z"); i++) {
    wordCharCodes.push(i);
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes


  var whitespaceCodes = [cc(" "), cc("\f"), cc("\n"), cc("\r"), cc("\t"), cc("\v"), cc("\t"), cc("\xA0"), cc("\u1680"), cc("\u2000"), cc("\u2001"), cc("\u2002"), cc("\u2003"), cc("\u2004"), cc("\u2005"), cc("\u2006"), cc("\u2007"), cc("\u2008"), cc("\u2009"), cc("\u200A"), cc("\u2028"), cc("\u2029"), cc("\u202F"), cc("\u205F"), cc("\u3000"), cc("\uFEFF")];

  function BaseRegExpVisitor() {}

  BaseRegExpVisitor.prototype.visitChildren = function (node) {
    for (var key in node) {
      var child = node[key];
      /* istanbul ignore else */

      if (node.hasOwnProperty(key)) {
        if (child.type !== undefined) {
          this.visit(child);
        } else if (Array.isArray(child)) {
          child.forEach(function (subChild) {
            this.visit(subChild);
          }, this);
        }
      }
    }
  };

  BaseRegExpVisitor.prototype.visit = function (node) {
    switch (node.type) {
      case "Pattern":
        this.visitPattern(node);
        break;

      case "Flags":
        this.visitFlags(node);
        break;

      case "Disjunction":
        this.visitDisjunction(node);
        break;

      case "Alternative":
        this.visitAlternative(node);
        break;

      case "StartAnchor":
        this.visitStartAnchor(node);
        break;

      case "EndAnchor":
        this.visitEndAnchor(node);
        break;

      case "WordBoundary":
        this.visitWordBoundary(node);
        break;

      case "NonWordBoundary":
        this.visitNonWordBoundary(node);
        break;

      case "Lookahead":
        this.visitLookahead(node);
        break;

      case "NegativeLookahead":
        this.visitNegativeLookahead(node);
        break;

      case "Character":
        this.visitCharacter(node);
        break;

      case "Set":
        this.visitSet(node);
        break;

      case "Group":
        this.visitGroup(node);
        break;

      case "GroupBackReference":
        this.visitGroupBackReference(node);
        break;

      case "Quantifier":
        this.visitQuantifier(node);
        break;
    }

    this.visitChildren(node);
  };

  BaseRegExpVisitor.prototype.visitPattern = function (node) {};

  BaseRegExpVisitor.prototype.visitFlags = function (node) {};

  BaseRegExpVisitor.prototype.visitDisjunction = function (node) {};

  BaseRegExpVisitor.prototype.visitAlternative = function (node) {}; // Assertion


  BaseRegExpVisitor.prototype.visitStartAnchor = function (node) {};

  BaseRegExpVisitor.prototype.visitEndAnchor = function (node) {};

  BaseRegExpVisitor.prototype.visitWordBoundary = function (node) {};

  BaseRegExpVisitor.prototype.visitNonWordBoundary = function (node) {};

  BaseRegExpVisitor.prototype.visitLookahead = function (node) {};

  BaseRegExpVisitor.prototype.visitNegativeLookahead = function (node) {}; // atoms


  BaseRegExpVisitor.prototype.visitCharacter = function (node) {};

  BaseRegExpVisitor.prototype.visitSet = function (node) {};

  BaseRegExpVisitor.prototype.visitGroup = function (node) {};

  BaseRegExpVisitor.prototype.visitGroupBackReference = function (node) {};

  BaseRegExpVisitor.prototype.visitQuantifier = function (node) {};

  return {
    RegExpParser: RegExpParser,
    BaseRegExpVisitor: BaseRegExpVisitor,
    VERSION: "0.5.0"
  };
});

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayFilter = __webpack_require__(84),
    baseFilter = __webpack_require__(239),
    baseIteratee = __webpack_require__(13),
    isArray = __webpack_require__(0),
    negate = __webpack_require__(501);
/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */


function reject(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, negate(baseIteratee(predicate, 3)));
}

module.exports = reject;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseDifference = __webpack_require__(502),
    baseFlatten = __webpack_require__(97),
    baseRest = __webpack_require__(94),
    isArrayLikeObject = __webpack_require__(503);
/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */


var difference = baseRest(function (array, values) {
  return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
});
module.exports = difference;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createFind = __webpack_require__(505),
    findIndex = __webpack_require__(240);
/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */


var find = createFind(findIndex);
module.exports = find;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayFilter = __webpack_require__(84),
    baseFilter = __webpack_require__(239),
    baseIteratee = __webpack_require__(13),
    isArray = __webpack_require__(0);
/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */


function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearRegExpParserCache = exports.getRegExpAst = void 0;

var regexp_to_ast_1 = __webpack_require__(100);

var regExpAstCache = {};
var regExpParser = new regexp_to_ast_1.RegExpParser();

function getRegExpAst(regExp) {
  var regExpStr = regExp.toString();

  if (regExpAstCache.hasOwnProperty(regExpStr)) {
    return regExpAstCache[regExpStr];
  } else {
    var regExpAst = regExpParser.pattern(regExpStr);
    regExpAstCache[regExpStr] = regExpAst;
    return regExpAst;
  }
}

exports.getRegExpAst = getRegExpAst;

function clearRegExpParserCache() {
  regExpAstCache = {};
}

exports.clearRegExpParserCache = clearRegExpParserCache;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSlice = __webpack_require__(92),
    toInteger = __webpack_require__(38);
/**
 * Creates a slice of `array` with `n` elements dropped from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.dropRight([1, 2, 3]);
 * // => [1, 2]
 *
 * _.dropRight([1, 2, 3], 2);
 * // => [1]
 *
 * _.dropRight([1, 2, 3], 5);
 * // => []
 *
 * _.dropRight([1, 2, 3], 0);
 * // => [1, 2, 3]
 */


function dropRight(array, n, guard) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return [];
  }

  n = guard || n === undefined ? 1 : toInteger(n);
  n = length - n;
  return baseSlice(array, 0, n < 0 ? 0 : n);
}

module.exports = dropRight;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Lookahead keys are 32Bit integers in the form
// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX
// XXXX -> Occurrence Index bitmap.
// YYYY -> DSL Method Type bitmap.
// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.
// TTTTTTTTT -> alternation alternative index bitmap

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getKeyForAutomaticLookahead = exports.AT_LEAST_ONE_SEP_IDX = exports.MANY_SEP_IDX = exports.AT_LEAST_ONE_IDX = exports.MANY_IDX = exports.OPTION_IDX = exports.OR_IDX = exports.BITS_FOR_ALT_IDX = exports.BITS_FOR_RULE_IDX = exports.BITS_FOR_OCCURRENCE_IDX = exports.BITS_FOR_METHOD_TYPE = void 0;
exports.BITS_FOR_METHOD_TYPE = 4;
exports.BITS_FOR_OCCURRENCE_IDX = 8;
exports.BITS_FOR_RULE_IDX = 12; // TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.

exports.BITS_FOR_ALT_IDX = 8; // short string used as part of mapping keys.
// being short improves the performance when composing KEYS for maps out of these
// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)

exports.OR_IDX = 1 << exports.BITS_FOR_OCCURRENCE_IDX;
exports.OPTION_IDX = 2 << exports.BITS_FOR_OCCURRENCE_IDX;
exports.MANY_IDX = 3 << exports.BITS_FOR_OCCURRENCE_IDX;
exports.AT_LEAST_ONE_IDX = 4 << exports.BITS_FOR_OCCURRENCE_IDX;
exports.MANY_SEP_IDX = 5 << exports.BITS_FOR_OCCURRENCE_IDX;
exports.AT_LEAST_ONE_SEP_IDX = 6 << exports.BITS_FOR_OCCURRENCE_IDX; // this actually returns a number, but it is always used as a string (object prop key)

function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
  return occurrence | dslMethodIdx | ruleIdx;
}

exports.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
var BITS_START_FOR_ALT_IDX = 32 - exports.BITS_FOR_ALT_IDX;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsZWJ = "\\u200d";
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */

function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.headerItemsData = exports.defaultHeaderItems = void 0;
var defaultHeaderItems = ["add", "delete", "moveUp", "moveDown", "refresh"];
exports.defaultHeaderItems = defaultHeaderItems;
var headerItemsData = [{
  type: "add",
  cls: "text-add-tip-font",
  title: "BI-Basic_Parameter_Insert",
  event: "EVENT_INSERT"
}, {
  type: "delete",
  cls: "close-font bi-error",
  title: "BI-Basic_Parameter_Delete",
  event: "EVENT_DELETE"
}, {
  type: "moveUp",
  cls: "add-up-font",
  title: "BI-Basic_Parameter_Move_Up",
  event: "EVENT_MOVE_UP"
}, {
  type: "moveDown",
  cls: "minus-down-font",
  title: "BI-Basic_Parameter_Move_Down",
  event: "EVENT_MOVE_DOWN"
}, {
  type: "refresh",
  cls: "parameter-refresh-font",
  title: "BI-Basic_Parameter_Refresh",
  event: "EVENT_REFRESH"
}];
exports.headerItemsData = headerItemsData;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token = __webpack_require__(43);

var _chevrotain = __webpack_require__(47);

var _FormulaParser = _interopRequireDefault(__webpack_require__(69));

var _FormulaInterpreter = _interopRequireDefault(__webpack_require__(70));

var _FunctionCheck = _interopRequireDefault(__webpack_require__(112));

var _get = _interopRequireDefault(__webpack_require__(85));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * 表单公式计算
 */
var FormulaCheck = /*#__PURE__*/function () {
  var _proto = FormulaCheck.prototype;

  _proto.setFormula = function setFormula() {};

  function FormulaCheck(checker) {
    this.checker = checker;
    this.lexer = new _chevrotain.Lexer(_token.allTokens, {
      ensureOptimizations: true
    });
    this.parser = (0, _FormulaParser["default"])();

    var _getFormulaInterprete = (0, _FormulaInterpreter["default"])(),
        interpreter = _getFormulaInterprete.interpreter,
        setFormula = _getFormulaInterprete.setFormula;

    this.interpreter = interpreter;
    this.setFormula = setFormula;
  }

  _proto.parse = function parse(input) {
    // 设置公式对象
    this.setFormula(new _FunctionCheck["default"](this.checker)); // 词法分析，产生tokens

    var lexResult = this.lexer.tokenize(input);

    if (lexResult.errors.length > 0) {
      var error = lexResult.errors[0];
      throw new Error(JSON.stringify({
        type: "lexer",
        name: error.message,
        token: (0, _get["default"])(error.message.match(/->(.)<-/), [1], ""),
        errorText: BI.i18nText('BI-Expression_syntax_error')
      }));
    } // 将tokens传入parser，生成具体语法树


    this.parser.input = lexResult.tokens;
    var cst = this.parser.expr();

    if (this.parser.errors.length > 0) {
      var _error = this.parser.errors[0];
      throw new Error(JSON.stringify({
        type: "parser",
        name: _error.name,
        token: (0, _get["default"])(_error.message.match(/->\s(\w+)\s<-/), [1], (0, _get["default"])(_error, "previousToken.image") || (0, _get["default"])(_error, "token.image")),
        errorText: BI.i18nText('BI-Expression_syntax_error')
      }));
    } // 遍历语法树，产生解析结果


    return this.interpreter.visit(cst);
  };

  return FormulaCheck;
}();

var _default = FormulaCheck;
exports["default"] = _default;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _size = _interopRequireDefault(__webpack_require__(538));

var _forEach = _interopRequireDefault(__webpack_require__(3));

var _isUndefined = _interopRequireDefault(__webpack_require__(22));

var _FormulaInterpreter = __webpack_require__(70);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FunctionCheck = function FunctionCheck(tempCheckers) {
  _defineProperty(this, "LOG", function () {
    checkParamsType({
      name: "LOG",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param);
      },
      minCount: 1,
      optionalCount: 1,
      paramType: [["number"], ["number", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_number_number_default', "LOG")
    });
    return "number";
  });

  _defineProperty(this, "log", this.LOG);

  _defineProperty(this, "MAX", function () {
    checkParamsType({
      name: "MAX",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isArrayType)(param);
      },
      minCount: 1,
      paramType: ["number", ["array"]],
      errorText: BI.i18nText('BI-Front-Expression_param_all_number', "MAX")
    });
    return "number";
  });

  _defineProperty(this, "max", this.MAX);

  _defineProperty(this, "MIN", function () {
    checkParamsType({
      name: "MIN",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isArrayType)(param);
      },
      minCount: 1,
      paramType: ["number", ["array"]],
      errorText: BI.i18nText('BI-Front-Expression_param_all_number', "MIN")
    });
    return "number";
  });

  _defineProperty(this, "min", this.MIN);

  _defineProperty(this, "RAND", function () {
    checkParamsType({
      name: "RAND",
      params: arguments,
      paramCount: 0,
      errorText: BI.i18nText('BI-Front-Expression_param_none', "RAND")
    });
    return "number";
  });

  _defineProperty(this, "rand", this.RAND);

  _defineProperty(this, "TRUNC", function () {
    checkParamsType({
      name: "TRUNC",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param);
      },
      minCount: 1,
      optionalCount: 1,
      paramType: [["number"], ["number", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_number_number_default', "TRUNC")
    });
    return "number";
  });

  _defineProperty(this, "trunc", this.TRUNC);

  _defineProperty(this, "DATE", function () {
    checkParamsType({
      name: "DATE",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 3,
      paramType: [["number", "string"], ["number", "string"], ["number", "string"]],
      errorText: BI.i18nText('BI-Front-Expression_param_multi_number_or_text', "DATE")
    });
    return "date";
  });

  _defineProperty(this, "date", this.DATE);

  _defineProperty(this, "DATEDELTA", function () {
    checkParamsType({
      name: "DATEDELTA",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
        }

        return (0, _FormulaInterpreter.isNumberType)(param);
      },
      paramCount: 2,
      paramType: [["string", "date"], ["number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_or_text_number', 'DATEDELTA')
    });
    return "date";
  });

  _defineProperty(this, "datedelta", this.DATEDELTA);

  _defineProperty(this, "DATEDIF", function () {
    checkParamsType({
      name: "DATEDIF",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 2) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 3,
      paramType: [["string", "date"], ["string", "date"], ["number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_two_date_text_and_text', "DATEDIF")
    });
    return "number";
  });

  _defineProperty(this, "datedif", this.DATEDIF);

  _defineProperty(this, "DATESUBDATE", function () {
    checkParamsType({
      name: "DATESUBDATE",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 2) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 3,
      paramType: [["string", "date"], ["string", "date"], ["number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_two_date_text_and_text', 'DATESUBDATE')
    });
    return "number";
  });

  _defineProperty(this, "datesubdate", this.DATESUBDATE);

  _defineProperty(this, "DATETONUMBER", function () {
    checkParamsType({
      name: "DATETONUMBER",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 1,
      paramType: [["string", "date"]],
      errorText: BI.i18nText('BI-Front-Expression_param_one_date_or_text', 'DATETONUMBER')
    });
    return "number";
  });

  _defineProperty(this, "datetonumber", this.DATETONUMBER);

  _defineProperty(this, "DAY", function () {
    checkParamsType({
      name: "DAY",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param);
      },
      minCount: 0,
      optionalCount: 2,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'DAY')
    });
    return "number";
  });

  _defineProperty(this, "day", this.DAY);

  _defineProperty(this, "DAYS360", function () {
    checkParamsType({
      name: "DAYS360",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 2) {
          return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isBooleanType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 2,
      paramType: [["string", "date"], ["string", "date"], ["string", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_two_dateText_textNumber_default', 'DAYS360')
    });
    return "number";
  });

  _defineProperty(this, "days360", this.DAYS360);

  _defineProperty(this, "DAYSOFMONTH", function () {
    checkParamsType({
      name: "DAYSOFMONTH",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 1,
      paramType: [["string", "date"]],
      errorText: BI.i18nText('BI-Front-Expression_param_one_date_or_text', 'DAYSOFMONTH')
    });
    return "number";
  });

  _defineProperty(this, "daysofmonth", this.DAYSOFMONTH);

  _defineProperty(this, "DAYSOFQUARTER", function () {
    checkParamsType({
      name: "DAYSOFQUARTER",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 1,
      paramType: [["string", "date"]],
      errorText: BI.i18nText('BI-Front-Expression_param_one_date_or_text', 'DAYSOFQUARTER')
    });
    return "number";
  });

  _defineProperty(this, "daysofquarter", this.DAYSOFQUARTER);

  _defineProperty(this, "DAYVALUE", function () {
    checkParamsType({
      name: "DAYVALUE",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 1,
      paramType: [["string", "date"]],
      errorText: BI.i18nText('BI-Front-Expression_param_one_date_or_text', 'DAYVALUE')
    });
    return "number";
  });

  _defineProperty(this, "dayvalue", this.DAYVALUE);

  _defineProperty(this, "HOUR", function () {
    checkParamsType({
      name: "HOUR",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      optionalCount: 2,
      paramType: [[], [["string", "number"]], [["string", "number"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'HOUR')
    });
    return "number";
  });

  _defineProperty(this, "hour", this.HOUR);

  _defineProperty(this, "LUNAR", function () {
    checkParamsType({
      name: "LUNAR",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 3,
      paramType: [["string", "number"], ["string", "number"], ["string", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_multi_number_or_text', 'LUNAR')
    });
    return "string";
  });

  _defineProperty(this, "lunar", this.LUNAR);

  _defineProperty(this, "MINUTE", function () {
    checkParamsType({
      name: "MINUTE",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      optionalCount: 2,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'MINUTE')
    });
    return "number";
  });

  _defineProperty(this, "minute", this.MINUTE);

  _defineProperty(this, "MONTH", function () {
    checkParamsType({
      name: "MONTH",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      optionalCount: 2,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'MONTH')
    });
    return "number";
  });

  _defineProperty(this, "month", this.MONTH);

  _defineProperty(this, "MONTHDELTA", function () {
    checkParamsType({
      name: "MONTHDELTA",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 2,
      paramType: [["string", "date"], ["number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_or_text_number', 'MONTHDELTA')
    });
    return "date";
  });

  _defineProperty(this, "monthdelta", this.MONTHDELTA);

  _defineProperty(this, "NOW", function () {
    checkParamsType({
      name: "NOW",
      params: arguments,
      paramCount: 0,
      errorText: BI.i18nText('BI-Front-Expression_param_none', 'NOW')
    });
    return "date";
  });

  _defineProperty(this, "now", this.NOW);

  _defineProperty(this, "QUARTER", function () {
    checkParamsType({
      name: "QUARTER",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      optionalCount: 2,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'QUARTER')
    });
    return "number";
  });

  _defineProperty(this, "quarter", this.QUARTER);

  _defineProperty(this, "SECOND", function () {
    checkParamsType({
      name: "SECOND",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      optionalCount: 2,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'SECOND')
    });
    return "number";
  });

  _defineProperty(this, "second", this.SECOND);

  _defineProperty(this, "TIME", function () {
    checkParamsType({
      name: "TIME",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 3,
      paramType: [["string", "number"], ["string", "number"], ["string", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_multi_number_or_text', 'TIME')
    });
    return "date";
  });

  _defineProperty(this, "time", this.TIME);

  _defineProperty(this, "TODATE", function () {
    checkParamsType({
      name: "TODATE",
      params: arguments,
      checkFunction: function checkFunction(param, index, params) {
        if (params.length === 1 && index === 0) {
          return true;
        }

        return (0, _FormulaInterpreter.isStringType)(param);
      },
      minCount: 1,
      optionalCount: 2,
      paramType: [["any"], ["string", "string"], ["string", "string", "string"]],
      errorText: BI.i18nText('BI-Front-Expression_param_to_date', 'TODATE')
    });
    return "date";
  });

  _defineProperty(this, "todate", this.TODATE);

  _defineProperty(this, "TODAY", function () {
    checkParamsType({
      name: "TODAY",
      params: arguments,
      paramCount: 0,
      errorText: BI.i18nText('BI-Front-Expression_param_none', 'TODAY')
    });
    return "date";
  });

  _defineProperty(this, "today", this.TODAY);

  _defineProperty(this, "WEEK", function () {
    checkParamsType({
      name: "WEEK",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'WEEK')
    });
    return "number";
  });

  _defineProperty(this, "week", this.WEEK);

  _defineProperty(this, "WEEKDATE", function () {
    checkParamsType({
      name: "WEEKDATE",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param) || (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 4,
      paramType: [["string", "number"], ["string", "number"], ["string", "number"], ["string", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_four_number_or_text', 'WEEKDATE')
    });
    return "date";
  });

  _defineProperty(this, "weekdate", this.WEEKDATE);

  _defineProperty(this, "WEEKDAY", function () {
    checkParamsType({
      name: "WEEKDAY",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      paramCount: 1,
      paramType: [["string", "date"]],
      errorText: BI.i18nText('BI-Front-Expression_param_one_date_or_text', 'WEEKDAY')
    });
    return "number";
  });

  _defineProperty(this, "weekday", this.WEEKDAY);

  _defineProperty(this, "YEAR", function () {
    checkParamsType({
      name: "YEAR",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
      },
      minCount: 0,
      paramType: [[], [["string", "date"]], [["string", "date"], ["string"]]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_precision', 'YEAR')
    });
    return "number";
  });

  _defineProperty(this, "year", this.YEAR);

  _defineProperty(this, "YEARDELTA", function () {
    checkParamsType({
      name: "YEARDELTA",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return (0, _FormulaInterpreter.isStringType)(param) || (0, _FormulaInterpreter.isDateType)(param);
        }

        return (0, _FormulaInterpreter.isNumberType)(param);
      },
      paramCount: 2,
      paramType: [["string", "date"], ["number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_date_or_text_number', 'YEARDELTA')
    });
    return "date";
  });

  _defineProperty(this, "yeardelta", this.YEARDELTA);

  _defineProperty(this, "CHAR", function () {
    checkParamsType({
      name: "CHAR",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isNumberType)(param);
      },
      paramCount: 1,
      paramType: ["number"],
      errorText: BI.i18nText('BI-Front-Expression_param_number', 'CHAR')
    });
    return "string";
  });

  _defineProperty(this, "char", this.CHAR);

  _defineProperty(this, "CODE", function () {
    checkParamsType({
      name: "CODE",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 1,
      paramType: ["string"],
      errorText: BI.i18nText('BI-Front-Expression_param_text', 'CODE')
    });
    return "number";
  });

  _defineProperty(this, "code", this.CODE);

  _defineProperty(this, "CONCATENATE", function () {
    checkParamsType({
      name: "CONCATENATE",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      minCount: 1,
      paramType: ["any"],
      errorText: BI.i18nText('BI-Front-Expression_param_multi_any_type', 'CONCATENATE')
    });
    return "string";
  });

  _defineProperty(this, "concatenate", this.CONCATENATE);

  _defineProperty(this, "ENDWITH", function () {
    checkParamsType({
      name: "ENDWITH",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      paramCount: 2,
      paramType: ["any", "any"],
      errorText: BI.i18nText('BI-Front-Expression_param_two_any', 'ENDWITH')
    });
    return "number";
  });

  _defineProperty(this, "endwith", this.ENDWITH);

  _defineProperty(this, "EXACT", function () {
    checkParamsType({
      name: "EXACT",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      paramCount: 2,
      paramType: ["any", "any"],
      errorText: BI.i18nText('BI-Front-Expression_param_two_any', 'EXACT')
    });
    return "number";
  });

  _defineProperty(this, "exact", this.EXACT);

  _defineProperty(this, "FIND", function () {
    checkParamsType({
      name: "FIND",
      params: arguments,
      checkFunction: function checkFunction(param, index, params) {
        if (index === 2) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      minCount: 2,
      optionalCount: 1,
      paramType: [["any", "any"], ["any", "any", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_two_any_number_default', 'FIND')
    });
    return "number";
  });

  _defineProperty(this, "find", this.FIND);

  _defineProperty(this, "FORMAT", function () {
    checkParamsType({
      name: "FORMAT",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isStringType)(param);
        }

        return true;
      },
      paramCount: 2,
      paramType: ["any", "string"],
      errorText: BI.i18nText('BI-Front-Expression_param_any_text', 'FORMAT')
    });
    return "string";
  });

  _defineProperty(this, "format", this.FORMAT);

  _defineProperty(this, "INDEXOF", function () {
    checkParamsType({
      name: "INDEXOF",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      paramCount: 2,
      paramType: ["any", "number"],
      errorText: BI.i18nText('BI-Front-Expression_param_any_number', 'INDEXOF')
    });
    return "string";
  });

  _defineProperty(this, "indexof", this.INDEXOF);

  _defineProperty(this, "LEFT", function () {
    checkParamsType({
      name: "LEFT",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      minCount: 1,
      optionalCount: 1,
      paramType: [["any"], ["any", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_any_number_default', 'LEFT')
    });
    return "string";
  });

  _defineProperty(this, "left", this.LEFT);

  _defineProperty(this, "LEN", function () {
    checkParamsType({
      name: "LEN",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return true;
      },
      paramCount: 1,
      paramType: ["any"],
      errorText: BI.i18nText('BI-Front-Expression_param_one_any_type', 'LEN')
    });
    return "number";
  });

  _defineProperty(this, "len", this.LEN);

  _defineProperty(this, "LOWER", function () {
    checkParamsType({
      name: "LOWER",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 1,
      paramType: ["string"],
      errorText: BI.i18nText('BI-Front-Expression_param_text', 'LOWER')
    });
    return "string";
  });

  _defineProperty(this, "lower", this.LOWER);

  _defineProperty(this, "MID", function () {
    checkParamsType({
      name: "MID",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return true;
        }

        return (0, _FormulaInterpreter.isNumberType)(param);
      },
      paramCount: 3,
      paramType: ["any", "number", "number"],
      errorText: BI.i18nText('BI-Front-Expression_param_any_number_number', 'MID')
    });
    return "string";
  });

  _defineProperty(this, "mid", this.MID);

  _defineProperty(this, "NUMTO", function () {
    checkParamsType({
      name: "NUMTO",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return (0, _FormulaInterpreter.isBooleanType)(param) || (0, _FormulaInterpreter.isNumberType)(param); // 兼容BI, BI因为没有布尔类型字段, NUMBER类型是可以作为BOOL使用
      },
      minCount: 1,
      optionalCount: 1,
      paramType: [["number"], ["number", "boolean"]],
      errorText: BI.i18nText('BI-Front-Expression_param_number_bool_default', 'NUMTO')
    });
    return "string";
  });

  _defineProperty(this, "numto", this.NUMTO);

  _defineProperty(this, "PROPER", function () {
    checkParamsType({
      name: "PROPER",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 1,
      paramType: ["string"],
      errorText: BI.i18nText('BI-Front-Expression_param_text', 'PROPER')
    });
    return "string";
  });

  _defineProperty(this, "proper", this.PROPER);

  _defineProperty(this, "REGEXP", function () {
    checkParamsType({
      name: "REGEXP",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 2) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return (0, _FormulaInterpreter.isStringType)(param);
      },
      minCount: 2,
      optionalCount: 1,
      paramType: [["string", "string"], ["string", "string", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_text_text_number_default', 'REGEXP')
    });
    return "string";
  });

  _defineProperty(this, "regexp", this.REGEXP);

  _defineProperty(this, "REPEAT", function () {
    checkParamsType({
      name: "REPEAT",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      paramCount: 2,
      paramType: ["any", "number"],
      errorText: BI.i18nText('BI-Front-Expression_param_any_number', 'REPEAT')
    });
    return "string";
  });

  _defineProperty(this, "repeat", this.REPEAT);

  _defineProperty(this, "REPLACE", function () {
    checkParamsType({
      name: "REPLACE",
      params: arguments,
      checkFunction: function checkFunction(param, index, params) {
        if (params.length === 3) {
          return true;
        }

        if (index === 1 || index === 2) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      minCount: 3,
      optionalCount: 1,
      paramType: [["any", "any", "any"], ["any", "number", "number", "any"]],
      errorText: BI.i18nText('BI-Front-Expression_param_three_text_or_text_two_number_text', 'REPLACE')
    });
    return "string";
  });

  _defineProperty(this, "replace", this.REPLACE);

  _defineProperty(this, "RIGHT", function () {
    checkParamsType({
      name: "RIGHT",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 1) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      minCount: 1,
      optionalCount: 1,
      paramType: [["any"], ["any", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_any_number_default', 'RIGHT')
    });
    return "string";
  });

  _defineProperty(this, "right", this.RIGHT);

  _defineProperty(this, "SPLIT", function () {
    checkParamsType({
      name: "SPLIT",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      paramCount: 2,
      paramType: ["any", "any"],
      errorText: BI.i18nText('BI-Front-Expression_param_two_any', 'SPLIT')
    });
    return "array";
  });

  _defineProperty(this, "split", this.SPLIT);

  _defineProperty(this, "STARTWITH", function () {
    checkParamsType({
      name: "STARTWITH",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        return true;
      },
      paramCount: 2,
      paramType: ["any", "any"],
      errorText: BI.i18nText('BI-Front-Expression_param_two_any', 'STARTWITH')
    });
    return "number";
  });

  _defineProperty(this, "startwith", this.STARTWITH);

  _defineProperty(this, "SUBSTITUTE", function () {
    checkParamsType({
      name: "SUBSTITUTE",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 3) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      minCount: 3,
      optionalCount: 1,
      paramType: [["any", "any", "any"], ["any", "any", "any", "number"]],
      errorText: BI.i18nText('BI-Front-Expression_param_three_any_number_default', 'SUBSTITUTE')
    });
    return "string";
  });

  _defineProperty(this, "substitute", this.SUBSTITUTE);

  _defineProperty(this, "TODOUBLE", function () {
    checkParamsType({
      name: "TODOUBLE",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      paramCount: 1,
      paramType: ["any"],
      errorText: BI.i18nText('BI-Front-Expression_param_one_any_type', 'TODOUBLE')
    });
    return "number";
  });

  _defineProperty(this, "todouble", this.TODOUBLE);

  _defineProperty(this, "TOINTEGER", function () {
    checkParamsType({
      name: "TOINTEGER",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      paramCount: 1,
      paramType: ["any"],
      errorText: BI.i18nText('BI-Front-Expression_param_one_any_type', 'TOINTEGER')
    });
    return "number";
  });

  _defineProperty(this, "tointeger", this.TOINTEGER);

  _defineProperty(this, "TRIM", function () {
    checkParamsType({
      name: "TRIM",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 1,
      paramType: ["string"],
      errorText: BI.i18nText('BI-Front-Expression_param_text', 'TRIM')
    });
    return "string";
  });

  _defineProperty(this, "trim", this.TRIM);

  _defineProperty(this, "UPPER", function () {
    checkParamsType({
      name: "UPPER",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isStringType)(param);
      },
      paramCount: 1,
      paramType: ["string"],
      errorText: BI.i18nText('BI-Front-Expression_param_text', 'UPPER')
    });
    return "string";
  });

  _defineProperty(this, "upper", this.UPPER);

  _defineProperty(this, "AND", function () {
    checkParamsType({
      name: "AND",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isBooleanType)(param) || (0, _FormulaInterpreter.isNumberType)(param);
      },
      minCount: 0,
      paramType: ["any"]
    });
    return "number";
  });

  _defineProperty(this, "and", this.AND);

  _defineProperty(this, "OR", function () {
    checkParamsType({
      name: "OR",
      params: arguments,
      checkFunction: function checkFunction(param) {
        return (0, _FormulaInterpreter.isBooleanType)(param) || (0, _FormulaInterpreter.isNumberType)(param);
      },
      minCount: 0,
      paramType: ["any"]
    });
    return "number";
  });

  _defineProperty(this, "or", this.OR);

  _defineProperty(this, "IF", function () {
    checkParamsType({
      name: "IF",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return (0, _FormulaInterpreter.isBooleanType)(param) || (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      paramCount: 3,
      paramType: [["boolean", "number"], "any", "any"],
      errorText: BI.i18nText('BI-Front-Expression_logic_if_three_param', 'IF')
    });
    return "any";
  });

  _defineProperty(this, "if", this.IF);

  _defineProperty(this, "SWITCH", function () {
    checkParamsType({
      name: "SWITCH",
      params: arguments,
      checkFunction: function checkFunction(param, index) {
        if (index === 0) {
          return (0, _FormulaInterpreter.isBooleanType)(param) || (0, _FormulaInterpreter.isNumberType)(param);
        }

        return true;
      },
      minCount: 3,
      paramType: [["boolean", "number"], "any", "any"],
      errorText: BI.i18nText('BI-Front-Expression_logic_switch_le_three_param', 'SWITCH')
    });
    return "any";
  });

  _defineProperty(this, "switch", this.SWITCH);

  _defineProperty(this, "ISNULL", function () {
    checkParamsType({
      name: "ISNULL",
      params: arguments,
      checkFunction: function checkFunction() {
        return true;
      },
      minCount: 1,
      paramType: ["any"],
      errorText: BI.i18nText('BI-Front-Expression_param_multi_any_type', 'ISNULL')
    });
    return "number";
  });

  _defineProperty(this, "isnull", this.ISNULL);

  _defineProperty(this, "NVL", function () {
    var error = false;
    var params = [].slice.call(arguments);
    var types = [];
    params.forEach(function (p) {
      if (p !== null && p !== undefined && !types.includes(p)) {
        types.push(p);
      }
    });

    if (types.length > 1) {
      error = true;
    }

    checkParamsType({
      name: "NVL",
      params: arguments,
      checkFunction: function checkFunction() {
        return !error;
      },
      minCount: 1,
      paramType: ["any"],
      errorText: BI.i18nText('BI-Front-Expression_nvl_param_same', 'ISNULL')
    });
    return "any";
  });

  _defineProperty(this, "nvl", this.NVL);

  var self = this;
  ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CEILING", "COS", "DEGREES", "EXP", "FACT", "FLOOR", "INT", "LN", "LOG10", "PI", "RADIANS", "SIGN", "SIN", "SORT", "TAN"].forEach(function (name) {
    self[name] = self[name.toLowerCase()] = function () {
      checkParamsType({
        name: name,
        params: arguments,
        checkFunction: function checkFunction(param) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        },
        paramCount: 1,
        paramType: ["number"],
        errorText: BI.i18nText('BI-Front-Expression_param_number', name)
      });
      return "number";
    };
  });
  ["MOD", "POWER", "PROMOTION", "RANBETWEEN", "ROUND", "SIGN", "SIN", "SORT", "TAN"].forEach(function (name) {
    self[name] = self[name.toLowerCase()] = function () {
      checkParamsType({
        name: name,
        params: arguments,
        checkFunction: function checkFunction(param) {
          return (0, _FormulaInterpreter.isNumberType)(param);
        },
        paramCount: 2,
        paramType: ["number", "number"],
        errorText: BI.i18nText("BI-Front-Expression_param_two_number", name)
      });
      return "number";
    };
  });
  var checkers = BI.Providers.getProvider("bi.formula_editor.checker");
  BI.each(checkers, function (name, checker) {
    self[name] = self[name.toLowerCase()] = checker;
  });
  BI.each(tempCheckers, function (name, checker) {
    self[name] = self[name.toLowerCase()] = checker;
  });
}
/**
 * 数学函数－对数
 *
 * @returns {boolean}
 */
;
/**
 * 校验函数的参数个数及类型是否正确
 *
 * @param config.name 函数名
 * @param config.params 函数参数
 * @param config.checkFunction 参数类型校验函数
 * @param config.paramCount 必填参数个数
 * @param config.minCount 最少必填参数个数
 * @param config.paramType 参数类型
 * @param config.optionalCount 可选参数个数
 * @param config.isSupportDynamic 是否支持动态参数
 * @param config.errorText 错误提示文本
 * @param config
 */


exports["default"] = FunctionCheck;

var checkParamsType = function checkParamsType(config) {
  if (!(0, _isUndefined["default"])(config.paramCount) && (0, _size["default"])(config.params) !== config.paramCount || !(0, _isUndefined["default"])(config.minCount) && (0, _size["default"])(config.params) < config.minCount || !(0, _isUndefined["default"])(config.minCount) && !(0, _isUndefined["default"])(config.optionalCount) && (0, _size["default"])(config.params) > config.minCount + config.optionalCount) {
    throw new Error(JSON.stringify({
      type: "function",
      name: config.name,
      paramCount: config.paramCount,
      minCount: config.minCount,
      optionalCount: config.optionalCount,
      errorType: "paramCount",
      errorText: config.errorText
    }));
  } // 公式有可能会添加一些不作为参数的字段，用于动态取数，所以只校验需要校验的位数


  var needCheckCount = config.minCount + (config.optionalCount || 0); // 公式如果不支持动态取数，则校验所有的参数

  var supportDynamic = !!config.isSupportDynamic;
  (0, _forEach["default"])(config.params, function (p, i) {
    if (i + 1 > needCheckCount && supportDynamic) {
      return false;
    }

    if (!config.checkFunction(p, i, config.params) && !(0, _FormulaInterpreter.isAnyType)(p)) {
      throw new Error(JSON.stringify({
        type: "function",
        name: config.name,
        paramIndex: i + 1,
        paramType: config.paramType,
        errorType: "paramType",
        errorText: config.errorText
      }));
    }
  });
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Created by richie on 15/7/8.
 */

/**
 * 初始化BI对象
 */
var _global;

if (typeof window !== "undefined") {
  _global = window;
} else if (typeof global !== "undefined") {
  _global = global;
} else if (typeof self !== "undefined") {
  _global = self;
} else {
  _global = void 0;
}

if (_global.BI == null) {
  _global.BI = {
    prepares: []
  };
}

if (_global.BI.prepares == null) {
  _global.BI.prepares = [];
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(68)))

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Constants used for time computations */
Date.SECOND = 1000;
Date.MINUTE = 60 * Date.SECOND;
Date.HOUR = 60 * Date.MINUTE;
Date.DAY = 24 * Date.HOUR;
Date.WEEK = 7 * Date.DAY;
/**
 * 获取时区
 * @returns {String}
 */

Object.defineProperty(Date.prototype, 'getTimezone', {
  value: function value() {
    return BI.getTimezone(this);
  }
});
/** Returns the number of days in the current month */

Object.defineProperty(Date.prototype, 'getMonthDays', {
  value: function value(month) {
    return BI.getMonthDays(this, month);
  }
});
/**
 * 获取每月的最后一天
 * @returns {Date}
 */

Object.defineProperty(Date.prototype, 'getLastDateOfMonth', {
  value: function value() {
    return BI.getLastDateOfMonth(this);
  }
});
/** Returns the number of day in the year. */

Object.defineProperty(Date.prototype, 'getDayOfYear', {
  value: function value() {
    return BI.getDayOfYear(this);
  }
});
/** Returns the number of the week in year, as defined in ISO 8601. */

Object.defineProperty(Date.prototype, 'getWeekNumber', {
  value: function value() {
    return BI.getWeekNumber(this);
  }
});
Object.defineProperty(Date.prototype, 'getQuarter', {
  value: function value() {
    return BI.getQuarter(this);
  }
}); // 离当前时间多少天的时间

Object.defineProperty(Date.prototype, 'getOffsetDate', {
  value: function value(offset) {
    return BI.getOffsetDate(this, offset);
  }
});
Object.defineProperty(Date.prototype, 'getOffsetQuarter', {
  value: function value(n) {
    return BI.getOffsetQuarter(this, n);
  }
}); // 得到本季度的起始月份

Object.defineProperty(Date.prototype, 'getQuarterStartMonth', {
  value: function value() {
    return BI.getQuarter(this);
  }
}); // 获得本季度的起始日期

Object.defineProperty(Date.prototype, 'getQuarterStartDate', {
  value: function value() {
    return BI.getQuarterStartDate(this);
  }
}); // 得到本季度的结束日期

Object.defineProperty(Date.prototype, 'getQuarterEndDate', {
  value: function value() {
    return BI.getQuarterEndDate(this);
  }
}); // 指定日期n个月之前或之后的日期

Object.defineProperty(Date.prototype, 'getOffsetMonth', {
  value: function value(n) {
    return BI.getOffsetMonth(this, n);
  }
}); // 获得本周的起始日期

Object.defineProperty(Date.prototype, 'getWeekStartDate', {
  value: function value() {
    return BI.getWeekStartDate(this);
  }
}); // 得到本周的结束日期

Object.defineProperty(Date.prototype, 'getWeekEndDate', {
  value: function value() {
    return BI.getWeekEndDate(this);
  }
}); // 格式化打印日期

Object.defineProperty(Date.prototype, 'print', {
  value: function value(str) {
    return BI.print(this, str);
  }
});

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Function.prototype.before = function (func) {
  return BI.beforeFunc(this, func);
};

Function.prototype.after = function (func) {
  return BI.afterFunc(this, func);
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 ** 加法函数，用来得到精确的加法结果
 ** 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。
 ** 调用：accAdd(arg1,arg2)
 ** 返回值：arg1加上arg2的精确结果
 **/
// 给Number类型增加一个add方法，调用起来更加方便。
Number.prototype.add = function (arg) {
  return BI.add(this, arg);
};
/**
 ** 减法函数，用来得到精确的减法结果
 ** 说明：javascript的减法结果会有误差，在两个浮点数相减的时候会比较明显。这个函数返回较为精确的减法结果。
 ** 调用：accSub(arg1,arg2)
 ** 返回值：arg1加上arg2的精确结果
 **/
// 给Number类型增加一个mul方法，调用起来更加方便。


Number.prototype.sub = function (arg) {
  return BI.sub(this, arg);
};
/**
 ** 乘法函数，用来得到精确的乘法结果
 ** 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。
 ** 调用：accMul(arg1,arg2)
 ** 返回值：arg1乘以 arg2的精确结果
 **/
// 给Number类型增加一个mul方法，调用起来更加方便。


Number.prototype.mul = function (arg) {
  return BI.mul(this, arg);
}; // 给Number类型增加一个div方法，调用起来更加方便。


Number.prototype.div = function (arg) {
  return BI.div(this, arg);
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 对字符串对象的扩展
 * @class String
 */
_.extend(String.prototype, {
  /**
   * 判断字符串是否已指定的字符串开始
   * @param {String} startTag   指定的开始字符串
   * @return {Boolean}  如果字符串以指定字符串开始则返回true，否则返回false
   */
  startWith: function startWith(startTag) {
    return BI.startWith(this, startTag);
  },

  /**
   * 判断字符串是否以指定的字符串结束
   * @param {String} endTag 指定的字符串
   * @return {Boolean}  如果字符串以指定字符串结束则返回true，否则返回false
   */
  endWith: function endWith(endTag) {
    return BI.endWith(this, endTag);
  },

  /**
   * 获取url中指定名字的参数
   * @param {String} name 参数的名字
   * @return {String} 参数的值
   */
  getQuery: function getQuery(name) {
    return BI.getQuery(this, name);
  },

  /**
   * 给url加上给定的参数
   * @param {Object} paras 参数对象，是一个键值对对象
   * @return {String} 添加了给定参数的url
   */
  appendQuery: function appendQuery(paras) {
    return BI.appendQuery(this, paras);
  },

  /**
   * 将所有符合第一个字符串所表示的字符串替换成为第二个字符串
   * @param {String} s1 要替换的字符串的正则表达式
   * @param {String} s2 替换的结果字符串
   * @returns {String} 替换后的字符串
   */
  replaceAll: function replaceAll(s1, s2) {
    return BI.replaceAll(this, s1, s2);
  },

  /**
   * 总是让字符串以指定的字符开头
   * @param {String} start 指定的字符
   * @returns {String} 以指定字符开头的字符串
   */
  perfectStart: function perfectStart(start) {
    return BI.perfectStart(this, start);
  },

  /**
   * 获取字符串中某字符串的所有项位置数组
   * @param {String} sub 子字符串
   * @return {Number[]} 子字符串在父字符串中出现的所有位置组成的数组
   */
  allIndexOf: function allIndexOf(sub) {
    return BI.allIndexOf(this, sub);
  }
});

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  BI.extend(BI, {
    /**
     * same with Window.open()
     * @param strUrl
     * @param strWindowName
     * @param windowFeatures
     * @returns {Window}
     */
    openWindow: function openWindow(strUrl, strWindowName, windowFeatures) {
      var windowObjectReference = null;

      try {
        windowObjectReference = window.top.open.apply(window.top, arguments);
      } catch (e) {
        windowObjectReference = window.open.apply(window, arguments);
      }

      return windowObjectReference;
    }
  });
}();

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var MD5 = function MD5(hexcase) {
    this.hexcase = !hexcase ? 0 : 1;
    /* hex output format. 0 - lowercase; 1 - uppercase */

    this.b64pad = "";
    /* base-64 pad character. "=" for strict RFC compliance */

    this.chrsz = 8;
    /* bits per input character. 8 - ASCII; 16 - Unicode */
  };
  /*
  * These are the functions you'll usually want to call
  * They take string arguments and return either hex or base-64 encoded strings
  */


  MD5.prototype.hex_md5 = function (s) {
    return this.binl2hex(this.core_md5(this.str2binl(s), s.length * this.chrsz));
  };

  MD5.prototype.hex_md5_salt = function (s) {
    var md5ed = this.hex_md5(s);
    var items1 = [];
    var items2 = [];

    for (var i = 0; i < md5ed.length; i++) {
      if (i % 2 === 0) {
        items1.push(md5ed.charAt(i));
      } else {
        items2.push(md5ed.charAt(i));
      }
    }

    var result = ":" + items1.join("") + items2.join("");
    return result;
  };

  MD5.prototype.b64_md5 = function (s) {
    return this.binl2b64(this.core_md5(this.str2binl(s), s.length * this.chrsz));
  };

  MD5.prototype.hex_hmac_md5 = function (key, data) {
    return this.binl2hex(this.core_hmac_md5(key, data));
  };

  MD5.prototype.b64_hmac_md5 = function (key, data) {
    return this.binl2b64(this.core_hmac_md5(key, data));
  };
  /* Backwards compatibility - same as hex_md5() */


  MD5.prototype.calcMD5 = function (s) {
    return this.binl2hex(this.core_md5(this.str2binl(s), s.length * this.chrsz));
  };

  MD5.prototype.core_md5 = function (x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << len % 32;
    x[(len + 64 >>> 9 << 4) + 14] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;

    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = this.md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
      d = this.md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = this.md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = this.md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = this.md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = this.md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = this.md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = this.md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = this.md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = this.md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = this.md5_ff(c, d, a, b, x[i + 10], 17, -42063);
      b = this.md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = this.md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = this.md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = this.md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = this.md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = this.md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = this.md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = this.md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = this.md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
      a = this.md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = this.md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = this.md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = this.md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = this.md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = this.md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = this.md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = this.md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = this.md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = this.md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = this.md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = this.md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = this.md5_hh(a, b, c, d, x[i + 5], 4, -378558);
      d = this.md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = this.md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = this.md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = this.md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = this.md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = this.md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = this.md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = this.md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = this.md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
      c = this.md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = this.md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = this.md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = this.md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = this.md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = this.md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = this.md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
      d = this.md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = this.md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = this.md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = this.md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = this.md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = this.md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = this.md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = this.md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = this.md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = this.md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = this.md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = this.md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = this.md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = this.md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = this.md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = this.safe_add(a, olda);
      b = this.safe_add(b, oldb);
      c = this.safe_add(c, oldc);
      d = this.safe_add(d, oldd);
    }

    return Array(a, b, c, d);
  };
  /*
  * These functions implement the four basic operations the algorithm uses.
  */


  MD5.prototype.md5_cmn = function (q, a, b, x, s, t) {
    return this.safe_add(this.bit_rol(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);
  };

  MD5.prototype.md5_ff = function (a, b, c, d, x, s, t) {
    return this.md5_cmn(b & c | ~b & d, a, b, x, s, t);
  };

  MD5.prototype.md5_gg = function (a, b, c, d, x, s, t) {
    return this.md5_cmn(b & d | c & ~d, a, b, x, s, t);
  };

  MD5.prototype.md5_hh = function (a, b, c, d, x, s, t) {
    return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);
  };

  MD5.prototype.md5_ii = function (a, b, c, d, x, s, t) {
    return this.md5_cmn(c ^ (b | ~d), a, b, x, s, t);
  };
  /*
  * Calculate the HMAC-MD5, of a key and some data
  */


  MD5.prototype.core_hmac_md5 = function (key, data) {
    var bkey = this.str2binl(key);

    if (bkey.length > 16) {
      bkey = this.core_md5(bkey, key.length * this.chrsz);
    }

    var ipad = Array(16),
        opad = Array(16);

    for (var i = 0; i < 16; i++) {
      ipad[i] = bkey[i] ^ 0x36363636;
      opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }

    var hash = this.core_md5(ipad.concat(this.str2binl(data)), 512 + data.length * this.chrsz);
    return this.core_md5(opad.concat(hash), 512 + 128);
  };
  /*
  * Add integers, wrapping at 2^32. This uses 16-bit operations internally
  * to work around bugs in some JS interpreters.
  */


  MD5.prototype.safe_add = function (x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
  };
  /*
  * Bitwise rotate a 32-bit number to the left.
  */


  MD5.prototype.bit_rol = function (num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  };
  /*
  * Convert a string to an array of little-endian words
  * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
  */


  MD5.prototype.str2binl = function (str) {
    var bin = Array();
    var mask = (1 << this.chrsz) - 1;

    for (var i = 0; i < str.length * this.chrsz; i += this.chrsz) {
      bin[i >> 5] |= (str.charCodeAt(i / this.chrsz) & mask) << i % 32;
    }

    return bin;
  };
  /*
  * Convert an array of little-endian words to a hex string.
  */


  MD5.prototype.binl2hex = function (binarray) {
    var hex_tab = this.hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var str = "";

    for (var i = 0; i < binarray.length * 4; i++) {
      str += hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 + 4 & 0xF) + hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 & 0xF);
    }

    return str;
  };
  /*
  * Convert an array of little-endian words to a base-64 string
  */


  MD5.prototype.binl2b64 = function (binarray) {
    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var str = "";

    for (var i = 0; i < binarray.length * 4; i += 3) {
      var triplet = (binarray[i >> 2] >> 8 * (i % 4) & 0xFF) << 16 | (binarray[i + 1 >> 2] >> 8 * ((i + 1) % 4) & 0xFF) << 8 | binarray[i + 2 >> 2] >> 8 * ((i + 2) % 4) & 0xFF;

      for (var j = 0; j < 4; j++) {
        if (i * 8 + j * 6 > binarray.length * 32) {
          str += this.b64pad;
        } else {
          str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);
        }
      }
    }

    return str;
  };

  BI.MD5 = new MD5();
}();

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var DECRYPT = 0;
  var ROUND = 32;
  var BLOCK = 16; // S盒

  var Sbox = [0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48]; // 固定参数 CK

  var CK = [0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279];
  var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

  function rotl(x, y) {
    return x << y | x >>> 32 - y;
  }

  function byteSub(a) {
    return (Sbox[a >>> 24 & 0xFF] & 0xFF) << 24 | (Sbox[a >>> 16 & 0xFF] & 0xFF) << 16 | (Sbox[a >>> 8 & 0xFF] & 0xFF) << 8 | Sbox[a & 0xFF] & 0xFF;
  }

  function l1(b) {
    return b ^ rotl(b, 2) ^ rotl(b, 10) ^ rotl(b, 18) ^ rotl(b, 24);
  }

  function l2(b) {
    return b ^ rotl(b, 13) ^ rotl(b, 23);
  }

  function sms4Crypt(input, output, roundKey) {
    var r;
    var mid;
    var x = new Array(4);
    var tmp = new Array(4);

    for (var i = 0; i < 4; i++) {
      tmp[0] = input[0 + 4 * i] & 0xff;
      tmp[1] = input[1 + 4 * i] & 0xff;
      tmp[2] = input[2 + 4 * i] & 0xff;
      tmp[3] = input[3 + 4 * i] & 0xff;
      x[i] = tmp[0] << 24 | tmp[1] << 16 | tmp[2] << 8 | tmp[3];
    }

    for (r = 0; r < 32; r += 4) {
      mid = x[1] ^ x[2] ^ x[3] ^ roundKey[r + 0];
      mid = byteSub(mid);
      x[0] = x[0] ^ l1(mid); // x4

      mid = x[2] ^ x[3] ^ x[0] ^ roundKey[r + 1];
      mid = byteSub(mid);
      x[1] = x[1] ^ l1(mid); // x5

      mid = x[3] ^ x[0] ^ x[1] ^ roundKey[r + 2];
      mid = byteSub(mid);
      x[2] = x[2] ^ l1(mid); // x6

      mid = x[0] ^ x[1] ^ x[2] ^ roundKey[r + 3];
      mid = byteSub(mid);
      x[3] = x[3] ^ l1(mid); // x7
    } // Reverse


    for (var j = 0; j < 16; j += 4) {
      output[j] = x[3 - j / 4] >>> 24 & 0xff;
      output[j + 1] = x[3 - j / 4] >>> 16 & 0xff;
      output[j + 2] = x[3 - j / 4] >>> 8 & 0xff;
      output[j + 3] = x[3 - j / 4] & 0xff;
    }
  }
  /**
  * 密钥扩展算法
  * @param key
  * @param roundKey
  * @param cryptFlag
  */


  function sms4KeyExt(key, roundKey, cryptFlag) {
    var r;
    var mid;
    var x = new Array(4);
    var tmp = new Array(4);

    for (var i = 0; i < 4; i++) {
      tmp[0] = key[0 + 4 * i] & 0xff;
      tmp[1] = key[1 + 4 * i] & 0xff;
      tmp[2] = key[2 + 4 * i] & 0xff;
      tmp[3] = key[3 + 4 * i] & 0xff;
      x[i] = tmp[0] << 24 | tmp[1] << 16 | tmp[2] << 8 | tmp[3];
    }

    x[0] ^= 0xa3b1bac6;
    x[1] ^= 0x56aa3350;
    x[2] ^= 0x677d9197;
    x[3] ^= 0xb27022dc;

    for (r = 0; r < 32; r += 4) {
      mid = x[1] ^ x[2] ^ x[3] ^ CK[r + 0];
      mid = byteSub(mid);
      roundKey[r + 0] = x[0] ^= l2(mid); // roundKey0 = K4

      mid = x[2] ^ x[3] ^ x[0] ^ CK[r + 1];
      mid = byteSub(mid);
      roundKey[r + 1] = x[1] ^= l2(mid); // roundKey1 = K5

      mid = x[3] ^ x[0] ^ x[1] ^ CK[r + 2];
      mid = byteSub(mid);
      roundKey[r + 2] = x[2] ^= l2(mid); // roundKey2 = K6

      mid = x[0] ^ x[1] ^ x[2] ^ CK[r + 3];
      mid = byteSub(mid);
      roundKey[r + 3] = x[3] ^= l2(mid); // roundKey3 = K7
    } // 解密时轮密钥使用顺序：roundKey31, roundKey30, ..., roundKey0


    if (cryptFlag === DECRYPT) {
      for (r = 0; r < 16; r++) {
        mid = roundKey[r];
        roundKey[r] = roundKey[31 - r];
        roundKey[31 - r] = mid;
      }
    }
  }

  function sm4(inArray, key, cryptFlag) {
    var outArray = [];
    var point = 0;
    var roundKey = new Array(ROUND);
    sms4KeyExt(key, roundKey, cryptFlag);
    var input = new Array(16);
    var output = new Array(16);
    var inLen = inArray.length;

    while (inLen >= BLOCK) {
      input = inArray.slice(point, point + 16);
      sms4Crypt(input, output, roundKey);

      for (var i = 0; i < BLOCK; i++) {
        outArray[point + i] = output[i];
      }

      inLen -= BLOCK;
      point += BLOCK;
    }

    return outArray;
  }
  /**
  * 填充
  * @param input 输入
  * @param cryptFlag
  * @returns {*}
  */


  function padding(input, cryptFlag) {
    if (cryptFlag === DECRYPT) {
      return input.slice(0, input.lastIndexOf(0x80));
    }

    var paddingLen = 16 - input.length % 16;

    if (paddingLen > 0) {
      input.push(0x80);
    }

    for (var i = 0; i < paddingLen - 1; i++) {
      input.push(0x00);
    }

    return input;
  }
  /**
  * 字符串转bytes
  * @param str
  * @returns {[]}
  */


  function utf8StrToBytes(str) {
    var input = unescape(encodeURIComponent(str));
    var words = [];

    for (var i = 0; i < input.length; i++) {
      words[i] = input.charCodeAt(i);
    }

    return words;
  }
  /**
  * bytes转字符串
  * @param arr
  * @returns {string}
  */


  function arrayToUtf8(arr) {
    var utf8Byte = arr;
    var latin1Chars = [];

    for (var i = 0; i < utf8Byte.length; i++) {
      latin1Chars.push(String.fromCharCode(utf8Byte[i]));
    }

    return decodeURIComponent(escape(latin1Chars.join("")));
  }
  /**
  * btoa方法
  * base64编码
  * https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa
  * @param string
  * @returns {string|string}
  */


  function encode(string) {
    string = String(string);
    var bitmap,
        a,
        b,
        c,
        result = "",
        i = 0,
        rest = string.length % 3; // To determine the final padding

    for (; i < string.length;) {
      if ((a = string.charCodeAt(i++)) > 255 || (b = string.charCodeAt(i++)) > 255 || (c = string.charCodeAt(i++)) > 255) {
        throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range.");
      }

      bitmap = a << 16 | b << 8 | c;
      result += b64.charAt(bitmap >> 18 & 63) + b64.charAt(bitmap >> 12 & 63) + b64.charAt(bitmap >> 6 & 63) + b64.charAt(bitmap & 63);
    } // If there's need of padding, replace the last 'A's with equal signs


    return rest ? result.slice(0, rest - 3) + "===".substring(rest) : result;
  }
  /**
  * atob方法
  * base64解码
  * https://github.com/MaxArt2501/base64-js/blob/master/base64.js#L54
  * @param string
  * @returns {string}
  */


  function decode(str) {
    // atob can work with strings with whitespaces, even inside the encoded part,
    // but only \t, \n, \f, \r and ' ', which can be stripped.
    str = String(str).replace(/[\t\n\f\r ]+/g, "");

    if (!/^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/.test(str)) {
      throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    } // Adding the padding if missing, for semplicity


    str += "==".slice(2 - (str.length & 3));
    var bitmap,
        result = "",
        r1,
        r2,
        i = 0;

    for (; i < str.length;) {
      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 | (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }

    return result;
  }
  /**
  * byte数组转base64字符串
  * @param buffer
  * @returns {string}
  */


  function arrayBuffer2Base64(buffer) {
    var binary = "";
    var len = buffer.length;

    for (var i = 0; i < len; i++) {
      binary += String.fromCharCode(buffer[i]);
    }

    return encode(binary);
  }
  /**
  * base64字符串转byte数组
  * @param str
  * @returns {[]}
  */


  function base642ArrayBuffer(str) {
    var input = decode(str);
    var arr = [];

    for (var i = 0; i < input.length; i++) {
      arr[i] = input.charCodeAt(i);
    }

    return arr;
  }
  /**
  * 16进制字符串转数组
  * @param hex
  * @returns {[]}
  */


  function hex2Array(hex) {
    var arr = [];

    for (var i = 0; i < hex.length; i += 2) {
      arr.push(parseInt(hex.substr(i, 2), 16));
    }

    return arr;
  }

  var SM4 = function SM4() {
    /**
    * 国密sm4算法 ecb模式加密
    * @param str 明文字符串
    * @param key 长度为16位的16进制字符串
    * @returns {string} 密文字符串
    */
    this.ecbEncrypt = function (str, key) {
      if (key.length !== 32 || /[^0-9a-fA-F]/.test(key)) {
        throw new Error("key error");
      }

      return arrayBuffer2Base64(sm4(padding(utf8StrToBytes(str)), hex2Array(key), 1));
    };
    /**
    * 国密sm4算法 ecb模式解密
    * @param str 密文字符串
    * @param key 长度为16位的16进制字符串
    * @returns {string} 明文字符串
    */


    this.ecbDecrypt = function (str, key) {
      if (key.length !== 32 || /[^0-9a-fA-F]/.test(key)) {
        throw new Error("key error");
      }

      return arrayToUtf8(padding(sm4(base642ArrayBuffer(str), hex2Array(key), 0), 0));
    };
  };

  BI.SM4 = new SM4();
}();

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 校验器
 * qcc
 * 2019/12/23
 */
!function () {
  // 一些规则参考，实际使用覆盖掉
  var ruleMap = {
    required: {
      message: "required",
      validate: function validate(value) {
        return BI.isNotEmptyString(value) || BI.isNotEmptyArray(value) || BI.isNotEmptyObject(value);
      }
    },
    range: {
      validate: function validate(value, pars) {
        if (BI.isNumeric(value)) {
          return value >= pars.min && value <= pars.max;
        } else if (BI.isString(value)) {
          return BI.size(value) >= pars.min && BI.size(value) <= pars.max;
        }

        return false;
      },
      message: "not in range",
      expects: ["min", "max"]
    },
    min: {
      message: "not min",
      validate: function validate(value, pars) {
        return BI.size(value) >= pars.value;
      },
      expects: ["value"]
    },
    max: {
      message: function message(value, pars) {
        return value + " max than " + pars.value;
      },
      validate: function validate(value, pars) {
        return BI.size(value) <= pars.value;
      },
      expects: ["value"]
    },
    equal: {
      message: "not equal",
      validate: function validate(value, pars) {
        return BI.isEqual(value, pars.value);
      },
      expects: ["value"]
    },
    regex: {
      message: "not match",
      validate: function validate(value, pars) {
        if (BI.isRegExp(pars.value)) {
          return pars.value.test(value);
        }

        _global.console && console.error(pars.value + " is not a valid regular expression");
      },
      expects: ["value"]
    }
  };
  /**
   * 执行校验
   * @param value
   * @param rules
   * @param stop
   * @returns {{approved: boolean, errors: Array, rules: {}}}
   * @private
   */

  function _start(value, rules, stop) {
    var result = {
      approved: true,
      errors: [],
      rules: {}
    };
    BI.each(rules, function (ruleName, rule) {
      if (stop && !result.approved) {
        return false;
      }

      if (BI.has(ruleMap, ruleName)) {
        if (rule === false) {
          return;
        }

        var args = _getArgs(rule, ruleMap[ruleName]),
            res = ruleMap[ruleName].validate(value, args);

        var errMsg = BI.has(rule, "message") ? rule.message : ruleMap[ruleName].message;
        errMsg = BI.isFunction(errMsg) ? errMsg(value, args) : errMsg; // errMsg = BI.i18nText.apply(BI, [errMsg].concat(BI.values(args)));

        result["rules"][ruleName] = {
          approved: res,
          errors: res ? "" : errMsg
        };

        if (!res) {
          result.errors.push(errMsg);
          result.approved = false;
        }
      } else {
        _global.console && console.error(ruleName + " is not support");
      }
    });
    return result;
  }
  /**
   * 获取校验方法的参数
   * @param constraint
   * @param rule
   * @private
   */


  function _getArgs(constraint, rule) {
    var pars = {},
        options = rule.options,
        expects = rule.expects,
        len = BI.size(expects);

    if (BI.isNotEmptyArray(expects)) {
      BI.each(expects, function (i, expect) {
        if (BI.has(constraint, expect)) {
          pars[expect] = constraint[expect];
        } else if (len <= 1 && (BI.isKey(constraint) || BI.isRegExp(constraint))) {
          pars[expect] = constraint;
        } else if (len <= 1 && BI.isFunction(constraint)) {
          pars[expect] = constraint();
        } else {
          _global.console && console.error("expects the " + expects + " parameter");
        }
      });
    }

    if (BI.isNotEmptyArray(options)) {
      BI.each(options, function (i, option) {
        if (BI.has(constraint, option)) {
          pars[option] = constraint[option];
        }
      });
    }

    return pars;
  }

  var validator = function validator() {
    /**
     * 初始化规则
     * 定义统一的规则
     * @param rules
     */
    this.init = function (rules) {
      ruleMap = BI.extend(ruleMap, rules);
    };
    /**
     * 校验是否符合规则
     * @param val: any 校验值
     * @param rules: Object 规则
     * @param stop: boolean 是否出现错误就停止
     * @returns {{approved: boolean, errors: Array, rules: {}}}
     */


    this.validate = function (val, rules, stop) {
      if (BI.isObject(rules)) {
        return _start(val, rules, stop);
      }
    };
    /**
     * 添加校验规则，不能覆盖已有规则
     * @param name: string 规则名称
     * @param rule: Object 规则
     */


    this.addRule = function (name, rule) {
      if (BI.has(ruleMap, name)) {
        _global.console && console.error("rule:[" + name + "] has been registed");
        return;
      }

      ruleMap[name] = rule;
    };
  };

  BI.validator = new validator();
}();

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by lei.wang on 2018/11/2.
 */
(function () {
  BI.SearchIconTextValueCombo = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-material-search-icon-text-value-combo",
      height: 24,
      text: "",
      items: [],
      iconCls: "",
      tipType: "",
      warningTitle: "",
      attributes: {
        tabIndex: 0
      }
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.absolute",
        items: [{
          el: {
            type: "bi.combo",
            container: o.container,
            adjustLength: 2,
            toggle: false,
            ref: function ref() {
              self.combo = this;
            },
            el: {
              type: "bi.material.search_icon_text_value_trigger",
              simple: o.simple,
              cls: "search-text-value-trigger",
              ref: function ref() {
                self.trigger = this;
              },
              items: o.items,
              height: o.height - (o.simple ? 1 : 2),
              text: o.text,
              value: o.value,
              tipType: o.tipType,
              iconCls: o.iconCls,
              warningTitle: o.warningTitle,
              title: o.title,
              listeners: [{
                eventName: BI.SearchTextValueTrigger.EVENT_CHANGE,
                action: function action() {
                  self.setValue(this.getValue());
                  self.combo.hideView();
                  self.fireEvent("EVENT_CHANGE");
                }
              }]
            },
            popup: {
              el: {
                type: "bi.icon_text_value_combo_popup",
                chooseType: BI.ButtonGroup.CHOOSE_TYPE_SINGLE,
                value: o.value,
                items: o.items,
                ref: function ref() {
                  self.popup = this;
                  self.trigger.getSearcher().setAdapter(self.popup);
                },
                listeners: [{
                  eventName: BI.TextValueComboPopup.EVENT_CHANGE,
                  action: function action() {
                    self.setValue(this.getValue());
                    self.combo.hideView();
                    self.fireEvent("EVENT_CHANGE");
                  }
                }]
              },
              maxHeight: 252
            },
            listeners: [{
              eventName: BI.Combo.EVENT_AFTER_HIDEVIEW,
              action: function action() {
                self.trigger.stopEditing();
              }
            }, {
              eventName: BI.Combo.EVENT_BEFORE_POPUPVIEW,
              action: function action() {
                self.fireEvent("EVENT_BEFORE_POPUPVIEW");
              }
            }],
            hideChecker: function hideChecker(e) {
              return self.triggerBtn.element.find(e.target).length === 0;
            }
          },
          left: 0,
          right: 0,
          bottom: 0,
          top: 0
        }, {
          el: {
            type: "bi.trigger_icon_button",
            cls: "trigger-icon-button",
            ref: function ref() {
              self.triggerBtn = this;
            },
            width: o.height,
            height: o.height,
            handler: function handler() {
              if (self.combo.isViewVisible()) {
                self.combo.hideView();
              } else {
                self.combo.showView();
              }
            }
          },
          right: 0,
          bottom: 0,
          top: 0
        }]
      };
    },
    mounted: function mounted() {
      var o = this.options;

      if (BI.isKey(o.value)) {
        this._checkError(o.value);
      }
    },
    _checkError: function _checkError(v) {
      if (BI.isNotNull(v)) {
        v = BI.isArray(v) ? v : [v];
        var result = BI.find(this.options.items, function (idx, item) {
          return BI.contains(v, item.value);
        });

        if (BI.isNull(result)) {
          this.element.removeClass("combo-error").addClass("combo-error");
          this.trigger.attr("tipType", "warning");
        } else {
          this.element.removeClass("combo-error");
          this.trigger.attr("tipType", "success");
        }
      }
    },
    populate: function populate(items) {
      this.options.items = items;
      this.combo.populate(items);
    },
    setValue: function setValue(v) {
      this.combo.setValue(v);

      this._checkError(v);
    },
    getValue: function getValue() {
      var value = this.popup.getValue();
      return BI.isNull(value) ? [] : BI.isArray(value) ? value : [value];
    }
  });
  BI.shortcut("bi.material.search_icon_text_value_combo", BI.SearchIconTextValueCombo);
})();

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by lei.wang on 2018/11/2.
 */
(function () {
  var Trigger = BI.inherit(BI.Trigger, {
    props: function props(opt) {
      return {
        extraCls: "bi-material-search-icon-text-trigger " + (opt.simple ? "bi-border-bottom" : "bi-border"),
        height: 24
      };
    },
    render: function render() {
      var self = this,
          o = this.options;

      var iconCls = this._digistIcon(o.value, o.items);

      return {
        type: "bi.htape",
        items: [{
          el: {
            type: "bi.icon_change_button",
            cls: "icon-combo-trigger-icon",
            iconCls: iconCls,
            ref: function ref(_ref) {
              self.icon = _ref;
            },
            disableSelected: true
          },
          vgap: 3,
          width: !BI.isKey(iconCls) ? 0 : o.iconWrapperWidth || o.height
        }, {
          el: {
            type: "bi.searcher",
            ref: function ref() {
              self.searcher = this;
            },
            isAutoSearch: false,
            el: {
              type: "bi.state_editor",
              ref: function ref() {
                self.editor = this;
              },
              defaultText: this._getText(),
              text: o.text,
              value: o.value,
              height: o.height,
              tipText: ""
            },
            popup: {
              type: "bi.icon_text_value_combo_popup",
              cls: "bi-card",
              chooseType: BI.ButtonGroup.CHOOSE_TYPE_SINGLE
            },
            onSearch: function onSearch(obj, callback) {
              var keyword = obj.keyword;
              var finding = BI.Func.getSearchResult(o.items, keyword);
              var matched = finding.match,
                  find = finding.find;
              var items = BI.concat(find, matched);
              callback(items);
            },
            listeners: [{
              eventName: BI.Searcher.EVENT_CHANGE,
              action: function action() {
                self.fireEvent("EVENT_CHANGE");
              }
            }]
          }
        }, {
          el: {
            type: "bi.layout",
            width: 24
          },
          width: 24
        }],
        ref: function ref(_ref) {
          self.wrapper = _ref;
        }
      };
    },
    _setState: function _setState(v) {
      this.editor.setState(v);
    },
    _getText: function _getText() {
      var o = this.options;
      return BI.isKey(o.value) && o.text === this._digest(o.value, o.items) ? "" : o.text;
    },
    _digest: function _digest(vals, items) {
      var o = this.options;
      vals = BI.isArray(vals) ? vals : [vals];
      var result = [];
      var formatItems = BI.Tree.transformToArrayFormat(items);
      BI.each(formatItems, function (i, item) {
        if (BI.deepContains(vals, item.value) && !BI.contains(result, item.text || item.value)) {
          result.push(item.text || item.value);
        }
      });

      if (result.length > 0) {
        return result.join(",");
      }

      return o.text;
    },
    _digistIcon: function _digistIcon(vals, items) {
      var o = this.options;
      vals = BI.isArray(vals) ? vals : [vals];
      var result;
      var formatItems = BI.Tree.transformToArrayFormat(items);
      BI.any(formatItems, function (i, item) {
        if (BI.deepContains(vals, item.value)) {
          result = {
            text: item.text || item.value,
            iconCls: item.iconCls
          };
          return true;
        }
      });

      if (BI.isNotNull(result)) {
        return result.iconCls;
      }

      return o.iconCls;
    },
    stopEditing: function stopEditing() {
      this.searcher.stopSearch();
    },
    getSearcher: function getSearcher() {
      return this.searcher;
    },
    populate: function populate(items) {
      this.options.items = items;
    },
    setValue: function setValue(vals) {
      var iconCls = this._digistIcon(vals, this.options.items);

      this.setIcon(iconCls);

      this._setState(this._digest(vals, this.options.items));
    },
    setIcon: function setIcon(iconCls) {
      var o = this.options;
      this.icon.setIcon(iconCls);
      var iconItem = this.wrapper.attr("items")[0];

      if (!BI.isKey(iconCls)) {
        if (iconItem.width !== 0) {
          iconItem.width = 0;
          this.wrapper.resize();
        }
      } else {
        if (iconItem.width !== (o.iconWrapperWidth || o.height)) {
          iconItem.width = o.iconWrapperWidth || o.height;
          this.wrapper.resize();
        }
      }
    },
    getValue: function getValue() {
      return this.searcher.getValue();
    }
  });
  BI.shortcut("bi.material.search_icon_text_value_trigger", Trigger);
})();

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *@desc  全屏操作控制器
 *@author dailer
 *@date 2018/09/29
 */
!function () {
  BI.FullScreenController = BI.inherit(BI.Controller, {
    props: {},
    _init: function _init() {
      BI.FullScreenController.superclass._init.apply(this, arguments);

      this.exitHandlers = [];
    },
    requestFullScreen: function requestFullScreen(target, complete, exitHandler) {
      if (BI.isNull(this.support)) {
        this.support = this._checkSupportScreenHandler();
      }

      if (!this.support) {
        BI.Msg.toast(BI.i18nText("fullscreen api not support"), {
          level: "error"
        });
        complete(false);
        return;
      }

      if (BI.isWidget(target)) {
        target = target.element[0];
      }

      this._launchFullScreen(target, exitHandler);

      complete.call(this, true);
    },
    //  获取当前全屏的元素
    getFullScreenElement: function getFullScreenElement() {
      return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || null;
    },
    //  是否全屏
    isFullScreen: function isFullScreen(doc) {
      doc = doc || document;
      return !!(doc.fullscreenElement || doc.webkitFullscreenElement || doc.mozFullScreenElement || doc.msFullscreenElement || null);
    },
    //  退出全屏
    exitFullScreen: function exitFullScreen() {
      this._existFullscreenHandler();

      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }

      BI.each(this.exitHandlers, function (index, handler) {
        BI.isFunction(handler) && handler();
      });
      return this;
    },
    _launchFullScreen: function _launchFullScreen(element, exitHandler) {
      var self = this;

      if (element.requestFullscreen) {
        element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
      } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
      } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullScreen();
      }

      BI.$(element).addClass("bi-fullscreen-element");
      this.fullscreenElement = element; //  解决按esc键的状态问题

      BI.$(document).bind("fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange", function () {
        if (!self.isFullScreen()) {
          BI.isFunction(exitHandler) && exitHandler();
          self.exitHandlers = [];

          self._existFullscreenHandler();

          BI.$(document).unbind("fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange");
        }
      });
    },
    _checkSupportScreenHandler: function _checkSupportScreenHandler() {
      var requestFullScreen;

      if (document.body) {
        requestFullScreen = document.body.requestFullscreen || document.body.webkitRequestFullscreen || document.body.mozRequestFullScreen || document.body.msRequestFullscreen;
      }

      var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled;
      return !!(requestFullScreen && fullscreenEnabled);
    },
    _existFullscreenHandler: function _existFullscreenHandler() {
      var element = this.getFullScreenElement() || this.fullscreenElement;

      if (element) {
        BI.$(element).removeClass("bi-fullscreen-element");
      }

      this.fullscreenElement = null;
    }
  });
  BI.FullScreen = new BI.FullScreenController();
}();

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 过滤条件抽象类
 *
 * @class BI.AbstractFilterItem
 * @extend BI.Widget
 */
BI.AbstractFilterItem = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-filter-item bi-border-right bi-border-bottom"
  },
  isSelectedCondition: function isSelectedCondition() {
    return this.emptyItem && this.emptyItem.isVisible();
  },
  setSelectedCondition: function setSelectedCondition(b) {
    if (b) {
      if (!this.emptyItem) {
        this.emptyItem = BI.createWidget({
          type: "bi.absolute",
          height: 40,
          cls: "filter-item-empty-item bi-border-top",
          items: [{
            el: {
              type: "bi.center_adapt",
              cls: "empty-filter-item-leaf"
            }
          }],
          hgap: 10,
          vgap: 5
        });
        BI.createWidget({
          type: "bi.vertical",
          element: this,
          items: [this.emptyItem],
          scrolly: false
        });
      }
    }

    this.emptyItem && this.emptyItem.setVisible(b);
  }
});
BI.extend(BI.AbstractFilterItem, {
  FILTER_OPERATION_FORMULA: 1,
  FILTER_OPERATION_CONDITION: 2,
  FILTER_OPERATION_CONDITION_AND: 3,
  FILTER_OPERATION_CONDITION_OR: 4,
  FILTER_OPERATION_FORMULA_AND: 5,
  FILTER_OPERATION_FORMULA_OR: 6,
  FILTER_OPERATION_SHAKE: 7
});

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by Urthur on 2017/11/21.
 */
!function () {
  BI.AndOrFilterExpander = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-filter-expander",
      el: {},
      popup: {}
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.filter_expander",
        switchable: o.switchable,
        el: o.el,
        popup: o.popup,
        id: o.id,
        value: o.value,
        listeners: [{
          eventName: BI.Controller.EVENT_CHANGE,
          action: function action() {
            self.fireEvent(BI.Controller.EVENT_CHANGE, arguments);
          }
        }],
        ref: function ref(_ref) {
          self.expander = _ref;
        }
      };
    },
    populate: function populate() {
      this.expander.populate.apply(this.expander, arguments);
    },
    getValue: function getValue() {
      var val = this.expander.getValue();
      return {
        filterType: val.type,
        filterValue: val.value,
        id: val.id
      };
    }
  });
  BI.shortcut("bi.and.or.filter.expander", BI.AndOrFilterExpander);
}();

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @class BI.FilterExpander
 * @extend BI.AbstractFilterItem
 * 过滤树的一个expander节点
 */
!function () {
  var FilterExpander = BI.inherit(BI.AbstractFilterItem, {
    _constant: {
      EXPANDER_WIDTH: 30
    },
    props: {
      baseCls: "bi-filter-expander-item bi-filter-expander bi-border-left bi-border-bottom",
      el: {},
      popup: {},
      switchable: true
    },
    render: function render() {
      var self = this,
          o = this.options;
      var value = o.el.value;
      return {
        type: "bi.horizontal_adapt",
        cls: "filter-item-empty-item",
        horizontalAlign: BI.HorizontalAlign.Stretch,
        columnSize: [this._constant.EXPANDER_WIDTH, "fill"],
        verticalAlign: BI.VerticalAlign.Middle,
        items: [{
          type: "bi.absolute",
          cls: "filter-item-expander-wrapper",
          items: [{
            el: {
              type: "bi.text_button",
              $testId: "bi-materials-filter-and-or-expander",
              cls: "condition-and-or",
              text: this._getText(value),
              value: value,
              id: o.id,
              width: this._constant.EXPANDER_WIDTH,
              height: "100%",
              ref: function ref(_ref) {
                self.expander = _ref;
              },
              listeners: [{
                eventName: BI.TextButton.EVENT_CHANGE,
                action: function action() {
                  self.fireEvent(BI.Controller.EVENT_CHANGE, BI.Events.CLICK, "", self);
                }
              }]
            },
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          }, {
            el: {
              type: "bi.icon_button",
              invisible: !o.switchable,
              stopPropagation: true,
              cls: "change-and-or-font",
              title: BI.i18nText("BI-Basic_Switch"),
              handler: function handler() {
                self.switchText();
                self.fireEvent(BI.Controller.EVENT_CHANGE, BI.Events.CLICK, true, self);
              }
            },
            top: 10,
            width: 16,
            height: 16,
            left: 7
          }],
          width: this._constant.EXPANDER_WIDTH,
          height: "100%"
        }, BI.extend(o.popup, {
          ref: function ref(_ref) {
            self.conditionsView = _ref;
          },
          listeners: [{
            eventName: BI.Controller.EVENT_CHANGE,
            action: function action() {
              self.fireEvent(BI.Controller.EVENT_CHANGE, arguments);
            }
          }]
        })]
      };
    },
    _getText: function _getText(value) {
      var text = "";

      if (value === BI.Filter.FILTER_TYPE.AND) {
        text = BI.i18nText("BI-Basic_And");
      } else {
        text = BI.i18nText("BI-Basic_Or");
      }

      return text;
    },
    switchText: function switchText() {
      var value = this.expander.getValue() === BI.Filter.FILTER_TYPE.AND ? BI.Filter.FILTER_TYPE.OR : BI.Filter.FILTER_TYPE.AND;
      this.expander.setValue(value);
      this.expander.setText(this._getText(value));
    },
    getValue: function getValue() {
      return {
        type: this.expander.getValue(),
        value: this.conditionsView.getValue(),
        id: this.options.id
      };
    },
    populate: function populate() {
      this.conditionsView.populate.apply(this.conditionsView, arguments);
    }
  });
  BI.shortcut("bi.filter_expander", FilterExpander);
}();

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 过滤
 *
 * Created by GUY on 2015/11/20.
 * @class BI.Filter
 * @extend BI.Widget
 */
BI.Filter = BI.inherit(BI.Widget, {
  constants: {
    FIELD_TYPE_NUMBER: 1,
    FIELD_TYPE_STRING: 0,
    FIELD_TYPE_DATE: 2
  },
  props: {
    baseCls: "bi-filter",
    expander: {},
    items: [],
    el: {},
    itemCreator: BI.empty
  },
  _store: function _store() {
    return BI.Models.getModel("bi.model.material.filter");
  },
  watch: {
    shakeTree: function shakeTree() {
      this.shakeTree();
    }
  },
  render: function render() {
    var self = this,
        o = this.options;
    return BI.extend({
      type: "bi.filter_operation",
      addWarningTitle: o.addWarningTitle,
      expander: o.expander,
      listeners: [{
        eventName: "EVENT_OPERATION",
        action: function action(type) {
          switch (type) {
            case BI.AbstractFilterItem.FILTER_OPERATION_CONDITION:
              self.store.addCondition();

              self._addAndOrCondition(BI.Filter.FILTER_TYPE.EMPTY_CONDITION);

              break;

            case BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND:
              self.store.addAndCondition();

              self._addAndOrCondition(BI.Filter.FILTER_TYPE.EMPTY_CONDITION);

              break;

            case BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_OR:
              self.store.addOrCondition();

              self._addAndOrCondition(BI.Filter.FILTER_TYPE.EMPTY_CONDITION, 1);

              break;

            case BI.AbstractFilterItem.FILTER_OPERATION_FORMULA:
              self.store.addFormula();

              self._addAndOrCondition(BI.Filter.FILTER_TYPE.EMPTY_FORMULA);

              break;

            case BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_AND:
              self.store.addAndFormula();

              self._addAndOrCondition(BI.Filter.FILTER_TYPE.EMPTY_FORMULA);

              break;

            case BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_OR:
              self.store.addOrFormula();

              self._addAndOrCondition(BI.Filter.FILTER_TYPE.EMPTY_FORMULA, 1);

              break;

            case BI.AbstractFilterItem.FILTER_OPERATION_SHAKE:
              self.store.shakeTree();
              break;
          }
        }
      }, {
        eventName: "BI.FilterOperation.EVENT_DESTROY_ITEM",
        action: function action(id) {
          self._removeCondition(id);
        }
      }, {
        eventName: "EVENT_CLICK_EXPANDER",
        action: function action(type, value, obj) {
          self._switchConditionLink(obj);

          self._checkBeautifyLevelNecessary();

          self.fireEvent("EVENT_CHANGE");
        }
      }],
      ref: function ref(_ref) {
        self.filter = _ref;
      }
    }, o.el);
  },
  mounted: function mounted() {
    this.tree = new BI.Tree();
    this.tree.initTree(this.options.items);

    this._populate(this.tree.toJSONWithNode());
  },
  _checkBeautifyLevelNecessary: function _checkBeautifyLevelNecessary() {
    this.filter.setBeautifyButtonVisible(this._checkLevelStructure(this.tree.getRoot()));
  },
  _checkLevelStructure: function _checkLevelStructure(node, pnode) {
    var self = this;
    var children = node.getChildren();

    if (BI.isNotNull(pnode)) {
      var pdata = pnode.get("data"),
          data = node.get("data"); // 父子节点类型相同, 就是存在可合并类型，直接返回

      if (BI.isNotNull(pdata) && pdata.value === data.value) {
        return true;
      }
    }

    return BI.any(children, function (idx, child) {
      return self._checkLevelStructure(child, node);
    });
  },
  _switchConditionLink: function _switchConditionLink(obj) {
    var finded = this.tree.search(obj.attr("id"));

    if (BI.isNotNull(finded)) {
      var data = finded.get("data");
      data.value = data.value === BI.Filter.FILTER_TYPE.AND ? BI.Filter.FILTER_TYPE.OR : BI.Filter.FILTER_TYPE.AND;
    }
  },
  _createEmptyNode: function _createEmptyNode(type) {
    var node = new BI.Node(BI.UUID());
    node.set("data", {
      value: type
    });
    return node;
  },
  _insertAndOrCondition: function _insertAndOrCondition(id, formulaOrField, type) {
    var ANDOR = ["AND", "OR"];
    type || (type = 0);
    var finded = this.tree.search(id); // finded节点是selectItem的父节点

    if (BI.isNotNull(finded)) {
      var data = finded.get("data"); // 父亲的数据

      var parent = finded.getParent(); // 祖父节点

      var index = parent.getChildIndex(finded.id); // 父亲所在祖父下的索引

      var pdata = parent.get("data") || {}; // 祖父数据

      var node = this._createEmptyNode(formulaOrField);

      if (data.value === BI.Filter.FILTER_TYPE[ANDOR[type]]) {
        this.tree.addNode(finded, node); // 和父亲节点类型相同直接作为儿子节点添加进去

        return;
      }

      if (data.value === BI.Filter.FILTER_TYPE[ANDOR[1 - type]]) {
        // 相反
        if (pdata.value === BI.Filter.FILTER_TYPE[ANDOR[type]]) {
          // 但是和祖父相同
          parent.addChild(node, index + 1); // 作为父亲的兄弟，添加到父亲之后

          return;
        }
      } // 类型与父亲节点相反 && 和祖父节点不同(祖父有可能为空) 或者 与祖父节点相反 或者 祖父节点类型不是and且祖父节点不是or(为空)


      if (data.value === BI.Filter.FILTER_TYPE[ANDOR[1 - type]] && pdata.value !== BI.Filter.FILTER_TYPE[ANDOR[type]] || pdata.value === BI.Filter.FILTER_TYPE[ANDOR[1 - type]] || pdata.value !== BI.Filter.FILTER_TYPE.AND && pdata.value !== BI.Filter.FILTER_TYPE.OR) {
        var andor = new BI.Node(BI.UUID());
        andor.set("data", {
          value: BI.Filter.FILTER_TYPE[ANDOR[type]],
          children: [finded.get("data"), node.get("data")]
        });
        parent.removeChildByIndex(index); // 删除整个父节点，重新构造放到祖父下

        parent.addChild(andor, index);
        andor.addChild(finded);
        andor.addChild(node);
        return;
      }

      parent.addChild(node, index + 1);
    }
  },
  _removeCondition: function _removeCondition(id) {
    var finded = this.tree.search(id);

    if (BI.isNotNull(finded)) {
      var parent = finded.getParent();
      parent.removeChild(id);

      if (parent.getChildrenLength() <= 1) {
        var prev = parent.getParent();

        if (BI.isNotNull(prev)) {
          var index = prev.getChildIndex(parent.id);
          prev.removeChildByIndex(index);

          if (parent.getChildrenLength() === 1) {
            prev.addChild(parent.getFirstChild(), index);
          }
        }
      }

      this._populate(this.tree.toJSONWithNode());

      this.fireEvent("EVENT_CHANGE");
    }
  },
  _addAndOrCondition: function _addAndOrCondition(formulaOrField, type) {
    var ANDOR = ["AND", "OR"];
    type || (type = 0);
    var currentSelectItem = this.filter.getCurrentSelectItem();

    if (BI.isNotNull(currentSelectItem)) {
      var id = currentSelectItem.attr("id");

      this._insertAndOrCondition(id, formulaOrField, type);
    } else {
      var node = this._createEmptyNode(formulaOrField);

      var root = this.tree.getRoot();
      var child = root.getLastChild(); // 获取第一层最后一个节点, 需要整个替换掉

      if (BI.isNotNull(child)) {
        var data = child.get("data");

        if (data.value === BI.Filter.FILTER_TYPE[ANDOR[type]]) {
          // 和父亲节点类型相同直接作为儿子节点添加进去
          this.tree.addNode(child, node);
        } else {
          // 重新组织节点andor, 此节点为第一层最后一个节点和新增节点的父亲, 作为第一层最后一个节点
          var andor = new BI.Node(BI.UUID());
          andor.set("data", {
            value: BI.Filter.FILTER_TYPE[ANDOR[type]],
            children: [child.get("data"), node.get("data")]
          });
          root.removeChild(child.id); // 删除原来的节点，一个个添加

          this.tree.addNode(andor);
          this.tree.addNode(andor, child);
          this.tree.addNode(andor, node);
        }
      } else {
        this.tree.addNode(node);
      }
    }

    this._populate(this.tree.toJSONWithNode());

    this.fireEvent("EVENT_CHANGE");
  },
  _shakeTree: function _shakeTree(node, pnode) {
    var self = this;
    var count = 0,
        i;
    var children = node.getChildren();

    for (i = 0; i < children.length; i++) {
      var childCount = self._shakeTree(children[i], node);

      childCount > 0 && (i += childCount - 1); // 索引要向前加上增加的节点格式 - 1
    }

    if (BI.isNotNull(pnode)) {
      var pdata = pnode.get("data"),
          data = node.get("data");

      if (BI.isNotNull(pdata) && pdata.value === data.value) {
        // 父子节点类型相同, 就把子节点的儿子全部移动到父节点中去
        var removeIndex = pnode.getChildIndex(node.id);
        pnode.removeChild(node.id); // 父亲删除现有子节点

        BI.each(node.getChildren(), function (i, cNode) {
          // 父亲添加儿子节点的子节点
          count++; // 向祖父添加了n个节点

          self.tree.addNode(pnode, cNode, removeIndex + i);
        });
      }
    }

    return count;
  },
  // 将整棵树中可以合并的节点全都合并起来
  shakeTree: function shakeTree() {
    var root = this.tree.getRoot();

    this._shakeTree(root);

    this._populate(this.tree.toJSONWithNode());

    this.fireEvent("EVENT_CHANGE");
  },
  _populate: function _populate(items) {
    this.filter.defaultState();
    var o = this.options;
    o.items = items;
    BI.Tree.traversal(items, function (i, item) {
      o.itemCreator(item);
    });
    this.filter.populate.apply(this.filter, [items]);

    this._checkBeautifyLevelNecessary();
  },
  populate: function populate(conditions) {
    this.tree.initTree(conditions);

    this._populate(this.tree.toJSONWithNode());
  },
  getValue: function getValue() {
    return this.filter.getValue();
  }
});
BI.shortcut("bi.filter", BI.Filter);
BI.Filter.FILTER_TYPE = {};
BI.Filter.FILTER_TYPE.FORMULA = 33;
BI.Filter.FILTER_TYPE.AND = 34;
BI.Filter.FILTER_TYPE.OR = 35;
BI.Filter.FILTER_TYPE.EMPTY_FORMULA = 36;
BI.Filter.FILTER_TYPE.EMPTY_CONDITION = 37;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by windy on 2017/3/28.
 */
!function () {
  var FilterList = BI.inherit(BI.ButtonTree, {
    props: {
      baseCls: "bi-button-map"
    },
    _createBtns: function _createBtns(items) {
      var o = this.options;
      var buttons = BI.createWidgets(BI.createItems(items, {
        type: "bi.text_button",
        once: o.chooseType === 0
      }));
      var keys = BI.map(items, function (i, item) {
        item = BI.stripEL(item);

        if (!(item.id || item.value)) {
          throw new Error("item must have 'id' or 'value' as its property");
        }

        return item.id || item.value;
      });
      return BI.zipObject(keys, buttons);
    },
    setValue: function setValue(v) {
      v = BI.isArray(v) ? v : [v];
      BI.each(this.buttons, function (val, item) {
        if (!BI.isFunction(item.setSelected)) {
          item.setValue(v);
          return;
        }

        if (BI.contains(v, val)) {
          item.setSelected && item.setSelected(true);
        } else {
          item.setSelected && item.setSelected(false);
        }
      });
    },
    setNotSelectedValue: function setNotSelectedValue(v) {
      v = BI.isArray(v) ? v : [v];
      BI.each(this.buttons, function (val, item) {
        if (!BI.isFunction(item.setSelected)) {
          item.setNotSelectedValue(v);
          return;
        }

        if (BI.contains(v, val)) {
          item.setSelected && item.setSelected(false);
        } else {
          item.setSelected && item.setSelected(true);
        }
      });
    },
    populate: function populate(items) {
      var self = this;
      var args = [].slice.call(arguments);
      var linkHashMap = new BI.LinkHashMap();

      var val = function val(item) {
        return item.id || item.value;
      };

      if (!this.buttons) {
        this.buttons = {};
      } // 所有已存在的和新添加的


      var willCreated = [];
      BI.each(items, function (i, item) {
        item = BI.stripEL(item);

        if (self.buttons[val(item)]) {
          var ob = self.buttons[val(item)];
          args[0] = item.items;
          args[2] = item;
          ob.populate && ob.populate.apply(ob, args);
        } else {
          willCreated.push(item);
        }
      }); // 创建新元素

      args[0] = willCreated;

      var newBtns = this._btnsCreator.apply(this, args); // 整理


      var array = [];
      BI.each(items, function (i, item) {
        item = BI.stripEL(item);
        var button = self.buttons[val(item)] || newBtns[val(item)];
        linkHashMap.add(val(item), button);
        array.push(button);
      });
      this.buttons = linkHashMap.map;
      BI.DOM.hang(this.buttons);
      this.element.empty();

      var packages = this._packageItems(items, this._packageBtns(array));

      BI.createWidget(BI.extend({
        element: this
      }, this._packageLayout(packages)));
    },
    getIndexByValue: function getIndexByValue() {
      throw new Error("Can not use getIndexByValue");
    }
  });
  BI.shortcut("bi.filter_list", FilterList);
}();

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Model = BI.inherit(Fix.Model, {
    state: function state() {
      return {
        setSelectedCondition: false,
        shakeTree: false
      };
    },
    childContext: ["setSelectedCondition"],
    computed: {},
    actions: {
      addCondition: function addCondition() {},
      addAndCondition: function addAndCondition() {},
      addOrCondition: function addOrCondition() {},
      addFormula: function addFormula() {},
      addAndFormula: function addAndFormula() {},
      addOrFormula: function addOrFormula() {},
      shakeTree: function shakeTree() {
        this.model.shakeTree = !this.model.shakeTree;
      }
    }
  });
  BI.model("bi.model.material.filter", Model);
}();

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 过滤条件
 *
 * Created by GUY on 2015/9/25.
 * @class BI.FilterOperation
 * @extend BI.Widget
 */
!function () {
  BI.FilterOperation = BI.inherit(BI.Widget, {
    _defaultConfig: function _defaultConfig() {
      return BI.extend(BI.FilterOperation.superclass._defaultConfig.apply(this, arguments), {
        constants: {
          FORMULA_COMBO: [{
            text: BI.i18nText("BI-Conf_Formula_And"),
            $testId: "bi-materials-formula-add",
            value: BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_AND
          }, {
            text: BI.i18nText("BI-Conf_Formula_Or"),
            $testId: "bi-materials-formula-or",
            value: BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_OR
          }],
          CONDITION_COMBO: [{
            text: BI.i18nText("BI-Conf_Condition_And"),
            $testId: "bi-materials-condition-add",
            value: BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND
          }, {
            text: BI.i18nText("BI-Conf_Condition_Or"),
            $testId: "bi-materials-condition-or",
            value: BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_OR
          }]
        }
      });
    },
    props: {
      baseCls: "bi-filter-operation",
      expander: {},
      items: [],
      logic: {
        dynamic: false
      },
      selections: [BI.AbstractFilterItem.FILTER_OPERATION_CONDITION, BI.AbstractFilterItem.FILTER_OPERATION_FORMULA],
      itemsCreator: BI.emptyFn
    },
    _store: function _store() {
      return BI.Models.getModel("bi.model.material.filter_operation");
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.currentSelected = null;
      return BI.extend({
        items: [{
          el: {
            type: "bi.left_right_vertical_adapt",
            items: {
              left: self._buildOperationButton(),
              right: [{
                type: "bi.icon_button",
                cls: "combine-level-font",
                title: BI.i18nText("BI-Basic_Beautify_Level"),
                ref: function ref(_ref) {
                  self.beautifyButton = _ref;
                },
                listeners: [{
                  eventName: BI.IconButton.EVENT_CHANGE,
                  action: function action() {
                    self.fireEvent("EVENT_OPERATION", BI.AbstractFilterItem.FILTER_OPERATION_SHAKE);
                  }
                }]
              }]
            },
            height: 24,
            lrgap: 20,
            rrgap: 10
          },
          height: 24
        }, {
          el: BI.extend({
            tgap: 10,
            items: [{
              el: {
                type: "bi.left",
                items: [{
                  type: "bi.filter_pane",
                  expander: o.expander,
                  items: o.items,
                  itemsCreator: o.itemsCreator,
                  listeners: [{
                    eventName: "EVENT_CHANGE",
                    action: function action(type, value, obj) {
                      if (type === BI.Events.CLICK && value !== true) {
                        if (BI.isNotNull(self.currentSelected) && self.currentSelected === obj) {
                          self.store.setSelectedCondition(!obj.isSelectedCondition());
                          obj.setSelectedCondition(!obj.isSelectedCondition());
                        } else {
                          if (BI.isNotNull(self.currentSelected)) {
                            self.store.setSelectedCondition(false);
                            self.currentSelected.setSelectedCondition(false);
                          }

                          self.currentSelected = obj;
                          self.store.setSelectedCondition(true);
                          obj.setSelectedCondition(true);
                        }
                      }

                      if (type === BI.Events.CLICK && value === true) {
                        self.fireEvent("EVENT_CLICK_EXPANDER", arguments);
                      }

                      if (type === BI.Events.DESTROY) {
                        if (self.currentSelected === obj) {
                          self.currentSelected = null;
                        }

                        self.fireEvent("BI.FilterOperation.EVENT_DESTROY_ITEM", value, obj);
                      }
                    }
                  }],
                  ref: function ref(_ref) {
                    self.filter = _ref;
                  }
                }]
              },
              // for absolute
              top: 0,
              right: 2,
              bottom: 0,
              left: 0,
              // for vertical
              rgap: 2
            }]
          }, o.logic.dynamic ? {
            type: "bi.vertical",
            scrolly: false
          } : {
            type: "bi.absolute",
            scrollable: true
          })
        }]
      }, o.logic.dynamic ? {
        type: "bi.vertical",
        scrolly: false
      } : {
        type: "bi.vtape"
      });
    },
    _buildOperationButton: function _buildOperationButton() {
      var self = this,
          combos = [],
          o = this.options;
      BI.each(this.options.selections, function (i, type) {
        switch (type) {
          case BI.AbstractFilterItem.FILTER_OPERATION_FORMULA:
            combos.push({
              type: "bi.filter_operation_switch",
              warningTitle: o.addWarningTitle,
              addType: BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_AND,
              listeners: [{
                eventName: "EVENT_CHANGE",
                action: function action(v) {
                  doAdd(v);
                }
              }]
            });
            break;

          case BI.AbstractFilterItem.FILTER_OPERATION_CONDITION:
          default:
            combos.push({
              type: "bi.filter_operation_switch",
              warningTitle: o.addWarningTitle,
              addType: BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND,
              listeners: [{
                eventName: "EVENT_CHANGE",
                action: function action(v) {
                  doAdd(v);
                }
              }]
            });
            break;
        }
      });
      return combos;

      function doAdd(v) {
        self.fireEvent("EVENT_OPERATION", v);
        self.defaultState();
      }
    },
    defaultState: function defaultState() {
      if (BI.isNotNull(this.currentSelected)) {
        this.store.setSelectedCondition(false);
        this.currentSelected.setSelectedCondition(false);
      }
    },
    getCurrentSelectItem: function getCurrentSelectItem() {
      if (BI.isNotNull(this.currentSelected) && this.currentSelected.isSelectedCondition()) {
        return this.currentSelected;
      }
    },
    setBeautifyButtonVisible: function setBeautifyButtonVisible(b) {
      this.beautifyButton.setVisible(!!b);
    },
    populate: function populate() {
      this.filter.populate.apply(this.filter, arguments);
    },
    getValue: function getValue() {
      return this.filter.getValue();
    }
  });
  BI.shortcut("bi.filter_operation", BI.FilterOperation);
}();

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Model = BI.inherit(Fix.Model, {
    context: ["setSelectedCondition"],
    computed: {},
    actions: {
      setSelectedCondition: function setSelectedCondition(selected) {
        this.model.setSelectedCondition = selected;
      }
    }
  });
  BI.model("bi.model.material.filter_operation", Model);
}();

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  BI.FilterOperationSwitch = BI.inherit(BI.Single, {
    props: {
      baseCls: "bi-filter-operation-switch",
      width: 112,
      height: 24,
      addType: BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND
    },
    render: function render() {
      var self = this;
      return {
        type: "bi.htape",
        items: [{
          el: {
            type: "bi.text_button",
            cls: "filter-add-item left-item-radius",
            $testId: "bi-filter-operation-switch-add-button",
            text: this._getShowText(this._getDefaultValue()),
            ref: function ref(_ref) {
              self.addButton = _ref;
            },
            value: this._getDefaultValue(),
            listeners: [{
              eventName: "EVENT_CHANGE",
              action: function action() {
                self.fireEvent("EVENT_CHANGE", this.getValue());
              }
            }]
          },
          rgap: 1
        }, {
          el: {
            type: "bi.down_list_combo",
            el: {
              cls: "filter-add-item",
              title: BI.i18nText("BI-Basic_Switch")
            },
            iconCls: "filter-down-font icon-size-12",
            $testId: "bi-filter-operation-switch-combo",
            cls: "filter-add-item right-item-radius",
            items: this._getItemsByType(),
            value: [{
              value: this._getDefaultValue()
            }],
            listeners: [{
              eventName: "EVENT_CHANGE",
              action: function action() {
                var value = this.getValue()[0].value;
                self.addButton.setValue(value);
                self.addButton.setText(self._getShowText(value));
                self.fireEvent("EVENT_CHANGE", value);
              }
            }]
          },
          width: 16
        }]
      };
    },
    _getShowText: function _getShowText(v) {
      switch (v) {
        case BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_OR:
          return BI.i18nText("BI-Basic_Add_Or_Condition");

        case BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_AND:
          return BI.i18nText("BI-Basic_Add_And_Formula");

        case BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_OR:
          return BI.i18nText("BI-Basic_Add_Or_Formula");

        case BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND:
        default:
          return BI.i18nText("BI-Basic_Add_And_Condition");
      }
    },
    _getDefaultValue: function _getDefaultValue() {
      return this.options.addType === BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND ? BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND : BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_AND;
    },
    _getItemsByType: function _getItemsByType() {
      return this.options.addType === BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND ? [[{
        text: BI.i18nText("BI-Basic_And_Condition"),
        cls: "dot-e-font",
        value: BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_AND,
        $testId: "bi-filter-operation-switch-combo-item-condition-and"
      }, {
        text: BI.i18nText("BI-Basic_Or_Condition"),
        cls: "dot-e-font",
        value: BI.AbstractFilterItem.FILTER_OPERATION_CONDITION_OR,
        $testId: "bi-filter-operation-switch-combo-item-condition-or"
      }]] : [[{
        text: BI.i18nText("BI-Basic_And_Formula"),
        cls: "dot-e-font",
        value: BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_AND,
        $testId: "bi-filter-operation-switch-combo-item-formula-and"
      }, {
        text: BI.i18nText("BI-Basic_Or_Formula"),
        cls: "dot-e-font",
        value: BI.AbstractFilterItem.FILTER_OPERATION_FORMULA_OR,
        $testId: "bi-filter-operation-switch-combo-item-formula-or"
      }]];
    }
  });
  BI.shortcut("bi.filter_operation_switch", BI.FilterOperationSwitch);
}();

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @class BI.FilterPane
 * @extend BI.Widget
 * 过滤面板
 */
!function () {
  var FilterPane = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-filter-pane",
      expander: {},
      items: [],
      itemsCreator: BI.emptyFn
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.custom_tree",
        cls: BI.isNotEmptyArray(o.items) ? "bi-border-right bi-border-top" : "",
        expander: BI.extend({
          type: "bi.filter_expander",
          el: {},
          popup: {
            type: "bi.custom_tree"
          }
        }, o.expander),
        el: {
          type: "bi.filter_list",
          cls: "filter-list-pane",
          chooseType: BI.ButtonGroup.CHOOSE_TYPE_DEFAULT,
          layouts: [{
            type: "bi.vertical",
            scrolly: false
          }]
        },
        items: o.items,
        listeners: [{
          eventName: BI.Controller.EVENT_CHANGE,
          action: function action() {
            self.fireEvent("EVENT_CHANGE", arguments);
          }
        }],
        ref: function ref(_ref) {
          self.tree = _ref;
        }
      };
    },
    populate: function populate(items) {
      if (BI.isNotEmptyArray(items)) {
        this.element.addClass("bi-border-right bi-border-top");
      } else {
        this.element.removeClass("bi-border-right bi-border-top");
      }

      this.tree.populate.apply(this.tree, arguments);
    },
    getValue: function getValue() {
      return this.tree.getValue();
    }
  });
  BI.shortcut("bi.filter_pane", FilterPane);
}();

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 表单
 * qcc
 * 2019/12/26
 */
!function () {
  var Form = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-form",
      items: [],
      rules: {},
      // 对每个表单项都生效，会被表单项相同规则覆盖
      stop: false,
      // 是否出现错误即中断校验
      layouts: [{
        type: "bi.vertical"
      }]
    },
    _init: function _init() {
      Form.superclass._init.apply(this, arguments);

      this.populate(this.options.items);
    },
    _createItems: function _createItems(items) {
      var rules = this.options.rules;
      return BI.createWidgets(BI.map(items, function (i, item) {
        return BI.extend({
          type: "bi.form.item"
        }, item, {
          rules: BI.extend({}, rules, item.rules)
        });
      }));
    },
    _itemsCreator: function _itemsCreator(items) {
      var self = this;

      var formItems = this._createItems(items);

      BI.each(formItems, function (i, btn) {
        btn.on(BI.Events.DESTROY, function () {
          BI.remove(self.formItems, btn);
        });
      });
      return formItems;
    },
    _packageItemLayout: function _packageItemLayout(items) {
      var o = this.options;

      for (var i = o.layouts.length - 1; i > 0; i--) {
        items = BI.map(items, function (k, it) {
          return BI.extend({}, o.layouts[i], {
            items: [BI.extend({}, o.layouts[i].el, {
              el: it
            })]
          });
        });
      }

      return items;
    },
    _packageSimpleItems: function _packageSimpleItems(nodes) {
      var o = this.options;
      return BI.map(o.items, function (i, item) {
        if (BI.stripEL(item) === item) {
          return nodes[i];
        }

        return BI.extend({}, item, {
          el: nodes[i]
        });
      });
    },
    _packageItems: function _packageItems(items, packBtns) {
      return BI.createItems(BI.makeArrayByArray(items, {}), BI.clone(packBtns));
    },
    _packageLayout: function _packageLayout(items) {
      var o = this.options,
          layout = BI.deepClone(o.layouts[0]);
      var lay = BI.formatEL(layout).el;

      while (lay && lay.items && !BI.isEmpty(lay.items)) {
        lay = BI.formatEL(lay.items[0]).el;
      }

      lay.items = items;
      return layout;
    },
    // 简单的layout
    _isSimpleLayout: function _isSimpleLayout() {
      var o = this.options;
      return o.layouts.length === 1 && !BI.isArray(o.items[0]);
    },

    /**
     * 提交表单
     * 会进行校验且显示错误提示
     * @param callback
     */
    submit: function submit(callback) {
      var stop = this.options.stop,
          approved = true,
          result;
      BI.each(this.formItems, function (i, item) {
        if (!approved && stop) {
          return true;
        }

        if (!item.isEnabled() || !BI.isFunction(item.getValidations)) {
          return;
        }

        result = item.getValidations();

        if (result && !result.approved) {
          item.showError && item.showError(result.errors[0]);
          approved = false;
        } else {
          item.hideError && item.hideError();
        }
      });
      approved && BI.isFunction(callback) && callback(this.getValue());
      return approved;
    },

    /**
     * 表单校验
     * @returns {boolean}
     */
    validate: function validate() {
      var approved = true,
          stop = this.options.stop;
      BI.each(this.formItems, function (i, item) {
        if (!approved && stop) {
          return true;
        }

        if (item.isEnabled() && BI.isFunction(item.validate) && !item.validate()) {
          approved = false;
        }
      });
      return approved;
    },

    /**
     * 获取表单校验结果
     * 包含错误信息
     * @returns {Array}
     */
    getValidations: function getValidations() {
      var v = [];
      BI.each(this.formItems, function (i, item) {
        if (item.isEnabled() && BI.isFunction(item.getValidations)) {
          v.push(item.getValidations());
        }
      });
      return v;
    },

    /**
     * 设置表单项值
     * 需要给表单项传递name属性
     * @param val
     * @param name
     */
    setValue: function setValue(val, name) {
      var node = this.getNodeByName(name);
      node && node.setValue(val);
    },

    /**
     * 获取表单结果
     * @returns {Array}
     */
    getValue: function getValue() {
      var v = [];
      BI.each(this.formItems, function (i, item) {
        if (item.isEnabled()) {
          v.push(item.getValue());
        }
      });
      return v;
    },

    /**
     * 获取具名表单值
     * @returns {Object}
     */
    getFormValue: function getFormValue() {
      var v = {};
      BI.each(this.formItems, function (i, item) {
        if (item.options.name) {
          v[item.options.name] = item.getValue();
        }
      });
      return v;
    },

    /**
     * 刷新整个表单
     * @param items
     */
    populate: function populate(items) {
      items = items || [];
      this.empty();
      this.options.items = items;
      this.formItems = this._itemsCreator.apply(this, arguments);

      if (this._isSimpleLayout()) {
        items = this._packageSimpleItems(this.formItems);
      } else {
        items = this._packageItems(items, this._packageItemLayout(this.formItems));
      }

      this.layouts = BI.createWidget(BI.extend({
        element: this
      }, this._packageLayout(items)));
    },

    /**
     * 通过name使能某些表单项
     * @param v
     */
    setEnabledItems: function setEnabledItems(v) {
      v = BI.isArray(v) ? v : [v];
      BI.each(this.formItems, function (i, item) {
        if (BI.contains(v, item.options.name)) {
          item.setEnable(true);
        } else {
          item.setEnable(false);
        }
      });
    },
    getAllItems: function getAllItems() {
      return this.formItems;
    },
    getIndexByName: function getIndexByName(name) {
      var index = -1;
      BI.some(this.formItems, function (i, item) {
        if (item.isEnabled() && item.options.name === name) {
          index = i;
          return true;
        }
      });
      return index;
    },
    getNodeByName: function getNodeByName(name) {
      var node;
      BI.some(this.formItems, function (i, item) {
        if (item.isEnabled() && item.options.name === name) {
          node = item;
          return true;
        }
      });
      return node;
    },
    empty: function empty() {
      Form.superclass.empty.apply(this, arguments);
      this.options.items = [];
    },
    destroy: function destroy() {
      Form.superclass.destroy.apply(this, arguments);
      this.options.items = [];
    }
  });
  BI.shortcut("bi.form", Form);
}();

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 使用absolute显示错误的表单项
 * 更多场景是基于此再封装通用项
 * qcc
 * 2019/12/26
 */
!function () {
  var Item = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-form-error-item",
      errorText: "",
      stop: true,
      rules: {}
    },
    render: function render() {
      var self = this,
          o = this.options;
      this._formItem = BI.createWidget(o.el);

      if (o.label) {
        return {
          type: "bi.vertical_adapt",
          items: [{
            el: BI.isKey(o.label) ? {
              type: "bi.label",
              textAlign: "left",
              textHeight: 24,
              text: o.label,
              title: o.label,
              rgap: 10
            } : o.label
          }, {
            el: this._formItem
          }]
        };
      }

      return {
        type: "bi.vertical_adapt",
        items: [{
          el: this._formItem
        }]
      };
    },
    getValue: function getValue() {
      return this._formItem.getValue();
    },
    validate: function validate() {
      var o = this.options;
      var res = BI.validator.validate(this.getValue(), o.rules, o.stop);
      return BI.isNull(res) || res.approved;
    },
    getValidations: function getValidations() {
      var o = this.options;
      return BI.validator.validate(this.getValue(), o.rules, o.stop);
    },
    showError: function showError(text) {
      text && BI.Bubbles.show(this.getName(), text, this._formItem);
    },
    hideError: function hideError() {
      BI.Bubbles.hide(this.getName());
    }
  });
  BI.shortcut("bi.form.error.item", Item);
}();

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 包装成表单项
 * qcc
 * 2019/12/26
 */
!function () {
  var Item = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-form-item",
      stop: true,
      rules: {}
    },
    render: function render() {
      var o = this.options;

      if (o.label) {
        this.item = BI.createWidget({
          rules: o.rules,
          stop: o.stop
        }, o.el);
        return {
          type: "bi.vertical_adapt",
          items: [{
            el: BI.isKey(o.label) ? {
              type: "bi.label",
              textAlign: "left",
              textHeight: 24,
              text: o.label,
              title: o.label,
              rgap: 10
            } : o.label
          }, {
            el: this.item
          }]
        };
      }

      this.item = BI.createWidget({
        rules: o.rules,
        stop: o.stop,
        element: this
      }, o.el);
    },
    getValue: function getValue() {
      return this.item.getValue();
    },
    validate: function validate() {
      return BI.isFunction(this.item.validate) ? this.item.validate() : this._validate();
    },
    getValidations: function getValidations() {
      var o = this.options;
      return BI.isFunction(this.item.getValidations) ? this.item.getValidations() : BI.validator.validate(this.getValue(), o.rules, o.stop);
    },
    showError: function showError(text) {
      BI.isFunction(this.item.showError) && this.item.showError(text);
    },
    hideError: function hideError() {
      BI.isFunction(this.item.hideError) && this.item.hideError();
    },
    _validate: function _validate() {
      var o = this.options;
      var res = BI.validator.validate(this.getValue(), o.rules, o.stop);
      return BI.isNull(res) || res.approved;
    }
  });
  BI.shortcut("bi.form.item", Item);
}();

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  BI.Func = BI.Func || {};
  BI.extend(BI.Func, {
    paintWaterMark: function paintWaterMark(canvas, conf) {
      var markConfig = BI.extend({
        text: "watermark",
        fontSize: 16,
        fontFamily: "Microsoft YaHei, PingFangSC-Light, SimHei, SimSun, FangSong, KaiTi, Arial, Tahoma, Verdana, Times New Roman",
        color: "#999999",
        opacity: 0.15,
        angle: 20,
        fontWeight: "bold",
        horizontalGap: 200,
        verticalGap: 100
      }, conf);
      var deg = markConfig.angle * Math.PI / 180;
      var watermarkCanvas = BI.Func.createEmptyCanvas();
      var cheight = canvas.height,
          cwidth = canvas.width;
      var texts = (markConfig.text + "").split("\n");
      var actualWidth = cwidth * Math.cos(deg) + cheight * Math.sin(deg),
          actualHeight = cwidth * Math.sin(deg) + cheight / Math.cos(deg);
      watermarkCanvas.width = actualWidth;
      watermarkCanvas.height = actualHeight;
      var watermarkCtx = watermarkCanvas.getContext("2d");
      watermarkCtx.rotate(-deg);
      watermarkCtx.font = markConfig.fontWeight + " " + markConfig.fontSize + "px " + markConfig.fontFamily;
      watermarkCtx.fillStyle = markConfig.color;
      watermarkCtx.globalAlpha = markConfig.opacity;
      watermarkCtx.textAlign = "center"; // 用measureText在canvas渲染前就计算宽度确保宽度正确
      // 计算\n处理后最长的文本宽度

      var maxTextWidth = 0;

      for (var t = 0; t < texts.length; t++) {
        maxTextWidth = Math.max(maxTextWidth, watermarkCtx.measureText(texts[t]).width);
      }

      var markWidth = maxTextWidth + markConfig.horizontalGap,
          textHeight = BI.DOM.getTextSizeHeight(markConfig.text, markConfig.fontSize),
          markHeight = textHeight * texts.length + markConfig.verticalGap;
      var col = BI.parseInt(actualWidth / markWidth);
      var row = BI.parseInt(actualHeight / markHeight);
      var fillLeft = canvas.height * Math.tan(deg);

      for (var r = 0; r < row + 1; r++) {
        for (var c = 0; c < col + 3; c++) {
          var left = c * markWidth - fillLeft + (r % 2 === 0 ? -(markWidth / 2) : 0);

          for (var textLen = 0; textLen < texts.length; textLen++) {
            watermarkCtx.fillText(texts[textLen], left, r * markHeight + textHeight * textLen);
          }
        }
      }

      var ctxr = canvas.getContext("2d");
      ctxr.fillStyle = ctxr.createPattern(watermarkCanvas, "no-repeat");
      ctxr.fillRect(0, 0, watermarkCanvas.width, watermarkCanvas.height);
    },
    createEmptyCanvas: function createEmptyCanvas() {
      var canvas = document.createElement("canvas");

      if (!document.createElement("canvas").getContext) {
        canvas = window.G_vmlCanvasManager.initElement(canvas);
      }

      return canvas;
    }
  });
}();

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 预览表列
 *
 * Created by GUY on 2015/12/25.
 * @class BI.PreviewTableCell
 * @extends BI.Widget
 */
BI.WarningLabel = BI.inherit(BI.Single, {
  props: {
    baseCls: "bi-warning-label",
    textAlign: "center",
    whiteSpace: "nowrap",
    // normal  or  nowrap
    forceCenter: false,
    // 是否无论如何都要居中, 不考虑超出边界的情况, 在未知宽度和高度时有效
    textWidth: null,
    textHeight: null,
    hgap: 0,
    vgap: 0,
    lgap: 0,
    rgap: 0,
    tgap: 0,
    bgap: 0,
    text: ""
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.label",
      ref: function ref() {
        self.label = this;
      },
      textAlign: o.textAlign,
      whiteSpace: o.whiteSpace,
      // normal  or  nowrap
      forceCenter: o.forceCenter,
      // 是否无论如何都要居中, 不考虑超出边界的情况, 在未知宽度和高度时有效
      textWidth: o.textWidth,
      textHeight: o.textHeight,
      hgap: o.hgap,
      vgap: o.vgap,
      lgap: o.lgap,
      rgap: o.rgap,
      tgap: o.tgap,
      bgap: o.bgap
    };
  },
  mounted: function mounted() {
    var o = this.options;

    if (BI.isKey(o.text)) {
      this.setText(o.text);
    }
  },
  _digest: function _digest(text) {
    text = BI.htmlEncode(text || "");
    return text.replaceAll("\\$\\{(.*?)\\}", function (ori, str) {
      return "<span class='warning-label'>" + str + "</span>";
    });
  },
  setText: function setText(v) {
    this.options.text = v;
    this.label.text.text.element.html(this._digest(v));
  },
  getText: function getText() {
    return this.options.text;
  },
  setValue: function setValue(v) {
    this.label.setValue(v);
  }
});
BI.shortcut("bi.warning_label", BI.WarningLabel);

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  /**
   * 一个button选中的时候下面有条线
   *
   * Created by GUY on 2015/9/30.
   * @class BI.LineSegmentButton
   * @extends BI.BasicButton
   */
  var LineSegmentButton = BI.inherit(BI.BasicButton, {
    props: {
      baseCls: "bi-line-segment-button bi-list-item-effect",
      once: true,
      readonly: true,
      hgap: 10,
      height: 25,
      lineHeight: 3
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.text = BI.createWidget({
        type: "bi.label",
        element: this,
        text: o.text,
        height: o.height,
        value: o.value,
        hgap: o.hgap
      });
      BI.createWidget({
        type: "bi.absolute",
        element: this,
        items: [{
          el: {
            type: "bi.layout",
            cls: "line-segment-button-line",
            height: o.lineHeight,
            ref: function ref(_ref) {
              self.line = _ref;
            }
          },
          left: 0,
          right: 0,
          bottom: 0
        }]
      });
    },
    setSelected: function setSelected(v) {
      LineSegmentButton.superclass.setSelected.apply(this, arguments);

      if (v) {
        this.line.element.addClass("bi-high-light-background");
      } else {
        this.line.element.removeClass("bi-high-light-background");
      }
    },
    setText: function setText(text) {
      LineSegmentButton.superclass.setText.apply(this, arguments);
      this.text.setText(text);
    }
  });
  BI.shortcut("bi.line_segment_button", LineSegmentButton);
}();

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/9/2
 */
BI.VirtaulTreeListItem = BI.inherit(BI.Widget, {
  props: {
    layer: 0,
    id: "",
    pId: "",
    height: 24
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.htape",
      items: [{
        el: {
          type: 'bi.layout'
        },
        width: o.layer * 15
      }, {
        type: "bi.text_item",
        logic: {
          dynamic: true
        },
        id: o.id,
        pId: o.pId,
        height: o.height,
        hgap: o.hgap,
        text: o.text,
        value: o.value,
        py: o.py,
        keyword: o.keyword,
        listeners: [{
          eventName: '__EVENT_CHANGE__',
          action: function action() {
            self.fireEvent('__EVENT_CHANGE__');
          }
        }],
        ref: function ref(_ref) {
          self.item = _ref;
        }
      }]
    };
  },
  doHighLight: function doHighLight() {
    this.item.doHighLight.apply(this.item, arguments);
  },
  unHighLight: function unHighLight() {
    this.item.unHighLight.apply(this.item, arguments);
  },
  getId: function getId() {
    return this.options.id;
  },
  getPId: function getPId() {
    return this.options.pId;
  },
  doClick: function doClick() {
    BI.VirtaulTreeListItem.superclass.doClick.apply(this, arguments);
    this.item.setSelected(this.isSelected());
  },
  setSelected: function setSelected(v) {
    BI.VirtaulTreeListItem.superclass.setSelected.apply(this, arguments);
    this.item.setSelected(v);
  }
});
BI.shortcut("bi.virtual_tree_list_item", BI.VirtaulTreeListItem);

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * author: young
 * createdDate: 2019-07-10
 * description: 适用简单列表场景的grid_view
 * @Maintainers: young
 */
BI.GridList = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-grid-list",
    items: [],
    // 一维数组
    // itemFormatter
    itemHeight: 30,
    showLoader: false,
    itemsCreator: BI.emptyFn,
    onLoaded: BI.emptyFn,
    hasNext: BI.emptyFn,
    count: false,
    overscanRowCount: 0,
    overflowX: true,
    overflowY: true
  },
  mounted: function mounted() {
    var self = this;
    this._resizeHandler = BI.debounce(function () {
      var width = self._getListWidth(),
          height = self._getListHeight();

      if (self.list.getWidth() !== width || self.list.getHeight() !== height) {
        self._populate();
      }
    }, 30);
    this.removeListener = BI.ResizeDetector.addResizeListener(this.wrapper, function () {
      self._resizeHandler();
    });

    if (BI.isNotEmptyArray(this.options.items)) {
      this._populate();
    }
  },
  render: function render() {
    var self = this,
        o = this.options;
    this.times = 1;
    this.count = 0;
    this.loaderStatus = "loaded";
    return {
      type: "bi.absolute",
      items: [{
        el: {
          type: "bi.grid_view",
          overflowX: o.overflowX,
          overflowY: o.overflowY,
          estimatedRowSize: o.itemHeight,
          estimatedColumnSize: this._getListWidth(),
          overscanRowCount: o.overscanRowCount,
          itemFormatter: o.itemFormatter,
          rowHeightGetter: function rowHeightGetter() {
            return o.itemHeight;
          },
          columnWidthGetter: function columnWidthGetter() {
            return self.listWidth - BI.DOM.getScrollWidth();
          },
          ref: function ref(_ref2) {
            self.list = _ref2;
          },
          listeners: [{
            eventName: BI.GridView.EVENT_SCROLL,
            action: function action(sc) {
              self.fireEvent("EVENT_SCROLL", sc.scrollTop);
            }
          }]
        },
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }],
      ref: function ref(_ref) {
        self.wrapper = _ref;
      }
    };
  },
  _getListWidth: function _getListWidth() {
    return this.element.width();
  },
  _getListHeight: function _getListHeight() {
    return this.element.height();
  },
  _populate: function _populate() {
    var o = this.options,
        self = this;
    this.listWidth = this._getListWidth();
    this.list.setEstimatedColumnSize(this.listWidth - BI.DOM.getScrollWidth());
    this.list.setWidth(this.listWidth);
    this.list.setHeight(this._getListHeight());
    var items = BI.map(this.options.items, function (i, item) {
      return [item];
    });

    if (o.showLoader && (this._hasNext() || this.loaderStatus === "end")) {
      items.push([{
        type: "bi.loading_bar",
        ref: function ref() {
          switch (self.loaderStatus) {
            case "end":
              this.setEnd();
              break;

            case "loaded":
            default:
              this.setLoaded();
              break;
          }
        },
        listeners: [{
          eventName: BI.Controller.EVENT_CHANGE,
          action: function action(type) {
            if (type === BI.Events.CLICK) {
              this.setLoading();

              self._nextLoad();
            }
          }
        }]
      }]);
    }

    this.list.populate(items);
  },
  _nextLoad: function _nextLoad() {
    var self = this,
        o = this.options;
    o.itemsCreator.apply(this, [{
      times: ++this.times
    }, function () {
      self._addItems.apply(self, arguments);
    }]);
  },
  _addItems: function _addItems(items) {
    var o = this.options;
    this.count += items.length;
    o.items = BI.concat(o.items, items);

    if (this._hasNext()) {
      this.setLoaded();
    } else {
      this.setEnd();
    }

    this._populate();
  },
  _hasNext: function _hasNext() {
    var o = this.options;

    if (BI.isNumber(o.count)) {
      return this.count < o.count;
    }

    return !!o.hasNext.apply(this, [{
      times: this.times,
      count: this.count
    }]);
  },
  populate: function populate(items) {
    var o = this.options,
        self = this;

    if (arguments.length === 0 && BI.isFunction(o.itemsCreator)) {
      o.itemsCreator.apply(this, [{
        times: 1
      }, function () {
        if (arguments.length === 0) {
          throw new Error("参数不能为空");
        }

        self.populate.apply(self, arguments);
        o.onLoaded();
      }]);
      return;
    }

    if (items && items !== o.items) {
      o.items = items;
    }

    this.times = 1;
    this.count = items.length;
    this.loaderStatus = "loaded";

    this._populate();
  },
  setScrollTop: function setScrollTop(top) {
    this.list.setScrollTop(top);
  },
  setLoaded: function setLoaded() {
    this.loaderStatus = "loaded";
  },
  setEnd: function setEnd() {
    this.loaderStatus = "end";
  },
  setLoading: function setLoading() {
    this.loaderStatus = "loading";
  },
  destroyed: function destroyed() {
    this.removeListener && this.removeListener();
  }
});
BI.GridList.EVENT_CHANGE = "EVENT_CHANGE";
BI.shortcut("bi.grid_list", BI.GridList);

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/9/2
 */
BI.VirtualTreeList = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-virtual-tree-list",
    itemsCreator: BI.emptyFn,
    items: [],
    el: {
      type: 'bi.virtual_group_list',
      rowHeight: 32
    }
  },
  render: function render() {
    var self = this,
        o = this.options;
    return BI.extend({
      items: this._getNodes(),
      ref: function ref(_ref) {
        self.treeList = _ref;
      },
      overscanHeight: 200,
      blockSize: 20
    }, o.el);
  },
  _initTree: function _initTree(nodes) {
    if (BI.isNull(this.tree)) {
      this.tree = new BI.Tree();
    }

    var tree = BI.Tree.transformToTreeFormat(nodes);
    this.tree.initTree(tree);
  },
  _fillTree: function _fillTree(pId, nodes) {
    var self = this;
    var root = this.tree.getRoot();
    var parentNode = this.tree.search(root, pId) || root;
    BI.each(nodes, function (_idx, node) {
      var tNode = new BI.Node(node);
      tNode.set("data", _objectSpread({
        checked: parentNode.data.checked
      }, node));
      self.tree.addNode(parentNode, tNode);
    });

    this._populate();
  },
  _cutTree: function _cutTree(id) {
    var root = this.tree.getRoot();
    var parentNode = this.tree.search(root, id);

    if (BI.isNotNull(parentNode)) {
      parentNode.data.open = false;
    }

    this._populate();
  },
  _getNodes: function _getNodes() {
    var self = this;
    var nodes = [];

    if (!this.tree) {
      this._initTree(this.options.items);
    }

    this.tree.recursion(function (node) {
      nodes.push(BI.extend({
        id: node.id,
        pId: node.pId,
        key: node.key || node.id
      }, node.data));

      if (node.data.open !== true) {
        return true;
      }
    });
    return self._wrapperEvent(nodes);
  },
  _triggerNode: function _triggerNode(id) {
    var self = this;
    var node = this.tree.search(this.tree.getRoot(), id) || this.tree.getRoot();

    if (node.data.open === true) {
      // 收起
      this._cutTree(id);
    } else {
      if (node.getChildrenLength() === 0 && node.isParent) {
        this.options.itemsCreator({
          node: node
        }, function (nodes) {
          // 初次展开
          node.data.open = true;

          self._fillTree(node.id, nodes);
        });
      } else {
        node.data.open = true;

        this._populate();
      }
    }
  },
  _triggerNodeChecked: function _triggerNodeChecked(id, checked) {
    var self = this;
    var node = this.tree.search(this.tree.getRoot(), id);

    if (node) {
      // 把子节点设置成选中状态
      node.data.checked = checked;
      node.data.half = false;
      var queue = node.getChildren().slice();

      while (queue.length) {
        var _node = queue.shift();

        if (checked === _node.data.checked && !_node.data.half) {
          continue;
        }

        _node.data.checked = checked;
        _node.data.half = false;
        queue = queue.concat(_node.getChildren());
      }

      if (checked) {
        var parent = node.getParent();

        while (parent !== this.tree.getRoot()) {
          var exist = BI.some(parent.getChildren(), function (i, child) {
            if (!child.data.checked || child.data.half) {
              return true;
            }
          });

          if (exist) {
            parent.data.checked = false;
            parent.data.half = true;
          } else {
            parent.data.checked = true;
            parent.data.half = false;
          }

          parent = parent.getParent();
        }
      } else {
        var _parent = node.getParent();

        while (_parent !== this.tree.getRoot()) {
          var _exist = BI.some(_parent.getChildren(), function (i, child) {
            if (child.data.checked || child.data.half) {
              return true;
            }
          });

          if (_exist) {
            _parent.data.checked = false;
            _parent.data.half = true;
          } else {
            _parent.data.checked = false;
            _parent.data.half = false;
          }

          _parent = _parent.getParent();
        }
      }
    }

    this._populate();
  },
  _populate: function _populate() {
    this.treeList.populate(this._getNodes());
  },
  _wrapperEvent: function _wrapperEvent(nodes) {
    var self = this;
    return BI.map(nodes, function (_idx, node) {
      node.listeners = node.listeners || [];
      var has = BI.find(node.listeners, function (idx, listener) {
        return listener.eventName === '__EVENT_CHANGE__';
      });

      if (!has) {
        node.listeners.push({
          eventName: '__EVENT_CHANGE__',
          action: function action(v, value) {
            if (v === BI.Events.COLLAPSE || v === BI.Events.EXPAND) {
              self._triggerNode(node.id);

              self.fireEvent(BI.VirtualTreeList.EVENT_NODE_CHANGE, self.tree.search(self.tree.getRoot(), node.id) || self.tree.getRoot());
            }

            if (v === BI.Events.CHANGE) {
              self._triggerNodeChecked(node.id, value);

              self.fireEvent("EVENT_CHANGE", self.getTree());
            }
          }
        });
      }

      return node;
    });
  },
  move: function move(start, end) {
    if (start == null || end == null || start === end) {
      return;
    }

    var node1 = this.tree.search(this.tree.getRoot(), start);
    var node2 = this.tree.search(this.tree.getRoot(), end);

    if (node1.getParent() !== node2.getParent()) {
      return false;
    }

    var parent = node1.getParent();
    var indexStart = parent.getChildIndex(start);
    var indexEnd = parent.getChildIndex(end);

    if (indexStart < indexEnd) {
      parent.addChild(node1, indexEnd + 1);
      parent.removeChildByIndex(indexStart);
    } else {
      parent.addChild(node1, indexEnd);
      parent.removeChildByIndex(indexStart + 1);
    }

    this._populate();
  },
  getTree: function getTree() {
    return this.tree;
  },
  setOpened: function setOpened(nodeId, b) {
    var self = this;

    function openTree(nodeId) {
      var node = self.tree.search(self.tree.getRoot(), nodeId);
      var open = node && node.data.open;

      if (node && open === false) {
        node.data.open = true;
        openTree(node.pId);
      }
    }

    if (b) {
      openTree(nodeId);

      this._populate();
    } else {
      this._cutTree(nodeId);
    }
  },
  scrollToViewPosition: function scrollToViewPosition(nodeId) {
    // 暂时只支持传了rowHeight属性的滚动对应节点到可视位置
    if (BI.isKey(this.options.el.rowHeight)) {
      var count = 0;
      this.tree.recursion(function (node) {
        if (node.id === nodeId) {
          return false;
        }

        if (BI.get(node, ['parent', 'data', 'open']) !== false) {
          count++;
        }
      });
      var currentScrollTop = this.element.scrollTop();
      var itemPosition = (count + 1) * this.options.el.rowHeight;

      if (itemPosition < currentScrollTop || itemPosition > currentScrollTop + this.element.height()) {
        var scrollTop = BI.max([0, (count + 1) * this.options.el.rowHeight - this.element.height()]);
        this.element.scrollTop(scrollTop);
      }
    }
  },
  getValue: function getValue() {
    var result = [];
    this.tree.recursion(function (node) {
      var data = node.data;

      if (data.checked) {
        result.push(BI.isNull(data.value) ? data.id : data.value);
      }
    });
    return result;
  },
  populate: function populate(nodes) {
    this.options.items = nodes;

    this._initTree(this.options.items);

    this._populate();
  }
});
BI.VirtualTreeList.EVENT_CHANGE = "EVENT_CHANGE";
BI.VirtualTreeList.EVENT_NODE_CHANGE = "EVENT_NODE_CHANGE";
BI.shortcut("bi.virtual_tree_list", BI.VirtualTreeList);

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/9/2
 */
BI.VirtualTreeListNode = BI.inherit(BI.NodeButton, {
  props: {
    baseCls: 'bi-virtual-tree-list-node',
    id: "",
    height: 24,
    layer: 0,
    expandIcon: "expander-down-font",
    narrowIcon: "expander-right-font"
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: 'bi.htape',
      items: [{
        el: {
          type: 'bi.layout'
        },
        width: o.layer * 15
      }, {
        el: {
          type: "bi.arrow_group_node_checkbox",
          cls: o.open ? o.expandIcon : o.narrowIcon,
          ref: function ref(_ref) {
            self.arrow = _ref;
          }
        },
        width: 16
      }, {
        type: "bi.label",
        textAlign: "left",
        whiteSpace: "nowrap",
        textHeight: o.height,
        height: o.height,
        text: o.text,
        value: o.value,
        py: o.py,
        keyword: o.keyword,
        ref: function ref(_ref2) {
          self.text = _ref2;
        }
      }]
    };
  },
  doRedMark: function doRedMark() {
    this.text.doRedMark.apply(this.text, arguments);
  },
  unRedMark: function unRedMark() {
    this.text.unRedMark.apply(this.text, arguments);
  },
  doClick: function doClick() {
    if (this.isSelected()) {
      this.triggerExpand();
    } else {
      this.triggerCollapse();
    }
  },
  setOpened: function setOpened(v) {
    BI.VirtualTreeListNode.superclass.setOpened.apply(this, arguments);
    this.arrow.setSelected(v);
  },
  shouldUpdate: function shouldUpdate(opt) {
    var o = this.options;
    var keys = ["open", "layer", "pId", "value", 'keyword'];
    return BI.some(keys, function (idx, key) {
      return opt[key] !== o[key];
    });
  },
  update: function update(opt) {
    var o = this.options;

    if (opt.value !== o.value) {
      o.value = opt.value;
      this.text.setText(opt.value);
    }

    if (opt.open !== o.open) {
      o.open = opt.open;
      this.arrow.setSelected(opt.open);
    }

    if (!opt.keyword) {
      o.keyword = '';
      this.text.unRedMark(opt.value);
    } else if (opt.keyword !== o.keyword) {
      o.keyword = opt.keyword;
      this.text.doRedMark(opt.keyword);
    }
  }
});
BI.shortcut("bi.virtual_tree_list_node", BI.VirtualTreeListNode);

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/10/22
 * 兼容外部继承LoadingPane的情况
 */
BI.LoadingPane = BI.Pane;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * author: young
 * createdDate: 2019/4/19
 * description:
 * @Maintainers: young
 */
!function () {
  BI.ResizeContainerHtape = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-resize-container-htape",
      minSize: 260,
      maxSize: 260 * 1.5,
      initLeftSize: null,
      left: {
        type: "bi.default"
      },
      right: {
        type: "bi.default"
      }
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.htape",
        items: [{
          type: "bi.resizable_container",
          minSize: o.minSize,
          maxSize: o.maxSize,
          content: o.left,
          resize: BI.bind(this._resizeContainer, this),
          width: o.initLeftSize || o.minSize
        }, {
          el: o.right
        }],
        ref: function ref(_ref) {
          self.contianer = _ref;
        }
      };
    },
    _resizeContainer: function _resizeContainer(size) {
      this.contianer.attr("items")[0].width = size;
      this.contianer.resize();
      this.fireEvent("EVENT_RESIZE", size);
    }
  });
  BI.ResizeContainerHtape.EVENT_RESIZE = "EVENT_RESIZE";
  BI.shortcut("bi.resize_container.htape", BI.ResizeContainerHtape);
}();

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * author: young
 * createdDate: 2019/4/19
 * description:
 * @Maintainers: young
 */
!function () {
  BI.ResizableContainer = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-resizable-container",
      content: {},
      direction: "e",
      // e s w n ew sn we ns
      minSize: 15,
      maxSize: Number.MAX_VALUE,
      resizable: true,
      start: BI.emptyFn,
      resize: BI.emptyFn,
      stop: BI.emptyFn,
      startDragging: BI.emptyFn,
      broadCastResize: true
    },
    render: function render() {
      var self = this,
          o = this.options;
      var startDrag = false;
      var size = 0,
          offset = 0;
      this.defaultSize = o.height ? o.height : null;
      this.handler = BI.createWidget(BI.extend(this._createHandle(), {
        invisible: !o.resizable
      }));
      this.handler.element.on("click", function (e) {
        e.stopPropagation();
      });

      function optimizeSize(s) {
        return BI.clamp(s, o.minSize, o.maxSize || Number.MAX_VALUE);
      }

      this._stared = false;
      var mouseMoveTracker = new BI.MouseMoveTracker(function (deltaX, deltaY) {
        if (mouseMoveTracker.isDragging()) {
          if (!self._stared) {
            self._stared = true;
            o.startDragging();
          }

          BI.$(document.body).css("cursor", self._isHorizontalResize() ? "ew-resize" : "ns-resize");
          startDrag = true;

          if (BI.get(o.direction, 0) === "w") {
            deltaX = -deltaX;
          }

          offset += deltaX;

          if (BI.get(o.direction, 0) === "n") {
            deltaY = -deltaY;
          }

          offset += deltaY;
          size = optimizeSize((self.defaultSize || self._getDefaultSize()) + offset);
          self.handler.element.addClass("dragging");
          o.resize(size);
          o.broadCastResize && BI.$(window).trigger("resize");
        }
      }, function () {
        if (startDrag === true) {
          size = optimizeSize(size);
          o.stop(size);
          self.defaultSize = size;
          size = 0;
          offset = 0;
          startDrag = false;
          self._stared = false;
          BI.$(document.body).css("cursor", "auto");
        }

        self.handler.element.removeClass("dragging");
        self.handler.element.removeClass("suitable");
        mouseMoveTracker.releaseMouseMoves();
      }, document);
      this.handler.element.on("mousedown", function (event) {
        mouseMoveTracker.captureMouseMoves(event);
      });
      return {
        type: "bi.absolute",
        items: [{
          el: o.content,
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, BI.extend({
          el: this.handler
        }, this._getHandlePosition())]
      };
    },
    _isHorizontalResize: function _isHorizontalResize() {
      return BI.get(this.options.direction, 0) === "w" || BI.get(this.options.direction, 0) === "e";
    },
    _createHandle: function _createHandle() {
      if (this._isHorizontalResize()) {
        return {
          type: "bi.icon_label",
          cls: "horizontal-drag-font resize-handle-ew",
          width: 5
        };
      }

      return {
        type: "bi.icon_label",
        cls: "vertical-drag-font resize-handle-ns",
        height: 5
      };
    },
    _getHandlePosition: function _getHandlePosition() {
      switch (this.options.direction) {
        case "e":
          return {
            right: -2,
            top: 0,
            bottom: 0
          };

        case "ew":
          return {
            right: 8,
            top: 0,
            bottom: 0
          };

        case "w":
          return {
            left: -2,
            top: 0,
            bottom: 0
          };

        case "we":
          return {
            left: 8,
            top: 0,
            bottom: 0
          };

        case "s":
          return {
            left: 0,
            right: 0,
            bottom: -3
          };

        case "sn":
          return {
            left: 0,
            right: 0,
            bottom: 2
          };

        case "n":
          return {
            top: -3,
            left: 0,
            right: 0
          };

        case "ns":
          return {
            top: 2,
            left: 0,
            right: 0
          };

        default:
          break;
      }
    },
    _getDefaultSize: function _getDefaultSize() {
      var o = this.options;

      if (this._isHorizontalResize()) {
        return o.width || o.minSize;
      }

      return o.height || o.minSize;
    },
    setMinSize: function setMinSize(minWidth) {
      this.options.minSize = minWidth;
    },
    setMaxSize: function setMaxSize(maxWidth) {
      this.options.maxSize = maxWidth;
    },
    setResizable: function setResizable(resizable) {
      this.options.resizable = resizable;
      this.handler.setVisible(resizable);
      BI.$(window).trigger("resize");
    },
    reset: function reset() {
      this.defaultSize = null;
    }
  });
  BI.shortcut("bi.resizable_container", BI.ResizableContainer);
}();

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * author: young
 * createdDate: 2019/4/19
 * description:
 * @Maintainers: young
 */
!function () {
  BI.ResizeContainerVtape = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-resize-container-vtape",
      minSize: 100,
      maxSize: 200,
      initTopSize: null,
      top: {
        type: "bi.default"
      },
      bottom: {
        type: "bi.default"
      }
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.vtape",
        items: [{
          type: "bi.resizable_container",
          direction: "s",
          minSize: o.minSize,
          maxSize: o.maxSize,
          content: o.top,
          resize: BI.bind(this._resizeContainer, this),
          height: o.initTopSize || o.minSize
        }, {
          el: o.bottom
        }],
        ref: function ref(_ref) {
          self.contianer = _ref;
        }
      };
    },
    _resizeContainer: function _resizeContainer(size) {
      this.contianer.attr("items")[0].height = size;
      this.contianer.resize();
      this.fireEvent("EVENT_RESIZE", size);
    }
  });
  BI.ResizeContainerVtape.EVENT_RESIZE = "EVENT_RESIZE";
  BI.shortcut("bi.resize_container.vtape", BI.ResizeContainerVtape);
}();

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 自定义滚动条
 */
!function () {
  BI.ScrollbarContainer = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-scrollbar-container",
      el: {}
    },
    render: function render() {
      var self = this,
          o = this.options;
      return [o.el, {
        type: "bi.absolute",
        items: [{
          el: {
            type: "bi.grid_table_scrollbar",
            ref: function ref(_ref) {
              self.verticalScrollbar = _ref;
            },
            listeners: [{
              eventName: BI.GridTableScrollbar.EVENT_SCROLL,
              action: function action(scrollTop) {
                try {
                  self.element.scrollTop(scrollTop);
                } catch (e) {}
              }
            }]
          },
          top: 0,
          bottom: 0,
          right: 0
        }, {
          el: {
            type: 'bi.grid_table_scrollbar',
            orientation: 'horizontal',
            ref: function ref(_ref) {
              self.horizontalScrollbar = _ref;
            },
            listeners: [{
              eventName: BI.GridTableScrollbar.EVENT_SCROLL,
              action: function action(scrollLeft) {
                try {
                  self.element.scrollLeft(scrollLeft);
                } catch (e) {}
              }
            }]
          },
          left: 0,
          bottom: 0,
          right: 0
        }]
      }];
    },
    _handleResize: function _handleResize() {
      var scrollTop = this.element.scrollTop();
      var scrollHeight = this.element[0].scrollHeight;
      var height = this.element.height();
      this.verticalScrollbar.setContentSize(scrollHeight);
      this.verticalScrollbar.setSize(height);
      this.verticalScrollbar.setPosition(scrollTop);
      this.verticalScrollbar.populate();
      var scrollLeft = this.element.scrollLeft();
      var scrollWidth = this.element[0].scrollWidth;
      var width = this.element.width();
      this.horizontalScrollbar.setContentSize(scrollWidth);
      this.horizontalScrollbar.setSize(width);
      this.horizontalScrollbar.setPosition(scrollLeft);
      this.horizontalScrollbar.populate();
    },
    mounted: function mounted() {
      var self = this;
      this.element.scroll(function () {
        var scrollTop = self.element.scrollTop();
        self.verticalScrollbar.setVisible(true);
        self.verticalScrollbar.setPosition(scrollTop);
        self.verticalScrollbar.populate();
        var scrollLeft = self.element.scrollLeft();
        self.horizontalScrollbar.setVisible(true);
        self.horizontalScrollbar.setPosition(scrollLeft);
        self.horizontalScrollbar.populate();
      });
      this.resizeObserver = BI.ResizeDetector.addResizeListener(this, this._handleResize.bind(this));

      if (window.MutationObserver) {
        this.mutationObserver = new window.MutationObserver(this._handleResize.bind(this));
        this.mutationObserver.observe(this.element[0], {
          attributes: true,
          childList: true,
          subtree: true
        });
      }

      this.verticalPopper = BI.Popper.createPopper(this.element[0], this.verticalScrollbar.element[0], {
        placement: 'right-start',
        strategy: 'fixed',
        modifiers: [{
          name: 'offset',
          options: {
            offset: [0, 0]
          }
        }, {
          name: "flip",
          enabled: false
        }]
      });
      this.horizontalPopper = BI.Popper.createPopper(this.element[0], this.horizontalScrollbar.element[0], {
        placement: 'bottom-start',
        strategy: 'fixed',
        modifiers: [{
          name: 'offset',
          options: {
            offset: [0, 0]
          }
        }, {
          name: "flip",
          enabled: false
        }]
      });

      this._handleResize();
    },
    destroyed: function destroyed() {
      this.resizeObserver();
      this.mutationObserver && this.mutationObserver.disconnect();
      this.verticalPopper.destroy();
      this.horizontalPopper.destroy();
    }
  });
  BI.shortcut("bi.scrollbar_container", BI.ScrollbarContainer);
  BI.config("bi.scrollbar_container", function (ob) {
    // 只做chrome和edge的，因为chrome下滚动条可以隐藏，其他的不可以
    if (BI.isIE()) {
      return BI.extend({}, ob, {
        type: "bi.el"
      });
    }

    return ob;
  });
}();

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * ------------------------------------------------------------------
 * 组合色选择的单个组合，有五种颜色
 * @param    {array}  value     初始选择的颜色组合
 * @param    {array}  colors    所有颜色组合配置
 * ------------------------------------------------------------------
 */
!function () {
  var SelectColorItem = BI.inherit(BI.BasicButton, {
    props: {
      extraCls: "bi-select-color-item bi-border",
      value: [],
      colors: [],
      once: true,
      height: 50,
      width: 130
    },
    mounted: function mounted() {
      var o = this.options;
      BI.each(this.layouts, function (i, layout) {
        layout.element.css("background-color", o.value[i]);
      });
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.layouts = [];
      return {
        type: "bi.absolute",
        items: [{
          el: {
            type: "bi.button_group",
            items: BI.map(o.colors, function () {
              return {
                type: "bi.layout",
                ref: function ref(_ref) {
                  self.layouts.push(_ref);
                }
              };
            }),
            layouts: [{
              type: "bi.center",
              hgap: 0.5,
              vgap: 2
            }]
          },
          left: 1,
          right: 2,
          top: 0,
          bottom: 0
        }]
      };
    }
  });
  SelectColorItem.EVENT_CHANGE = "EVENT_CHANGE";
  BI.shortcut("bi.select_color_item", SelectColorItem);
}();

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * ------------------------------------------------------------------
 * 组合色选择的弹出层，列出所有的颜色组合
 * @param    {array}  colors    所有颜色组合配置
 * @param    {array}  value     当前选中颜色组合
 * ------------------------------------------------------------------
 */
!function () {
  var SelectColorPopup = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-select-color-popup",
      height: 160,
      items: []
    },
    render: function render() {
      var self = this,
          o = this.options;
      var items = [];
      BI.each(o.colors, function (i, style) {
        items.push({
          type: "bi.select_color_item_wrapper",
          selected: BI.isEqual(o.value, style.colors),
          header: style.value,
          colors: style.colors.slice(0, 5),
          value: style.colors
        });
      });
      return {
        type: "bi.absolute",
        items: [{
          el: {
            type: "bi.button_group",
            items: items,
            layouts: [{
              type: "bi.vertical",
              hgap: 5
            }],
            listeners: [{
              eventName: BI.ButtonGroup.EVENT_CHANGE,
              action: function action(value, item) {
                self.popup.setValue(value);
                item.setSelected && item.setSelected(true);
                self.fireEvent(SelectColorPopup.EVENT_CHANGE, value);
              }
            }],
            ref: function ref(_ref) {
              self.popup = _ref;
            }
          },
          top: 5,
          right: 0,
          bottom: 5,
          left: 0
        }]
      };
    },
    getValue: function getValue() {
      return this.popup.getValue();
    }
  });
  SelectColorPopup.EVENT_CHANGE = "EVENT_CHANGE";
  BI.shortcut("bi.select_color_popup", SelectColorPopup);
}();

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * ------------------------------------------------------------------
 * 组合色选择
 * @param    {array}  value     初始选择的颜色组合
 * @param    {array}  colors    所有颜色组合配置
 * ------------------------------------------------------------------
 */
!function () {
  BI.SelectColorCombo = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-select-color-combo",
      width: 130,
      items: [],
      colors: [],
      value: []
    },
    _store: function _store() {
      return BI.Models.getModel("bi.model.select.color.combo", {
        value: this.options.value
      });
    },
    watch: {
      selectedColor: function selectedColor(color) {
        color = BI.isArray(color) ? color : [color];
        this.combo.setValue(color);
      }
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.combo",
        value: this.model.selectedColor,
        adjustLength: 5,
        el: {
          type: "bi.select_color_trigger",
          title: function title() {
            var res = BI.find(o.colors, function (i, style) {
              if (BI.isEqual(style.colors, self.model.selectedColor)) {
                return true;
              }
            });
            return res && res.text;
          },
          value: this.model.selectedColor
        },
        popup: {
          el: {
            type: "bi.select_color_popup",
            value: this.model.selectedColor,
            colors: o.colors,
            listeners: [{
              eventName: "EVENT_CHANGE",
              action: function action(value) {
                self.store.setSelectedColor(value);
                self.combo.hideView();
                self.fireEvent(BI.SelectColorCombo.EVENT_CHANGE);
              }
            }],
            ref: function ref(_ref) {
              self.popup = _ref;
            }
          },
          stopPropagation: false,
          minWidth: 152
        },
        ref: function ref(_ref2) {
          self.combo = _ref2;
        },
        listeners: [{
          eventName: BI.Combo.EVENT_AFTER_INIT,
          action: function action() {
            self.popup.setValue(self.model.selectedColor);
          }
        }]
      };
    }
  });
  BI.SelectColorCombo.EVENT_CHANGE = "EVENT_CHANGE";
  BI.shortcut("bi.select_color_combo", BI.SelectColorCombo);
}();

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var SelectColorComboModel = BI.inherit(Fix.Model, {
    state: function state() {
      return {
        selectedColor: this.options.value
      };
    },
    actions: {
      setSelectedColor: function setSelectedColor(v) {
        this.model.selectedColor = v;
      }
    }
  });
  BI.model("bi.model.select.color.combo", SelectColorComboModel);
}();

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * ------------------------------------------------------------------
 * 组合色选择的弹窗触发器，有五种颜色
 * @param    {array}  value     初始选择的颜色组合
 * @param    {array}  colors    所有颜色组合配置
 * ------------------------------------------------------------------
 */
!function () {
  var SelectColorTrigger = BI.inherit(BI.Trigger, {
    props: {
      extraCls: " bi-select-color-trigger bi-border",
      height: 28,
      value: []
    },
    mounted: function mounted() {
      var self = this,
          o = this.options;
      BI.each(this.layouts, function (i, layout) {
        layout.element.css("background-color", o.value[i]);
      });
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.layouts = [];
      return {
        type: "bi.absolute",
        items: [{
          el: {
            type: "bi.button_group",
            items: BI.map(o.value.slice(0, 5), function () {
              return {
                type: "bi.layout",
                ref: function ref(_ref) {
                  self.layouts.push(_ref);
                }
              };
            }),
            layouts: [{
              type: "bi.center",
              hgap: 0.5,
              vgap: 2
            }],
            ref: function ref(_ref2) {
              self.colorContainer = _ref2;
            }
          },
          left: 1,
          right: 2,
          top: 0,
          bottom: 0
        }, {
          el: {
            type: "bi.icon_button",
            disableSelected: true,
            cls: "icon-combo-down-icon trigger-triangle-font",
            width: 15,
            height: 10,
            ref: function ref(_ref3) {
              self.down = _ref3;
            }
          },
          right: 4,
          bottom: 5
        }]
      };
    },
    populate: function populate(items) {
      this.options.items = items;
    },
    setValue: function setValue(vals) {
      this.value = vals;
      BI.each(this.layouts, function (i, layout) {
        layout.element.css("background-color", vals[i]);
      });
    },
    getValue: function getValue() {
      return this.value;
    }
  });
  SelectColorTrigger.EVENT_CHANGE = "EVENT_CHANGE";
  BI.shortcut("bi.select_color_trigger", SelectColorTrigger);
}();

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * ------------------------------------------------------------------
 * 组合色选择的单个组合加上标题形成的新容器
 * @param    {String}  header     颜色组合标题名称
 * @param    {Array}   value      初始选择的颜色组合
 * @param    {Array}   colors     所有颜色组合配置
 * ------------------------------------------------------------------
 */
!function () {
  var SelectColorItemWrapper = BI.inherit(BI.BasicButton, {
    props: {
      extraCls: "bi-select-color-item-wrapper",
      header: "",
      value: [],
      colors: [],
      height: 50,
      width: 130
    },
    render: function render() {
      var self = this,
          o = this.options;
      return {
        type: "bi.vtape",
        hgap: 2,
        items: [{
          type: "bi.label",
          textAlign: "left",
          text: o.header,
          lgap: 3
        }, {
          el: {
            type: "bi.select_color_item",
            value: o.value,
            colors: o.colors,
            ref: function ref(_ref) {
              self.item = _ref;
            },
            listeners: [{
              eventName: "EVENT_CHANGE",
              action: function action() {
                self.fireEvent(BI.Controller.EVENT_CHANGE, this.getValue());
              }
            }]
          },
          height: 28
        }]
      };
    },
    setSelected: function setSelected(v) {
      this.item.setSelected(v);
    },
    isSelected: function isSelected() {
      return this.item.isSelected();
    }
  });
  BI.shortcut("bi.select_color_item_wrapper", SelectColorItemWrapper);
}();

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Widget = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-steps-item",
      text: "",
      stepWidth: 88,
      stepHeight: 50,
      showLine: true
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.constant = BI.Constants.getConstant("bi.constants.steps.status");
      this.status = this.constant.NEXT;
      return {
        type: "bi.htape",
        height: o.stepHeight,
        items: [{
          el: {
            type: "bi.vertical_adapt",
            items: [{
              type: "bi.layout",
              cls: "step-line",
              height: 2,
              width: "100%",
              invisible: !o.showLine
            }]
          },
          rgap: 8
        }, {
          el: {
            type: "bi.right_vertical_adapt",
            items: [{
              type: "bi.icon_change_button",
              iconCls: "step-next",
              iconWidth: 14,
              iconHeight: 14,
              ref: function ref(_ref) {
                self.icon = _ref;
              },
              rgap: 8
            }, {
              type: "bi.label",
              cls: "step-text",
              textAlign: "left",
              whiteSpace: "nowrap",
              rgap: 5,
              text: o.text
            }]
          },
          width: o.stepWidth
        }]
      };
    },
    setStatus: function setStatus(status) {
      if (status === this.status) {
        return;
      }

      this.status = status;

      switch (status) {
        case this.constant.CURR:
          this.icon.setIcon("step-now");
          this.element.addClass("active");
          break;

        case this.constant.PREV:
          this.icon.setIcon("step-prev");
          this.element.addClass("active");
          break;

        case this.constant.NEXT:
        default:
          this.icon.setIcon("step-next");
          this.element.removeClass("active");
          break;
      }
    }
  });
  BI.shortcut("bi.steps.item", Widget);
}();

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  BI.constant("bi.constants.steps.status", {
    PREV: 0,
    CURR: 1,
    NEXT: 2
  });
}();

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 步骤条组件
 * 需要外部给宽度
 */
!function () {
  BI.Steps = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-steps",
      stepItems: [],
      stepHeight: 50,
      stepWidth: 88
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.steps = [];
      this.currStep = 0;
      this.constant = BI.Constants.getConstant("bi.constants.steps.status"); // 初始化第一个步骤

      this.steps.push(BI.createWidget(this._createStep(o.stepItems[0], false)));
      var grid = BI.createWidget({
        type: "bi.grid",
        rows: 1,
        width: "100%",
        columns: o.stepItems.length - 1,
        items: BI.map(o.stepItems.slice(1), function (idx, val) {
          return {
            row: 0,
            column: idx,
            el: BI.extend(self._createStep(val, true), {
              ref: function ref(_ref) {
                self.steps.push(_ref);
              }
            })
          };
        })
      });
      return {
        type: "bi.htape",
        items: [{
          el: this.steps[0],
          width: o.stepWidth
        }, {
          el: grid
        }],
        height: o.stepHeight
      };
    },
    _createStep: function _createStep(v, showLine) {
      var o = this.options;
      return BI.extend(v, {
        type: "bi.steps.item",
        stepHeight: o.stepHeight,
        stepWidth: o.stepWidth,
        showLine: showLine
      });
    },
    mounted: function mounted() {
      this.steps[0] && this.steps[0].setStatus(this.constant.CURR);
    },
    setValue: function setValue(val) {
      var self = this;
      this.currStep = val;
      BI.each(this.options.stepItems, function (i) {
        if (i < val) {
          self.steps[i].setStatus(self.constant.PREV);
        } else if (i === val) {
          self.steps[i].setStatus(self.constant.CURR);
        } else {
          self.steps[i].setStatus(self.constant.NEXT);
        }
      });
    },
    getValue: function getValue() {
      return this.currStep;
    }
  });
  BI.shortcut("bi.steps", BI.Steps);
}();

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * ASCII 32-126 单位字体大小宽度
 * windows下场景,默认字体族：Avenir, "Segoe UI", PingFangSC-Regular, "Microsoft YaHei"
 * https://kms.fineres.com/pages/viewpage.action?pageId=271278482
 */
!function () {
  var WIDTHS = {
    32: 0.274,
    33: 0.284,
    34: 0.393,
    35: 0.592,
    36: 0.540,
    37: 0.819,
    38: 0.801,
    39: 0.230,
    40: 0.303,
    41: 0.303,
    42: 0.418,
    43: 0.684,
    44: 0.218,
    45: 0.400,
    46: 0.218,
    47: 0.391,
    48: 0.54,
    49: 0.54,
    50: 0.54,
    51: 0.54,
    52: 0.54,
    53: 0.54,
    54: 0.54,
    55: 0.54,
    56: 0.54,
    57: 0.54,
    58: 0.218,
    59: 0.218,
    60: 0.684,
    61: 0.684,
    62: 0.684,
    63: 0.449,
    64: 0.955,
    65: 0.646,
    66: 0.574,
    67: 0.620,
    68: 0.703,
    69: 0.507,
    70: 0.488,
    71: 0.687,
    72: 0.710,
    73: 0.267,
    74: 0.358,
    75: 0.580,
    76: 0.471,
    77: 0.899,
    78: 0.749,
    79: 0.754,
    80: 0.561,
    81: 0.754,
    82: 0.599,
    83: 0.532,
    84: 0.524,
    85: 0.688,
    86: 0.622,
    87: 0.934,
    88: 0.591,
    89: 0.553,
    90: 0.571,
    91: 0.303,
    92: 0.379,
    93: 0.303,
    94: 0.684,
    95: 0.416,
    96: 0.269,
    97: 0.509,
    98: 0.588,
    99: 0.463,
    100: 0.590,
    101: 0.524,
    102: 0.313,
    103: 0.590,
    104: 0.567,
    105: 0.243,
    106: 0.243,
    107: 0.498,
    108: 0.243,
    109: 0.862,
    110: 0.567,
    111: 0.587,
    112: 0.588,
    113: 0.590,
    114: 0.348,
    115: 0.425,
    116: 0.340,
    117: 0.567,
    118: 0.479,
    119: 0.723,
    120: 0.459,
    121: 0.484,
    122: 0.453,
    123: 0.303,
    124: 0.240,
    125: 0.303,
    126: 0.684
  };
  BI.constant("bi.constant.char.widths", WIDTHS);
}();

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * DynamicGridView
 *
 * Created by GUY on 2020/6/24.
 * @class GridView
 * @extends BI.Widget
 */
!function () {
  var GridView = BI.inherit(BI.Widget, {
    props: function props() {
      return {
        baseCls: "bi-dynamic-collection-view",
        overscanHeight: 100,
        blockSize: 10,
        scrollTop: 0,
        scrollLeft: 0,
        columnSize: [],
        isNeedFreeze: false,
        freezeCols: [],
        isNeedMerge: false,
        mergeCols: [],
        mergeRule: BI.emptyFn,
        stopScrollEvent: false,
        items: [],
        el: {},
        trRenderer: null
      };
    },
    created: function created() {
      var self = this;
      this.renderedIndex = -1;
      this.cache = {};
      this.trCache = {};
      this._debounceRelease = BI.debounce(function () {
        self._scrollLock = false;
      }, 1000 / 60);
    },
    render: function render() {
      var self = this,
          o = this.options;
      return BI.extend(o.el, {
        type: "bi.vertical",
        scrolly: false,
        scrollable: true,
        items: [{
          type: "bi.default",
          tagName: o.trRenderer ? "div" : "table",
          css: {
            marginLeft: o.isNeedFreeze ? -1 * BI.sum(o.columnSize.slice(0, o.freezeCols.length)) : 0
          },
          ref: function ref() {
            self.table = this;
          },
          items: (o.trRenderer ? [] : [{
            type: "bi.default",
            tagName: "colgroup",
            ref: function ref() {
              self.colGroup = this;
            }
          }]).concat([{
            type: "bi.layout",
            ref: function ref() {
              self.topBlank = this;
            }
          }, {
            type: "bi.default",
            tagName: o.trRenderer ? "div" : "tbody",
            ref: function ref() {
              self.container = this;
            }
          }, {
            type: "bi.layout",
            ref: function ref() {
              self.bottomBlank = this;
            }
          }])
        }]
      });
    },
    mounted: function mounted() {
      var self = this,
          o = this.options;

      if (o.items.length > 0) {
        this._populate();
      }

      this.element.scroll(function (e) {
        if (self._scrollLock === true) {
          return;
        }

        o.scrollLeft = self.element.scrollLeft();
        o.scrollTop = self.element.scrollTop();
        !o.stopScrollEvent && self._calculateBlocksToRender();
        self.fireEvent(GridView.EVENT_SCROLL, {
          scrollLeft: o.scrollLeft,
          scrollTop: o.scrollTop
        });
      });
      BI.ResizeDetector.addResizeListener(this, function () {
        try {
          self._calculateBlocksToRender();
        } catch (e) {}
      });
    },
    _renderMoreIf: function _renderMoreIf() {
      var self = this,
          o = this.options;
      var height = this.element.height();
      var minContentHeight = o.scrollTop + height + o.overscanHeight;
      var index = this.cache[this.renderedIndex] && this.cache[this.renderedIndex].index + this.cache[this.renderedIndex].size || 0,
          cnt = this.renderedIndex + 1;
      var lastHeight;

      var getElementHeight = function getElementHeight() {
        return self.container.element.height() + self.topBlank.element.height() + self.bottomBlank.element.height();
      };

      while ((lastHeight = getElementHeight()) < minContentHeight && index < o.items.length) {
        // 找到最大扩展行，考虑到行合并的情况
        var queue = [];

        for (var i = index; i < index + o.blockSize && i < o.items.length; i++) {
          queue.push(i);
        }

        var spanSizeTo = index + o.blockSize;

        while (queue.length > 0) {
          var row = queue[0];

          for (var j = 0; j < o.columnSize.length; j++) {
            var mergeRows = self.itemsMap[row][j].__mergeRows;
            var rowspan = mergeRows ? mergeRows.length : 1;
            var spanTo = row + (rowspan | 0);

            for (var i = row; i < spanTo; i++) {
              if (queue.indexOf(i) < 0) {
                queue.push(i);
                spanSizeTo = spanTo;
              }
            }
          }

          queue.shift();
        }

        var items = o.items.slice(index, spanSizeTo);

        this._addItems(items, index);

        var addedHeight = getElementHeight() - lastHeight;
        this.cache[cnt] = {
          index: index,
          height: addedHeight,
          size: spanSizeTo - index
        };
        this.tree.set(cnt, addedHeight);
        this.renderedIndex = cnt;
        cnt++;
        index += spanSizeTo - index;
      }
    },
    _addItem: function _addItem(rows, index) {
      var self = this,
          o = this.options;

      if (o.trRenderer) {
        return BI.createWidget(o.trRenderer(rows, index, this.itemsMap[index]), {
          root: true
        });
      }

      var tr = BI.createWidget({
        type: "bi.adaptive",
        root: true,
        tagName: "tr",
        height: o.rowSizeGetter ? o.rowSizeGetter(index) : null,
        items: BI.map(rows, function (j, item) {
          if (BI.isNotEmptyObject(self.itemsMap[index][j])) {
            var rowspan = self.itemsMap[index][j].__mergeRows.length;
            var colspan = self.itemsMap[index][j].__mergeCols.length;
            return {
              type: "bi.default",
              tagName: "td",
              attributes: {
                rowspan: rowspan > 1 ? rowspan : undefined,
                colspan: colspan > 1 ? colspan : undefined
              },
              cls: "bi-collection-table-cell",
              items: [BI.extend({
                type: "bi.label"
              }, item)]
            };
          }
        })
      });
      return tr;
    },
    _serialize: function _serialize(items, columnSize, mergeCols, mergeRows) {
      mergeCols = mergeCols || [];
      mergeRows = mergeRows || [];
      var self = this,
          o = this.options;
      var result = [],
          cache = {},
          preCol = {},
          preRow = {},
          map = {};
      var summaryColumnSize = [];

      for (var i = 0; i < columnSize.length; i++) {
        if (i === 0) {
          summaryColumnSize[i] = columnSize[i];
        } else {
          summaryColumnSize[i] = summaryColumnSize[i - 1] + columnSize[i];
        }
      }

      var mergeRow = function mergeRow(i, j) {
        preCol[j].__mergeRows.push(i);
      };

      var mergeCol = function mergeCol(i, j) {
        preRow[i]._width += columnSize[j];

        preRow[i].__mergeCols.push(j);
      };

      var createOneEl = function createOneEl(r, c) {
        var width = columnSize[c];
        map[r][c]._row = r;
        map[r][c]._col = c;
        map[r][c]._width = width;
        preCol[c] = map[r][c];
        preCol[c].__mergeRows = [r];
        preRow[r] = map[r][c];
        preRow[r].__mergeCols = [c];
      };

      BI.each(items, function (i, cols) {
        for (var j = 0; j < cols.length; j++) {
          if (!cache[i]) {
            cache[i] = {};
          }

          if (!map[i]) {
            map[i] = {};
          }

          cache[i][j] = cols[j];
          map[i][j] = {};

          if (mergeCols === true || mergeCols.indexOf(j) > -1 || mergeRows === true || mergeRows.indexOf(i) > -1) {
            if (i === 0 && j === 0) {
              createOneEl(0, 0);
            } else if (j === 0 && i > 0) {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);

              if (isNeedMergeRow === true) {
                mergeRow(i, j);
                preRow[i] = preCol[j];
              } else {
                createOneEl(i, j);
              }
            } else if (i === 0 && j > 0) {
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol === true) {
                mergeCol(i, j);
                preCol[j] = preRow[i];
              } else {
                createOneEl(i, j);
              }
            } else {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol && isNeedMergeRow) {
                continue; // mergeRow(i, j);//优先合并列
              }

              if (isNeedMergeCol) {
                mergeCol(i, j);
              }

              if (isNeedMergeRow) {
                mergeRow(i, j);
              }

              if (!isNeedMergeCol && !isNeedMergeRow) {
                createOneEl(i, j);
              }
            }
          } else {
            createOneEl(i, j);
          }
        }
      });
      return map;
    },
    _addItems: function _addItems(items, startIndex) {
      var self = this;

      var fragment = BI.Widget._renderEngine.createFragment();

      BI.each(items, function (i, rows) {
        var tr = self._addItem(rows, startIndex + i);

        self.trCache[startIndex + i] = tr;
        fragment.appendChild(tr.element[0]);
      });
      this.container.element.append(fragment);
    },
    _calculateBlocksToRender: function _calculateBlocksToRender() {
      if (!this.tree || this.options.items.length === 0) {
        return;
      }

      var self = this,
          o = this.options;

      this._renderMoreIf();

      var height = this.element.height();
      var minContentHeightFrom = o.scrollTop - o.overscanHeight;
      var minContentHeightTo = o.scrollTop + height + o.overscanHeight;
      var start = this.tree.greatestLowerBound(minContentHeightFrom);
      var end = this.tree.leastUpperBound(minContentHeightTo);
      var needDestroyed = [];

      for (var i = 0; i < start; i++) {
        if (this.cache[i]) {
          var index = this.cache[i].index;

          if (!this.cache[i].destroyed) {
            for (var j = index; j < index + this.cache[i].size && j < o.items.length; j++) {
              needDestroyed.push(this.trCache[j]);
              delete this.trCache[j];
            }

            this.cache[i].destroyed = true;
          }
        }
      }

      for (var i = end + 1; i <= this.renderedIndex; i++) {
        if (this.cache[i]) {
          var index = this.cache[i].index;

          if (!this.cache[i].destroyed) {
            for (var j = index; j < index + this.cache[i].size && j < o.items.length; j++) {
              needDestroyed.push(this.trCache[j]);
              delete this.trCache[j];
            }

            this.cache[i].destroyed = true;
          }
        }
      }

      var firstFragment = BI.Widget._renderEngine.createFragment(),
          lastFragment = BI.Widget._renderEngine.createFragment();

      var currentFragment = firstFragment;

      for (var i = start < 0 ? 0 : start; i <= end && i <= this.renderedIndex; i++) {
        var index = this.cache[i].index;

        if (!this.cache[i].destroyed) {
          currentFragment = lastFragment;
        }

        if (this.cache[i].destroyed === true) {
          for (var j = index; j < index + this.cache[i].size && j < o.items.length; j++) {
            var tr = self._addItem(o.items[j], j);

            this.trCache[j] = tr;
            currentFragment.appendChild(tr.element[0]);
          }

          this.cache[i].destroyed = false;
        }
      }

      this.container.element.prepend(firstFragment);
      this.container.element.append(lastFragment);
      this.topBlank.setHeight(this.tree.sumTo(Math.max(-1, start - 1)));
      this.bottomBlank.setHeight(this.tree.sumTo(this.renderedIndex) - this.tree.sumTo(Math.min(end, this.renderedIndex)));
      BI.each(needDestroyed, function (i, child) {
        child && child._destroy();
      }); // 更新高度

      for (var i = start < 0 ? 0 : start; i <= end && i <= this.renderedIndex; i++) {
        var index = this.cache[i].index;
        var h = 0;

        for (var j = index; j < index + this.cache[i].size && j < o.items.length; j++) {
          if (o.rowSizeGetter) {
            var t = o.rowSizeGetter(j);
            this.trCache[j].element.height(t);
            h += t;
          } else {
            h += this.trCache[j].element.height();
          }
        }

        if (this.cache[i].height !== h) {
          this.cache[i].height = h;
          this.tree.set(i, h);
        }
      }
    },
    _populate: function _populate(items) {
      var self = this,
          o = this.options;

      if (items && this.options.items !== items) {
        this.options.items = items;
        this.itemsMap = this._serialize(o.items, o.columnSize, o.mergeCols);
      }

      if (!this.tree) {
        this.tree = BI.PrefixIntervalTree.empty(Math.ceil(o.items.length / o.blockSize));
      }

      this.table.setWidth(BI.sum(o.columnSize));
      this.table.element.css({
        marginLeft: o.isNeedFreeze ? -1 * BI.sum(o.columnSize.slice(0, o.freezeCols.length)) : 0
      });

      if (this.colGroup) {
        BI.each(o.columnSize, function (i, size) {
          if (self.colGroup.element.children().eq(i).length === 0) {
            self.colGroup.addItem({
              type: "bi.layout",
              tagName: "col",
              width: size
            });
          } else {
            self.colGroup.element.children().eq(i).css("width", size);
          }
        });
      }

      this._calculateBlocksToRender(); // try {
      //     this.element.scrollTop(o.scrollTop);
      // } catch (e) {
      // }

    },
    _clearChildren: function _clearChildren() {
      this.colGroup.empty();
      this.container.empty();
    },
    setColumnSize: function setColumnSize(columnSize) {
      this.options.columnSize = columnSize;
    },
    setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
      this.options.regionColumnSize = regionColumnSize;
    },
    getMaxScrollTop: function getMaxScrollTop() {
      return this.container.element.height() + this.topBlank.element.height() + this.bottomBlank.element.height() - this.element.height();
    },
    getScrollTop: function getScrollTop() {
      return this.options.scrollTop;
    },
    getScrollLeft: function getScrollLeft() {
      return this.options.scrollLeft;
    },
    setScrollLeft: function setScrollLeft(scrollLeft) {
      if (this.options.scrollLeft === scrollLeft) {
        return;
      }

      this._scrollLock = true;
      this.options.scrollLeft = scrollLeft;

      this._debounceRelease(); // this._calculateChildrenToRender();


      this.element.scrollLeft(this.options.scrollLeft);
    },
    setScrollTop: function setScrollTop(scrollTop) {
      if (this.options.scrollTop === scrollTop) {
        return;
      }

      this._scrollLock = true;
      this.options.scrollTop = scrollTop;

      this._debounceRelease();

      this._calculateBlocksToRender();

      this.element.scrollTop(this.options.scrollTop);
      this.fireEvent("EVENT_SYNC", scrollTop);
    },
    restore: function restore() {
      this.renderedIndex = -1;

      this._clearChildren();

      this.cache = {};
      this.tree = null;
      this.trCache = {};
      this.options.scrollTop = 0; // 依赖于cache的占位元素也要初始化

      this.topBlank.setHeight(0);
      this.bottomBlank.setHeight(0);
    },
    populate: function populate(items) {
      var o = this.options;

      if (items && this.options.items !== items) {
        this.restore();
      }

      this._populate(items);
    },
    destroyed: function destroyed() {
      this.restore();
    }
  });
  GridView.EVENT_SCROLL = "EVENT_SCROLL";
  BI.shortcut("bi.dynamic_collection_view", GridView);
}();

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 原生表格滚动条，为了IE8的兼容
 *
 * Created by GUY on 2016/1/12.
 * @class BI.NativeTableScrollbar
 * @extends BI.Widget
 */
BI.NativeTableScrollbar = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.NativeTableScrollbar.superclass._defaultConfig.apply(this, arguments), {
      attributes: {
        tabIndex: 0
      },
      contentSize: 0,
      defaultPosition: 0,
      position: 0,
      size: 0
    });
  },
  render: function render() {
    var self = this,
        o = this.options; // 把滚动条size改掉

    this.element.width(36);
    var throttle = BI.throttle(function () {
      self.fireEvent(BI.NativeTableScrollbar.EVENT_SCROLL, self.element.scrollTop());
    }, 150, {
      leading: false
    });
    this.element.scroll(function () {
      throttle();
    });
    return {
      type: "bi.default",
      scrolly: true,
      items: [{
        type: "bi.layout",
        width: 1,
        ref: function ref(_ref) {
          self.inner = _ref;
        }
      }]
    };
  },
  mounted: function mounted() {
    this._populate();
  },
  _populate: function _populate() {
    var self = this,
        o = this.options;

    if (o.size < 1 || o.contentSize <= o.size) {
      this.setVisible(false);
      return;
    }

    this.setVisible(true);

    try {
      this.element.scrollTop(o.position);
    } catch (e) {}

    this.inner.element.height(o.contentSize);
  },
  setContentSize: function setContentSize(contentSize) {
    this.options.contentSize = contentSize;
  },
  setPosition: function setPosition(position) {
    this.options.position = position;
  },
  setSize: function setSize(size) {
    this.setHeight(size);
    this.options.size = size;
  },
  populate: function populate() {
    this._populate();
  }
});
BI.NativeTableScrollbar.EVENT_SCROLL = "EVENT_SCROLL";
BI.shortcut("bi.native_table_scrollbar", BI.NativeTableScrollbar);
BI.NativeTableHorizontalScrollbar = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.NativeTableHorizontalScrollbar.superclass._defaultConfig.apply(this, arguments), {
      attributes: {
        tabIndex: 0
      },
      contentSize: 0,
      position: 0,
      size: 0
    });
  },
  render: function render() {
    var self = this,
        o = this.options; // 把滚动台size改掉

    this.element.height(36);
    var throttle = BI.throttle(function () {
      self.fireEvent(BI.NativeTableScrollbar.EVENT_SCROLL, self.element.scrollLeft());
    }, 150, {
      leading: false
    });
    this.element.scroll(function () {
      throttle();
    });
    return {
      type: "bi.default",
      scrollx: true,
      items: [{
        type: "bi.layout",
        height: 1,
        ref: function ref(_ref) {
          self.inner = _ref;
        }
      }]
    };
  },
  setContentSize: function setContentSize(contentSize) {
    this.options.contentSize = contentSize;
  },
  setPosition: function setPosition(position) {
    this.options.position = position;
  },
  setSize: function setSize(size) {
    this.setWidth(size);
    this.options.size = size;
  },
  _populate: function _populate() {
    var self = this,
        o = this.options;

    if (o.size < 1 || o.contentSize <= o.size) {
      this.setVisible(false);
      return;
    }

    this.setVisible(true);

    try {
      this.element.scrollLeft(o.position);
    } catch (e) {}

    this.inner.element.width(o.contentSize);
  },
  populate: function populate() {
    this._populate();
  }
});
BI.NativeTableHorizontalScrollbar.EVENT_SCROLL = "EVENT_SCROLL";
BI.shortcut("bi.native_table_horizontal_scrollbar", BI.NativeTableHorizontalScrollbar);

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var constants = {
    INSERT_HELPER_WIDTH: 12,
    INSERT_HELPER_OFFSET: 6,
    DRAG_START_DISTANCE: 20,
    DRAG_HELPER_WIDTH: 200,
    DRAG_HELPER_HEIGHT: 300,
    TRANSITION_DURATION: 300
  };
  BI.SortableTable = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-sortable-table",
      el: {
        type: "bi.grid_table"
      },
      sortable: true
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.header = {};
      this.cell = {};
      this.quickSelectHelper = new BI.SortableTable.QuickSelectHelper();
      this.styleHelper = new BI.SortableTable.StyleHelper(this.header, this.cell, BI.bind(this._getCell, this), this.quickSelectHelper);
      return [BI.extend({
        type: "bi.grid_table",
        width: o.width,
        height: o.height,
        headerRowSize: o.headerRowSize,
        rowSize: o.rowSize,
        columnSize: o.columnSize,
        header: this._formatHeader(o.header),
        items: this._formatCell(o.items),
        listeners: [{
          eventName: BI.Table.EVENT_TABLE_SCROLL,
          action: function action() {
            self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
          }
        }, {
          eventName: BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE,
          action: function action() {
            self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
          }
        }, {
          eventName: BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE,
          action: function action() {
            self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
          }
        }]
      }, o.el, {
        ref: function ref(_ref) {
          self.table = _ref;
          o.el.ref && o.el.ref.call(this, _ref);
        },
        mounted: function mounted() {
          self.autoScrollHelper = new BI.SortableTable.AutoScrollHelper(self.table, BI.bind(self._onAutoScroll, self));
        }
      })];
    },
    _getColumnsLeftPosition: function _getColumnsLeftPosition() {
      var position = [];
      var columnSizes = this.table.getColumnSize();
      BI.each(columnSizes, function (idx) {
        if (idx === 0) {
          position.push(0);
        } else {
          position.push(position[idx - 1] + columnSizes[idx - 1]);
        }
      });
      return position;
    },
    _exchangeItemsAndHeaderPosition: function _exchangeItemsAndHeaderPosition(sourceIndexes, targetIndex) {
      var o = this.options;

      if (sourceIndexes.length === 1 && sourceIndexes[0] === targetIndex) {
        return false;
      }

      var header = BI.unzip(o.header);
      var items = BI.unzip(o.items);
      var columnSize = this.getColumnSize();
      var deleteIndexes = BI.map(sourceIndexes, function (idx, sourceIndex) {
        return sourceIndex < targetIndex ? sourceIndex : sourceIndex + sourceIndexes.length;
      });
      o.header = BI.unzip(this._dealExchangeConfig(header, sourceIndexes, targetIndex, deleteIndexes));
      o.items = BI.unzip(this._dealExchangeConfig(items, sourceIndexes, targetIndex, deleteIndexes));
      o.columnSize = this._dealExchangeConfig(columnSize, sourceIndexes, targetIndex, deleteIndexes);
      return true;
    },
    _dealExchangeConfig: function _dealExchangeConfig(targets, sourceIndexes, targetIndex, deleteIndexes) {
      var sourceTargets = BI.filter(targets, function (idx) {
        return BI.contains(sourceIndexes, idx);
      });
      sourceTargets.unshift(targetIndex, 0);
      [].splice.apply(targets, sourceTargets);
      BI.removeAt(targets, deleteIndexes);
      return targets;
    },
    _getCell: function _getCell(cell) {
      if (this.options.customCell) {
        return cell.element;
      }

      var parent = cell.element.parent();

      while (parent) {
        if (parent.hasClass('bi-grid-table-cell')) {
          break;
        }

        parent = parent.parent();
      }

      return parent;
    },
    _formatHeader: function _formatHeader() {
      var self = this,
          o = this.options;
      return BI.map(o.header, function (i, row) {
        return BI.map(row, function (j, col) {
          return BI.extend({}, col, {
            ref: function ref(_ref2) {
              self.header[j] = self.header[j] || {};
              self.header[j][i] = _ref2;
              col.ref && col.ref.call(this, _ref2);
              var hasSelected = false;

              _ref2.element.on("mousedown", function (e) {
                self.disableSelectText(true);

                if (!BI.contains(self.quickSelectHelper.getSelectedColumns(), j)) {
                  self._clickSelectColumn(j, e);

                  self.fireEvent("EVENT_TABLE_SELECT_COLUMN", j);
                } else {
                  hasSelected = true;
                }

                self._prepareDrag(e, _ref2, j);
              });

              _ref2.element.on("click", function (e) {
                if (hasSelected) {
                  hasSelected = false;

                  self._clickSelectColumn(j, e);

                  self.fireEvent("EVENT_TABLE_SELECT_COLUMN", j);
                }
              });
            },
            mounted: function mounted() {
              if (!self.startDrag) {
                if (BI.contains(self.quickSelectHelper.getSelectedColumns(), j)) {
                  self.styleHelper.selectCell(true, self.header[j][i], {
                    column: j,
                    row: i,
                    header: true
                  });

                  self._initDrag(j, self.header[j][i], true);
                }

                if (BI.contains(self.quickSelectHelper.getSelectedColumns(), j + 1)) {
                  var preEle = self._getCell(self.header[j][i]);

                  preEle.addClass('column-select-helper');
                }
              }

              if (self.columnIndex === j) {
                self.styleHelper.setInVisibility(self.header[j][i]);
              }
            },
            destroyed: function destroyed() {
              self.header[j] && delete self.header[j][i];

              if (BI.size(self.header[j]) === 0) {
                delete self.header[j];
              }
            }
          });
        });
      });
    },
    _clickSelectColumn: function _clickSelectColumn(col, e) {
      var self = this;
      this.quickSelectHelper.selectColumns(col, e);
      BI.each(this.header, function (j, col) {
        BI.each(col, function (i, h) {
          var selected;

          if (BI.contains(self.quickSelectHelper.getSelectedColumns(), BI.parseInt(j))) {
            selected = self.styleHelper.selectColumn(true, j);
          } else {
            selected = self.styleHelper.selectColumn(false, j);
          }

          self._initDrag(j, h, selected);
        });
      });
    },
    _formatCell: function _formatCell() {
      var self = this,
          o = this.options;
      return BI.map(o.items, function (i, row) {
        return BI.map(row, function (j, cell) {
          return BI.extend({}, cell, {
            ref: function ref(_ref3) {
              self.cell[j] = self.cell[j] || {};
              self.cell[j][i] = _ref3;
              cell.ref && cell.ref.call(this, _ref3);
            },
            mounted: function mounted() {
              if (!self.startDrag) {
                BI.contains(self.quickSelectHelper.getSelectedColumns(), j) && self.styleHelper.selectCell(true, self.cell[j][i], {
                  column: j,
                  row: i,
                  lastRowCell: i === o.items.length - 1
                });

                if (BI.contains(self.quickSelectHelper.getSelectedColumns(), j + 1)) {
                  var preEle = self._getCell(self.cell[j][i]);

                  preEle.addClass('column-select-helper');
                }
              }

              if (self.columnIndex === j) {
                self.styleHelper.setInVisibility(self.cell[j][i]);
              }
            },
            destroyed: function destroyed() {
              self.cell[j] && delete self.cell[j][i];

              if (BI.size(self.cell[j]) === 0) {
                delete self.cell[j];
              }
            }
          }, {
            lastRowCell: i === o.items.length - 1
          });
        });
      });
    },
    _drop: function _drop(indexes) {
      var o = this.options;
      var insertIndex = this.columnIndex > this.newColumnIndex ? this.newColumnIndex : this.newColumnIndex + 1; // 调整item顺序，重新populate

      var flag = this._exchangeItemsAndHeaderPosition(indexes, insertIndex);

      if (flag === true) {
        this.setColumnSize(o.columnSize);
        var selectedCols = this.getSelectedColumns();
        this.populate(o.items, o.header);
        var splitIndex = BI.findIndex(selectedCols, function (idx, col) {
          return col >= insertIndex;
        });
        var firstSelectCol = insertIndex - (selectedCols[0] < insertIndex ? splitIndex < 0 ? selectedCols.length : splitIndex : 0);
        this.selectColumns(BI.map(selectedCols, function (idx) {
          return BI.clamp(firstSelectCol + idx, 0, o.columnSize.length);
        }));
        this.fireEvent("EVENT_TABLE_SORT", indexes, insertIndex);
      }
    },
    _shouldStartDrag: function _shouldStartDrag(curPosX, startPosX) {
      return Math.abs(curPosX - startPosX) > constants.DRAG_START_DISTANCE;
    },

    /**
     * firefox: 拖拽的时候会触发文本的选中进而影响mousetracker mouseup的触发
     * @param disable
     */
    disableSelectText: function disableSelectText(disable) {
      BI.each(this.header, function (j, col) {
        BI.each(col, function (i, h) {
          h.element[disable ? 'addClass' : 'removeClass']('bi-user-select-disable');
        });
      });
    },
    _prepareDrag: function _prepareDrag(event, node, columnIndex) {
      this.tracker.captureMouseMoves(BI.extend({}, event, {
        preventDefault: BI.emptyFn
      }));
      this.start = false;
      this.startDrag = false;
      this.startX = this.oStartX = event.pageX;
      this.startY = event.pageY;
      this.boundingClientRect = node.element[0].getBoundingClientRect();
      this.columnIndex = this.newColumnIndex = columnIndex;
      this.positions = this._getColumnsLeftPosition();
      this.offsetX = this.positions[columnIndex];
      this.height = node.element[0].offsetHeight;
      this.width = node.element[0].offsetWidth;
      this.widths = this.table.getColumnSize();
      this.tableWidth = this.table.getWidth();
      this.tableHeight = this.table.getHeight();
      var containerBoundingRect = this.element[0].getBoundingClientRect();
      this.minTranslateX = containerBoundingRect.left - this.boundingClientRect.left - this.width / 2;
      this.maxTranslateX = containerBoundingRect.left + containerBoundingRect.width - this.boundingClientRect.left - this.width / 2;
      this.initialScrollX = this.table.getActualRightHorizontalScroll();
    },
    _initDrag: function _initDrag(idx, header, selected) {
      if (!this.options.sortable) {
        return;
      }

      var self = this;

      if (BI.isNull(this.tracker)) {
        this.tracker = new BI.MouseMoveTracker(function (deltaX, deltaY) {
          self.startX += deltaX;
          self.startY += deltaY;

          if (self.tracker.isDragging() && (self.startDrag || self._shouldStartDrag(self.startX, self.oStartX))) {
            self.startDrag = true;

            self._updateHelperPosition();

            self._animateColumns();

            self._autoScroll();
          }
        }, function () {
          self.dragHelper && self.dragHelper.setVisible(false);
          self.tracker.releaseMouseMoves();
          self.startDrag && self._drop(BI.sortBy(self.quickSelectHelper.getSelectedColumns()));

          self._stopDrag();
        }, window);
      }

      if (!selected) {
        header.element.off('mouseup');
      } else {
        header.element.off('mouseup').on('mouseup', function (event) {
          if (Math.abs(self.startX - event.pageX) < 5 && Math.abs(self.startY - event.pageY) < 5) {
            self._stopDrag();
          }
        });
      }
    },
    _updateHelperPosition: function _updateHelperPosition() {
      if (BI.isNull(this.dragHelper)) {
        this.dragHelper = BI.createWidget({
          type: "bi.layout",
          cls: "sortable_table_drag_helper cursor-drag-hand",
          zIndex: BI.zIndex_layer
        });
        BI.createWidget({
          type: "bi.absolute",
          element: 'body',
          items: [{
            el: this.dragHelper,
            left: this.boundingClientRect.left,
            top: this.boundingClientRect.top
          }]
        });
        this.translateX = this.startX - this.oStartX;
        this.styleHelper.setColumnInVisibility(this.columnIndex);
        this.styleHelper.setColumnDisabled(this._getOtherSelectedColumns(this.columnIndex));
      } else {
        this.translateX = this.startX - this.oStartX;
        this.styleHelper.setTranslateX(this.dragHelper.element, this.translateX);
        this.dragHelper.setWidth(this.widths[this.columnIndex]);
        this.dragHelper.setHeight(this.tableHeight);
        this.dragHelper.setVisible(true);
      }
    },
    _animateColumns: function _animateColumns() {
      var self = this;
      var sortingOffset = {
        left: this.offsetX + this.translateX + this.table.getActualRightHorizontalScroll() - this.initialScrollX,
        top: 0
      };
      this.newColumnIndex = null;
      BI.some(this.header, function (colKey, col) {
        if (colKey === self.columnIndex) {
          return false;
        }

        var translate = {
          x: 0,
          y: 0
        };
        BI.some(col, function (rowKey, header) {
          var width = header.element[0].offsetWidth;
          var height = header.element[0].offsetHeight;
          var offset = {
            height: self.height > height ? height / 2 : self.height / 2,
            width: self.width > width ? width / 2 : self.width / 2
          };
          self.styleHelper.setTransitionDuration(colKey, constants.TRANSITION_DURATION);

          if (colKey > self.columnIndex && sortingOffset.left + offset.width >= self.positions[colKey]) {
            translate.x = -self.width;
            self.newColumnIndex = parseInt(colKey);
          } else if (colKey < self.columnIndex && sortingOffset.left <= self.positions[colKey] + offset.width) {
            translate.x = self.width;

            if (self.newColumnIndex === null) {
              self.newColumnIndex = parseInt(colKey);
            }
          }

          self.styleHelper.setColumnTranslateX(colKey, translate.x);
        });
      });

      if (this.newColumnIndex === null) {
        this.newColumnIndex = this.columnIndex;
      }
    },
    _autoScroll: function _autoScroll() {
      this.autoScrollHelper.update({
        translateX: this.translateX,
        minTranslateX: this.minTranslateX,
        maxTranslateX: this.maxTranslateX,
        width: this.width
      });
    },
    _onAutoScroll: function _onAutoScroll(offsetX) {
      this.translateX += offsetX;

      this._animateColumns();
    },
    _getOtherSelectedColumns: function _getOtherSelectedColumns(columnIndex) {
      var columns = BI.clone(this.quickSelectHelper.getSelectedColumns());
      var index = columns.indexOf(columnIndex);
      columns.splice(index, 1);
      return columns;
    },
    _stopDrag: function _stopDrag() {
      var self = this;
      this.startDrag = false;
      this.styleHelper.setColumnInVisibility(this.columnIndex, false);
      this.styleHelper.setColumnDisabled(this._getOtherSelectedColumns(this.columnIndex), false);
      this.autoScrollHelper.clear();
      this.columnIndex = -1;
      this.tracker && this.tracker.releaseMouseMoves();
      BI.each(this.header, function (colKey) {
        self.styleHelper.setColumnTranslateX(colKey);
        self.styleHelper.setTransitionDuration(colKey, null);
      });
      this.dragHelper && this.dragHelper.destroy();
      this.dragHelper = null;
      this.disableSelectText(false);
    },
    selectColumns: function selectColumns(cols) {
      var self = this;
      cols = BI.isArray(cols) ? cols : [cols];
      this.quickSelectHelper.clearColumns();
      BI.each(this.header, function (j) {
        self.styleHelper.selectColumn(false, j);
      });
      BI.each(cols, function (idx, col) {
        self._clickSelectColumn(col, {
          ctrlKey: true
        });
      });
    },
    getSelectedColumns: function getSelectedColumns() {
      return this.quickSelectHelper.getSelectedColumns();
    },
    setWidth: function setWidth(width) {
      BI.SortableTable.superclass.setWidth.apply(this, arguments);
      this.table.setWidth(width);
    },
    setHeight: function setHeight(height) {
      BI.SortableTable.superclass.setHeight.apply(this, arguments);
      this.table.setHeight(height);
    },
    setVerticalScroll: function setVerticalScroll(scrollTop) {
      this.table.setVerticalScroll(scrollTop);
    },
    setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
      this.table.setLeftHorizontalScroll(scrollLeft);
    },
    setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
      this.table.setRightHorizontalScroll(scrollLeft);
    },
    setColumnSize: function setColumnSize(columnSize) {
      this.table.setColumnSize(columnSize);
    },
    getColumnSize: function getColumnSize() {
      return this.table.getColumnSize();
    },
    getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
      return this.table.getFirstColumnHeaderRowSize();
    },
    getFirstColumnRowSize: function getFirstColumnRowSize() {
      return this.table.getFirstColumnRowSize();
    },
    setRegionColumnSize: function setRegionColumnSize(columnSize) {
      this.options.regionColumnSize = columnSize;
      this.table.setRegionColumnSize(columnSize);
    },
    getRegionColumnSize: function getRegionColumnSize() {
      return this.table.getRegionColumnSize();
    },
    getVerticalScroll: function getVerticalScroll() {
      return this.table.getVerticalScroll();
    },
    getLeftHorizontalScroll: function getLeftHorizontalScroll() {
      return this.table.getLeftHorizontalScroll();
    },
    getRightHorizontalScroll: function getRightHorizontalScroll() {
      return this.table.getRightHorizontalScroll();
    },
    setSortable: function setSortable(sortable) {
      this.options.sortable = sortable;
    },
    attr: function attr() {
      BI.SortableTable.superclass.attr.apply(this, arguments);
      return this.table.attr.apply(this.table, arguments);
    },
    restore: function restore() {
      this.table.restore();
    },
    populate: function populate(items, headers) {
      var o = this.options;
      this.header = {};
      this.cell = {};
      this.styleHelper.update(this.header, this.cell);
      this.quickSelectHelper.clearColumns();

      this._stopDrag();

      o.header = headers || o.header;
      o.items = items || o.items;
      this.table.populate(this._formatCell(o.items), this._formatHeader(o.header));
    }
  });
  BI.shortcut("bi.sortable_table", BI.SortableTable);
}();

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var MOUSE_EVENT_KEY = {
    CLICK: 0,
    CONTROL_CLICK: 1,
    SHIFT_CLICK: 2
  };

  function QuickSelectHelper() {
    this.selectedColumns = [];
    this.lastSelectedColumn = null;
  }

  QuickSelectHelper.prototype.selectColumns = function (v, e) {
    var self = this;

    switch (this.getMouseHotKey(e)) {
      case MOUSE_EVENT_KEY.CLICK:
        this.selectedColumns = [v];
        this.lastSelectedColumn = v;
        break;

      case MOUSE_EVENT_KEY.CONTROL_CLICK:
        var cancelSelect = BI.some(this.selectedColumns, function (i, target) {
          if (target === v) {
            self.selectedColumns.splice(i, 1);
            return true;
          }
        });

        if (!cancelSelect) {
          this.selectedColumns.push(v);
        }

        break;

      case MOUSE_EVENT_KEY.SHIFT_CLICK:
        var startIndex = self.lastSelectedColumn;
        var endIndex = v;
        var sliceStartIndex = BI.min([startIndex, endIndex]);
        var sliceEndIndex = BI.max([startIndex, endIndex]) + 1;
        this.selectedColumns = BI.uniq(BI.concat(this.selectedColumns, BI.range(sliceStartIndex, sliceEndIndex)));
        break;

      default:
        break;
    }
  };

  QuickSelectHelper.prototype.getMouseHotKey = function (event) {
    if (event.ctrlKey || event.metaKey) {
      // ctrl/command逐个单选
      return MOUSE_EVENT_KEY.CONTROL_CLICK;
    }

    if (event.shiftKey) {
      // shift多选
      return MOUSE_EVENT_KEY.SHIFT_CLICK;
    } // 单选


    return MOUSE_EVENT_KEY.CLICK;
  };

  QuickSelectHelper.prototype.getSelectedColumns = function () {
    return this.selectedColumns;
  };

  QuickSelectHelper.prototype.MOUSE_EVENT_KEY = {
    CLICK: 0,
    CONTROL_CLICK: 1,
    SHIFT_CLICK: 2
  };

  QuickSelectHelper.prototype.clearColumns = function () {
    this.selectedColumns = [];
    this.lastSelectedColumn = null;
  };

  BI.SortableTable.QuickSelectHelper = QuickSelectHelper;
}();

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  function AutoScrollHelper(container, onScrollCallback) {
    this.container = container;
    this.onScrollCallback = onScrollCallback;
  }

  AutoScrollHelper.prototype.update = function (config) {
    var _this = this;

    var offsetX = 0,
        autoScroll = false;
    var translateX = config.translateX,
        minTranslateX = config.minTranslateX,
        maxTranslateX = config.maxTranslateX,
        width = config.width;

    if (translateX <= minTranslateX + width / 2) {
      offsetX = -10 * Math.abs((translateX - width / 2 - minTranslateX) / width);
      autoScroll = true;
    } else if (translateX >= maxTranslateX - width / 2) {
      offsetX = 10 * Math.abs((maxTranslateX - width / 2 - translateX) / width);
      autoScroll = true;
    }

    this.clear();

    if (autoScroll) {
      this.interval = setInterval(function () {
        var initialScrollLeft = _this.container.getActualRightHorizontalScroll();

        _this.container.setRightHorizontalScroll(initialScrollLeft + offsetX);

        _this.onScrollCallback(offsetX);

        if (_this.container.getActualRightHorizontalScroll() === initialScrollLeft) {
          _this.clear();
        }
      }, 5);
    }
  };

  AutoScrollHelper.prototype.clear = function () {
    if (this.interval === null) {
      return;
    }

    clearInterval(this.interval);
    this.interval = null;
  };

  BI.SortableTable.AutoScrollHelper = AutoScrollHelper;
}();

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  function StyleHelper(headers, cells, cellWrapperGetter, quickSelectHelper) {
    this.cellWrapperGetter = cellWrapperGetter;
    this.headers = headers;
    this.cells = cells;
    this.quickSelectHelper = quickSelectHelper;
  }

  StyleHelper.prototype.setTranslateX = function (widget, translateX) {
    widget[0].style.transform = BI.isNull(translateX) ? '' : "translateX(".concat(translateX, "px)");
  };

  StyleHelper.prototype.setInVisibility = function (widget) {
    var invisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var widgetWrapper = this.cellWrapperGetter(widget);
    widgetWrapper[0].style.opacity = invisible ? 0 : '';
    widgetWrapper[0].style.visibility = invisible ? 'hidden' : '';
  };

  StyleHelper.prototype.setDraggingStyle = function (widget) {
    var disabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var cls = arguments.length > 2 ? arguments[2] : undefined;
    var widgetWrapper = this.cellWrapperGetter(widget);
    widgetWrapper[disabled ? 'addClass' : 'removeClass'](cls || 'dragging-state');
  };

  StyleHelper.prototype.setColumnDisabled = function (columnIndexes) {
    var disabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var self = this;
    BI.each(columnIndexes, function (idx, columnIndex) {
      BI.each(self.cells[columnIndex], function (i, cell) {
        self.setDraggingStyle(cell, disabled);

        if (columnIndex > 0 && self.cells[columnIndex - 1]) {
          self.setDraggingStyle(self.cells[columnIndex - 1][i], disabled, "dragging-pre-column-state");
        }
      });
      BI.each(self.headers[columnIndex], function (i, header) {
        self.setDraggingStyle(header, disabled, "dragging-state dragging-header");

        if (columnIndex > 0 && self.headers[columnIndex - 1]) {
          self.setDraggingStyle(self.headers[columnIndex - 1][i], disabled, "dragging-pre-column-state");
        }
      });
      self.selectColumn(disabled ? false : BI.contains(self.quickSelectHelper.getSelectedColumns(), columnIndex), columnIndex);
    });
  };

  StyleHelper.prototype.setColumnInVisibility = function (columnIndex) {
    var invisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var self = this;
    BI.each(this.cells[columnIndex], function (i, cell) {
      self.setInVisibility(cell, invisible);
    });
    BI.each(this.headers[columnIndex], function (i, header) {
      self.setInVisibility(header, invisible);
    });
    this.selectColumn(invisible ? false : BI.contains(this.quickSelectHelper.getSelectedColumns(), columnIndex), columnIndex);
  };

  StyleHelper.prototype.setTransitionDuration = function (columnIndex, duration) {
    var self = this;
    BI.each(this.cells[columnIndex], function (i, cell) {
      var cellWrapper = self.cellWrapperGetter(cell);
      cellWrapper[0].style.transitionDuration = BI.isNull(duration) ? '' : "".concat(duration, "ms");
    });
    BI.each(this.headers[columnIndex], function (i, header) {
      var headerWrapper = self.cellWrapperGetter(header);
      headerWrapper[0].style.transitionDuration = BI.isNull(duration) ? '' : "".concat(duration, "ms");
    });
  };

  StyleHelper.prototype.setColumnTranslateX = function (columnIndex, translateX) {
    var self = this;
    BI.each(this.cells[columnIndex], function (i, cell) {
      self.setTranslateX(self.cellWrapperGetter(cell), translateX);
    });
    BI.each(this.headers[columnIndex], function (i, header) {
      self.setTranslateX(self.cellWrapperGetter(header), translateX);
    });
  };

  StyleHelper.prototype.selectColumn = function (selected, cIdx) {
    var self = this;
    BI.each(this.headers[cIdx], function (row, header) {
      self.selectCell(selected, header, {
        column: cIdx,
        row: row,
        header: true,
        cursor: 'cursor-hand'
      });
    });
    BI.each(this.cells[cIdx], function (row, cell) {
      self.selectCell(selected, cell, {
        column: cIdx,
        row: row,
        header: false,
        lastRowCell: cell.attr('lastRowCell')
      });
    });
    return selected;
  };

  StyleHelper.prototype.selectCell = function (selected, cell, opt) {
    var column = opt.column;
    var row = opt.row;
    var header = opt.header || false;
    var cursor = opt.cursor || "";
    var lastRowCell = opt.lastRowCell || false;
    var element = this.cellWrapperGetter(cell);
    element[selected ? "addClass" : "removeClass"](cursor + ' column-select' + (lastRowCell ? ' last-row-cell' : '') + (header ? BI.isEmpty(this.cells) ? " empty-cell header" : " header" : ""));

    if (column > 0) {
      var target = header ? this.headers : this.cells;

      if (target[column - 1]) {
        var preEle = this.cellWrapperGetter(target[column - 1][row]);
        preEle[selected ? "addClass" : "removeClass"]('column-select-helper');
      }
    }
  };

  StyleHelper.prototype.update = function (headers, cells) {
    this.headers = headers;
    this.cells = cells;
  };

  BI.SortableTable.StyleHelper = StyleHelper;
}();

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格
 *
 * Created by GUY on 2015/9/22.
 * @class BI.TableCell
 * @extends BI.Single
 */
BI.TableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.TableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-table-cell",
      textAlign: "left",
      text: ""
    });
  },
  _init: function _init() {
    BI.TableCell.superclass._init.apply(this, arguments);

    var o = this.options;
    BI.createWidget({
      type: "bi.label",
      element: this,
      whiteSpace: o.whiteSpace || "nowrap",
      textAlign: this.options.textAlign,
      height: this.options.height,
      text: this.options.text,
      value: this.options.value,
      lgap: o.lgap,
      rgap: o.rgap,
      hgap: o.hgap || 5
    });
  }
});
BI.shortcut("bi.table_cell", BI.TableCell);

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格单元格
 *
 * Created by GUY on 2016/1/12.
 * @class BI.CollectionTableCell
 * @extends BI.Widget
 */
BI.CollectionTableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.CollectionTableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-collection-table-cell bi-border-right bi-border-bottom",
      width: 0,
      height: 0,
      _left: 0,
      _top: 0,
      firstRowTopLine: true,
      firstColumnLeftLine: true,
      cell: {}
    });
  },
  _init: function _init() {
    BI.CollectionTableCell.superclass._init.apply(this, arguments);

    var o = this.options;
    this.cell = BI.createWidget(BI.extend({
      type: "bi.label"
    }, o.cell, {
      cls: (o.cell.cls || "") + " collection-table-cell-wrapper",
      width: o.width - (o.firstColumnLeftLine && o._left === 0 ? 1 : 0) - 1,
      height: o.height - (o.firstRowTopLine && o._top === 0 ? 1 : 0) - 1
    }));
    BI.createWidget({
      type: "bi.absolute",
      cls: (o.firstRowTopLine ? "bi-collection-table-cell-top-line" : "") + (o.firstColumnLeftLine ? " bi-collection-table-cell-left-line" : ""),
      element: this,
      items: [{
        el: this.cell,
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }]
    });
  },
  setWidth: function setWidth(width) {
    BI.CollectionTableCell.superclass.setWidth.apply(this, arguments);
    var o = this.options;
    this.cell.setWidth(o.width - (o.firstColumnLeftLine && o._left === 0 ? 1 : 0) - 1);
  },
  setHeight: function setHeight(height) {
    BI.CollectionTableCell.superclass.setHeight.apply(this, arguments);
    var o = this.options;
    this.cell.setHeight(o.height - (o.firstRowTopLine && o._top === 0 ? 1 : 0) - 1);
  }
});
BI.shortcut("bi.collection_table_cell", BI.CollectionTableCell);

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CollectionTable
 *
 * Created by GUY on 2016/1/12.
 * @class BI.CollectionTable
 * @extends BI.Widget
 */
BI.CollectionTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.CollectionTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-collection-table",
      headerRowSize: 25,
      rowSize: 25,
      columnSize: [],
      isNeedFreeze: false,
      freezeCols: [],
      isNeedMerge: false,
      mergeCols: [],
      mergeRule: BI.emptyFn,
      header: [],
      items: [],
      regionColumnSize: [],
      customCell: false // 自定义单元格处理

    });
  },
  render: function render() {
    var self = this,
        o = this.options;
    this._width = 0;
    this._height = 0;
    this.topLeftCollection = BI.createWidget({
      type: "bi.collection_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
        return self.topLeftItems[index];
      }
    });
    this.topLeftCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
      self.bottomLeftCollection.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.topRightCollection = BI.createWidget({
      type: "bi.collection_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
        return self.topRightItems[index];
      }
    });
    this.topRightCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
      self.bottomRightCollection.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.bottomLeftCollection = BI.createWidget({
      type: "bi.collection_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
        return self.bottomLeftItems[index];
      }
    });
    this.bottomLeftCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
      self.bottomRightCollection.setScrollTop(scroll.scrollTop);
      self.topLeftCollection.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.bottomRightCollection = BI.createWidget({
      type: "bi.collection_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
        return self.bottomRightItems[index];
      }
    });
    this.bottomRightCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
      self.bottomLeftCollection.setScrollTop(scroll.scrollTop);
      self.topRightCollection.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.topLeft = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.topLeftCollection]
    });
    this.topRight = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.topRightCollection]
    });
    this.bottomLeft = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.bottomLeftCollection]
    });
    this.bottomRight = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.bottomRightCollection]
    });
    this.shadow = BI.createWidget({
      type: "bi.layout",
      cls: "collection-table-shadow"
    });
    this.contextLayout = BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.topLeft,
        top: 0,
        left: 0
      }, {
        el: this.topRight,
        top: 0
      }, {
        el: this.bottomLeft,
        left: 0
      }, {
        el: this.bottomRight
      }, {
        el: this.shadow,
        top: 0,
        bottom: 0
      }]
    });
    this.topScrollbar = BI.createWidget({
      type: "bi.grid_table_scrollbar",
      width: BI.GridTableScrollbar.SIZE
    });
    this.topScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollTop) {
      self.bottomLeftCollection.setScrollTop(scrollTop);
      self.bottomRightCollection.setScrollTop(scrollTop);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.leftScrollbar = BI.createWidget({
      type: "bi.grid_table_horizontal_scrollbar",
      height: BI.GridTableScrollbar.SIZE
    });
    this.leftScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollLeft) {
      self.topLeftCollection.setScrollLeft(scrollLeft);
      self.bottomLeftCollection.setScrollLeft(scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.rightScrollbar = BI.createWidget({
      type: "bi.grid_table_horizontal_scrollbar",
      height: BI.GridTableScrollbar.SIZE
    });
    this.rightScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollLeft) {
      self.topRightCollection.setScrollLeft(scrollLeft);
      self.bottomRightCollection.setScrollLeft(scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.scrollBarLayout = BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.topScrollbar,
        right: 0,
        top: 0
      }, {
        el: this.leftScrollbar,
        left: 0
      }, {
        el: this.rightScrollbar
      }]
    });

    if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
      BI.createWidget({
        type: "bi.absolute",
        element: this,
        items: [{
          el: {
            type: "bi.default",
            cls: "bi-table-fix-scroll"
          },
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }]
      });
    }

    this._width = o.width - BI.GridTableScrollbar.SIZE;
    this._height = o.height - BI.GridTableScrollbar.SIZE;

    if (o.header.length > 0 || o.items.length > 0) {
      this._digest();

      this._populate();
    }
  },
  _getFreezeColLength: function _getFreezeColLength() {
    var o = this.options;
    return o.isNeedFreeze === true ? BI.clamp(o.freezeCols.length, 0, o.columnSize.length) : 0;
  },
  _getFreezeHeaderHeight: function _getFreezeHeaderHeight() {
    var o = this.options;

    if (o.header.length * o.headerRowSize >= this._height) {
      return 0;
    }

    return o.header.length * o.headerRowSize;
  },
  _getActualItems: function _getActualItems() {
    var o = this.options;

    if (o.header.length * o.headerRowSize >= this._height) {
      return o.header.concat(o.items);
    }

    return o.items;
  },
  _getContentHeight: function _getContentHeight() {
    var o = this.options;

    if (this._getFreezeHeaderHeight() <= 0) {
      return o.header.length * o.headerRowSize + o.items.length * o.rowSize;
    }

    return this._getActualItems().length * this.options.rowSize;
  },
  _populateScrollbar: function _populateScrollbar() {
    var o = this.options;
    var regionSize = this.getRegionSize(),
        totalLeftColumnSize = 0,
        totalRightColumnSize = 0,
        totalColumnSize = 0,
        summaryColumnSizeArray = [];
    BI.each(o.columnSize, function (i, size) {
      if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
        totalLeftColumnSize += size;
      } else {
        totalRightColumnSize += size;
      }

      totalColumnSize += size;

      if (i === 0) {
        summaryColumnSizeArray[i] = size;
      } else {
        summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
      }
    });
    this.topScrollbar.setContentSize(this._getContentHeight());

    var freezeHeaderHeight = this._getFreezeHeaderHeight();

    var topScrollbarSize = this._height - freezeHeaderHeight;
    this.topScrollbar.setSize(topScrollbarSize);
    var scrollTop = this.bottomRightCollection.getScrollTop();
    this.topScrollbar.setPosition(scrollTop);
    this.topScrollbar.populate();
    this.leftScrollbar.setContentSize(totalLeftColumnSize);
    this.leftScrollbar.setSize(regionSize);
    var leftScrollLeft = this.bottomLeftCollection.getScrollLeft();
    this.leftScrollbar.setPosition(leftScrollLeft);
    this.leftScrollbar.populate();
    this.rightScrollbar.setContentSize(totalRightColumnSize);
    this.rightScrollbar.setSize(this._width - regionSize);
    var rightScrollLeft = this.bottomRightCollection.getScrollLeft();
    this.rightScrollbar.setPosition(rightScrollLeft);
    this.rightScrollbar.populate();
    var items = this.scrollBarLayout.attr("items");
    items[0].top = this._getFreezeHeaderHeight();
    items[1].top = this._height;
    items[2].top = this._height;
    items[2].left = regionSize;
    this.scrollBarLayout.attr("items", items);
    this.scrollBarLayout.resize();
    var shadowVisible = false;

    if (totalLeftColumnSize > 0 && totalRightColumnSize > 0) {
      shadowVisible = totalLeftColumnSize > regionSize && leftScrollLeft < totalLeftColumnSize - regionSize || rightScrollLeft > 0;

      if (shadowVisible) {
        var firstColumnSize = this.getFirstColumnRowSize();
        var contentHeight = BI.sum(firstColumnSize);
        this.shadow.setHeight(Math.min(this._height, freezeHeaderHeight + contentHeight));
      }
    }

    this.shadow.setVisible(shadowVisible);
  },
  _populateTable: function _populateTable() {
    var self = this,
        o = this.options;
    var regionSize = this.getRegionSize(),
        totalLeftColumnSize = 0,
        totalRightColumnSize = 0,
        totalColumnSize = 0,
        summaryColumnSizeArray = [];
    BI.each(o.columnSize, function (i, size) {
      if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
        totalLeftColumnSize += size;
      } else {
        totalRightColumnSize += size;
      }

      totalColumnSize += size;

      if (i === 0) {
        summaryColumnSizeArray[i] = size;
      } else {
        summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
      }
    });
    var otlw = regionSize;

    var otlh = this._getFreezeHeaderHeight();

    var otrw = this._width - regionSize;

    var otrh = this._getFreezeHeaderHeight();

    var oblw = regionSize;
    var oblh = this._height - otlh;
    var obrw = this._width - regionSize;
    var obrh = this._height - otrh;
    var scrollBarSize = BI.isFireFox() ? 0 : BI.DOM.getScrollWidth();
    var tlw = otlw + scrollBarSize;
    var tlh = otlh + scrollBarSize;
    var trw = otrw + scrollBarSize;
    var trh = otrh + scrollBarSize;
    var blw = oblw + scrollBarSize;
    var blh = oblh + scrollBarSize;
    var brw = obrw + scrollBarSize;
    var brh = obrh + scrollBarSize;

    var digest = function digest(el) {
      el.element.css({
        overflow: "scroll",
        overflowX: "scroll",
        overflowY: "scroll"
      });
    };

    this.topLeft.setWidth(otlw);
    this.topLeft.setHeight(otlh);
    this.topRight.setWidth(otrw);
    this.topRight.setHeight(otrh);
    this.bottomLeft.setWidth(oblw);
    this.bottomLeft.setHeight(oblh);
    this.bottomRight.setWidth(obrw);
    this.bottomRight.setHeight(obrh);
    this.topLeftCollection.setWidth(tlw);
    this.topLeftCollection.setHeight(tlh);
    this.topRightCollection.setWidth(trw);
    this.topRightCollection.setHeight(trh);
    this.bottomLeftCollection.setWidth(blw);
    this.bottomLeftCollection.setHeight(blh);
    this.bottomRightCollection.setWidth(brw);
    this.bottomRightCollection.setHeight(brh);
    digest(this.topLeftCollection);
    digest(this.topRightCollection);
    digest(this.bottomLeftCollection);
    digest(this.bottomRightCollection);
    var items = this.contextLayout.attr("items");
    items[1].left = regionSize;
    items[2].top = this._getFreezeHeaderHeight();
    items[3].left = regionSize;
    items[3].top = this._getFreezeHeaderHeight();
    items[4].left = regionSize;
    this.contextLayout.attr("items", items);
    this.contextLayout.resize();
    var leftHeader = [],
        rightHeader = [],
        leftItems = [],
        rightItems = [];

    var run = function run(positions, items, rendered, firstRowTopLine, firstColumnLeftLine) {
      BI.each(positions, function (i, item) {
        if (o.customCell) {
          items[item.row][item.col]._rowIndex = item.row;
          items[item.row][item.col]._columnIndex = item.col;
          items[item.row][item.col].firstRowTopLine = firstRowTopLine;
          items[item.row][item.col].firstColumnLeftLine = firstColumnLeftLine;
          rendered.push(items[item.row][item.col]);
          return;
        }

        var cell = {
          type: "bi.collection_table_cell",
          cell: items[item.row][item.col],
          _rowIndex: item.row,
          _columnIndex: item.col,
          firstRowTopLine: firstRowTopLine,
          firstColumnLeftLine: firstColumnLeftLine
        };
        rendered.push(cell);
      });
    };

    run(this.topLeftItems, o.header, leftHeader, true, true);
    run(this.topRightItems, o.header, rightHeader, true, this.topLeftItems.length <= 0);
    run(this.bottomLeftItems, this._getActualItems(), leftItems, this.topRightItems.length <= 0, true);
    run(this.bottomRightItems, this._getActualItems(), rightItems, this.topRightItems.length <= 0, this.topLeftItems.length <= 0);

    this.topLeftCollection._populate(leftHeader);

    this.topRightCollection._populate(rightHeader);

    this.bottomLeftCollection._populate(leftItems);

    this.bottomRightCollection._populate(rightItems);
  },
  _syncScroll: function _syncScroll() {
    this.setLeftHorizontalScroll(this.getLeftHorizontalScroll());
    this.setRightHorizontalScroll(this.getRightHorizontalScroll());
    this.setVerticalScroll(this.getVerticalScroll());
  },
  _digest: function _digest() {
    var o = this.options;

    var freezeColLength = this._getFreezeColLength(); // 如果表头位置不够，取消表头冻结


    if (this._getFreezeHeaderHeight() <= 0) {
      this.topLeftItems = [];
      this.topRightItems = [];
      this.bottomLeftItems = BI.CollectionTable.serialize(this._getActualItems(), 0, freezeColLength, function (row) {
        if (row <= o.header.length - 1) {
          return o.headerRowSize;
        }

        return o.rowSize;
      }, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule, function (rows) {
        if (rows <= o.header.length) {
          return rows * o.headerRowSize;
        }

        return o.header.length * o.headerRowSize + (rows - o.header.length) * o.rowSize;
      });
      this.bottomRightItems = BI.CollectionTable.serialize(this._getActualItems(), freezeColLength, o.columnSize.length, function (row) {
        if (row <= o.header.length - 1) {
          return o.headerRowSize;
        }

        return o.rowSize;
      }, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule, function (rows) {
        if (rows <= o.header.length) {
          return rows * o.headerRowSize;
        }

        return o.header.length * o.headerRowSize + (rows - o.header.length) * o.rowSize;
      });
    } else {
      this.topLeftItems = BI.CollectionTable.serialize(o.header, 0, freezeColLength, o.headerRowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
      this.topRightItems = BI.CollectionTable.serialize(o.header, freezeColLength, o.columnSize.length, o.headerRowSize, o.columnSize, true, [], o.mergeRule);
      this.bottomLeftItems = BI.CollectionTable.serialize(o.items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
      this.bottomRightItems = BI.CollectionTable.serialize(o.items, freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
    }
  },
  _populate: function _populate() {
    if (this._width <= 0 || this._height <= 0) {
      return;
    }

    if (this._isNeedDigest === true) {
      this._digest();
    }

    this._isNeedDigest = false;

    this._populateTable();

    this._populateScrollbar();

    this._syncScroll();
  },
  attr: function attr(key, value) {
    var v = BI.CollectionTable.superclass.attr.apply(this, arguments);

    if (BI.isNotNull(value)) {
      switch (key) {
        case "scrollLeft":
          this.topRightCollection.attr(key, value);
          this.bottomRightCollection.attr(key, value);
          break;

        case "scrollTop":
          this.bottomLeftCollection.attr(key, value);
          this.bottomRightCollection.attr(key, value);
          break;
      }
    }

    return v;
  },
  getRegionSize: function getRegionSize() {
    var o = this.options;
    var regionSize = o.regionColumnSize[0] || 0;

    if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
      return 0;
    }

    if (!regionSize) {
      BI.each(o.freezeCols, function (i, col) {
        regionSize += o.columnSize[col];
      });
    }

    return regionSize;
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.bottomLeftCollection.setScrollTop(scrollTop);
    this.bottomRightCollection.setScrollTop(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.topLeftCollection.setScrollLeft(scrollLeft);
    this.bottomLeftCollection.setScrollLeft(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.topRightCollection.setScrollLeft(scrollLeft);
    this.bottomRightCollection.setScrollLeft(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.bottomRightCollection.getScrollTop();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.bottomLeftCollection.getScrollLeft();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.bottomRightCollection.getScrollLeft();
  },
  setWidth: function setWidth(width) {
    BI.CollectionTable.superclass.setWidth.apply(this, arguments);
    this._width = this.options.width - BI.GridTableScrollbar.SIZE;
  },
  setHeight: function setHeight(height) {
    BI.CollectionTable.superclass.setHeight.apply(this, arguments);
    this._height = this.options.height - BI.GridTableScrollbar.SIZE;
  },
  setColumnSize: function setColumnSize(columnSize) {
    this._isNeedDigest = true;
    this.options.columnSize = columnSize;
  },
  setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
    this._isNeedDigest = true;
    this.options.regionColumnSize = regionColumnSize;
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.options.regionColumnSize;
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    var freezeColLength = this._getFreezeColLength();

    var items = this.topLeftItems;

    if (freezeColLength <= 0) {
      items = this.topRightItems;
    }

    if (this._getFreezeHeaderHeight() <= 0) {
      items = this.bottomLeftItems;

      if (freezeColLength <= 0) {
        items = this.bottomRightItems;
      }

      items = (items || []).slice(0, this.options.header.length);
    }

    var rowHeight = [];
    BI.each(items, function (i, item) {
      if (item.col === 0) {
        rowHeight.push(item.height);
      }
    });
    return rowHeight;
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    var freezeColLength = this._getFreezeColLength();

    var items = this.bottomLeftItems;

    if (freezeColLength <= 0) {
      items = this.bottomRightItems;
    }

    if (this._getFreezeHeaderHeight() <= 0) {
      items = (items || []).slice(this.options.header.length);
    }

    var rowHeight = [];
    BI.each(items, function (i, item) {
      if (item.col === 0) {
        rowHeight.push(item.height);
      }
    });
    return rowHeight;
  },
  getLastColumnRowSize: function getLastColumnRowSize() {
    var items = this.bottomRightItems;

    if (this._getFreezeHeaderHeight() <= 0) {
      items = (items || []).slice(this.options.header.length);
    }

    var max = BI.max(BI.map(items, 'x'));
    var rowHeight = [];
    BI.each(items, function (i, item) {
      if (item.x === max) {
        rowHeight.push(item.height);
      }
    });
    return rowHeight;
  },
  populate: function populate(items, header) {
    if (items && items !== this.options.items) {
      this._isNeedDigest = true;
      this.options.items = items;

      this._restore();
    }

    if (header && header !== this.options.header) {
      this._isNeedDigest = true;
      this.options.header = header;

      this._restore();
    }

    this._populate();
  },
  _restore: function _restore() {
    this.topLeftCollection.restore();
    this.topRightCollection.restore();
    this.bottomLeftCollection.restore();
    this.bottomRightCollection.restore();
  },
  restore: function restore() {
    this._restore();
  }
});
BI.extend(BI.CollectionTable, {
  map: function map(items, startCol, endCol, rowHeight, columnSize, mergeCols, mergeRows, mergeRule, rowHeightsGetter) {
    mergeCols = mergeCols || [];
    mergeRows = mergeRows || [];
    var rowHeightGetter = BI.isFunction(rowHeight) ? rowHeight : function () {
      return rowHeight;
    };
    var result = [],
        cache = {},
        preCol = {},
        preRow = {},
        map = {};
    var summaryColumnSize = [];

    for (var i = startCol; i < endCol; i++) {
      if (i === startCol) {
        summaryColumnSize[i] = columnSize[i];
      } else {
        summaryColumnSize[i] = summaryColumnSize[i - 1] + columnSize[i];
      }
    }

    var mergeRow = function mergeRow(i, j) {
      preCol[j]._height += rowHeightGetter(i);

      preCol[j].__mergeRows.push(i);
    };

    var mergeCol = function mergeCol(i, j) {
      preRow[i]._width += columnSize[j];

      preRow[i].__mergeCols.push(j);
    };

    var createOneEl = function createOneEl(r, c) {
      var width = columnSize[c];
      var height = rowHeightGetter(r);
      map[r][c]._row = r;
      map[r][c]._col = c;
      map[r][c]._width = width;
      map[r][c]._height = height;
      preCol[c] = map[r][c];
      preCol[c].__mergeRows = [r];
      preRow[r] = map[r][c];
      preRow[r].__mergeCols = [c];
      result.push({
        x: summaryColumnSize[c] - columnSize[c],
        y: rowHeightsGetter ? rowHeightsGetter(r) : +r * rowHeight,
        item: map[r][c]
      });
    };

    BI.each(items, function (i, cols) {
      for (var j = startCol; j < endCol; j++) {
        if (!cache[i]) {
          cache[i] = {};
        }

        if (!map[i]) {
          map[i] = {};
        }

        cache[i][j] = cols[j];
        map[i][j] = {};

        if (mergeCols === true || mergeCols.indexOf(j) > -1 || mergeRows === true || mergeRows.indexOf(i) > -1) {
          if (i === 0 && j === startCol) {
            createOneEl(0, startCol);
          } else if (j === startCol && i > 0) {
            var isNeedMergeRow = mergeRule(cache[i][j], cache[i - 1][j]);

            if (isNeedMergeRow === true) {
              mergeRow(i, j);
              preRow[i] = preCol[j];
            } else {
              createOneEl(i, j);
            }
          } else if (i === 0 && j > startCol) {
            var isNeedMergeCol = mergeRule(cache[i][j], cache[i][j - 1]);

            if (isNeedMergeCol === true) {
              mergeCol(i, j);
              preCol[j] = preRow[i];
            } else {
              createOneEl(i, j);
            }
          } else {
            var isNeedMergeRow = mergeRule(cache[i][j], cache[i - 1][j]);
            var isNeedMergeCol = mergeRule(cache[i][j], cache[i][j - 1]);

            if (isNeedMergeCol && isNeedMergeRow) {
              continue; // mergeRow(i, j);//优先合并列
            }

            if (isNeedMergeCol) {
              mergeCol(i, j);
            }

            if (isNeedMergeRow) {
              mergeRow(i, j);
            }

            if (!isNeedMergeCol && !isNeedMergeRow) {
              createOneEl(i, j);
            }
          }
        } else {
          createOneEl(i, j);
        }
      }
    });
    return {
      map: map,
      cells: result
    };
  },
  serialize: function serialize(items, startCol, endCol, rowHeight, columnSize, mergeCols, mergeRows, mergeRule, rowHeightsGetter) {
    var res = BI.CollectionTable.map(items, startCol, endCol, rowHeight, columnSize, mergeCols, mergeRows, mergeRule, rowHeightsGetter);
    return BI.map(res.cells, function (i, item) {
      return {
        x: item.x,
        y: item.y,
        row: item.item._row,
        col: item.item._col,
        width: item.item._width,
        height: item.item._height
      };
    });
  }
});
BI.shortcut("bi.collection_table", BI.CollectionTable);

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * QuickCollectionTable
 *
 * Created by GUY on 2016/1/12.
 * @class BI.QuickCollectionTable
 * @extends BI.CollectionTable
 */
BI.QuickCollectionTable = BI.inherit(BI.CollectionTable, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.QuickCollectionTable.superclass._defaultConfig.apply(this, arguments), {
      extraCls: "bi-quick-collection-table"
    });
  },
  render: function render() {
    BI.QuickCollectionTable.superclass.render.apply(this, arguments);
    var self = this,
        o = this.options;
    this.topLeftCollection.setOverflowX(false);
    this.topLeftCollection.setOverflowY(false);
    this.topRightCollection.setOverflowX(false);
    this.topRightCollection.setOverflowY(false);
    this.bottomLeftCollection.setOverflowX(false);
    this.bottomLeftCollection.setOverflowY(false);
    this.bottomRightCollection.setOverflowX(false);
    this.bottomRightCollection.setOverflowY(false);
  },
  mounted: function mounted() {
    // BI.QuickCollectionTable.superclass.mounted.apply(this, arguments);
    var self = this;
    this._topLeftWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelLeft, this), BI.bind(this._shouldHandleLeftX, this), BI.bind(this._shouldHandleY, this));
    this._topRightWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelRight, this), BI.bind(this._shouldHandleRightX, this), BI.bind(this._shouldHandleY, this));
    this._bottomLeftWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelLeft, this), BI.bind(this._shouldHandleLeftX, this), BI.bind(this._shouldHandleY, this));
    this._bottomRightWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelRight, this), BI.bind(this._shouldHandleRightX, this), BI.bind(this._shouldHandleY, this));
    this.topLeftCollection.element.mousewheel(function (e) {
      self._topLeftWheelHandler.onWheel(e.originalEvent);
    });
    this.topRightCollection.element.mousewheel(function (e) {
      self._topRightWheelHandler.onWheel(e.originalEvent);
    });
    this.bottomLeftCollection.element.mousewheel(function (e) {
      self._bottomLeftWheelHandler.onWheel(e.originalEvent);
    });
    this.bottomRightCollection.element.mousewheel(function (e) {
      self._bottomRightWheelHandler.onWheel(e.originalEvent);
    });
  },
  _shouldHandleLeftX: function _shouldHandleLeftX(delta) {
    if (delta > 0) {
      return this.bottomLeftCollection.getScrollLeft() < this.bottomLeftCollection.getMaxScrollLeft();
    }

    return this.bottomLeftCollection.getScrollLeft() > 0;
  },
  _shouldHandleRightX: function _shouldHandleRightX(delta) {
    if (delta > 0) {
      return this.bottomRightCollection.getScrollLeft() < this.bottomRightCollection.getMaxScrollLeft();
    }

    return this.bottomRightCollection.getScrollLeft() > 0;
  },
  _shouldHandleY: function _shouldHandleY(delta) {
    if (delta > 0) {
      return this.bottomRightCollection.getScrollTop() < this.bottomRightCollection.getMaxScrollTop();
    }

    return this.bottomRightCollection.getScrollTop() > 0;
  },
  _onWheelLeft: function _onWheelLeft(deltaX, deltaY) {
    var self = this;
    var scrollTop = this.bottomLeftCollection.getScrollTop();
    var scrollLeft = this.bottomLeftCollection.getScrollLeft();

    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      deltaX = 0;
    } else {
      deltaY = 0;
    }

    scrollTop += deltaY;
    scrollLeft += deltaX;
    this.bottomLeftCollection.setScrollTop(scrollTop);
    this.bottomRightCollection.setScrollTop(scrollTop);
    this.topLeftCollection.setScrollLeft(scrollLeft);
    this.bottomLeftCollection.setScrollLeft(scrollLeft);

    self._populateScrollbar();

    this.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
  },
  _onWheelRight: function _onWheelRight(deltaX, deltaY) {
    var self = this;
    var scrollTop = this.bottomRightCollection.getScrollTop();
    var scrollLeft = this.bottomRightCollection.getScrollLeft();

    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      deltaX = 0;
    } else {
      deltaY = 0;
    }

    scrollTop += deltaY;
    scrollLeft += deltaX;
    this.bottomLeftCollection.setScrollTop(scrollTop);
    this.bottomRightCollection.setScrollTop(scrollTop);
    this.topRightCollection.setScrollLeft(scrollLeft);
    this.bottomRightCollection.setScrollLeft(scrollLeft);

    self._populateScrollbar();

    this.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
  },
  _populateTable: function _populateTable() {
    var self = this,
        o = this.options;
    var regionSize = this.getRegionSize(),
        totalLeftColumnSize = 0,
        totalRightColumnSize = 0,
        totalColumnSize = 0,
        summaryColumnSizeArray = [];
    BI.each(o.columnSize, function (i, size) {
      if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
        totalLeftColumnSize += size;
      } else {
        totalRightColumnSize += size;
      }

      totalColumnSize += size;

      if (i === 0) {
        summaryColumnSizeArray[i] = size;
      } else {
        summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
      }
    });
    var otlw = regionSize;

    var otlh = this._getFreezeHeaderHeight();

    var otrw = this._width - regionSize;

    var otrh = this._getFreezeHeaderHeight();

    var oblw = regionSize;
    var oblh = this._height - otlh;
    var obrw = this._width - regionSize;
    var obrh = this._height - otrh;
    this.topLeft.setWidth(otlw);
    this.topLeft.setHeight(otlh);
    this.topRight.setWidth(otrw);
    this.topRight.setHeight(otrh);
    this.bottomLeft.setWidth(oblw);
    this.bottomLeft.setHeight(oblh);
    this.bottomRight.setWidth(obrw);
    this.bottomRight.setHeight(obrh);
    this.topLeftCollection.setWidth(otlw);
    this.topLeftCollection.setHeight(otlh);
    this.topRightCollection.setWidth(otrw);
    this.topRightCollection.setHeight(otrh);
    this.bottomLeftCollection.setWidth(oblw);
    this.bottomLeftCollection.setHeight(oblh);
    this.bottomRightCollection.setWidth(obrw);
    this.bottomRightCollection.setHeight(obrh);
    var items = this.contextLayout.attr("items");
    items[1].left = regionSize;
    items[2].top = this._getFreezeHeaderHeight();
    items[3].left = regionSize;
    items[3].top = this._getFreezeHeaderHeight();
    items[4].left = regionSize;
    this.contextLayout.attr("items", items);
    this.contextLayout.resize();
    var leftHeader = [],
        rightHeader = [],
        leftItems = [],
        rightItems = [];

    var run = function run(positions, items, rendered, firstRowTopLine, firstColumnLeftLine) {
      BI.each(positions, function (i, item) {
        if (!firstRowTopLine && o.customCell) {
          items[item.row][item.col]._rowIndex = item.row;
          items[item.row][item.col]._columnIndex = item.col;
          items[item.row][item.col].firstRowTopLine = firstRowTopLine;
          items[item.row][item.col].firstColumnLeftLine = firstColumnLeftLine;
          rendered.push(items[item.row][item.col]);
          return;
        }

        var cell = {
          type: "bi.collection_table_cell",
          cell: items[item.row][item.col],
          _rowIndex: item.row,
          _columnIndex: item.col,
          firstRowTopLine: firstRowTopLine,
          firstColumnLeftLine: firstColumnLeftLine
        };
        rendered.push(cell);
      });
    };

    run(this.topLeftItems, o.header, leftHeader, true, true);
    run(this.topRightItems, o.header, rightHeader, true, this.topLeftItems.length <= 0);
    run(this.bottomLeftItems, this._getActualItems(), leftItems, this.topRightItems.length <= 0, true);
    run(this.bottomRightItems, this._getActualItems(), rightItems, this.topRightItems.length <= 0, this.topLeftItems.length <= 0);

    this.topLeftCollection._populate(leftHeader);

    this.topRightCollection._populate(rightHeader);

    this.bottomLeftCollection._populate(leftItems);

    this.bottomRightCollection._populate(rightItems);
  }
});
BI.shortcut("bi.quick_collection_table", BI.QuickCollectionTable);

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 行高自动算的表格
 *
 * Created by GUY on 2016/1/12.
 * @class BI.AutoHeightCollectionTable
 * @extends BI.Widget
 */
!function () {
  var getTextLines = function getTextLines(text, fontSize, cellWidth, maxLines) {
    var width = 0;
    var lines = 1;
    var charWidth = 0;
    var widths = BI.Constants.getConstant("bi.constant.char.widths");

    for (var i = 0, len = text.length; i < len; i++) {
      var _char = text.charCodeAt(i); // 回车和换行


      if (_char === 13 || _char === 10) {
        width = 0;
        lines++;
        continue;
      }

      if (_char >= 32 && _char <= 126) {
        charWidth = widths[_char] * fontSize;
      } else {
        charWidth = fontSize;
      }

      width += charWidth;

      if (width > cellWidth) {
        width = charWidth;
        lines++;
      }

      if (lines === maxLines) {
        break;
      }
    }

    return lines;
  };

  var getCellRowHeight = function getCellRowHeight(text, fontSize, width, lineHeight, rowGap, rowHeight, maxHeight) {
    var maxLines = Math.ceil((maxHeight - rowGap) / lineHeight);
    var lines = getTextLines(text || '', fontSize, width, maxLines);
    return Math.min(Math.max(lines * lineHeight + rowGap, rowHeight), maxHeight);
  };

  BI.AutoHeightCollectionTable = BI.inherit(BI.CollectionTable, {
    _defaultConfig: function _defaultConfig() {
      return BI.extend(BI.AutoHeightCollectionTable.superclass._defaultConfig.apply(this, arguments), {
        baseCls: "bi-collection-table bi-collection-auto-height-table",
        isAutoHeight: true,
        isHeaderAutoHeight: true,
        fontSize: 12,
        fontLineHeight: 14,
        columnGaps: [],
        rowGap: 1,
        headerFontSize: 12,
        headerFontLineHeight: 14,
        headerColumnGaps: [],
        headerRowGap: 1,
        rowSize: 0,
        // 在这个组件里rowSize表示最小高
        headerRowSize: 0,
        // 在这个组件里rowSize表示最小高
        maxRowSize: 400
      });
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight() {
      var o = this.options;

      if (!o.isHeaderAutoHeight) {
        return BI.AutoHeightCollectionTable.superclass._getFreezeHeaderHeight.call(this);
      }

      if (this.headerIntervalTree) {
        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);

        if (allHeaderHeight >= this._height) {
          return 0;
        }

        return allHeaderHeight;
      }

      return 0;
    },
    _getActualItems: function _getActualItems() {
      var o = this.options;

      if (!o.isHeaderAutoHeight) {
        return BI.AutoHeightCollectionTable.superclass._getActualItems.call(this);
      }

      if (this.headerIntervalTree) {
        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);

        if (allHeaderHeight >= this._height) {
          return o.header.concat(o.items);
        }
      }

      return o.items;
    },
    _getContentHeight: function _getContentHeight() {
      var o = this.options;

      if (!o.isAutoHeight && !o.isHeaderAutoHeight) {
        return BI.AutoHeightCollectionTable.superclass._getContentHeight.call(this);
      }

      if (!o.isHeaderAutoHeight) {
        var allHeaderHeight = this._getFreezeHeaderHeight();

        if (allHeaderHeight <= 0) {
          return o.header.length * o.headerRowSize + (this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0);
        } else {
          return this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0;
        }
      }

      if (!o.isAutoHeight) {
        var allHeaderHeight = this.headerIntervalTree ? this.headerIntervalTree.sumUntil(o.header.length) : 0;

        if (allHeaderHeight >= this._height) {
          return allHeaderHeight + o.items.length * o.rowSize;
        } else {
          return o.items.length * o.rowSize;
        }
      }

      if (this.headerIntervalTree) {
        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);

        if (allHeaderHeight >= this._height) {
          return allHeaderHeight + this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0;
        } else {
          return this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0;
        }
      }

      return 0;
    },
    _getOneRowHeight: function _getOneRowHeight(index) {
      var self = this,
          o = this.options;
      var columns = this.options.items[index];
      var maxHeight = 0;
      var heightCache = this.heightCache;

      var freezeColLength = this._getFreezeColLength();

      for (var i = 0, len = columns.length; i < len; i++) {
        var column = columns[i];

        if (heightCache[index] && heightCache[index][i]) {
          var cellHeight = heightCache[index][i];
        } else {
          var cell = self.mergeRules.map[index] && self.mergeRules.map[index][i];
          var mergeRows = cell && cell.__mergeRows || [];
          var mergeCols = cell && cell.__mergeCols || []; // 要考虑行合并和列合并的情况

          var columnSize = o.columnSize[i] - (o.columnGaps[i] || 0) - ((BI.isFunction(column.columnGap) ? column.columnGap() : column.columnGap) || 0) - (i === 0 || i === freezeColLength ? 2 : 1) - (column.layer || 0) * 30;

          if (mergeCols.length > 1) {
            // 合并列每一列要累计
            for (var t = 1; t < mergeCols.length; t++) {
              columnSize += o.columnSize[i + t];
            }

            i += mergeCols.length - 1;
          }

          var cellHeight = getCellRowHeight(column.text, o.fontSize, columnSize, o.fontLineHeight, o.rowGap, o.rowSize, o.maxRowSize);
          cellHeight = cellHeight / (mergeRows.length || 1);

          if (mergeRows.length > 0) {
            // 合并行每一行要使用平均值
            for (var t = index; t < index + mergeRows.length; t++) {
              if (!heightCache[t]) {
                heightCache[t] = {};
              }

              heightCache[t][i] = cellHeight;
            }
          }
        }

        if (cellHeight >= o.maxRowSize) {
          return o.maxRowSize;
        }

        maxHeight = Math.max(maxHeight, cellHeight);
      }

      return maxHeight;
    },
    _getOneHeaderRowHeight: function _getOneHeaderRowHeight(index) {
      var self = this,
          o = this.options;
      var columns = this.options.header[index];
      var maxHeight = 0;
      var heightCache = this.headerHeightCache;

      var freezeColLength = this._getFreezeColLength();

      for (var i = 0, len = columns.length; i < len; i++) {
        var column = columns[i];

        if (heightCache[index] && heightCache[index][i]) {
          var cellHeight = heightCache[index][i];
        } else {
          var cell = self.headerMergeRules.map[index] && self.headerMergeRules.map[index][i];
          var mergeRows = cell && cell.__mergeRows || [];
          var mergeCols = cell && cell.__mergeCols || []; // 要考虑行合并和列合并的情况

          var columnSize = o.columnSize[i] - (o.columnGaps[i] || 0) - ((column.cell ? BI.isFunction(column.cell.columnGap) ? column.cell.columnGap() : column.cell.columnGap : column.columnGap) || 0) - (i === 0 || i === freezeColLength ? 2 : 1);

          if (mergeCols.length > 1) {
            // 合并列每一列要累计
            for (var t = 1; t < mergeCols.length; t++) {
              columnSize += o.columnSize[i + t];
            }

            i += mergeCols.length - 1;
          }

          var cellHeight = getCellRowHeight(column.cell ? column.cell.text : column.text, o.headerFontSize, columnSize, o.headerFontLineHeight, o.headerRowGap, o.headerRowSize, o.maxRowSize);
          cellHeight = cellHeight / (mergeRows.length || 1);

          if (mergeRows.length > 0) {
            // 合并行每一行要使用平均值
            for (var t = index; t < index + mergeRows.length; t++) {
              if (!heightCache[t]) {
                heightCache[t] = {};
              }

              heightCache[t][i] = cellHeight;
            }
          }
        }

        if (cellHeight >= o.maxRowSize) {
          return o.maxRowSize;
        }

        maxHeight = Math.max(maxHeight, cellHeight);
      }

      return maxHeight;
    },
    _getActualRowHeights: function _getActualRowHeights() {
      var self = this,
          o = this.options;
      var items = this.options.items; // logn复杂度算线段树长

      this.intervalTree = BI.PrefixIntervalTree.empty(o.items.length);
      this.heightCache = {}; // 先计算一遍合并规则

      this.mergeRules = BI.CollectionTable.map(o.items, 0, this._getFreezeColLength(), o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
      BI.each(items, function (i, row) {
        self.intervalTree.set(i, self._getOneRowHeight(i));
      });
      return this.intervalTree;
    },
    _getActualHeaderRowHeights: function _getActualHeaderRowHeights() {
      var self = this,
          o = this.options;
      var items = this.options.header; // logn复杂度算线段树长

      this.headerIntervalTree = BI.PrefixIntervalTree.empty(o.header.length);
      this.headerHeightCache = {}; // 先计算一遍合并规则

      this.headerMergeRules = BI.CollectionTable.map(o.header, this._getFreezeColLength(), o.columnSize.length, o.headerRowSize, o.columnSize, true, [], o.mergeRule);
      BI.each(items, function (i, row) {
        self.headerIntervalTree.set(i, self._getOneHeaderRowHeight(i));
      });
      return this.headerIntervalTree;
    },
    _digest: function _digest() {
      var self = this,
          o = this.options;

      if (!o.isAutoHeight && !o.isHeaderAutoHeight) {
        return BI.AutoHeightCollectionTable.superclass._digest.call(this);
      }

      if (o.isHeaderAutoHeight) {
        this._getActualHeaderRowHeights();

        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);
      } else {
        var allHeaderHeight = o.header.length * o.headerRowSize;
      }

      if (o.isAutoHeight) {
        this._getActualRowHeights();
      }

      var freezeColLength = this._getFreezeColLength(); // 如果表头位置不够，取消表头冻结


      if (allHeaderHeight >= this._height) {
        var heightCache = {},
            allHeightCache = {};
        this.topLeftItems = [];
        this.topRightItems = [];
        this.bottomLeftItems = BI.CollectionTable.serialize(this._getActualItems(), 0, freezeColLength, function (row) {
          if (heightCache[row]) {
            return heightCache[row];
          }

          if (row <= o.header.length - 1) {
            if (!o.isHeaderAutoHeight) {
              return heightCache[row] = o.headerRowSize;
            }

            return heightCache[row] = self.headerIntervalTree.get(row);
          }

          if (!o.isAutoHeight) {
            return heightCache[row] = o.rowSize;
          }

          return heightCache[row] = self.intervalTree.get(row - o.header.length);
        }, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule, function (rows) {
          if (rows <= 0) {
            return 0;
          }

          if (allHeightCache[rows]) {
            return allHeightCache[rows];
          }

          if (rows <= o.header.length) {
            if (!o.isHeaderAutoHeight) {
              return allHeightCache[rows] = rows * o.headerRowSize;
            }

            return allHeightCache[rows] = self.headerIntervalTree.sumUntil(rows);
          }

          if (!o.isAutoHeight) {
            return allHeightCache[rows] = allHeaderHeight + (rows - o.header.length) * o.rowSize;
          }

          return allHeightCache[rows] = allHeaderHeight + self.intervalTree.sumUntil(rows - o.header.length);
        });
        this.bottomRightItems = BI.CollectionTable.serialize(this._getActualItems(), freezeColLength, o.columnSize.length, function (row) {
          if (heightCache[row]) {
            return heightCache[row];
          }

          if (row <= o.header.length - 1) {
            if (!o.isHeaderAutoHeight) {
              return heightCache[row] = o.headerRowSize;
            }

            return heightCache[row] = self.headerIntervalTree.get(row);
          }

          if (!o.isAutoHeight) {
            return heightCache[row] = o.rowSize;
          }

          return heightCache[row] = self.intervalTree.get(row - o.header.length);
        }, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule, function (rows) {
          if (rows <= 0) {
            return 0;
          }

          if (allHeightCache[rows]) {
            return allHeightCache[rows];
          }

          if (rows <= o.header.length) {
            if (!o.isHeaderAutoHeight) {
              return allHeightCache[rows] = rows * o.headerRowSize;
            }

            return allHeightCache[rows] = self.headerIntervalTree.sumUntil(rows);
          }

          if (!o.isAutoHeight) {
            return allHeightCache[rows] = allHeaderHeight + (rows - o.header.length) * o.rowSize;
          }

          return allHeightCache[rows] = allHeaderHeight + self.intervalTree.sumUntil(rows - o.header.length);
        });
      } else {
        var headerHeightCache = {},
            headerAllHeightCache = {};
        var itemHeightCache = {},
            itemAllHeightCache = {};
        this.topLeftItems = BI.CollectionTable.serialize(o.header, 0, freezeColLength, function (row) {
          if (headerHeightCache[row]) {
            return headerHeightCache[row];
          }

          if (!o.isHeaderAutoHeight) {
            return headerHeightCache[row] = o.headerRowSize;
          }

          return headerHeightCache[row] = self.headerIntervalTree.get(row);
        }, o.columnSize, o.mergeCols, [], o.mergeRule, function (rows) {
          if (rows === 0) {
            return 0;
          }

          if (headerAllHeightCache[rows]) {
            return headerAllHeightCache[rows];
          }

          if (!o.isHeaderAutoHeight) {
            return rows * o.headerRowSize;
          }

          return headerAllHeightCache[rows] = self.headerIntervalTree.sumUntil(rows);
        });
        this.topRightItems = BI.CollectionTable.serialize(o.header, freezeColLength, o.columnSize.length, function (row) {
          if (headerHeightCache[row]) {
            return headerHeightCache[row];
          }

          if (!o.isHeaderAutoHeight) {
            return headerHeightCache[row] = o.headerRowSize;
          }

          return headerHeightCache[row] = self.headerIntervalTree.get(row);
        }, o.columnSize, true, [], o.mergeRule, function (rows) {
          if (rows === 0) {
            return 0;
          }

          if (headerAllHeightCache[rows]) {
            return headerAllHeightCache[rows];
          }

          if (!o.isHeaderAutoHeight) {
            return rows * o.headerRowSize;
          }

          return headerAllHeightCache[rows] = self.headerIntervalTree.sumUntil(rows);
        });
        this.bottomLeftItems = BI.CollectionTable.serialize(o.items, 0, freezeColLength, function (row) {
          if (itemHeightCache[row]) {
            return itemHeightCache[row];
          }

          if (!o.isAutoHeight) {
            return itemHeightCache[row] = o.rowSize;
          }

          return itemHeightCache[row] = self.intervalTree.get(row);
        }, o.columnSize, o.mergeCols, [], o.mergeRule, function (rows) {
          if (rows === 0) {
            return 0;
          }

          if (itemAllHeightCache[rows]) {
            return itemAllHeightCache[rows];
          }

          if (!o.isAutoHeight) {
            return rows * o.rowSize;
          }

          return itemAllHeightCache[rows] = self.intervalTree.sumUntil(rows);
        });
        this.bottomRightItems = BI.CollectionTable.serialize(o.items, freezeColLength, o.columnSize.length, function (row) {
          if (itemHeightCache[row]) {
            return itemHeightCache[row];
          }

          if (!o.isAutoHeight) {
            return itemHeightCache[row] = o.rowSize;
          }

          return itemHeightCache[row] = self.intervalTree.get(row);
        }, o.columnSize, o.mergeCols, [], o.mergeRule, function (rows) {
          if (rows === 0) {
            return 0;
          }

          if (itemAllHeightCache[rows]) {
            return itemAllHeightCache[rows];
          }

          if (!o.isAutoHeight) {
            return rows * o.rowSize;
          }

          return itemAllHeightCache[rows] = self.intervalTree.sumUntil(rows);
        });
      } // this.topLeftCollection.restore();
      // this.topRightCollection.restore();
      // this.bottomLeftCollection.restore();
      // this.bottomRightCollection.restore();

    }
  });
  BI.shortcut("bi.collection_auto_height_table", BI.AutoHeightCollectionTable);
}();

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  /**
   * DynamicGridTable
   *
   * Created by GUY on 2020/6/26.
   * @class GridTable
   * @extends BI.Widget
   */
  var GridTable = BI.DynamicCollectionTable = BI.inherit(BI.Widget, {
    _defaultConfig: function _defaultConfig() {
      return BI.extend(GridTable.superclass._defaultConfig.apply(this, arguments), {
        baseCls: "bi-dynamic-collection-table",
        headerRowSize: 25,
        // rowSize: 25,
        columnSize: [],
        isNeedFreeze: false,
        freezeCols: [],
        isNeedMerge: false,
        mergeCols: [],
        mergeRule: BI.emptyFn,
        header: [],
        items: [],
        regionColumnSize: [],
        trRenderer: null,
        headerEl: {},
        bodyEl: {},
        bordered: true
      });
    },
    attr: function attr(key, value) {
      var v = GridTable.superclass.attr.apply(this, arguments);

      if (!BI.isNull(value)) {
        return v;
      }

      this.topRightCollection.attr.apply(this.topRightCollection, arguments);
      return this.bottomRightCollection.attr.apply(this.bottomRightCollection, arguments);
    },
    render: function render() {
      var self = this,
          o = this.options;
      this._width = 0;
      this._height = 0;
      this.topLeftCollection = BI.createWidget({
        type: "bi.dynamic_collection_view",
        stopScrollEvent: true,
        renderMore: true,
        columnSize: o.columnSize.slice(0, o.freezeCols.length),
        isNeedMerge: o.isNeedMerge,
        mergeCols: o.mergeCols,
        mergeRule: o.mergeRule,
        rowSizeGetter: function rowSizeGetter(index) {
          return o.headerRowSize;
        }
      });
      this.topLeftCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
        self.bottomLeftCollection.setScrollLeft(scroll.scrollLeft);

        self._populateScrollbar();

        self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      });
      this.topRightCollection = BI.createWidget({
        type: "bi.dynamic_collection_view",
        columnSize: o.columnSize,
        isNeedFreeze: o.isNeedFreeze,
        freezeCols: o.freezeCols,
        isNeedMerge: o.isNeedMerge,
        mergeCols: o.mergeCols,
        mergeRule: o.mergeRule,
        regionColumnSize: o.regionColumnSize,
        rowSizeGetter: function rowSizeGetter(index) {
          return o.headerRowSize;
        }
      });
      this.topRightCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
        self.bottomRightCollection.setScrollLeft(scroll.scrollLeft);

        self._populateScrollbar();

        self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      });
      this.bottomRightCollection = BI.createWidget({
        type: "bi.dynamic_collection_view",
        columnSize: o.columnSize,
        isNeedFreeze: o.isNeedFreeze,
        freezeCols: o.freezeCols,
        isNeedMerge: o.isNeedMerge,
        mergeCols: o.mergeCols,
        mergeRule: o.mergeRule,
        regionColumnSize: o.regionColumnSize,
        trRenderer: o.trRenderer,
        el: o.bodyEl
      });
      this.bottomRightCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
        self.bottomLeftCollection.setScrollTop(scroll.scrollTop);
        self.topRightCollection.setScrollLeft(scroll.scrollLeft);

        self._populateScrollbar();

        self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      });
      this.bottomRightCollection.on("EVENT_SYNC", function () {
        self.bottomLeftCollection._calculateBlocksToRender();
      });
      this.bottomLeftCollection = BI.createWidget({
        type: "bi.dynamic_collection_view",
        stopScrollEvent: true,
        renderMore: true,
        columnSize: o.columnSize.slice(0, o.freezeCols.length),
        isNeedMerge: o.isNeedMerge,
        mergeCols: o.mergeCols,
        mergeRule: o.mergeRule,
        rowSizeGetter: function rowSizeGetter(index) {
          return self.bottomRightCollection.trCache[index].element.height();
        },
        trRenderer: o.trRenderer
      });
      this.bottomLeftCollection.on(BI.CollectionView.EVENT_SCROLL, function (scroll) {
        self.bottomRightCollection.setScrollTop(scroll.scrollTop);
        self.topLeftCollection.setScrollLeft(scroll.scrollLeft);

        self._populateScrollbar();

        self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      });
      this.topLeft = BI.createWidget({
        type: "bi.vertical",
        scrollable: false,
        scrolly: false,
        items: [this.topLeftCollection]
      });
      this.topRight = BI.createWidget({
        type: "bi.vertical",
        scrollable: false,
        scrolly: false,
        items: [this.topRightCollection]
      });
      this.bottomLeft = BI.createWidget({
        type: "bi.vertical",
        scrollable: false,
        scrolly: false,
        items: [this.bottomLeftCollection]
      });
      this.bottomRight = BI.createWidget({
        type: "bi.vertical",
        // scrollable: false,
        scrolly: false,
        items: [this.bottomRightCollection]
      });
      this.contextLayout = BI.createWidget({
        type: "bi.absolute",
        cls: o.bordered ? "bordered bi-split" : "",
        element: this,
        items: [{
          el: this.topLeft,
          top: 0,
          left: 0
        }, {
          el: this.topRight,
          top: 0
        }, {
          el: this.bottomLeft,
          left: 0
        }, {
          el: this.bottomRight
        }]
      }); // this.topScrollbar = BI.createWidget({
      //     type: "bi.grid_table_scrollbar",
      //     width: BI.GridTableScrollbar.SIZE
      // });
      // this.topScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollTop) {
      //     self.bottomLeftCollection.setScrollTop(scrollTop);
      //     self.bottomRightCollection.setScrollTop(scrollTop);
      //     self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      // });

      this.leftScrollbar = BI.createWidget({
        type: "bi.grid_table_horizontal_scrollbar",
        height: BI.GridTableScrollbar.SIZE
      });
      this.leftScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollLeft) {
        self.topLeftCollection.setScrollLeft(scrollLeft);
        self.bottomLeftCollection.setScrollLeft(scrollLeft);
        self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      }); // this.rightScrollbar = BI.createWidget({
      //     type: "bi.grid_table_horizontal_scrollbar",
      //     height: BI.GridTableScrollbar.SIZE
      // });
      // this.rightScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollLeft) {
      //     self.topRightCollection.setScrollLeft(scrollLeft);
      //     self.bottomRightCollection.setScrollLeft(scrollLeft);
      //     self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
      // });

      this.scrollBarLayout = BI.createWidget({
        type: "bi.absolute",
        element: this,
        items: [{
          el: this.leftScrollbar,
          left: 0,
          bottom: 0
        }]
      });
      this._width = o.width - BI.GridTableScrollbar.SIZE;
      this._height = o.height - BI.GridTableScrollbar.SIZE;

      if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
        BI.createWidget({
          type: "bi.absolute",
          element: this,
          items: [{
            el: {
              type: "bi.default",
              cls: "bi-table-fix-scroll"
            },
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }]
        });
      }
    },
    mounted: function mounted() {
      var o = this.options;

      if (o.header.length > 0 || o.items.length > 0) {
        this._digest();

        this._populate();
      }
    },
    _getFreezeColLength: function _getFreezeColLength() {
      var o = this.options;
      return o.isNeedFreeze === true ? BI.clamp(o.freezeCols.length, 0, o.columnSize.length) : 0;
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight() {
      var o = this.options;

      if (o.header.length * o.headerRowSize >= this._height) {
        return 0;
      }

      return o.header.length * o.headerRowSize;
    },
    _getActualItems: function _getActualItems() {
      var o = this.options;

      if (o.header.length * o.headerRowSize >= this._height) {
        return o.header.concat(o.items);
      }

      return o.items;
    },
    _populateScrollbar: function _populateScrollbar() {
      var o = this.options;
      var regionSize = this.getRegionSize(),
          totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      }); // this.topScrollbar.setContentSize(this._getActualItems().length * o.rowSize);
      // this.topScrollbar.setSize(this._height - this._getFreezeHeaderHeight());
      // this.topScrollbar.setPosition(this.bottomRightCollection.getScrollTop());
      // this.topScrollbar.populate();

      this.leftScrollbar.setContentSize(totalLeftColumnSize);
      this.leftScrollbar.setSize(regionSize);
      this.leftScrollbar.setPosition(this.bottomLeftCollection.getScrollLeft());
      this.leftScrollbar.populate(); // this.rightScrollbar.setContentSize(totalRightColumnSize);
      // this.rightScrollbar.setSize(this._width - regionSize);
      // this.rightScrollbar.setPosition(this.bottomRightCollection.getScrollLeft());
      // this.rightScrollbar.populate();

      var items = this.scrollBarLayout.attr("items"); // items[0].top = this._getFreezeHeaderHeight();

      items[0].top = this._height; // items[2].top = this._height;
      // items[2].left = regionSize;

      this.scrollBarLayout.attr("items", items);
      this.scrollBarLayout.resize();
    },
    _populateTable: function _populateTable() {
      var self = this,
          o = this.options;
      var regionSize = this.getRegionSize(),
          totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      });
      var otlw = regionSize;

      var otlh = this._getFreezeHeaderHeight();

      var otrw = this._width - regionSize;

      var otrh = this._getFreezeHeaderHeight();

      var oblw = regionSize;
      var oblh = this._height - otlh;
      var obrw = this._width - regionSize;
      var obrh = this._height - otrh;
      var scrollBarSize = BI.DOM.getScrollWidth();
      var tlw = otlw + scrollBarSize;
      var tlh = otlh + scrollBarSize;
      var trw = otrw + scrollBarSize;
      var trh = otrh + scrollBarSize;
      var blw = oblw + scrollBarSize;
      var blh = oblh + scrollBarSize;
      var brw = obrw + scrollBarSize;
      var brh = obrh + scrollBarSize;

      var digest = function digest(el) {
        el.element.css({
          overflow: "scroll",
          overflowX: "scroll",
          overflowY: "scroll"
        });
      };

      this.topLeft.setWidth(otlw);
      this.topLeft.setHeight(otlh);
      this.topRight.setWidth(otrw);
      this.topRight.setHeight(otrh);
      this.bottomLeft.setWidth(oblw);
      this.bottomLeft.setHeight(oblh);
      this.bottomRight.setWidth(obrw);
      this.bottomRight.setHeight(obrh);
      this.topLeftCollection.setWidth(tlw);
      this.topLeftCollection.setHeight(tlh);
      this.topRightCollection.setWidth(trw);
      this.topRightCollection.setHeight(trh);
      this.bottomLeftCollection.setWidth(blw);
      this.bottomLeftCollection.setHeight(blh);
      this.bottomRightCollection.setWidth(brw);
      this.bottomRightCollection.setHeight(brh);
      digest(this.topLeftCollection);
      digest(this.topRightCollection);
      digest(this.bottomLeftCollection); // if (o.isNeedFreeze && o.freezeCols.length > 0) {

      digest(this.bottomRightCollection); // }

      var items = this.contextLayout.attr("items");
      items[1].left = regionSize;
      items[2].top = this._getFreezeHeaderHeight();
      items[3].left = regionSize;
      items[3].top = this._getFreezeHeaderHeight();
      this.contextLayout.attr("items", items);
      this.contextLayout.resize();
      var leftHeader = [],
          rightHeader = [],
          leftItems = [],
          rightItems = [];

      var run = function run(positions, items, rendered, firstRowTopLine, firstColumnLeftLine) {
        BI.each(positions, function (i, item) {
          if (o.customCell) {
            items[item.row][item.col]._rowIndex = item.row;
            items[item.row][item.col]._columnIndex = item.col;
            items[item.row][item.col].firstRowTopLine = firstRowTopLine;
            items[item.row][item.col].firstColumnLeftLine = firstColumnLeftLine;
            rendered.push(items[item.row][item.col]);
            return;
          }

          var cell = {
            type: "bi.collection_table_cell",
            cell: items[item.row][item.col],
            _rowIndex: item.row,
            _columnIndex: item.col,
            firstRowTopLine: firstRowTopLine,
            firstColumnLeftLine: firstColumnLeftLine
          };
          rendered.push(cell);
        });
      }; // run(this.topLeftItems, o.header, leftHeader, true, true);
      // run(this.topRightItems, o.header, rightHeader, true, this.topLeftItems.length <= 0);
      // run(this.bottomLeftItems, this._getActualItems(), leftItems, this.topRightItems.length <= 0, true);
      // run(this.bottomRightItems, this._getActualItems(), rightItems, this.topRightItems.length <= 0, this.topLeftItems.length <= 0);
      // if (o.isNeedFreeze && o.freezeCols.length > 0) {
      // }


      this.topRightCollection.setColumnSize(o.columnSize);

      this.topRightCollection._populate(o.header);

      this.bottomRightCollection.setColumnSize(o.columnSize);

      this.bottomRightCollection._populate(o.items);

      if (o.isNeedFreeze && o.freezeCols.length > 0) {
        this.topLeftCollection.setColumnSize(o.columnSize.slice(0, o.freezeCols.length));

        this.topLeftCollection._populate(BI.map(o.header, function (i, rows) {
          return rows.slice(0, o.freezeCols.length);
        }));

        this.bottomLeftCollection.setColumnSize(o.columnSize.slice(0, o.freezeCols.length));

        this.bottomLeftCollection._populate(BI.map(o.items, function (i, rows) {
          return rows.slice(0, o.freezeCols.length);
        }));
      }
    },
    _digest: function _digest() {
      var o = this.options; // var freezeColLength = this._getFreezeColLength();
      // 如果表头位置不够，取消表头冻结
      // if (this._getFreezeHeaderHeight() <= 0) {
      //     this.topLeftItems = [];
      //     this.topRightItems = [];
      //     this.bottomLeftItems = BI.CollectionTable.serialize(this._getActualItems(), 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule);
      //     this.bottomRightItems = BI.CollectionTable.serialize(this._getActualItems(), freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule);
      // } else {
      // this.topLeftItems = BI.CollectionTable.serialize(o.header, 0, freezeColLength, o.headerRowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
      // this.topRightItems = BI.CollectionTable.serialize(o.header, freezeColLength, o.columnSize.length, o.headerRowSize, o.columnSize, true, [], o.mergeRule);
      // this.bottomLeftItems = BI.CollectionTable.serialize(o.items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
      // this.bottomRightItems = BI.CollectionTable.serialize(o.items, 0, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
      // }
    },
    _populate: function _populate() {
      if (this._width <= 0 || this._height <= 0) {
        return;
      }

      if (this._isNeedDigest === true) {
        this._digest();
      }

      this._isNeedDigest = false;

      this._populateTable();

      this._populateScrollbar();
    },
    getRegionSize: function getRegionSize() {
      var o = this.options;
      var regionSize = o.regionColumnSize[0] || 0;

      if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
        return 0;
      }

      if (!regionSize) {
        BI.each(o.freezeCols, function (i, col) {
          regionSize += o.columnSize[col];
        });
      }

      return regionSize;
    },
    setVerticalScroll: function setVerticalScroll(scrollTop) {},
    setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
    setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
    getVerticalScroll: function getVerticalScroll() {
      return this.bottomRightCollection.getScrollTop();
    },
    getLeftHorizontalScroll: function getLeftHorizontalScroll() {
      return this.bottomLeftCollection.getScrollLeft();
    },
    getRightHorizontalScroll: function getRightHorizontalScroll() {
      return this.bottomRightCollection.getScrollLeft();
    },
    setWidth: function setWidth(width) {
      GridTable.superclass.setWidth.apply(this, arguments);
      this._width = this.options.width - BI.GridTableScrollbar.SIZE;
    },
    setHeight: function setHeight(height) {
      GridTable.superclass.setHeight.apply(this, arguments);
      this._height = this.options.height - BI.GridTableScrollbar.SIZE;
    },
    setColumnSize: function setColumnSize(columnSize) {
      this._isNeedDigest = true;
      this.options.columnSize = columnSize;
      this.topRightCollection.setColumnSize(columnSize);
      this.bottomRightCollection.setColumnSize(columnSize);
    },
    setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
      this._isNeedDigest = true;
      this.options.regionColumnSize = regionColumnSize;
      this.topRightCollection.setRegionColumnSize(regionColumnSize);
      this.bottomRightCollection.setRegionColumnSize(regionColumnSize);
    },
    getColumnSize: function getColumnSize() {
      return this.options.columnSize;
    },
    getRegionColumnSize: function getRegionColumnSize() {
      return this.options.regionColumnSize;
    },
    populate: function populate(items, header) {
      if (items && items !== this.options.items) {
        this._isNeedDigest = true;
        this.options.items = items;

        this._restore();
      }

      if (header && header !== this.options.header) {
        this._isNeedDigest = true;
        this.options.header = header;

        this._restore();
      }

      this._populate();
    },
    _restore: function _restore() {
      this.topLeftCollection.restore();
      this.topRightCollection.restore();
      this.bottomLeftCollection.restore();
      this.bottomRightCollection.restore();
    },
    restore: function restore() {
      this._restore();
    }
  });
  BI.shortcut("bi.dynamic_collection_table", GridTable);
}();

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格单元格
 *
 * Created by GUY on 2016/1/12.
 * @class BI.GridTableCell
 * @extends BI.Widget
 */
BI.GridTableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.GridTableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-grid-table-cell  bi-border-right bi-border-bottom",
      width: 0,
      height: 0,
      firstRowTopLine: true,
      firstColumnLeftLine: true,
      _rowIndex: 0,
      _columnIndex: 0,
      _left: 0,
      _top: 0,
      cell: {}
    });
  },
  _init: function _init() {
    BI.GridTableCell.superclass._init.apply(this, arguments);

    var o = this.options;
    this.cell = BI.createWidget(BI.extend({
      type: "bi.label"
    }, o.cell, {
      cls: (o.cell.cls || "") + " grid-table-cell-wrapper",
      width: o.width - (o.firstColumnLeftLine && o._columnIndex === 0 ? 1 : 0) - 1,
      height: o.height - (o.firstRowTopLine && o._rowIndex === 0 ? 1 : 0) - 1
    }));
    BI.createWidget({
      type: "bi.absolute",
      cls: (o.firstRowTopLine ? "bi-grid-table-cell-top-line" : "") + (o.firstColumnLeftLine ? " bi-grid-table-cell-left-line" : ""),
      element: this,
      items: [{
        el: this.cell,
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }]
    });
  },
  setWidth: function setWidth(width) {
    BI.GridTableCell.superclass.setWidth.apply(this, arguments);
    var o = this.options;
    this.cell.setWidth(o.width - (o.firstColumnLeftLine && o._columnIndex === 0 ? 1 : 0) - 1);
  },
  setHeight: function setHeight(height) {
    BI.GridTableCell.superclass.setHeight.apply(this, arguments);
    var o = this.options;
    this.cell.setHeight(o.height - (o.firstRowTopLine && o._rowIndex === 0 ? 1 : 0) - 1);
  }
});
BI.shortcut("bi.grid_table_cell", BI.GridTableCell);

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * GridTable
 *
 * Created by GUY on 2016/1/12.
 * @class BI.GridTable
 * @extends BI.Widget
 */
BI.GridTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.GridTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-grid-table",
      headerRowSize: 25,
      rowSize: 25,
      columnSize: [],
      isNeedFreeze: false,
      freezeCols: [],
      header: [],
      items: [],
      regionColumnSize: [],
      customCell: false // 自定义单元格处理

    });
  },
  render: function render() {
    var self = this,
        o = this.options;
    this._width = 0;
    this._height = 0;

    var columnLeftWidthGetter = function columnLeftWidthGetter(index) {
      return o.columnSize[index];
    };

    var columnRightWidthGetter = function columnRightWidthGetter(index) {
      return o.columnSize[index + self._getFreezeColLength()];
    };

    this.topLeftGrid = BI.createWidget({
      type: "bi.grid_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      rowHeightGetter: this._headerRowHeightGetter.bind(this),
      columnWidthGetter: columnLeftWidthGetter
    });
    this.topLeftGrid.on(BI.GridView.EVENT_SCROLL, function (scroll) {
      self.bottomLeftGrid.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.topRightGrid = BI.createWidget({
      type: "bi.grid_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      rowHeightGetter: this._headerRowHeightGetter.bind(this),
      columnWidthGetter: columnRightWidthGetter
    });
    this.topRightGrid.on(BI.GridView.EVENT_SCROLL, function (scroll) {
      self.bottomRightGrid.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.bottomLeftGrid = BI.createWidget({
      type: "bi.grid_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      rowHeightGetter: this._rowHeightGetter.bind(this),
      columnWidthGetter: columnLeftWidthGetter
    });
    this.bottomLeftGrid.on(BI.GridView.EVENT_SCROLL, function (scroll) {
      self.bottomRightGrid.setScrollTop(scroll.scrollTop);
      self.topLeftGrid.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.bottomRightGrid = BI.createWidget({
      type: "bi.grid_view",
      overflowX: !BI.isFireFox(),
      overflowY: !BI.isFireFox(),
      rowHeightGetter: this._rowHeightGetter.bind(this),
      columnWidthGetter: columnRightWidthGetter
    });
    this.bottomRightGrid.on(BI.GridView.EVENT_SCROLL, function (scroll) {
      self.bottomLeftGrid.setScrollTop(scroll.scrollTop);
      self.topRightGrid.setScrollLeft(scroll.scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.topLeft = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.topLeftGrid]
    });
    this.topRight = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.topRightGrid]
    });
    this.bottomLeft = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.bottomLeftGrid]
    });
    this.bottomRight = BI.createWidget({
      type: "bi.vertical",
      scrollable: false,
      scrolly: false,
      items: [this.bottomRightGrid]
    });
    this.shadow = BI.createWidget({
      type: "bi.layout",
      cls: "grid-table-shadow"
    });
    this.contextLayout = BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.topLeft,
        top: 0,
        left: 0
      }, {
        el: this.topRight,
        top: 0
      }, {
        el: this.bottomLeft,
        left: 0
      }, {
        el: this.bottomRight
      }, {
        el: this.shadow,
        top: 0,
        bottom: 0
      }]
    });
    this.topScrollbar = BI.createWidget({
      type: "bi.grid_table_scrollbar",
      width: BI.GridTableScrollbar.SIZE
    });
    this.topScrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function (scrollTop) {
      self.bottomLeftGrid.setScrollTop(scrollTop);
      self.bottomRightGrid.setScrollTop(scrollTop);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.leftScrollbar = BI.createWidget({
      type: "bi.grid_table_horizontal_scrollbar",
      height: BI.GridTableScrollbar.SIZE
    });
    this.leftScrollbar.on(BI.GridTableHorizontalScrollbar.EVENT_SCROLL, function (scrollLeft) {
      self.topLeftGrid.setScrollLeft(scrollLeft);
      self.bottomLeftGrid.setScrollLeft(scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.rightScrollbar = BI.createWidget({
      type: "bi.grid_table_horizontal_scrollbar",
      height: BI.GridTableScrollbar.SIZE
    });
    this.rightScrollbar.on(BI.GridTableHorizontalScrollbar.EVENT_SCROLL, function (scrollLeft) {
      self.topRightGrid.setScrollLeft(scrollLeft);
      self.bottomRightGrid.setScrollLeft(scrollLeft);

      self._populateScrollbar();

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.scrollBarLayout = BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.topScrollbar,
        right: 0,
        top: 0
      }, {
        el: this.leftScrollbar,
        left: 0
      }, {
        el: this.rightScrollbar
      }]
    });

    if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
      BI.createWidget({
        type: "bi.absolute",
        element: this,
        items: [{
          el: {
            type: "bi.default",
            cls: "bi-table-fix-scroll"
          },
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }]
      });
    }

    this._width = o.width - BI.GridTableScrollbar.SIZE;
    this._height = o.height - BI.GridTableScrollbar.SIZE;
    this.header = this._getHeader();
    this.items = this._getItems();

    if (o.header.length > 0 || o.items.length > 0) {
      this._populate();
    }
  },
  _rowHeightGetter: function _rowHeightGetter() {
    return this.options.rowSize;
  },
  _headerRowHeightGetter: function _headerRowHeightGetter() {
    return this.options.headerRowSize;
  },
  _getFreezeColLength: function _getFreezeColLength() {
    var o = this.options;
    return o.isNeedFreeze === true ? BI.clamp(o.freezeCols.length, 0, o.columnSize.length) : 0;
  },
  _getFreezeHeaderHeight: function _getFreezeHeaderHeight() {
    var o = this.options;

    if (o.header.length * o.headerRowSize >= this._height) {
      return 0;
    }

    return o.header.length * o.headerRowSize;
  },
  _getActualItems: function _getActualItems() {
    var o = this.options;

    if (o.header.length * o.headerRowSize >= this._height) {
      return o.header.concat(o.items);
    }

    return o.items;
  },
  _getContentHeight: function _getContentHeight() {
    return this._getActualItems().length * this.options.rowSize;
  },
  _getHeader: function _getHeader() {
    var o = this.options;

    var freezeColLength = this._getFreezeColLength();

    var leftHeader = [],
        rightHeader = [];
    BI.each(o.header, function (i, cols) {
      leftHeader[i] = [];
      rightHeader[i] = [];
      BI.each(cols, function (j, col) {
        var cell;

        if (o.customCell) {
          cell = col;
        } else {
          cell = {
            type: "bi.grid_table_cell",
            cell: col
          };
        }

        cell.firstRowTopLine = true;

        if (j === freezeColLength && freezeColLength > 0) {
          cell.firstColumnLeftLine = false;
        }

        if (j < freezeColLength) {
          leftHeader[i].push(cell);
        } else {
          rightHeader[i].push(cell);
        }
      });
    });
    return [leftHeader, rightHeader];
  },
  _populateScrollbar: function _populateScrollbar() {
    var o = this.options;
    var regionSize = this.getRegionSize(),
        totalLeftColumnSize = 0,
        totalRightColumnSize = 0,
        totalColumnSize = 0,
        summaryColumnSizeArray = [];
    BI.each(o.columnSize, function (i, size) {
      if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
        totalLeftColumnSize += size;
      } else {
        totalRightColumnSize += size;
      }

      totalColumnSize += size;

      if (i === 0) {
        summaryColumnSizeArray[i] = size;
      } else {
        summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
      }
    });
    this.topScrollbar.setContentSize(this._getContentHeight());

    var freezeHeaderHeight = this._getFreezeHeaderHeight();

    var topScrollbarSize = this._height - freezeHeaderHeight;
    this.topScrollbar.setSize(topScrollbarSize);
    this.topScrollbar.setPosition(Math.min(this.bottomLeftGrid.getScrollTop(), this.bottomRightGrid.getScrollTop()));
    this.topScrollbar.populate();
    this.leftScrollbar.setContentSize(totalLeftColumnSize);
    this.leftScrollbar.setSize(regionSize);
    var leftScrollLeft = Math.max(this.bottomLeftGrid.getScrollLeft(), this.topLeftGrid.getScrollLeft());
    this.leftScrollbar.setPosition(leftScrollLeft);
    this.leftScrollbar.populate();
    this.rightScrollbar.setContentSize(totalRightColumnSize);
    this.rightScrollbar.setSize(this._width - regionSize);
    var rightScrollLeft = Math.max(this.bottomRightGrid.getScrollLeft(), this.topRightGrid.getScrollLeft());
    this.rightScrollbar.setPosition(rightScrollLeft);
    this.rightScrollbar.populate();
    var items = this.scrollBarLayout.attr("items");
    items[0].top = this._getFreezeHeaderHeight();
    items[1].top = this._height;
    items[2].top = this._height;
    items[2].left = regionSize;
    this.scrollBarLayout.attr("items", items);
    this.scrollBarLayout.resize();
    var shadowVisible = false;

    if (totalLeftColumnSize > 0 && totalRightColumnSize > 0) {
      shadowVisible = totalLeftColumnSize > regionSize && leftScrollLeft < totalLeftColumnSize - regionSize || rightScrollLeft > 0;

      if (shadowVisible) {
        var firstColumnSize = this.getFirstColumnRowSize();
        var contentHeight = BI.sum(firstColumnSize);
        this.shadow.setHeight(Math.min(this._height, freezeHeaderHeight + contentHeight));
      }
    }

    this.shadow.setVisible(shadowVisible);
  },
  _getItems: function _getItems() {
    var o = this.options;

    var freezeColLength = this._getFreezeColLength();

    var leftItems = [],
        rightItems = [];
    var firstRowTopLine = !(o.header && o.header.length > 0);
    BI.each(this._getActualItems(), function (i, cols) {
      leftItems[i] = [];
      rightItems[i] = [];
      BI.each(cols, function (j, col) {
        var cell;

        if (o.customCell) {
          col && (col.firstRowTopLine = firstRowTopLine);
          cell = col;
        } else {
          cell = {
            type: "bi.grid_table_cell",
            cell: col,
            firstRowTopLine: firstRowTopLine
          };
        }

        if (j === freezeColLength && freezeColLength > 0) {
          cell.firstColumnLeftLine = false;
        }

        if (j < freezeColLength) {
          leftItems[i].push(cell);
        } else {
          rightItems[i].push(cell);
        }
      });
    });
    return [leftItems, rightItems];
  },
  _digest: function _digest() {
    var self = this,
        o = this.options;

    var freezeColLength = this._getFreezeColLength();

    var totalLeftColumnSize = 0,
        totalRightColumnSize = 0,
        totalColumnSize = 0,
        summaryColumnSizeArray = [];
    BI.each(o.columnSize, function (i, size) {
      if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
        totalLeftColumnSize += size;
      } else {
        totalRightColumnSize += size;
      }

      totalColumnSize += size;

      if (i === 0) {
        summaryColumnSizeArray[i] = size;
      } else {
        summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
      }
    });
    this.topLeftGrid.setEstimatedColumnSize(freezeColLength > 0 ? totalLeftColumnSize / freezeColLength : 0);
    this.topLeftGrid.setEstimatedRowSize(o.headerRowSize);
    this.topRightGrid.setEstimatedColumnSize(o.columnSize.length - freezeColLength > 0 ? totalRightColumnSize / (o.columnSize.length - freezeColLength) : 0);
    this.topRightGrid.setEstimatedRowSize(o.headerRowSize);
    this.bottomLeftGrid.setEstimatedColumnSize(freezeColLength > 0 ? totalLeftColumnSize / freezeColLength : 0);
    this.bottomLeftGrid.setEstimatedRowSize(o.rowSize);
    this.bottomRightGrid.setEstimatedColumnSize(o.columnSize.length - freezeColLength > 0 ? totalRightColumnSize / (o.columnSize.length - freezeColLength) : 0);
    this.bottomRightGrid.setEstimatedRowSize(o.rowSize);
    this.topLeftGrid.setColumnCount(freezeColLength);
    this.topRightGrid.setColumnCount(o.columnSize.length - freezeColLength);
    this.bottomLeftGrid.setColumnCount(freezeColLength);
    this.bottomRightGrid.setColumnCount(o.columnSize.length - freezeColLength);
  },
  _populateTable: function _populateTable() {
    var self = this,
        o = this.options;
    var regionSize = this.getRegionSize();
    var otlw = regionSize;

    var otlh = this._getFreezeHeaderHeight();

    var otrw = this._width - regionSize;

    var otrh = this._getFreezeHeaderHeight();

    var oblw = regionSize;
    var oblh = this._height - otlh;
    var obrw = this._width - regionSize;
    var obrh = this._height - otrh;
    var scrollBarSize = BI.isFireFox() ? 0 : BI.DOM.getScrollWidth();
    var tlw = otlw + scrollBarSize;
    var tlh = otlh + scrollBarSize;
    var trw = otrw + scrollBarSize;
    var trh = otrh + scrollBarSize;
    var blw = oblw + scrollBarSize;
    var blh = oblh + scrollBarSize;
    var brw = obrw + scrollBarSize;
    var brh = obrh + scrollBarSize;

    var digest = function digest(el) {
      el.element.css({
        overflow: "scroll",
        overflowX: "scroll",
        overflowY: "scroll"
      });
    };

    this.topLeft.setWidth(otlw);
    this.topLeft.setHeight(otlh);
    this.topRight.setWidth(otrw);
    this.topRight.setHeight(otrh);
    this.bottomLeft.setWidth(oblw);
    this.bottomLeft.setHeight(oblh);
    this.bottomRight.setWidth(obrw);
    this.bottomRight.setHeight(obrh);
    this.topLeftGrid.setWidth(tlw);
    this.topLeftGrid.setHeight(tlh);
    this.topRightGrid.setWidth(trw);
    this.topRightGrid.setHeight(trh);
    this.bottomLeftGrid.setWidth(blw);
    this.bottomLeftGrid.setHeight(blh);
    this.bottomRightGrid.setWidth(brw);
    this.bottomRightGrid.setHeight(brh);
    digest(this.topLeftGrid);
    digest(this.topRightGrid);
    digest(this.bottomLeftGrid);
    digest(this.bottomRightGrid);
    var items = this.contextLayout.attr("items");
    items[1].left = regionSize;
    items[2].top = this._getFreezeHeaderHeight();
    items[3].left = regionSize;
    items[3].top = this._getFreezeHeaderHeight();
    items[4].left = regionSize;
    this.contextLayout.attr("items", items);
    this.contextLayout.resize();

    var headers = this._getHeader();

    var tableItems = this._getItems(headers);

    this.topLeftGrid._populate(headers[0]);

    this.topRightGrid._populate(headers[1]);

    this.bottomLeftGrid._populate(tableItems[0]);

    this.bottomRightGrid._populate(tableItems[1]);
  },
  _syncScroll: function _syncScroll() {
    this.setLeftHorizontalScroll(this.getLeftHorizontalScroll());
    this.setRightHorizontalScroll(this.getRightHorizontalScroll());
    this.setVerticalScroll(this.getVerticalScroll());
  },
  _populate: function _populate() {
    if (this._width <= 0 || this._height <= 0) {
      return;
    }

    this._digest();

    this._populateTable();

    this._populateScrollbar();

    this._syncScroll();
  },
  attr: function attr(key, value) {
    var v = BI.GridTable.superclass.attr.apply(this, arguments);

    if (BI.isNotNull(value)) {
      switch (key) {
        case "scrollLeft":
          this.topRightGrid.attr(key, value);
          this.bottomRightGrid.attr(key, value);
          break;

        case "scrollTop":
          this.bottomLeftGrid.attr(key, value);
          this.bottomRightGrid.attr(key, value);
          break;
      }
    }

    return v;
  },
  getRegionSize: function getRegionSize() {
    var o = this.options;
    var regionSize = o.regionColumnSize[0] || 0;

    if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
      return 0;
    }

    if (!regionSize) {
      BI.each(o.freezeCols, function (i, col) {
        regionSize += o.columnSize[col];
      });
    }

    return regionSize;
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.bottomLeftGrid.setScrollTop(scrollTop);
    this.bottomRightGrid.setScrollTop(scrollTop);

    this._populateScrollbar();
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.topLeftGrid.setScrollLeft(scrollLeft);
    this.bottomLeftGrid.setScrollLeft(scrollLeft);

    this._populateScrollbar();
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.topRightGrid.setScrollLeft(scrollLeft);
    this.bottomRightGrid.setScrollLeft(scrollLeft);

    this._populateScrollbar();
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.bottomRightGrid.getScrollTop();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.bottomLeftGrid.getScrollLeft();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.bottomRightGrid.getScrollLeft();
  },
  getActualRightHorizontalScroll: function getActualRightHorizontalScroll() {
    return this.bottomRightGrid.element.scrollLeft();
  },
  setWidth: function setWidth(width) {
    BI.GridTable.superclass.setWidth.apply(this, arguments);
    this._width = this.options.width - BI.GridTableScrollbar.SIZE;
  },
  setHeight: function setHeight(height) {
    BI.GridTable.superclass.setHeight.apply(this, arguments);
    this._height = this.options.height - BI.GridTableScrollbar.SIZE;
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this._isNeedDigest = true;
  },
  setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
    this.options.regionColumnSize = regionColumnSize;
    this._isNeedDigest = true;
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.options.regionColumnSize;
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    var o = this.options,
        items = this.options.header;
    return BI.map(items, function () {
      return o.headerRowSize;
    });
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    var o = this.options,
        items = this.options.items;
    return BI.map(items, function () {
      return o.rowSize;
    });
  },
  populate: function populate(items, header) {
    var headerChanged = this.options.header !== header;
    var itemsChanged = this.options.items !== items;

    if (header && headerChanged) {
      this.options.header = header;
    }

    if (items && itemsChanged) {
      this.options.items = items;
    }

    if (items && itemsChanged) {
      this.items = this._getItems();

      this._restore();
    }

    if (header && headerChanged) {
      this.header = this._getHeader();

      this._restore();
    }

    this._populate();
  },
  _restore: function _restore() {
    this.topLeftGrid.restore();
    this.topRightGrid.restore();
    this.bottomLeftGrid.restore();
    this.bottomRightGrid.restore();
  },
  restore: function restore() {
    this._restore();
  }
});
BI.shortcut("bi.grid_table", BI.GridTable);

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * QuickGridTable
 *
 * Created by GUY on 2016/1/12.
 * @class BI.QuickGridTable
 * @extends BI.GridTable
 */
BI.QuickGridTable = BI.inherit(BI.GridTable, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.QuickGridTable.superclass._defaultConfig.apply(this, arguments), {
      extraCls: "bi-quick-grid-table"
    });
  },
  render: function render() {
    BI.QuickGridTable.superclass.render.apply(this, arguments);
    var self = this,
        o = this.options;
    this.topLeftGrid.setOverflowX(false);
    this.topLeftGrid.setOverflowY(false);
    this.topRightGrid.setOverflowX(false);
    this.topRightGrid.setOverflowY(false);
    this.bottomLeftGrid.setOverflowX(false);
    this.bottomLeftGrid.setOverflowY(false);
    this.bottomRightGrid.setOverflowX(false);
    this.bottomRightGrid.setOverflowY(false);
  },
  mounted: function mounted() {
    // BI.QuickGridTable.superclass.mounted.apply(this, arguments);
    var self = this;
    this._topLeftWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelLeft, this), BI.bind(this._shouldHandleLeftX, this), BI.bind(this._shouldHandleY, this));
    this._topRightWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelRight, this), BI.bind(this._shouldHandleRightX, this), BI.bind(this._shouldHandleY, this));
    this._bottomLeftWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelLeft, this), BI.bind(this._shouldHandleLeftX, this), BI.bind(this._shouldHandleY, this));
    this._bottomRightWheelHandler = new BI.WheelHandler(BI.bind(this._onWheelRight, this), BI.bind(this._shouldHandleRightX, this), BI.bind(this._shouldHandleY, this));
    this.topLeftGrid.element.mousewheel(function (e) {
      self._topLeftWheelHandler.onWheel(e.originalEvent);
    });
    this.topRightGrid.element.mousewheel(function (e) {
      self._topRightWheelHandler.onWheel(e.originalEvent);
    });
    this.bottomLeftGrid.element.mousewheel(function (e) {
      self._bottomLeftWheelHandler.onWheel(e.originalEvent);
    });
    this.bottomRightGrid.element.mousewheel(function (e) {
      self._bottomRightWheelHandler.onWheel(e.originalEvent);
    });
  },
  _shouldHandleLeftX: function _shouldHandleLeftX(delta) {
    if (delta > 0) {
      return this.bottomLeftGrid.getScrollLeft() < this.bottomLeftGrid.getMaxScrollLeft();
    }

    return this.bottomLeftGrid.getScrollLeft() > 0;
  },
  _shouldHandleRightX: function _shouldHandleRightX(delta) {
    if (delta > 0) {
      return this.bottomRightGrid.getScrollLeft() < this.bottomRightGrid.getMaxScrollLeft();
    }

    return this.bottomRightGrid.getScrollLeft() > 0;
  },
  _shouldHandleY: function _shouldHandleY(delta) {
    if (delta > 0) {
      return this.bottomRightGrid.getScrollTop() < this.bottomRightGrid.getMaxScrollTop();
    }

    return this.bottomRightGrid.getScrollTop() > 0;
  },
  _onWheelLeft: function _onWheelLeft(deltaX, deltaY) {
    var self = this;
    var scrollTop = this.bottomLeftGrid.getScrollTop();
    var scrollLeft = this.bottomLeftGrid.getScrollLeft();

    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      deltaX = 0;
    } else {
      deltaY = 0;
    }

    scrollTop += deltaY;
    scrollLeft += deltaX;
    this.bottomLeftGrid.setScrollTop(scrollTop);
    this.bottomRightGrid.setScrollTop(scrollTop);
    this.topLeftGrid.setScrollLeft(scrollLeft);
    this.bottomLeftGrid.setScrollLeft(scrollLeft);

    self._populateScrollbar();

    this.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
  },
  _onWheelRight: function _onWheelRight(deltaX, deltaY) {
    var self = this;
    var scrollTop = this.bottomRightGrid.getScrollTop();
    var scrollLeft = this.bottomRightGrid.getScrollLeft();

    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      deltaX = 0;
    } else {
      deltaY = 0;
    }

    scrollTop += deltaY;
    scrollLeft += deltaX;
    this.bottomLeftGrid.setScrollTop(scrollTop);
    this.bottomRightGrid.setScrollTop(scrollTop);
    this.topRightGrid.setScrollLeft(scrollLeft);
    this.bottomRightGrid.setScrollLeft(scrollLeft);

    self._populateScrollbar();

    this.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
  },
  _populateTable: function _populateTable() {
    var self = this,
        o = this.options;
    var regionSize = this.getRegionSize(),
        totalLeftColumnSize = 0,
        totalRightColumnSize = 0,
        totalColumnSize = 0,
        summaryColumnSizeArray = [];

    var freezeColLength = this._getFreezeColLength();

    BI.each(o.columnSize, function (i, size) {
      if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
        totalLeftColumnSize += size;
      } else {
        totalRightColumnSize += size;
      }

      totalColumnSize += size;

      if (i === 0) {
        summaryColumnSizeArray[i] = size;
      } else {
        summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
      }
    });
    var otlw = regionSize;

    var otlh = this._getFreezeHeaderHeight();

    var otrw = this._width - regionSize;

    var otrh = this._getFreezeHeaderHeight();

    var oblw = regionSize;
    var oblh = this._height - otlh;
    var obrw = this._width - regionSize;
    var obrh = this._height - otrh;
    this.topLeft.setWidth(otlw);
    this.topLeft.setHeight(otlh);
    this.topRight.setWidth(otrw);
    this.topRight.setHeight(otrh);
    this.bottomLeft.setWidth(oblw);
    this.bottomLeft.setHeight(oblh);
    this.bottomRight.setWidth(obrw);
    this.bottomRight.setHeight(obrh);
    this.topLeftGrid.setWidth(otlw);
    this.topLeftGrid.setHeight(otlh);
    this.topRightGrid.setWidth(otrw);
    this.topRightGrid.setHeight(otrh);
    this.bottomLeftGrid.setWidth(oblw);
    this.bottomLeftGrid.setHeight(oblh);
    this.bottomRightGrid.setWidth(obrw);
    this.bottomRightGrid.setHeight(obrh);
    this.topLeftGrid.setEstimatedColumnSize(freezeColLength > 0 ? totalLeftColumnSize / freezeColLength : 0);
    this.topLeftGrid.setEstimatedRowSize(o.headerRowSize);
    this.topRightGrid.setEstimatedColumnSize(o.columnSize.length - freezeColLength > 0 ? totalRightColumnSize / (o.columnSize.length - freezeColLength) : 0);
    this.topRightGrid.setEstimatedRowSize(o.headerRowSize);
    this.bottomLeftGrid.setEstimatedColumnSize(freezeColLength > 0 ? totalLeftColumnSize / freezeColLength : 0);
    this.bottomLeftGrid.setEstimatedRowSize(o.rowSize);
    this.bottomRightGrid.setEstimatedColumnSize(o.columnSize.length - freezeColLength > 0 ? totalRightColumnSize / (o.columnSize.length - freezeColLength) : 0);
    this.bottomRightGrid.setEstimatedRowSize(o.rowSize);
    this.topLeftGrid.setColumnCount(freezeColLength);
    this.topRightGrid.setColumnCount(o.columnSize.length - freezeColLength);
    this.bottomLeftGrid.setColumnCount(freezeColLength);
    this.bottomRightGrid.setColumnCount(o.columnSize.length - freezeColLength);
    var items = this.contextLayout.attr("items");
    items[1].left = regionSize;
    items[2].top = this._getFreezeHeaderHeight();
    items[3].left = regionSize;
    items[3].top = this._getFreezeHeaderHeight();
    items[4].left = regionSize;
    this.contextLayout.attr("items", items);
    this.contextLayout.resize();
    var leftHeader = [],
        rightHeader = [],
        leftItems = [],
        rightItems = [];
    BI.each(o.header, function (i, cols) {
      leftHeader[i] = [];
      rightHeader[i] = [];
      BI.each(cols, function (j, col) {
        var cell;

        if (o.customCell) {
          cell = col;
        } else {
          cell = {
            type: "bi.grid_table_cell",
            cell: col
          };
        }

        cell.firstRowTopLine = true;

        if (j === freezeColLength && freezeColLength > 0) {
          cell.firstColumnLeftLine = false;
        }

        if (j < freezeColLength) {
          leftHeader[i].push(cell);
        } else {
          rightHeader[i].push(cell);
        }
      });
    });
    var firstRowTopLine = !(o.header && o.header.length > 0);
    BI.each(this._getActualItems(), function (i, cols) {
      leftItems[i] = [];
      rightItems[i] = [];
      BI.each(cols, function (j, col) {
        var cell;

        if (o.customCell) {
          col && (col.firstRowTopLine = firstRowTopLine);
          cell = col;
        } else {
          cell = {
            type: "bi.grid_table_cell",
            cell: col,
            firstRowTopLine: firstRowTopLine
          };
        }

        if (j < freezeColLength) {
          leftItems[i].push(cell);
        } else {
          rightItems[i].push(cell);
        }
      });
    });

    this.topLeftGrid._populate(leftHeader);

    this.topRightGrid._populate(rightHeader);

    this.bottomLeftGrid._populate(leftItems);

    this.bottomRightGrid._populate(rightItems);
  }
});
BI.shortcut("bi.quick_grid_table", BI.QuickGridTable);

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格滚动条
 *
 * Created by GUY on 2016/1/12.
 * @class BI.GridTableScrollbar
 * @extends BI.Widget
 */
BI.GridTableScrollbar = BI.inherit(BI.Widget, {
  _const: {
    FACE_MARGIN: 4,
    FACE_MARGIN_2: 4 * 2,
    FACE_SIZE_MIN: 30,
    KEYBOARD_SCROLL_AMOUNT: 40
  },
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.GridTableScrollbar.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "scrollbar-layout-main public-scrollbar-main",
      attributes: {
        tabIndex: 0
      },
      contentSize: 0,
      defaultPosition: 0,
      isOpaque: false,
      orientation: "vertical",
      position: 0,
      size: 0
    });
  },
  render: function render() {
    var self = this,
        o = this.options;
    this.focused = false;
    this.isDragging = false;
    this.face = BI.createWidget({
      type: "bi.layout",
      cls: "scrollbar-layout-face public-scrollbar-face " + (this._isHorizontal() ? "scrollbar-layout-face-horizontal" : "scrollbar-layout-face-vertical")
    });
    this.contextLayout = BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.face,
        left: 0,
        top: 0
      }]
    });
  },
  mounted: function mounted() {
    var self = this,
        o = this.options;
    var onWheel = o.orientation === "horizontal" ? this._onWheelX : this._onWheelY;
    this._wheelHandler = new BI.WheelHandler(BI.bind(onWheel, this), BI.bind(this._shouldHandleX, this), BI.bind(this._shouldHandleY, this));
    this._mouseMoveTracker = new BI.MouseMoveTracker(BI.bind(this._onMouseMove, this), BI.bind(this._onMouseMoveEnd, this), _global.document);
    this.element.on("mousedown", BI.bind(this._onMouseDown, this));
    this.element.on("mousewheel", function (e) {
      self._wheelHandler.onWheel(e.originalEvent);
    });
    this.element.on("keydown", BI.bind(this._onKeyDown, this));
    this.element.on("focus", function () {
      self.focused = true;

      self._populate();
    });
    this.element.on("blur", function () {
      self.focused = false;

      self._populate();
    });

    if (this._isHorizontal()) {
      this.element.addClass("scrollbar-layout-main-horizontal");
    } else {
      this.element.addClass("scrollbar-layout-main-vertical");
    }

    this._populate();
  },
  _isHorizontal: function _isHorizontal() {
    return this.options.orientation === "horizontal";
  },
  _getScale: function _getScale() {
    var o = this.options;
    var scale = o.size / o.contentSize;
    var faceSize = o.size * scale;

    if (faceSize < this._const.FACE_SIZE_MIN) {
      scale = (o.size - this._const.FACE_SIZE_MIN) / (o.contentSize - o.size);
    }

    return scale;
  },
  _getFaceSize: function _getFaceSize() {
    var o = this.options;
    var scale = o.size / o.contentSize;
    var faceSize = o.size * scale;

    if (faceSize < this._const.FACE_SIZE_MIN) {
      faceSize = this._const.FACE_SIZE_MIN;
    }

    return faceSize;
  },
  _shouldHandleX: function _shouldHandleX(delta) {
    return this.options.orientation === "horizontal" ? this._shouldHandleChange(delta) : false;
  },
  _shouldHandleY: function _shouldHandleY(delta) {
    return this.options.orientation !== "horizontal" ? this._shouldHandleChange(delta) : false;
  },
  _shouldHandleChange: function _shouldHandleChange(delta) {
    return this.options.position + delta !== this.options.position;
  },
  _onWheelY: function _onWheelY(deltaX, deltaY) {
    this._onWheel(deltaY);
  },
  _onWheelX: function _onWheelX(deltaX, deltaY) {
    this._onWheel(deltaX);
  },
  _onWheel: function _onWheel(delta) {
    var maxPosition = this.options.contentSize - this.options.size;
    this.options.position += delta;

    if (this.options.position < 0) {
      this.options.position = 0;
    } else if (this.options.position > maxPosition) {
      this.options.position = maxPosition;
    }

    this._populate();

    this.fireEvent(BI.GridTableScrollbar.EVENT_SCROLL, this.options.position);
  },
  _onMouseDown: function _onMouseDown(e) {
    if (e.target !== this.face.element[0]) {
      var position = this._isHorizontal() ? e.offsetX : e.offsetY;
      position /= this._getScale();
      this.options.position = BI.clamp(position - this._getFaceSize() * 0.5 / this._getScale(), 0, this.options.contentSize - this.options.size);

      this._populate();

      this.fireEvent(BI.GridTableScrollbar.EVENT_SCROLL, this.options.position);
    } else {
      this._mouseMoveTracker.captureMouseMoves(e);
    }

    try {
      this.element[0].focus();
    } catch (e) {}
  },
  _onMouseMove: function _onMouseMove(deltaX, deltaY) {
    var delta = this._isHorizontal() ? deltaX : deltaY;
    delta /= this._getScale();
    this.options.position = BI.clamp(this.options.position + delta, 0, this.options.contentSize - this.options.size);
    this.isDragging = this._mouseMoveTracker.isDragging();

    this._populate();

    this.fireEvent(BI.GridTableScrollbar.EVENT_SCROLL, this.options.position);
  },
  _onMouseMoveEnd: function _onMouseMoveEnd(event) {
    this._mouseMoveTracker.releaseMouseMoves();

    if (this.isDragging === true) {
      this.isDragging = false;

      this._populate();
    }
  },
  _onKeyDown: function _onKeyDown(event) {
    var Keys = {
      BACKSPACE: 8,
      TAB: 9,
      RETURN: 13,
      ALT: 18,
      ESC: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      DELETE: 46,
      COMMA: 188,
      PERIOD: 190,
      A: 65,
      Z: 90,
      ZERO: 48,
      NUMPAD_0: 96,
      NUMPAD_9: 105
    };
    var keyCode = event.keyCode;

    if (keyCode === Keys.TAB) {
      return;
    }

    var distance = 40;
    var direction = 0;

    if (this._isHorizontal()) {
      switch (keyCode) {
        case Keys.HOME:
          direction = -1;
          distance = this.options.contentSize;
          break;

        case Keys.LEFT:
          direction = -1;
          break;

        case Keys.RIGHT:
          direction = 1;
          break;

        default:
          return;
      }
    }

    if (!this._isHorizontal()) {
      switch (keyCode) {
        case Keys.SPACE:
          if (event.shiftKey) {
            direction = -1;
          } else {
            direction = 1;
          }

          break;

        case Keys.HOME:
          direction = -1;
          distance = this.options.contentSize;
          break;

        case Keys.UP:
          direction = -1;
          break;

        case Keys.DOWN:
          direction = 1;
          break;

        case Keys.PAGE_UP:
          direction = -1;
          distance = this.options.size;
          break;

        case Keys.PAGE_DOWN:
          direction = 1;
          distance = this.options.size;
          break;

        default:
          return;
      }
    }

    this.options.position = BI.clamp(this.options.position + distance * direction, 0, this.options.contentSize - this.options.size);
    event.preventDefault();

    this._populate();

    this.fireEvent(BI.GridTableScrollbar.EVENT_SCROLL, this.options.position);
  },
  _populate: function _populate() {
    var self = this,
        o = this.options;

    if (o.size < 1 || o.contentSize <= o.size) {
      this.setVisible(false);
      return;
    }

    this.setVisible(true);
    var size = o.size;

    var isHorizontal = this._isHorizontal();

    var isActive = this.focused || this.isDragging;

    var faceSize = this._getFaceSize();

    var isOpaque = o.isOpaque;
    this.element[isOpaque === true ? "addClass" : "removeClass"]("public-scrollbar-main-opaque");
    this.element[isActive === true ? "addClass" : "removeClass"]("public-scrollbar-main-active");
    this.face.element[isActive === true ? "addClass" : "removeClass"]("public-scrollbar-face-active");

    var position = o.position * this._getScale() + this._const.FACE_MARGIN;

    var items = this.contextLayout.attr("items");

    if (isHorizontal) {
      this.setWidth(size);
      this.face.setWidth(faceSize - this._const.FACE_MARGIN_2);
      items[0].left = position;
      items[0].top = 0;
    } else {
      this.setHeight(size);
      this.face.setHeight(faceSize - this._const.FACE_MARGIN_2);
      items[0].left = 0;
      items[0].top = position;
    }

    this.contextLayout.attr("items", items);
    this.contextLayout.resize();
  },
  setContentSize: function setContentSize(contentSize) {
    this.options.contentSize = contentSize;
  },
  setPosition: function setPosition(position) {
    this.options.position = position;
  },
  setSize: function setSize(size) {
    this.options.size = size;
  },
  populate: function populate() {
    this._populate();
  }
});
BI.GridTableScrollbar.SIZE = 10;
BI.GridTableScrollbar.EVENT_SCROLL = "EVENT_SCROLL";
BI.shortcut("bi.grid_table_scrollbar", BI.GridTableScrollbar);
BI.GridTableHorizontalScrollbar = BI.inherit(BI.Widget, {
  _const: {
    FACE_MARGIN: 4,
    FACE_MARGIN_2: 4 * 2,
    FACE_SIZE_MIN: 30,
    KEYBOARD_SCROLL_AMOUNT: 40
  },
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.GridTableHorizontalScrollbar.superclass._defaultConfig.apply(this, arguments), {
      attributes: {
        tabIndex: 0
      },
      contentSize: 0,
      position: 0,
      size: 0
    });
  },
  _init: function _init() {
    BI.GridTableHorizontalScrollbar.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.scrollbar = BI.createWidget({
      type: "bi.grid_table_scrollbar",
      orientation: "horizontal",
      isOpaque: true,
      position: o.position,
      contentSize: o.contentSize,
      size: o.size
    });
    this.scrollbar.on(BI.GridTableScrollbar.EVENT_SCROLL, function () {
      self.fireEvent(BI.GridTableHorizontalScrollbar.EVENT_SCROLL, arguments);
    });
    BI.createWidget({
      type: "bi.absolute",
      cls: "horizontal-scrollbar",
      element: this,
      width: o.size,
      height: BI.GridTableScrollbar.SIZE,
      items: [{
        el: {
          type: "bi.absolute",
          scrollable: false,
          height: BI.GridTableScrollbar.SIZE,
          items: [{
            el: this.scrollbar,
            left: 0,
            top: 0
          }]
        },
        top: 0,
        left: 0,
        right: 0
      }]
    });
  },
  setContentSize: function setContentSize(contentSize) {
    this.options.contentSize = contentSize;
    this.scrollbar.setContentSize(contentSize);
  },
  setPosition: function setPosition(position) {
    this.options.position = position;
    this.scrollbar.setPosition(position);
  },
  setSize: function setSize(size) {
    this.setWidth(size);
    this.options.size = size;
    this.scrollbar.setSize(size);
  },
  populate: function populate() {
    this.scrollbar.populate();
    var o = this.options;

    if (o.size < 1 || o.contentSize <= o.size) {
      this.setVisible(false);
      return;
    }

    this.setVisible(true);
  }
});
BI.GridTableHorizontalScrollbar.EVENT_SCROLL = "EVENT_SCROLL";
BI.shortcut("bi.grid_table_horizontal_scrollbar", BI.GridTableHorizontalScrollbar);

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 行高自动算的表格
 *
 * Created by GUY on 2016/1/12.
 * @class BI.AutoHeightGridTable
 * @extends BI.Widget
 */
!function () {
  var getTextLines = function getTextLines(text, fontSize, cellWidth, maxLines) {
    var width = 0;
    var lines = 1;
    var charWidth = 0;
    var widths = BI.Constants.getConstant("bi.constant.char.widths");

    for (var i = 0, len = text.length; i < len; i++) {
      var _char = text.charCodeAt(i); // 回车和换行


      if (_char === 13 || _char === 10) {
        width = 0;
        lines++;
        continue;
      }

      if (_char >= 32 && _char <= 126) {
        charWidth = widths[_char] * fontSize;
      } else {
        charWidth = fontSize;
      }

      width += charWidth;

      if (width > cellWidth) {
        width = charWidth;
        lines++;
      }

      if (lines === maxLines) {
        break;
      }
    }

    return lines;
  };

  var getCellRowHeight = function getCellRowHeight(text, fontSize, width, lineHeight, rowGap, rowHeight, maxHeight) {
    var maxLines = Math.ceil((maxHeight - rowGap) / lineHeight);
    var lines = getTextLines(text || "", fontSize, width, maxLines);
    return Math.min(Math.max(lines * lineHeight + rowGap, rowHeight), maxHeight);
  };

  BI.AutoHeightGridTable = BI.inherit(BI.GridTable, {
    _defaultConfig: function _defaultConfig() {
      return BI.extend(BI.AutoHeightGridTable.superclass._defaultConfig.apply(this, arguments), {
        baseCls: "bi-grid-table bi-grid-auto-height-table",
        isAutoHeight: true,
        isHeaderAutoHeight: true,
        fontSize: 12,
        fontLineHeight: 14,
        columnGaps: [],
        rowGap: 1,
        headerFontSize: 12,
        headerFontLineHeight: 14,
        headerColumnGaps: [],
        headerRowGap: 1,
        rowSize: 0,
        // 在这个组件里rowSize表示最小高
        headerRowSize: 0,
        // 在这个组件里rowSize表示最小高
        maxRowSize: 400
      });
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight() {
      var o = this.options;

      if (!o.isHeaderAutoHeight) {
        return BI.AutoHeightGridTable.superclass._getFreezeHeaderHeight.call(this);
      }

      if (this.headerIntervalTree) {
        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);

        if (allHeaderHeight >= this._height) {
          return 0;
        }

        return allHeaderHeight;
      }

      return 0;
    },
    _getActualItems: function _getActualItems() {
      var o = this.options;

      if (!o.isHeaderAutoHeight) {
        return BI.AutoHeightGridTable.superclass._getActualItems.call(this);
      }

      if (this.headerIntervalTree) {
        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);

        if (allHeaderHeight >= this._height) {
          return o.header.concat(o.items);
        }

        return o.items;
      }

      return o.items;
    },
    _getContentHeight: function _getContentHeight() {
      var o = this.options;

      if (!o.isAutoHeight && !o.isHeaderAutoHeight) {
        return BI.AutoHeightGridTable.superclass._getContentHeight.call(this);
      }

      if (!o.isHeaderAutoHeight) {
        var allHeaderHeight = this._getFreezeHeaderHeight();

        if (allHeaderHeight <= 0) {
          return o.header.length * o.headerRowSize + (this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0);
        } else {
          return this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0;
        }
      }

      if (!o.isAutoHeight) {
        var allHeaderHeight = this.headerIntervalTree ? this.headerIntervalTree.sumUntil(o.header.length) : 0;

        if (allHeaderHeight >= this._height) {
          return allHeaderHeight + o.items.length * o.rowSize;
        } else {
          return o.items.length * o.rowSize;
        }
      }

      if (this.headerIntervalTree) {
        var allHeaderHeight = this.headerIntervalTree.sumUntil(o.header.length);

        if (allHeaderHeight >= this._height) {
          return allHeaderHeight + this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0;
        } else {
          return this.intervalTree ? this.intervalTree.sumUntil(o.items.length) : 0;
        }
      }

      return 0;
    },
    _getHeaderContentHeight: function _getHeaderContentHeight() {
      var o = this.options;

      if (!o.isHeaderAutoHeight) {
        return o.header.length * o.headerRowSize;
      }

      if (this.headerIntervalTree) {
        return this.headerIntervalTree.sumUntil(o.header.length);
      }

      return 0;
    },
    _getOneRowHeight: function _getOneRowHeight(index) {
      var o = this.options;
      var columns = this.options.items[index];
      var maxHeight = 0;

      var freezeColLength = this._getFreezeColLength();

      for (var i = 0, len = columns.length; i < len; i++) {
        var column = columns[i];
        var columnSize = o.columnSize[i] - (o.columnGaps[i] || 0) - ((BI.isFunction(column.columnGap) ? column.columnGap() : column.columnGap) || 0) - (i === 0 || i === freezeColLength ? 2 : 1);
        maxHeight = Math.max(maxHeight, getCellRowHeight(column.text, o.fontSize, columnSize, o.fontLineHeight, o.rowGap, o.rowSize, o.maxRowSize));

        if (maxHeight >= o.maxRowSize) {
          return o.maxRowSize;
        }
      }

      return maxHeight;
    },
    _getOneHeaderRowHeight: function _getOneHeaderRowHeight(index) {
      var o = this.options;
      var columns = this.options.header[index];
      var maxHeight = 0;

      var freezeColLength = this._getFreezeColLength();

      for (var i = 0, len = columns.length; i < len; i++) {
        var column = columns[i];
        var columnSize = o.columnSize[i] - (o.columnGaps[i] || 0) - ((column.cell ? BI.isFunction(column.cell.columnGap) ? column.cell.columnGap() : column.cell.columnGap : column.columnGap) || 0) - (i === 0 || i === freezeColLength ? 2 : 1);
        maxHeight = Math.max(maxHeight, getCellRowHeight(column.cell ? column.cell.text : column.text, o.headerFontSize, columnSize, o.headerFontLineHeight, o.headerRowGap, o.headerRowSize, o.maxRowSize));

        if (maxHeight >= o.maxRowSize) {
          return o.maxRowSize;
        }
      }

      return maxHeight;
    },
    _getActualRowHeights: function _getActualRowHeights() {
      var self = this,
          o = this.options;
      var items = this.options.items; // logn复杂度算线段树长

      this.intervalTree = BI.PrefixIntervalTree.empty(o.items.length);
      BI.each(items, function (i, row) {
        self.intervalTree.set(i, self._getOneRowHeight(i));
      });
      return this.intervalTree;
    },
    _getActualHeaderRowHeights: function _getActualHeaderRowHeights() {
      var self = this,
          o = this.options;
      var items = this.options.header; // logn复杂度算线段树长

      this.headerIntervalTree = BI.PrefixIntervalTree.empty(o.header.length);
      BI.each(items, function (i, row) {
        self.headerIntervalTree.set(i, self._getOneHeaderRowHeight(i));
      });
      return this.headerIntervalTree;
    },
    _headerRowHeightGetter: function _headerRowHeightGetter(i) {
      if (!this.options.isHeaderAutoHeight) {
        return BI.AutoHeightGridTable.superclass._headerRowHeightGetter.call(this, i);
      }

      return this.headerIntervalTree ? this.headerIntervalTree.get(i) : this.options.headerRowSize;
    },
    _rowHeightGetter: function _rowHeightGetter(i) {
      if (!this.options.isAutoHeight) {
        return BI.AutoHeightGridTable.superclass._rowHeightGetter.call(this, i);
      }

      return this.intervalTree ? this.intervalTree.get(i) : this.options.rowSize;
    },
    _digest: function _digest() {
      var o = this.options;

      if (!o.isAutoHeight && !o.isHeaderAutoHeight) {
        return BI.AutoHeightGridTable.superclass._digest.call(this);
      }

      if (o.isHeaderAutoHeight) {
        this._getActualHeaderRowHeights();
      }

      if (o.isAutoHeight) {
        this._getActualRowHeights();
      }

      var freezeColLength = this._getFreezeColLength();

      var totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      });
      var estimatedRowHeight = o.items.length > 0 ? this._getContentHeight() / o.items.length : 0;
      var estimatedHeaderRowHeight = this._getHeaderContentHeight() / o.header.length;
      this.topLeftGrid.setEstimatedColumnSize(freezeColLength > 0 ? totalLeftColumnSize / freezeColLength : 0);
      this.topLeftGrid.setEstimatedRowSize(estimatedHeaderRowHeight);
      this.topRightGrid.setEstimatedColumnSize(o.columnSize.length - freezeColLength > 0 ? totalRightColumnSize / (o.columnSize.length - freezeColLength) : 0);
      this.topRightGrid.setEstimatedRowSize(estimatedHeaderRowHeight);
      this.bottomLeftGrid.setEstimatedColumnSize(freezeColLength > 0 ? totalLeftColumnSize / freezeColLength : 0);
      this.bottomLeftGrid.setEstimatedRowSize(estimatedRowHeight);
      this.bottomRightGrid.setEstimatedColumnSize(o.columnSize.length - freezeColLength > 0 ? totalRightColumnSize / (o.columnSize.length - freezeColLength) : 0);
      this.bottomRightGrid.setEstimatedRowSize(estimatedRowHeight);
      this.topLeftGrid.setColumnCount(freezeColLength);
      this.topRightGrid.setColumnCount(o.columnSize.length - freezeColLength);
      this.bottomLeftGrid.setColumnCount(freezeColLength);
      this.bottomRightGrid.setColumnCount(o.columnSize.length - freezeColLength); // this.topLeftGrid.restore();
      // this.topRightGrid.restore();
      // this.bottomLeftGrid.restore();
      // this.bottomRightGrid.restore();
    },
    getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
      var self = this,
          o = this.options;

      if (!o.isHeaderAutoHeight) {
        return BI.AutoHeightGridTable.superclass.getFirstColumnHeaderRowSize.call(this);
      }

      var items = o.header;
      return BI.map(items, function (i) {
        return self.headerIntervalTree && self.headerIntervalTree.get(i);
      });
    },
    getFirstColumnRowSize: function getFirstColumnRowSize() {
      var self = this,
          o = this.options;

      if (!o.isAutoHeight) {
        return BI.AutoHeightGridTable.superclass.getFirstColumnRowSize.call(this);
      }

      var items = o.items;
      return BI.map(items, function (i) {
        return self.intervalTree && self.intervalTree.get(i);
      });
    }
  });
  BI.shortcut("bi.grid_auto_height_table", BI.AutoHeightGridTable);
}();

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格
 *
 * Created by GUY on 2015/9/22.
 * @class BI.TableHeaderCell
 * @extends BI.Single
 */
BI.TableHeaderCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.TableHeaderCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-table-header-cell",
      text: ""
    });
  },
  _init: function _init() {
    BI.TableHeaderCell.superclass._init.apply(this, arguments);

    var o = this.options;
    BI.createWidget({
      type: "bi.label",
      element: this,
      textAlign: o.textAlign || "center",
      height: this.options.height,
      text: this.options.text,
      value: this.options.value,
      lgap: o.lgap,
      rgap: o.rgap,
      hgap: o.hgap || 5
    });
  }
});
BI.shortcut("bi.table_header_cell", BI.TableHeaderCell);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格
 *
 * 能处理静态宽度以及动态宽度的表， 百分比宽度的表请使用PreviewTable
 *
 * Created by GUY on 2015/9/22.
 * @class BI.Table
 * @extends BI.Widget
 */
BI.Table = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.Table.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-table",
      logic: {
        // 冻结的页面布局逻辑
        dynamic: false
      },
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为true时生效
      isNeedMerge: false,
      // 是否需要合并单元格
      mergeCols: [],
      // 合并的单元格列号
      mergeRule: function mergeRule(row1, row2) {
        // 合并规则, 默认相等时合并
        return BI.isEqual(row1, row2);
      },
      columnSize: [],
      headerRowSize: 25,
      footerRowSize: 25,
      rowSize: 25,
      bordered: true,
      stripe: false,
      hover: false,
      regionColumnSize: false,
      header: [],
      footer: false,
      items: [],
      // 二维数组
      el: {
        type: "bi.vertical_fill"
      }
    });
  },
  _calculateWidth: function _calculateWidth(width) {
    if (!width || width === "0") {
      return "";
    }

    width = BI.parseFloat(width);

    if (width < 0) {
      width = 0;
    }

    return width > 1.01 ? width : width * 100 + "%";
  },
  _calculateHeight: function _calculateHeight(height) {
    return height ? height : "";
  },
  _isColumnSizeValid: function _isColumnSizeValid(columnSize, indexes) {
    return !BI.some(columnSize, function (i, c) {
      if (indexes && !indexes.includes(i)) {
        return false;
      }

      if (!c || !BI.isNumeric(c)) {
        return true;
      }
    });
  },
  _isRightFreeze: function _isRightFreeze() {
    return BI.isNotEmptyArray(this.options.freezeCols) && BI.first(this.options.freezeCols) !== 0;
  },
  _createTopLeft: function _createTopLeft() {
    var o = this.options,
        isRight = this._isRightFreeze();

    this.topLeftColGroupTds = {};
    this.topLeftBodyTds = {};
    this.topLeftBodyItems = {};

    var table = this._table();

    var colgroup = this._createColGroup(this.columnLeft, this.topLeftColGroupTds);

    var body = this.topLeftBody = this._body();

    body.element.append(this._createHeaderCells(this.topLeftItems, this.columnLeft, this.mergeLeft, this.topLeftBodyTds, this.topLeftBodyItems));
    this.topLeftContainer = BI.createWidget({
      type: "bi.default",
      element: table,
      width: this._calculateWidth(w),
      items: [colgroup, body]
    });

    if (isRight) {
      var w = 0,
          isValid = true;
      BI.each(o.columnSize, function (i, col) {
        if (!BI.isNumeric(col)) {
          isValid = false;
        }

        if (!o.freezeCols.includes(i)) {
          w += col;
        }
      });

      if (isValid && BI.isNumeric(w) && w > 1) {
        w = BI.parseFloat(w);
      }
    }

    return this.topLeftContainer;
  },
  _createTopRight: function _createTopRight() {
    var o = this.options,
        isRight = this._isRightFreeze();

    this.topRightColGroupTds = {};
    this.topRightBodyTds = {};
    this.topRightBodyItems = {};

    var table = this._table();

    var colgroup = this._createColGroup(this.columnRight, this.topRightColGroupTds);

    var body = this.topRightBody = this._body();

    body.element.append(this._createHeaderCells(this.topRightItems, this.columnRight, this.mergeRight, this.topRightBodyTds, this.topRightBodyItems, this.columnLeft.length));
    this.topRightContainer = BI.createWidget({
      type: "bi.default",
      width: this._calculateWidth(w),
      element: table,
      items: [colgroup, body]
    });

    if (!isRight) {
      var w = 0,
          isValid = true;
      BI.each(o.columnSize, function (i, col) {
        if (!BI.isNumeric(col)) {
          isValid = false;
        }

        if (!o.freezeCols.includes(i)) {
          w += col;
        }
      });

      if (isValid && BI.isNumeric(w) && w > 1) {
        w = BI.parseFloat(w);
      }
    }

    return this.topRightContainer;
  },
  _createBottomLeft: function _createBottomLeft() {
    var o = this.options,
        isRight = this._isRightFreeze();

    this.bottomLeftColGroupTds = {};
    this.bottomLeftBodyTds = {};
    this.bottomLeftBodyItems = {};

    var table = this._table();

    var colgroup = this._createColGroup(this.columnLeft, this.bottomLeftColGroupTds);

    var body = this._createBottomLeftBody();

    this.bottomLeftContainer = BI.createWidget({
      type: "bi.default",
      width: this._calculateWidth(w),
      element: table,
      items: [colgroup, body]
    });

    if (isRight) {
      var w = 0,
          isValid = true;
      BI.each(o.columnSize, function (i, col) {
        if (!BI.isNumeric(col)) {
          isValid = false;
        }

        if (!o.freezeCols.includes(i)) {
          w += col;
        }
      });

      if (isValid && BI.isNumeric(w) && w > 1) {
        w = BI.parseFloat(w);
      }
    }

    return this.bottomLeftContainer;
  },
  _createBottomLeftBody: function _createBottomLeftBody() {
    var body = this.bottomLeftBody = this._body();

    body.element.append(this._createCells(this.bottomLeftItems, this.columnLeft, this.mergeLeft, this.bottomLeftBodyTds, this.bottomLeftBodyItems));
    return body;
  },
  _createBottomRight: function _createBottomRight() {
    var o = this.options,
        isRight = this._isRightFreeze();

    this.bottomRightColGroupTds = {};
    this.bottomRightBodyTds = {};
    this.bottomRightBodyItems = {};

    var table = this._table();

    var colgroup = this._createColGroup(this.columnRight, this.bottomRightColGroupTds);

    var body = this._createBottomRightBody();

    this.bottomRightContainer = BI.createWidget({
      type: "bi.default",
      element: table,
      items: [colgroup, body]
    });

    if (!isRight) {
      var w = 0,
          isValid = true;
      BI.each(o.columnSize, function (i, col) {
        if (!BI.isNumeric(col)) {
          isValid = false;
        }

        if (!o.freezeCols.includes(i)) {
          w += col;
        }
      });

      if (isValid && BI.isNumeric(w) && w > 1) {
        w = BI.parseFloat(w);
      }
    }

    return this.bottomRightContainer;
  },
  _createBottomRightBody: function _createBottomRightBody() {
    var body = this.bottomRightBody = this._body();

    body.element.append(this._createCells(this.bottomRightItems, this.columnRight, this.mergeRight, this.bottomRightBodyTds, this.bottomRightBodyItems, this.columnLeft.length));
    return body;
  },
  _createFreezeTable: function _createFreezeTable() {
    var self = this,
        o = this.options;

    var isRight = this._isRightFreeze();

    var split = this._split(o.header);

    this.topLeftItems = split.left;
    this.topRightItems = split.right;
    split = this._split(o.items);
    this.bottomLeftItems = split.left;
    this.bottomRightItems = split.right;
    this.columnLeft = [];
    this.columnRight = [];
    BI.each(o.columnSize, function (i, size) {
      if (o.freezeCols.includes(i)) {
        self[isRight ? "columnRight" : "columnLeft"].push(size);
      } else {
        self[isRight ? "columnLeft" : "columnRight"].push(size);
      }
    });
    this.mergeLeft = [];
    this.mergeRight = [];
    BI.each(o.mergeCols, function (i, col) {
      if (o.freezeCols.includes(col)) {
        self[isRight ? "mergeRight" : "mergeLeft"].push(col);
      } else {
        self[isRight ? "mergeLeft" : "mergeRight"].push(col);
      }
    });

    var topLeft = this._createTopLeft();

    var topRight = this._createTopRight();

    var bottomLeft = this._createBottomLeft();

    var bottomRight = this._createBottomRight();

    this.scrollTopLeft = BI.createWidget({
      type: "bi.adaptive",
      cls: "scroll-top-left",
      width: "100%",
      height: "100%",
      scrollable: false,
      items: [topLeft]
    });
    this.scrollTopRight = BI.createWidget({
      type: "bi.adaptive",
      cls: "scroll-top-right",
      width: "100%",
      height: "100%",
      scrollable: false,
      items: [topRight]
    });
    this.scrollBottomLeft = BI.createWidget({
      type: "bi.adaptive",
      cls: "scroll-bottom-left",
      width: "100%",
      height: "100%",
      scrollable: isRight || null,
      scrollx: !isRight,
      items: [bottomLeft]
    });
    this.scrollBottomRight = BI.createWidget({
      type: "bi.adaptive",
      cls: "scroll-bottom-right",
      width: "100%",
      height: "100%",
      scrollable: !isRight || null,
      scrollx: isRight,
      items: [bottomRight]
    });
    this.topLeft = BI.createWidget({
      type: "bi.adaptive",
      cls: "top-left",
      scrollable: false,
      items: [this.scrollTopLeft]
    });
    this.topRight = BI.createWidget({
      type: "bi.adaptive",
      cls: "top-right",
      scrollable: false,
      items: [this.scrollTopRight]
    });
    this.bottomLeft = BI.createWidget({
      type: "bi.adaptive",
      cls: "bottom-left",
      scrollable: false,
      items: [this.scrollBottomLeft]
    });
    this.bottomRight = BI.createWidget({
      type: "bi.adaptive",
      cls: "bottom-right",
      scrollable: false,
      items: [this.scrollBottomRight]
    });
    var headerHeight = o.header.length * (o.headerRowSize || o.rowSize);
    var leftWidth = BI.sum(o.freezeCols, function (i, col) {
      return o.columnSize[col];
    });

    this._resize = function () {
      if (self.scrollBottomLeft.element.is(":visible")) {
        self.scrollBottomLeft.element.css({
          "overflow-x": "auto"
        });
        self.scrollBottomRight.element.css({
          "overflow-x": "auto"
        }); // self.setColumnSize(o.columnSize);

        if (isRight) {
          self.scrollBottomLeft.element.css({
            "overflow-y": "auto"
          });
        } else {
          self.scrollBottomRight.element.css({
            "overflow-y": "auto"
          });
        }

        if (self.scrollBottomLeft.element.hasHorizonScroll() || self.scrollBottomRight.element.hasHorizonScroll()) {
          self.scrollBottomLeft.element.css("overflow-x", "scroll");
          self.scrollBottomRight.element.css("overflow-x", "scroll");
        }

        if (self.scrollBottomLeft.element.hasVerticalScroll()) {
          self.scrollTopLeft.element.css("overflow-y", "scroll");
        } else {
          self.scrollTopLeft.element.css("overflow-y", "hidden");
        }

        self.scrollTopLeft.element[0].scrollLeft = self.scrollBottomLeft.element[0].scrollLeft;
        self.scrollBottomLeft.element[0].scrollTop = self.scrollBottomRight.element[0].scrollTop;
      }

      if (self.scrollBottomRight.element.hasVerticalScroll()) {
        self.scrollTopRight.element.css("overflow-y", "scroll");
      } else {
        self.scrollTopRight.element.css("overflow-y", "hidden");
      }

      self.scrollTopRight.element[0].scrollLeft = self.scrollBottomRight.element[0].scrollLeft;
    };

    var regionColumnSize = o.regionColumnSize && o.regionColumnSize.concat(["fill"]);

    if (o.freezeCols.length === 0) {
      regionColumnSize = ["fill", "fill"];
      isRight ? (this.topRight = null, this.bottomRight = null) : (this.topLeft = null, this.bottomLeft = null);
    } else if (o.freezeCols.length >= o.columnSize.length) {
      regionColumnSize = ["fill", "fill"];
      isRight ? (this.topLeft = null, this.bottomLeft = null) : (this.topRight = null, this.bottomRight = null);
    } // this.partitions = BI.createWidget(BI.extend({
    //     element: this,
    //     cls: o.bordered ? "bordered bi-split" : ""
    // }, BI.LogicFactory.createLogic("table", BI.extend({}, o.logic, {
    //     rows: 2,
    //     columns: 2,
    //     columnSize: regionColumnSize || (isRight ? ["fill", leftWidth] : [leftWidth, "fill"]),
    //     rowSize: [headerHeight, "fill"],
    //     items: [[{
    //         el: this.topLeft
    //     }, {
    //         el: this.topRight
    //     }], [{
    //         el: this.bottomLeft
    //     }, {
    //         el: this.bottomRight
    //     }]]
    // }))));


    BI.createWidget(o.el, {
      element: this,
      cls: "".concat(o.bordered ? "bordered" : "", " ").concat(o.stripe ? "stripe" : "", " ").concat(o.hover ? "hover" : ""),
      rowSize: ["", "fill"],
      items: [{
        type: "bi.horizontal_fill",
        columnSize: regionColumnSize || (isRight ? ["fill", leftWidth] : [leftWidth, "fill"]),
        items: [this.topLeft, this.topRight]
      }, {
        type: "bi.horizontal_fill",
        columnSize: regionColumnSize || (isRight ? ["fill", leftWidth] : [leftWidth, "fill"]),
        items: [this.bottomLeft, this.bottomRight]
      }]
    });

    this._initFreezeScroll();

    BI.ResizeDetector.addResizeListener(this, function () {
      self._resize();

      self.fireEvent(BI.Table.EVENT_TABLE_RESIZE);
    });
  },
  mounted: function mounted() {
    this._resize && this._resize();

    if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
      BI.createWidget({
        type: "bi.absolute",
        element: this,
        items: [{
          el: {
            type: "bi.default",
            cls: "bi-table-fix-scroll"
          },
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }]
      });
    }

    this.fireEvent(BI.Table.EVENT_TABLE_AFTER_INIT);
  },
  _initFreezeScroll: function _initFreezeScroll() {
    var self = this,
        o = this.options;
    scroll(this.scrollBottomRight.element, this.scrollTopRight.element, this.scrollBottomLeft.element);
    scroll(this.scrollBottomLeft.element, this.scrollTopLeft.element);

    function scroll(scrollElement, scrollTopElement, otherElement) {
      scrollElement.scroll(function (e) {
        otherElement === null || otherElement === void 0 ? void 0 : otherElement.scrollTop(scrollElement.scrollTop());
        scrollTopElement.scrollLeft(scrollElement.scrollLeft());
        self.fireEvent(BI.Table.EVENT_TABLE_SCROLL);
      });
    }
  },
  resize: function resize() {
    this._resize && this._resize();
  },
  _createCells: function _createCells(items, columnSize, mergeCols, TDs, Ws, start, rowSize, isHeader) {
    var self = this,
        o = this.options,
        preCol = {},
        preRow = {},
        preRW = {},
        preCW = {},
        map = {};
    columnSize = columnSize || o.columnSize;
    mergeCols = mergeCols || o.mergeCols;
    TDs = TDs || {};
    Ws = Ws || {};
    start = start || 0;
    rowSize || (rowSize = o.rowSize);
    var frag = document.createDocumentFragment();
    BI.each(items, function (i, rows) {
      var tr = BI.$("<tr>").addClass((i & 1) === 0 ? "odd" : "even").height(rowSize);
      BI.each(rows, function (j, row) {
        if (!map[i]) {
          map[i] = {};
        }

        if (!TDs[i]) {
          TDs[i] = {};
        }

        if (!Ws[i]) {
          Ws[i] = {};
        }

        map[i][j] = row;

        if (o.isNeedMerge && mergeCols.includes(j)) {
          if (i === 0 && j === 0) {
            createOneEl(0, 0);
          } else if (j === 0 && i > 0) {
            var isNeedMergeRow = o.mergeRule(map[i][j], map[i - 1][j]);

            if (isNeedMergeRow === true) {
              mergeRow(i, j);
              preRow[i] = preCol[j];
              preRW[i] = preCW[j];
            } else {
              createOneEl(i, j);
            }
          } else if (i === 0 && j > 0) {
            var isNeedMergeCol = o.mergeRule(map[i][j], map[i][j - 1]);

            if (isNeedMergeCol === true) {
              mergeCol(i, j);
              preCol[j] = preRow[i];
              preCW[j] = preRW[i];
            } else {
              createOneEl(i, j);
            }
          } else {
            var isNeedMergeRow = o.mergeRule(map[i][j], map[i - 1][j]);
            var isNeedMergeCol = o.mergeRule(map[i][j], map[i][j - 1]);

            if (isNeedMergeCol && isNeedMergeRow) {
              return;
            }

            if (isNeedMergeCol) {
              mergeCol(i, j);
            }

            if (isNeedMergeRow) {
              mergeRow(i, j);
            }

            if (!isNeedMergeCol && !isNeedMergeRow) {
              createOneEl(i, j);
            }
          }
        } else {
          createOneEl(i, j);
        }
      });

      function mergeRow(i, j) {
        // var height = (preCol[j].attr("height") | 0) + rowSize;
        // preCol[j].attr("height", height).css("height", height);
        // preCW[j].element.css("height", height);
        var rowspan = ((preCol[j].attr("rowspan") || 1) | 0) + 1;
        preCol[j].attr("rowspan", rowspan);
        BI.pushDistinct(preCol[j].__mergeRows, i);
        TDs[i][j] = preCol[j];
        Ws[i][j] = preCW[j];
      }

      function mergeCol(i, j) {
        if (columnSize[j]) {// var width = preRow[i].attr("width") | 0;
          // width = width + columnSize[j];
          // width = self._calculateWidth(width);
          // preRow[i].attr("width", width);
          // preRW[i].element.width(width);
        }

        var colspan = ((preRow[i].attr("colspan") || 1) | 0) + 1;
        preRow[i].attr("colspan", colspan);
        BI.pushDistinct(preRow[i].__mergeCols, j);
        TDs[i][j] = preRow[i];
        Ws[i][j] = preRW[i];
      }

      function createOneEl(r, c) {
        // var width = self._calculateWidth(columnSize[c]);
        // var height = self._calculateHeight(rowSize);
        var td = BI.$("<td>").css({
          // height: height || "",
          position: "relative"
        }).addClass((c & 1) === 0 ? "odd-col" : "even-col").addClass(r === 0 ? "first-row" : "").addClass(c === 0 ? "first-col" : "").addClass(c === rows.length - 1 ? "last-col" : "");
        var w = BI.createWidget(map[r][c], {
          type: "bi.table_cell",
          // width: BI.isNumeric(width) ? (width - (c === 0 ? 2 : 1)) : "",
          // height: BI.isNumeric(height) ? (height - (r === 0 ? 2 : 1)) : "",
          _row: r,
          _col: c + start
        });
        self.addWidget(w.getName(), w);

        w._mount(); // w.element.css("position", "relative");


        td.append(w.element);
        tr.append(td);
        preCol[c] = td;
        preCol[c].__mergeRows = [r];
        preCW[c] = w;
        preRow[r] = td;
        preRow[r].__mergeCols = [c];
        preRW[r] = w;
        TDs[r][c] = td;
        Ws[r][c] = w;
      }

      frag.appendChild(tr[0]);
    });
    return frag;
  },
  _createColGroupCells: function _createColGroupCells(columnSize, store) {
    var self = this,
        o = this.options;
    columnSize = columnSize || o.columnSize;
    store = store || {};
    var frag = document.createDocumentFragment();
    BI.each(columnSize, function (i, size) {
      var width = self._calculateWidth(size);

      var col = BI.$("<col>").css("width", width);
      store[i] = col;
      frag.appendChild(col[0]);
    });
    return frag;
  },
  _createHeaderCells: function _createHeaderCells(items, columnSize, mergeCols, TDs, Ws, start) {
    var self = this,
        o = this.options;
    start || (start = 0);

    var frag = this._createCells(items, columnSize, BI.range(o.columnSize.length), TDs, Ws, start, o.headerRowSize || o.rowSize, true);

    return frag;
  },
  _createFooterCells: function _createFooterCells(items, columnSize, TDs, Ws) {
    var o = this.options;

    var frag = this._createCells(items, columnSize, [], TDs, Ws, 0);

    return frag;
  },
  _createColGroup: function _createColGroup(columnSize, store, widgets) {
    var self = this,
        o = this.options;
    this.colgroup = this._colgroup();
    this.colgroup.element.append(this._createColGroupCells(columnSize, store, widgets));
    return this.colgroup;
  },
  _createHeader: function _createHeader() {
    var self = this,
        o = this.options;

    if (o.header === false) {
      return;
    }

    this.header = this._header();
    this.header.element.append(this._createHeaderCells(o.header, null, null, this.headerTds, this.headerItems));
    return this.header;
  },
  _createFooter: function _createFooter(columnSize, store, widgets) {
    var self = this,
        o = this.options;

    if (o.footer === false) {
      return;
    }

    this.footer = this._footer();
    this.footer.element.append(this._createFooterCells(o.footer, null, this.footerTds, this.footerItems));
    return this.footer;
  },
  _createBody: function _createBody() {
    var self = this,
        o = this.options;
    this.body = this._body();
    this.body.element.append(this._createCells(o.items, null, null, this.bodyTds, this.bodyItems));
    return this.body;
  },
  _createNormalTable: function _createNormalTable() {
    var self = this,
        o = this.options,
        table = this._table();

    this.colgroupTds = {};
    this.headerTds = {};
    this.footerTds = {};
    this.bodyTds = {};
    this.headerItems = {};
    this.footerItems = {};
    this.bodyItems = {};

    var colgroup = this._createColGroup(null, this.colgroupTds);

    var header = this._createHeader();

    var footer = this._createFooter();

    var body = this._createBody();

    this.tableContainer = BI.createWidget({
      type: "bi.default",
      element: table,
      width: this._calculateWidth(w),
      items: [colgroup, header, footer, body]
    });

    if (this._isColumnSizeValid(o.columnSize)) {
      var w = BI.sum(o.columnSize) || undefined;
      w = this._calculateWidth(w);
    }

    this.scrollBottomRight = BI.createWidget({
      type: "bi.adaptive",
      width: "100%",
      height: "100%",
      cls: "scroll-bottom-right",
      scrollable: true,
      items: [this.tableContainer]
    });
    BI.createWidget({
      type: "bi.adaptive",
      cls: "".concat(o.bordered ? "bordered" : "", " ").concat(o.stripe ? "stripe" : "", " \"bottom-right\""),
      element: this,
      scrollable: false,
      items: [this.scrollBottomRight]
    });

    this._initNormalScroll();
  },
  _initNormalScroll: function _initNormalScroll() {
    var self = this;
    this.scrollBottomRight.element.scroll(function (e) {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL);
    });
  },
  _split: function _split(items) {
    var o = this.options,
        left = [],
        right = [],
        isRight = this._isRightFreeze();

    BI.each(items, function (i, rows) {
      left.push([]);
      right.push([]);
      BI.each(rows, function (j, cell) {
        if (o.freezeCols.includes(j)) {
          (isRight ? right : left)[i].push(cell);
        } else {
          (isRight ? left : right)[i].push(cell);
        }
      });
    });
    return {
      left: left,
      right: right
    };
  },
  _table: function _table() {
    return BI.createWidget({
      type: "bi.layout",
      tagName: "table",
      cls: "table-view-table",
      attribute: {
        cellspacing: 0,
        cellpadding: 0
      }
    });
  },
  _header: function _header() {
    return BI.createWidget({
      type: "bi.layout",
      cls: "table-view-header",
      tagName: "thead"
    });
  },
  _footer: function _footer() {
    return BI.createWidget({
      type: "bi.layout",
      cls: "table-view-footer",
      tagName: "tfoot"
    });
  },
  _body: function _body() {
    return BI.createWidget({
      type: "bi.layout",
      tagName: "tbody",
      cls: "table-view-body"
    });
  },
  _colgroup: function _colgroup() {
    return BI.createWidget({
      type: "bi.layout",
      tagName: "colgroup"
    });
  },
  render: function render() {
    if (this.options.items.length > 0 || this.options.header.length > 0) {
      this.populate(this.options.items);
    }
  },
  setColumnSize: function setColumnSize(columnSize) {
    var self = this,
        o = this.options;

    var isRight = this._isRightFreeze();

    o.columnSize = columnSize || [];

    if (o.isNeedFreeze) {
      var columnLeft = [];
      var columnRight = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.freezeCols.includes(i)) {
          isRight ? columnRight.push(size) : columnLeft.push(size);
        } else {
          isRight ? columnLeft.push(size) : columnRight.push(size);
        }
      });
      var topleft = 0,
          topright = 1,
          bottomleft = 2,
          bottomright = 3;

      var run = function run(direction) {
        var colgroupTds, bodyTds, bodyItems, sizes;

        switch (direction) {
          case topleft:
            colgroupTds = self.topLeftColGroupTds;
            bodyTds = self.topLeftBodyTds;
            bodyItems = self.topLeftBodyItems;
            sizes = columnLeft;
            break;

          case topright:
            colgroupTds = self.topRightColGroupTds;
            bodyTds = self.topRightBodyTds;
            bodyItems = self.topRightBodyItems;
            sizes = columnRight;
            break;

          case bottomleft:
            colgroupTds = self.bottomLeftColGroupTds;
            bodyTds = self.bottomLeftBodyTds;
            bodyItems = self.bottomLeftBodyItems;
            sizes = columnLeft;
            break;

          case bottomright:
            colgroupTds = self.bottomRightColGroupTds;
            bodyTds = self.bottomRightBodyTds;
            bodyItems = self.bottomRightBodyItems;
            sizes = columnRight;
            break;
        }

        BI.each(colgroupTds, function (i, colgroup) {
          var width = colgroup.attr("width") | 0;

          if (sizes[i] !== "" && width !== sizes[i]) {
            var w = self._calculateWidth(sizes[i]);

            colgroup.attr("width", w).css("width", w);
          }
        });
      };

      run(topleft);
      run(topright);
      run(bottomleft);
      run(bottomright);
      var lw = 0,
          rw = 0,
          lValid = true,
          rValid = true;
      this.columnLeft = [];
      this.columnRight = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.freezeCols.includes(i)) {
          if (!BI.isNumeric(size)) {
            isRight ? rValid = false : lValid = false;
          }

          lw += size;
          self[isRight ? "columnRight" : "columnLeft"].push(size);
        } else {
          if (!BI.isNumeric(size)) {
            isRight ? lValid = false : rValid = false;
          }

          rw += size;
          self[isRight ? "columnLeft" : "columnRight"].push(size);
        }
      });

      if (lValid) {
        lw = this._calculateWidth(lw);

        if (BI.isNumeric(lw)) {
          lw = BI.parseFloat(lw);
        }
      }

      if (rValid) {
        rw = this._calculateWidth(rw);

        if (BI.isNumeric(rw)) {
          rw = BI.parseFloat(rw);
        }
      }

      if (lValid || rValid && isRight) {
        this.topLeftContainer.element.width(isRight ? rw : lw);
        this.bottomLeftContainer.element.width(isRight ? rw : lw);
      } else {
        this.topLeftContainer.element.width("");
        this.bottomLeftContainer.element.width("");
      }

      if (rValid || lValid && isRight) {
        this.topRightContainer.element.width(isRight ? lw : rw);
        this.bottomRightContainer.element.width(isRight ? lw : rw);
      } else {
        this.topRightContainer.element.width("");
        this.bottomRightContainer.element.width("");
      }

      this.scrollTopLeft.element[0].scrollLeft = this.scrollBottomLeft.element[0].scrollLeft;
      this.scrollTopRight.element[0].scrollLeft = this.scrollBottomRight.element[0].scrollLeft;
    } else {
      BI.each(this.colgroupTds, function (i, colgroup) {
        var width = colgroup.attr("width") | 0;

        if (o.columnSize[i] !== "" && width !== o.columnSize[i]) {
          var w = self._calculateWidth(o.columnSize[i]);

          colgroup.attr("width", w).css("width", w);
        }
      });

      if (this._isColumnSizeValid(o.columnSize)) {
        var w = this._calculateWidth(BI.sum(o.columnSize));

        if (w > 1.05) {
          this.tableContainer.element.width(w);
        }
      } else {
        this.tableContainer.element.width("");
      }
    }
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  getCalculateColumnSize: function getCalculateColumnSize() {
    var self = this,
        o = this.options;
    var columnSize = [];

    if (o.isNeedFreeze === true) {
      if (BI.size(this.bottomLeftBodyTds) > 0 || BI.size(this.bottomRightBodyTds) > 0) {
        if (!BI.any(this.bottomLeftBodyTds, function (i, tds) {
          if (!BI.any(tds, function (i, item) {
            if (item.__mergeCols.length > 1) {
              return true;
            }
          })) {
            BI.each(tds, function (i, item) {
              var width = item.width() / item.__mergeCols.length;

              columnSize.push(width);
            });
            return true;
          }
        })) {
          BI.each(this.bottomLeftBodyTds[0], function (i, item) {
            var width = item.width() / item.__mergeCols.length;

            columnSize.push(width);
          });
        }

        if (!BI.any(this.bottomRightBodyTds, function (i, tds) {
          if (!BI.any(tds, function (i, item) {
            if (item.__mergeCols.length > 1) {
              return true;
            }
          })) {
            BI.each(tds, function (i, item) {
              var width = item.width() / item.__mergeCols.length;

              columnSize.push(width);
            });
            return true;
          }
        })) {
          BI.each(this.bottomRightBodyTds[0], function (i, item) {
            var width = item.width() / item.__mergeCols.length;

            columnSize.push(width);
          });
        }

        return columnSize;
      }

      if (!BI.any(this.topLeftBodyTds, function (i, tds) {
        if (!BI.any(tds, function (i, item) {
          if (item.__mergeCols.length > 1) {
            return true;
          }
        })) {
          BI.each(tds, function (i, item) {
            var width = item.width() / item.__mergeCols.length;

            columnSize.push(width);
          });
          return true;
        }
      })) {
        BI.each(this.topLeftBodyTds[BI.size(this.topLeftBodyTds) - 1], function (i, item) {
          var width = item.width() / item.__mergeCols.length;

          columnSize.push(width);
        });
      }

      if (!BI.any(this.topRightBodyTds, function (i, tds) {
        if (!BI.any(tds, function (i, item) {
          if (item.__mergeCols.length > 1) {
            return true;
          }
        })) {
          BI.each(tds, function (i, item) {
            var width = item.width() / item.__mergeCols.length;

            columnSize.push(width);
          });
          return true;
        }
      })) {
        BI.each(this.topRightBodyTds[BI.size(this.topRightBodyTds) - 1], function (i, item) {
          var width = item.width() / item.__mergeCols.length;

          columnSize.push(width);
        });
      }
    } else {
      BI.each(this.headerTds[BI.size(this.headerTds) - 1], function (i, item) {
        var width = item.width() / item.__mergeCols.length;

        columnSize.push(width);
      });
    }

    return columnSize;
  },
  setHeaderColumnSize: function setHeaderColumnSize(columnSize) {
    var self = this,
        o = this.options;

    var isRight = this._isRightFreeze();

    if (o.isNeedFreeze) {
      var columnLeft = [];
      var columnRight = [];
      BI.each(columnSize, function (i, size) {
        if (o.freezeCols.includes(i)) {
          isRight ? columnRight.push(size) : columnLeft.push(size);
        } else {
          isRight ? columnLeft.push(size) : columnRight.push(size);
        }
      });
      var topleft = 0,
          topright = 1;

      var run = function run(direction) {
        var colgroupTds, bodyTds, bodyItems, sizes;

        switch (direction) {
          case topleft:
            colgroupTds = self.topLeftColGroupTds;
            bodyTds = self.topLeftBodyTds;
            bodyItems = self.topLeftBodyItems;
            sizes = columnLeft;
            break;

          case topright:
            colgroupTds = self.topRightColGroupTds;
            bodyTds = self.topRightBodyTds;
            bodyItems = self.topRightBodyItems;
            sizes = columnRight;
            break;
        }

        BI.each(colgroupTds, function (i, colgroup) {
          var width = colgroup.attr("width") | 0;

          if (width !== sizes[i]) {
            var w = self._calculateWidth(sizes[i]);

            colgroup.attr("width", w).css("width", w);
          }
        });
      };

      run(topleft);
      run(topright);
      var lw = 0,
          rw = 0;
      BI.each(columnSize, function (i, size) {
        if (o.freezeCols.includes(i)) {
          lw += size;
        } else {
          rw += size;
        }
      });
      lw = this._calculateWidth(lw);
      rw = this._calculateWidth(rw);

      if (BI.isNumeric(lw)) {
        lw = BI.parseFloat(lw);
      }

      if (BI.isNumeric(rw)) {
        rw = BI.parseFloat(rw);
      }

      this.topLeftContainer.element.width(isRight ? rw : lw);
      this.topRightContainer.element.width(isRight ? lw : rw);
      this.scrollTopLeft.element[0].scrollLeft = this.scrollBottomLeft.element[0].scrollLeft;
      this.scrollTopRight.element[0].scrollLeft = this.scrollBottomRight.element[0].scrollLeft;
    } else {
      BI.each(this.colgroupTds, function (i, colgroup) {
        var width = colgroup.attr("width") | 0;

        if (width !== columnSize[i]) {
          var w = self._calculateWidth(columnSize[i]);

          colgroup.attr("width", w).css("width", w);
        }
      });

      var cW = this._calculateWidth(BI.sum(columnSize));

      this.tableContainer.element.width(cW);
    }
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    var self = this,
        o = this.options;
    o.regionColumnSize = columnSize;

    if (o.freezeCols.length === 0) {
      if (o.isNeedFreeze) {//     this.topLeft.element.css("width", columnSize);
        //     this.topRight.element.css("left", columnSize);
        //     this.bottomLeft.element.css("width", columnSize);
        //     this.bottomRight.element.css("left", columnSize);
      } else {// this.tableContainer.element.width(columnSize[0]);
      }
    } else if (o.freezeCols.length > 0 && o.freezeCols.length < o.columnSize.length) {
      if (o.isNeedFreeze) {
        this.topLeft.element.css("width", columnSize); // this.topRight.element.css("left", columnSize + "px");

        this.bottomLeft.element.css("width", columnSize); // this.bottomRight.element.css("left", columnSize + "px");
      } else {// this.tableContainer.element.width(columnSize[0]);
      }
    } else {
      if (o.isNeedFreeze) {// this.partitions.attr("columnSize", this._isRightFreeze() ? [0, "fill"] : ["fill", 0]);
        // this.partitions.resize();
      } else {// this.tableContainer.element.width(columnSize[0]);
      }
    }
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.options.regionColumnSize;
  },
  getCalculateRegionColumnSize: function getCalculateRegionColumnSize() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return [this.scrollBottomLeft.element.width(), this.scrollBottomRight.element.width()];
    }

    return [this.scrollBottomRight.element.width()];
  },
  getCalculateRegionRowSize: function getCalculateRegionRowSize() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return [this.scrollTopRight.element.height(), this.scrollBottomRight.element.height()];
    }

    return [this.scrollBottomRight.element.height()];
  },
  getClientRegionColumnSize: function getClientRegionColumnSize() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return [this.scrollBottomLeft.element[0].clientWidth, this.scrollBottomRight.element[0].clientWidth];
    }

    return [this.scrollBottomRight.element[0].clientWidth];
  },
  getClientRegionRowSize: function getClientRegionRowSize() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return [this.scrollBottomLeft.element[0].clientHeight, this.scrollBottomRight.element[0].clientHeight];
    }

    return [this.scrollBottomRight.element[0].clientHeight];
  },
  getScrollRegionColumnSize: function getScrollRegionColumnSize() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return [this.scrollBottomLeft.element[0].scrollWidth, this.scrollBottomRight.element[0].scrollWidth];
    }

    return [this.scrollBottomRight.element[0].scrollWidth];
  },
  getScrollRegionRowSize: function getScrollRegionRowSize() {
    var o = this.options;

    if (o.isNeedFreeze) {
      if (o.freezeCols.length < o.columnSize.length) {
        return [this.scrollTopRight.element[0].scrollHeight, this.scrollBottomRight.element[0].scrollHeight];
      }

      return [this.scrollTopLeft.element[0].scrollHeight, this.scrollBottomLeft.element[0].scrollHeight];
    }

    return [this.scrollBottomRight.element[0].scrollHeight];
  },
  hasVerticalScroll: function hasVerticalScroll() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return this.scrollBottomRight.element.hasVerticalScroll() || this.scrollBottomLeft.element.hasVerticalScroll();
    }

    return this.scrollBottomRight.element.hasVerticalScroll();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    var o = this.options;

    if (o.isNeedFreeze) {
      if (this.scrollBottomRight.element[0].scrollTop !== scrollTop) {
        this.scrollBottomRight.element[0].scrollTop = scrollTop;
      }

      if (this.scrollBottomLeft.element[0].scrollTop !== scrollTop) {
        this.scrollBottomLeft.element[0].scrollTop = scrollTop;
      }
    } else {
      if (this.scrollBottomRight.element[0].scrollTop !== scrollTop) {
        this.scrollBottomRight.element[0].scrollTop = scrollTop;
      }
    }
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    var o = this.options;

    if (o.isNeedFreeze) {
      if (this.scrollBottomLeft.element[0].scrollLeft !== scrollLeft) {
        this.scrollBottomLeft.element[0].scrollLeft = scrollLeft;
      }

      if (this.scrollTopLeft.element[0].scrollLeft !== scrollLeft) {
        this.scrollTopLeft.element[0].scrollLeft = scrollLeft;
      }
    } else {
      if (this.scrollBottomRight.element[0].scrollLeft !== scrollLeft) {
        this.scrollBottomRight.element[0].scrollLeft = scrollLeft;
      }
    }
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    var o = this.options;

    if (o.isNeedFreeze) {
      if (this.scrollBottomRight.element[0].scrollLeft !== scrollLeft) {
        this.scrollBottomRight.element[0].scrollLeft = scrollLeft;
      }

      if (this.scrollTopRight.element[0].scrollLeft !== scrollLeft) {
        this.scrollTopRight.element[0].scrollLeft = scrollLeft;
      }
    } else {
      if (this.scrollBottomRight.element[0].scrollLeft !== scrollLeft) {
        this.scrollBottomRight.element[0].scrollLeft = scrollLeft;
      }
    }
  },
  getVerticalScroll: function getVerticalScroll() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return this.scrollBottomRight.element[0].scrollTop || this.scrollBottomLeft.element[0].scrollTop;
    }

    return this.scrollBottomRight.element[0].scrollTop;
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return this.scrollBottomLeft.element[0].scrollLeft;
    }

    return this.scrollBottomRight.element[0].scrollLeft;
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return this.scrollBottomRight.element[0].scrollLeft;
    }

    return this.scrollBottomRight.element[0].scrollLeft;
  },
  getColumns: function getColumns() {
    var o = this.options;

    if (o.isNeedFreeze) {
      return {
        topLeft: this.topLeftBodyItems,
        topRight: this.topRightBodyItems,
        bottomLeft: this.bottomLeftBodyItems,
        bottomRight: this.bottomRightBodyItems
      };
    }

    return {
      header: this.headerItems,
      body: this.bodyItems,
      footer: this.footerItems
    };
  },
  // _empty: function () {
  //     this.scrollBottomRight && this.scrollBottomRight.destroy();
  //     BI.each(this.partitions && this.partitions._children, function (name, child) {
  //         child && child.destroy();
  //     });
  // },
  populate: function populate(items, header) {
    if (!items) {
      return;
    }

    this.options.items = items || [];

    if (header) {
      this.options.header = header;
    }

    this.empty();

    if (this.options.isNeedFreeze) {
      this._createFreezeTable();
    } else {
      this._createNormalTable();
    }
  }
});
BI.Table.EVENT_TABLE_AFTER_INIT = "EVENT_TABLE_AFTER_INIT";
BI.Table.EVENT_TABLE_RESIZE = "EVENT_TABLE_RESIZE";
BI.Table.EVENT_TABLE_SCROLL = "EVENT_TABLE_SCROLL";
BI.Table.EVENT_TABLE_BEFORE_COLUMN_RESIZE = "EVENT_TABLE_BEFORE_COLUMN_RESIZE";
BI.Table.EVENT_TABLE_COLUMN_RESIZE = "EVENT_TABLE_COLUMN_RESIZE";
BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE = "EVENT_TABLE_AFTER_COLUMN_RESIZE";
BI.Table.EVENT_TABLE_BEFORE_REGION_RESIZE = "EVENT_TABLE_BEFORE_REGION_RESIZE";
BI.Table.EVENT_TABLE_REGION_RESIZE = "EVENT_TABLE_REGION_RESIZE";
BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE = "EVENT_TABLE_AFTER_REGION_RESIZE";
BI.shortcut("bi.table_view", BI.Table);

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格单元格
 *
 * Created by GUY on 2016/1/12.
 * @class BI.ResizableTableCell
 * @extends BI.Widget
 */
BI.ResizableTableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.ResizableTableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-resizable-table-cell",
      cell: {},
      minSize: 30,
      // suitableSize,
      maxSize: Number.MAX_VALUE,
      start: BI.emptyFn,
      resize: BI.emptyFn,
      stop: BI.emptyFn,
      _rowIndex: null,
      _columnIndex: null,
      _left: 0,
      _top: 0,
      firstRowTopLine: true,
      firstColumnLeftLine: true
    });
  },
  render: function render() {
    var self = this,
        o = this.options;
    this.cell = BI.createWidget(BI.extend({
      type: "bi.label"
    }, o.cell, {
      width: o.width,
      height: o.height,
      _rowIndex: o._rowIndex,
      _columnIndex: o._columnIndex,
      _left: o._left,
      _top: o._top,
      firstRowTopLine: o.firstRowTopLine,
      firstColumnLeftLine: o.firstColumnLeftLine
    }));
    this.handler = BI.createWidget({
      type: "bi.absolute",
      cls: "resizable-table-cell-resizer-container",
      width: 6,
      items: [{
        el: {
          type: "bi.layout",
          cls: "resizable-table-cell-resizer-knob",
          width: 4
        },
        right: 0,
        top: 0,
        bottom: 0
      }]
    });
    return [{
      type: "bi.vertical_adapt",
      columnSize: ["fill"],
      items: [this.cell]
    }, {
      type: "bi.absolute",
      items: [{
        el: this.handler,
        right: 0,
        top: 0,
        bottom: 0
      }]
    }];
  },
  mounted: function mounted() {
    var self = this,
        o = this.options;
    var startDrag = false;
    var size = 0,
        offset = 0,
        defaultSize = o.width;

    function optimizeSize(s) {
      var optSize = BI.clamp(s, o.minSize, o.maxSize || Number.MAX_VALUE); // if (o.suitableSize) {
      //     if (Math.abs(o.suitableSize - optSize) < 5) {
      //         optSize = o.suitableSize;
      //         self.handler.element.addClass("suitable");
      //     } else {
      //         self.handler.element.removeClass("suitable");
      //     }
      // }

      return optSize;
    }

    var mouseMoveTracker = new BI.MouseMoveTracker(function (deltaX, deltaY) {
      if (mouseMoveTracker.isDragging()) {
        startDrag = true;
        offset += deltaX;
        size = optimizeSize(defaultSize + offset);
        self.handler.element.addClass("dragging");
        o.resize(size, self);
      }
    }, function () {
      if (startDrag === true) {
        size = optimizeSize(size);
        o.stop(size);
        size = 0;
        offset = 0;
        defaultSize = o.width || self.element.width();
        startDrag = false;
      }

      self.handler.element.removeClass("dragging");
      self.handler.element.removeClass("suitable");
      mouseMoveTracker.releaseMouseMoves();
    }, _global.document);
    this.handler.element.on("mousedown", function (event) {
      defaultSize = o.width || self.element.width();
      optimizeSize(defaultSize);
      mouseMoveTracker.captureMouseMoves(event);
    });
  },
  setWidth: function setWidth(width) {
    BI.ResizableTableCell.superclass.setWidth.apply(this, arguments);
    var o = this.options;
    this.cell.setWidth(o.width);
  },
  setHeight: function setHeight(height) {
    BI.ResizableTableCell.superclass.setHeight.apply(this, arguments);
    var o = this.options;
    this.cell.setHeight(o.height);
  }
});
BI.shortcut("bi.resizable_table_cell", BI.ResizableTableCell);

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 可调整列宽的grid表格
 *
 * Created by GUY on 2016/1/12.
 * @class BI.ResizableTable
 * @extends BI.Widget
 */
BI.ResizableTable = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-resizable-table",
    el: {
      type: "bi.grid_table"
    },
    isNeedFreeze: false,
    isNeedResize: true,
    headerRowSize: 25,
    rowSize: 25,
    isNeedMerge: true,
    // 是否需要合并单元格
    mergeCols: [],
    mergeRule: BI.emptyFn,
    columnSize: [],
    minColumnSize: [],
    maxColumnSize: [],
    freezeCols: [],
    header: [],
    items: [],
    regionColumnSize: []
  },
  render: function render() {
    var self = this,
        o = this.options;
    return [BI.extend({
      type: "bi.grid_table",
      width: o.width,
      height: o.height,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      columnSize: o.columnSize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: o.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: BI.bind(this._mergeRule, this),
      header: this._formatHeader(o.header),
      items: o.items,
      regionColumnSize: o.regionColumnSize,
      listeners: [{
        eventName: BI.Table.EVENT_TABLE_SCROLL,
        action: function action() {
          self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
        }
      }]
    }, o.el, {
      ref: function ref(_ref) {
        self.table = _ref;
        o.el.ref && o.el.ref.call(this, _ref);
      }
    }), {
      type: "bi.absolute",
      items: [{
        el: this._createResizerHandler(),
        left: 0,
        top: 0,
        bottom: 0
      }, {
        el: {
          type: "bi.layout",
          cls: "resizable-table-resizer",
          invisible: true,
          width: 2,
          ref: function ref(_ref) {
            self.resizer = _ref;
          }
        },
        left: 0,
        top: 0
      }]
    }];
  },
  mounted: function mounted() {
    var self = this,
        o = this.options;
    var size = 0,
        offset = 0,
        defaultSize = 0,
        start = false;

    this._populate();

    var mouseMoveTracker = new BI.MouseMoveTracker(function (deltaX, deltaY) {
      if (mouseMoveTracker.isDragging()) {
        start = true;
        offset += deltaX;
        size = BI.clamp(defaultSize + offset, 30, o.width - 40);
        self.regionResizerHandler.element.addClass("dragging");

        self._setRegionResizerHandlerPosition(size - 3, 0);
      }
    }, function () {
      if (start === true) {
        o.regionColumnSize[0] = BI.clamp(size, 30, (o.width || self.element.width()) - 40);
        self.table.setRegionColumnSize(o.regionColumnSize); // if (o.isResizeAdapt === true) {
        //     var freezeColumnSize = self._getFreezeColumnSize();
        //     o.columnSize[self._getFreezeColLength() - 1] += o.regionColumnSize[0] - freezeColumnSize;
        //     self.table.setColumnSize(o.columnSize);
        // }
        // self.table.populate();

        self._populate();

        self.regionResizerHandler.element.removeClass("dragging");
        self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE);
        start = false;
      }

      mouseMoveTracker.releaseMouseMoves();
    }, _global.document);
    this.regionResizerHandler.element.on("mousedown", function (event) {
      defaultSize = size = self._getRegionSize();
      offset = 0;

      self._setResizerPosition(0, 0);

      mouseMoveTracker.captureMouseMoves(event);
    });
  },
  _mergeRule: function _mergeRule(row1, row2) {
    var o = this.options;

    if (row1.type === "bi.resizable_table_cell") {
      row1 = row1.cell;
    }

    if (row2.type === "bi.resizable_table_cell") {
      row2 = row2.cell;
    }

    return o.mergeRule(row1, row2);
  },
  _createResizerHandler: function _createResizerHandler() {
    var self = this;
    return {
      type: "bi.absolute",
      cls: "resizable-table-region-resizer",
      invisible: true,
      width: 6,
      items: [{
        el: {
          type: "bi.layout",
          width: 2,
          cls: "resizable-table-region-resizer-knob"
        },
        left: 2,
        top: 0,
        bottom: 0
      }],
      ref: function ref(_ref) {
        self.regionResizerHandler = _ref;
      }
    };
  },
  _setResizerPosition: function _setResizerPosition(left, top) {
    this.resizer.element.css({
      left: left + "px",
      top: top + "px"
    });
  },
  _setRegionResizerHandlerPosition: function _setRegionResizerHandlerPosition(left, top) {
    this.regionResizerHandler.element.css({
      left: left + "px",
      top: top + "px"
    });
  },
  _getRegionSize: function _getRegionSize() {
    var o = this.options;
    var regionSize = o.regionColumnSize[0] || 0;

    if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
      return 0;
    }

    if (!regionSize) {
      BI.each(o.freezeCols, function (i, col) {
        regionSize += o.columnSize[col];
      });
    }

    return regionSize;
  },
  _getHeaderHeight: function _getHeaderHeight() {
    var o = this.options;
    var headerHeights = this.table.getFirstColumnHeaderRowSize && this.table.getFirstColumnHeaderRowSize();
    return headerHeights ? BI.sum(headerHeights) : o.headerRowSize * o.header.length;
  },
  _getItemsHeight: function _getItemsHeight() {
    var o = this.options;
    return this.table.getFirstColumnRowSize ? BI.sum(this.table.getFirstColumnRowSize()) : o.items.length * o.rowSize;
  },
  _getRegionRowSize: function _getRegionRowSize() {
    var o = this.options;

    var headerHeight = this._getHeaderHeight();

    var itemHeight = this._getItemsHeight();

    return [headerHeight, Math.min((o.height || this.element.height()) - headerHeight, itemHeight)];
  },
  _getFreezeColLength: function _getFreezeColLength() {
    var o = this.options;
    return o.isNeedFreeze === true ? BI.clamp(o.freezeCols.length, 0, o.columnSize.length) : 0;
  },
  _getFreezeColumnSize: function _getFreezeColumnSize() {
    var columnSize = this.options.columnSize;
    var sum = 0;

    for (var i = 0, len = this._getFreezeColLength(); i < len; i++) {
      sum += columnSize[i];
    }

    return sum;
  },
  _getResizerLeft: function _getResizerLeft(j, resizeObj) {
    var tableOffsetLeft = this.element.offset().left;
    return resizeObj.element.offset().left - tableOffsetLeft;
  },
  _formatHeader: function _formatHeader(header) {
    var self = this,
        o = this.options;

    if (!o.isNeedResize) {
      return header;
    }

    var result = [];

    var resize = function resize(j, size, resizeObj) {
      self.resizer.setVisible(true);

      var rowSize = self._getRegionRowSize();

      var height = rowSize[0] + rowSize[1];
      self.resizer.setHeight(height); // TODO 不知道为什么加入这段代码会使得列宽调整出问题
      // if (o.minColumnSize[j]) {
      //     if (size === o.minColumnSize[j]) {
      //         self.resizer.element.addClass("suitable");
      //     } else {
      //         self.resizer.element.removeClass("suitable");
      //     }
      // }

      self._setResizerPosition(self._getResizerLeft(j, resizeObj) + size, 0);
    };

    var stop = function stop(j, size) {
      self.resizer.setVisible(false);
      var columnSize = o.columnSize.slice();
      columnSize[j] = size; // 缩小单列宽度，若有多余宽（容器宽度>总列宽）

      var freezeColLength = self._getFreezeColLength();

      var freezeContainerWidth = self._getRegionSize();

      var unFreezeContainerWidth = (o.width || self.element.width()) - BI.GridTableScrollbar.SIZE - freezeContainerWidth;
      var totalColumnWidth = 0;
      var remainWidth = 0;

      if (j < freezeColLength) {
        // 调整冻结列宽
        remainWidth = freezeContainerWidth - BI.sum(columnSize.slice(0, freezeColLength));

        if (remainWidth > 0) {
          // 无滚动条且缩小
          if (j === freezeColLength - 1) {
            // 若为冻结列最后一列，则将多余宽度按比例分配给该列右侧的所有列，冻结区域宽度相应需要有所调整。
            totalColumnWidth = BI.sum(columnSize.slice(j + 1));
            BI.each(columnSize, function (idx, columnWidth) {
              idx > j && (columnSize[idx] = Math.floor(columnWidth + remainWidth * columnWidth / totalColumnWidth));
            });
            freezeContainerWidth -= remainWidth;
          } else {
            // 若非缩小冻结列最后一列，则将多余宽度按比例分配给该列右侧冻结列
            totalColumnWidth = BI.sum(columnSize.slice(j + 1, freezeColLength));
            BI.each(columnSize, function (idx, columnWidth) {
              idx > j && idx < freezeColLength && (columnSize[idx] = Math.floor(columnWidth + remainWidth * columnWidth / totalColumnWidth));
            });
          }
        }
      } else {
        // 调整非冻结列宽
        remainWidth = unFreezeContainerWidth - BI.sum(columnSize.slice(freezeColLength));

        if (remainWidth > 0) {
          // 无滚动条且缩小
          if (j === BI.size(columnSize) - 1) {
            // 缩小最后一列，按比例将缩小的宽度分配给其他列（包括冻结列）。冻结区域宽度相应需要有所调整。
            totalColumnWidth = BI.sum(columnSize.slice(0, BI.size(columnSize) - 1));
            BI.each(columnSize, function (idx, columnWidth) {
              var increaseWidth = Math.floor(remainWidth * columnWidth / totalColumnWidth);

              if (idx < j) {
                columnSize[idx] = columnWidth + increaseWidth;

                if (idx < freezeColLength) {
                  freezeContainerWidth += increaseWidth;
                }
              }
            });
          } else {
            // 若非最后一列，则将多余宽度按比例分配给该列右侧的非冻结列
            totalColumnWidth = BI.sum(columnSize.slice(j + 1));
            BI.each(columnSize, function (idx, columnWidth) {
              idx > j && (columnSize[idx] = Math.floor(columnWidth + remainWidth * columnWidth / totalColumnWidth));
            });
          }
        }
      }

      o.columnSize = columnSize;
      self.setColumnSize(columnSize);
      self.setRegionColumnSize([freezeContainerWidth]);

      self._populate();

      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, j);
    };

    BI.each(header, function (i, cols) {
      if (i === header.length - 1) {
        result[i] = [];
        BI.each(cols, function (j, col) {
          result[i][j] = {
            type: "bi.resizable_table_cell",
            cell: col,
            suitableSize: o.minColumnSize[j],
            maxSize: o.maxColumnSize[j],
            resize: BI.bind(resize, null, j),
            stop: BI.bind(stop, null, j)
          };

          if (o.isNeedMerge) {
            var r = i;

            while (r > 0 && self._mergeRule(result[r][j], result[r - 1][j])) {
              result[r - 1][j] = {
                type: "bi.resizable_table_cell",
                cell: result[r - 1][j],
                suitableSize: o.minColumnSize[j],
                maxSize: o.maxColumnSize[j],
                resize: BI.bind(resize, null, j),
                stop: BI.bind(stop, null, j)
              };
              r--;
            }
          }
        });
      } else {
        result.push(cols);
      }
    });
    return result;
  },
  _populate: function _populate() {
    var o = this.options;

    var regionSize = this._getRegionSize();

    if (regionSize > 0) {
      this.regionResizerHandler.setVisible(true);

      this._setRegionResizerHandlerPosition(regionSize - 3, this._getHeaderHeight());
    } else {
      this.regionResizerHandler.setVisible(false);
    }
  },
  setWidth: function setWidth(width) {
    BI.ResizableTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.ResizableTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this.table.setColumnSize(columnSize);
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    return this.table.getFirstColumnHeaderRowSize();
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    return this.table.getFirstColumnRowSize();
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.regionColumnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  getActualRightHorizontalScroll: function getActualRightHorizontalScroll() {
    return this.table.getActualRightHorizontalScroll();
  },
  attr: function attr() {
    BI.ResizableTable.superclass.attr.apply(this, arguments);
    return this.table.attr.apply(this.table, arguments);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items, header) {
    if (items) {
      this.options.items = items;
    }

    if (header) {
      this.options.header = header;

      if (this.options.isNeedResize) {
        header = this._formatHeader(header);
      }
    }

    this.table.populate(items, header);

    this._populate();
  }
});
BI.shortcut("bi.resizable_table", BI.ResizableTable);

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 列宽自适应的表格
 * 1.列宽支持传递""表示自动，在自动列宽的前提下，列宽会平分剩余宽度
 * 2.自动列宽前提下，区域列宽变化会和列宽变化同步，当区域列宽过小时，列宽最小值为minColumnSize
 *
 * Created by GUY on 2021/9/10.
 * @class BI.ColumnSizeAdaptiveTable
 * @extends BI.Widget
 */
BI.ColumnSizeAdaptiveTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.ColumnSizeAdaptiveTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-column-size-adaptive-table",
      el: {
        type: "bi.resizable_table"
      },
      isNeedResize: true,
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为true时生效
      isNeedMerge: false,
      // 是否需要合并单元格
      mergeCols: [],
      // 合并的单元格列号
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      header: [],
      items: [],
      // 二维数组
      // 交叉表头
      crossHeader: [],
      crossItems: []
    });
  },
  _init: function _init() {
    BI.ColumnSizeAdaptiveTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;

    var data = this._digest();

    this.table = BI.createWidget(o.el, {
      type: "bi.resizable_table",
      element: this,
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: data.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: o.mergeRule,
      columnSize: data.columnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: data.regionColumnSize,
      header: o.header,
      items: o.items,
      // 交叉表头
      crossHeader: o.crossHeader,
      crossItems: o.crossItems
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();

      self._populate();

      self.table.populate();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function (index) {
      // 谁resize了谁改
      o.columnSize[index] = this.getColumnSize()[index]; // o.regionColumnSize = this.getRegionColumnSize();

      self._populate();

      self.table.populate();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
  },
  _getFreezeColLength: function _getFreezeColLength() {
    var o = this.options;

    if (o.isNeedFreeze === true) {
      // 冻结列与总列数相同时
      if (o.freezeCols.length === o.columnSize.length) {
        return 0;
      }

      return BI.clamp(o.freezeCols.length, 0, o.columnSize.length);
    }

    return 0;
  },
  _digest: function _digest() {
    var o = this.options;
    var regionColumnSize = o.regionColumnSize.slice();
    var freezeCols = o.freezeCols.slice();
    var regionSize = o.regionColumnSize[0];

    var freezeColLength = this._getFreezeColLength();

    var emptyColumns = [];
    var allColumnSize = BI.sum(o.columnSize, function (i, size) {
      return size || 0;
    });
    BI.each(o.columnSize, function (i, size) {
      if (!size) {
        emptyColumns.push(i);
      }
    }); // 空列就平分剩下的宽度

    var emptyColumnSize = (o.width - BI.GridTableScrollbar.SIZE - allColumnSize) / emptyColumns.length;
    var columnSize = o.columnSize.map(function (size, i) {
      if (!size) {
        if (o.minColumnSize[i]) {
          return BI.clamp(emptyColumnSize, o.minColumnSize, o.width - BI.GridTableScrollbar.SIZE);
        }

        return emptyColumnSize;
      }

      return size;
    });

    if (!regionSize || regionSize > o.width - BI.GridTableScrollbar.SIZE || regionSize < BI.GridTableScrollbar.SIZE) {
      var rs = BI.sum(columnSize, function (i, size) {
        if (i < freezeColLength) {
          return size;
        }

        return 0;
      });
      regionSize = BI.clamp(rs, 0, 4 / 5 * o.width);
    }

    if (freezeColLength === 0) {
      regionSize = 0;
    }

    if (freezeCols.length >= columnSize.length) {
      freezeCols = [];
    }

    var summaryFreezeColumnSize = 0,
        summaryColumnSize = 0;
    BI.each(columnSize, function (i, size) {
      if (i < freezeColLength) {
        summaryFreezeColumnSize += size;
      }

      summaryColumnSize += size;
    }); // 区域列宽宽度总和不大于区域宽度

    if (freezeColLength > 0 && summaryFreezeColumnSize < regionSize) {
      columnSize[freezeColLength - 1] += regionSize - summaryFreezeColumnSize;
    } // 区域列宽宽度总和大于区域宽度


    if (freezeColLength > 0 && summaryFreezeColumnSize > regionSize) {
      columnSize[freezeColLength - 1] = regionSize - (summaryFreezeColumnSize - columnSize[freezeColLength - 1]);

      if (columnSize[freezeColLength - 1] < (o.minColumnSize[freezeColLength - 1] || emptyColumnSize)) {
        columnSize[freezeColLength - 1] = o.minColumnSize[freezeColLength - 1] || emptyColumnSize;
      }
    } // 冻结只取冻结区域宽度


    var actualSize = summaryColumnSize;

    if (o.isNeedFreeze && freezeColLength > 0) {
      actualSize = summaryColumnSize - summaryFreezeColumnSize + regionSize;
    } // 列宽总和不大于表格总宽度


    if (columnSize.length > 0 && actualSize < o.width - BI.GridTableScrollbar.SIZE) {
      // BI-49217 列宽总和小于表格总宽度（容器宽度）时，将最后一列重新赋值，以使其填满容器
      columnSize[columnSize.length - 1] = o.width - BI.GridTableScrollbar.SIZE - regionSize - (summaryColumnSize - summaryFreezeColumnSize - columnSize[columnSize.length - 1]);
    }

    regionColumnSize[0] = regionSize;
    return {
      freezeCols: freezeCols,
      columnSize: columnSize,
      regionColumnSize: regionColumnSize
    };
  },
  _populate: function _populate() {
    var o = this.options;

    var data = this._digest(); // o.regionColumnSize = data.regionColumnSize;
    // o.columnSize = data.columnSize;


    this.table.setColumnSize(data.columnSize);
    this.table.setRegionColumnSize(data.regionColumnSize);
    this.table.attr("freezeCols", data.freezeCols);
  },
  setWidth: function setWidth(width) {
    BI.ColumnSizeAdaptiveTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.ColumnSizeAdaptiveTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
    this.options.regionColumnSize = regionColumnSize;
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  attr: function attr(key, value) {
    var v = BI.ColumnSizeAdaptiveTable.superclass.attr.apply(this, arguments);

    if (key === "freezeCols") {
      return v;
    }

    return this.table.attr.apply(this.table, arguments);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items) {
    var self = this,
        o = this.options;

    this._populate();

    this.table.populate.apply(this.table, arguments);
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.ColumnSizeAdaptiveTable.superclass.destroy.apply(this, arguments);
  }
});
BI.shortcut("bi.column_size_adaptive_table", BI.ColumnSizeAdaptiveTable);

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 自适应宽度的表格
 *
 * Created by GUY on 2016/2/3.
 * @class BI.AdaptiveTable
 * @extends BI.Widget
 */
BI.AdaptiveTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.AdaptiveTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-adaptive-table",
      el: {
        type: "bi.resizable_table"
      },
      isNeedResize: true,
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为true时生效
      isNeedMerge: false,
      // 是否需要合并单元格
      mergeCols: [],
      // 合并的单元格列号
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      header: [],
      items: [],
      // 二维数组
      // 交叉表头
      crossHeader: [],
      crossItems: []
    });
  },
  _init: function _init() {
    BI.AdaptiveTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;

    var data = this._digest();

    this.table = BI.createWidget(o.el, {
      type: "bi.resizable_table",
      element: this,
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: data.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: o.mergeRule,
      columnSize: data.columnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: data.regionColumnSize,
      header: o.header,
      items: o.items,
      // 交叉表头
      crossHeader: o.crossHeader,
      crossItems: o.crossItems
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();

      self._populate();

      self.table.populate();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      o.columnSize = this.getColumnSize();
      o.regionColumnSize = this.getRegionColumnSize();

      self._populate();

      self.table.populate();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
  },
  _getFreezeColLength: function _getFreezeColLength() {
    var o = this.options;

    if (o.isNeedFreeze === true) {
      // 冻结列与总列数相同时
      if (o.freezeCols.length === o.columnSize.length) {
        return 0;
      }

      return BI.clamp(o.freezeCols.length, 0, o.columnSize.length);
    }

    return 0;
  },
  _digest: function _digest() {
    var o = this.options;
    var columnSize = o.columnSize.slice();
    var regionColumnSize = o.regionColumnSize.slice();
    var freezeCols = o.freezeCols.slice();
    var regionSize = o.regionColumnSize[0];

    var freezeColLength = this._getFreezeColLength();

    if (!regionSize || regionSize > o.width - BI.GridTableScrollbar.SIZE || regionSize < BI.GridTableScrollbar.SIZE) {
      var rs = BI.sum(columnSize, function (i, size) {
        if (i < freezeColLength) {
          return size;
        }

        return 0;
      });
      regionSize = BI.clamp(rs, 1 / 5 * o.width, 4 / 5 * o.width);
    }

    if (freezeColLength === 0) {
      regionSize = 0;
    }

    if (freezeCols.length >= columnSize.length) {
      freezeCols = [];
    }

    if (!BI.isNumber(columnSize[0])) {
      columnSize = o.minColumnSize.slice();
    }

    var summaryFreezeColumnSize = 0,
        summaryColumnSize = 0;
    BI.each(columnSize, function (i, size) {
      if (i < freezeColLength) {
        summaryFreezeColumnSize += size;
      }

      summaryColumnSize += size;
    });

    if (freezeColLength > 0 && summaryFreezeColumnSize < regionSize) {
      columnSize[freezeColLength - 1] += regionSize - summaryFreezeColumnSize;
    } // 冻结只取冻结区域宽度


    var actualSize = summaryColumnSize;

    if (o.isNeedFreeze && freezeColLength > 0) {
      actualSize = summaryColumnSize - summaryFreezeColumnSize + regionSize;
    } // 列宽总和不大于表格总宽度


    if (columnSize.length > 0 && actualSize < o.width - BI.GridTableScrollbar.SIZE) {
      // BI-49217 列宽总和小于表格总宽度（容器宽度）时，将最后一列重新赋值，以使其填满容器
      columnSize[columnSize.length - 1] = o.width - BI.GridTableScrollbar.SIZE - regionSize - (summaryColumnSize - summaryFreezeColumnSize - columnSize[columnSize.length - 1]);
    }

    regionColumnSize[0] = regionSize;
    return {
      freezeCols: freezeCols,
      columnSize: columnSize,
      regionColumnSize: regionColumnSize
    };
  },
  _populate: function _populate() {
    var o = this.options;

    var data = this._digest();

    o.regionColumnSize = data.regionColumnSize;
    o.columnSize = data.columnSize;
    this.table.setColumnSize(data.columnSize);
    this.table.setRegionColumnSize(data.regionColumnSize);
    this.table.attr("freezeCols", data.freezeCols);
  },
  setWidth: function setWidth(width) {
    BI.AdaptiveTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.AdaptiveTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    return this.table.getFirstColumnHeaderRowSize();
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    return this.table.getFirstColumnRowSize();
  },
  setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
    this.options.regionColumnSize = regionColumnSize;
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  attr: function attr(key, value) {
    var v = BI.AdaptiveTable.superclass.attr.apply(this, arguments);

    if (key === "freezeCols") {
      return v;
    }

    return this.table.attr.apply(this.table, arguments);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items) {
    var self = this,
        o = this.options;

    this._populate();

    this.table.populate.apply(this.table, arguments);
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.AdaptiveTable.superclass.destroy.apply(this, arguments);
  }
});
BI.shortcut("bi.adaptive_table", BI.AdaptiveTable);

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 层级树状结构的表格
 *
 * Created by GUY on 2016/8/12.
 * @class BI.DynamicSummaryLayerTreeTable
 * @extends BI.Widget
 */
BI.DynamicSummaryLayerTreeTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.DynamicSummaryLayerTreeTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-dynamic-summary-layer-tree-table",
      el: {
        type: "bi.resizable_table"
      },
      isNeedResize: true,
      // 是否需要调整列宽
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      footerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      // 行表头
      rowHeaderCreator: null,
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      header: [],
      footer: false,
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right"
    });
  },
  _getVDeep: function _getVDeep() {
    return this.options.crossHeader.length; // 纵向深度
  },
  _getHDeep: function _getHDeep() {
    var o = this.options;
    return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
  },
  _createHeader: function _createHeader(vDeep) {
    var self = this,
        o = this.options;
    var header = o.header || [],
        crossHeader = o.crossHeader || [];
    var items = BI.isEmpty(header) ? BI.TableTree.formatCrossItems4Special(o.crossItems, vDeep, o.headerCellStyleGetter, {
      sumPosition: this.options.colPosition === "right",
      summaryText: o.summaryText
    }) : BI.TableTree.formatCrossItems(o.crossItems, vDeep, o.headerCellStyleGetter, {
      sumPosition: this.options.colPosition === "right",
      summaryText: o.summaryText
    });
    var result = [];
    BI.each(items, function (row, node) {
      var c = [crossHeader[row]];
      result.push(c.concat(node || []));
    });
    var rowHeaderCreator = BI.isFunction(o.rowHeaderCreator) ? o.rowHeaderCreator() : o.rowHeaderCreator;

    if (header && header.length > 0) {
      var newHeader = this._formatColumns(header);

      var deep = this._getHDeep();

      if (deep <= 0) {
        newHeader.unshift(rowHeaderCreator || {
          type: "bi.table_style_cell",
          text: BI.i18nText("BI-Row_Header"),
          styleGetter: o.headerCellStyleGetter,
          _store: o.tableStyleCellStoreGetter
        });
      } else {
        newHeader[0] = rowHeaderCreator || {
          type: "bi.table_style_cell",
          text: BI.i18nText("BI-Row_Header"),
          styleGetter: o.headerCellStyleGetter,
          _store: o.tableStyleCellStoreGetter
        };
      }

      result.push(newHeader);
    }

    return result;
  },
  _formatItems: function _formatItems(nodes, header, deep) {
    var self = this,
        o = this.options;
    var result = [];

    function track(node, layer) {
      node.type || (node.type = "bi.layer_tree_table_cell");
      node.layer = layer;
      var next = [node];
      next = next.concat(node.values || []);

      if (next.length > 0) {
        result.push(next);
      }

      if (BI.isNotEmptyArray(node.children)) {
        BI.each(node.children, function (index, child) {
          track(child, layer + 1);
        });
      }
    }

    BI.each(nodes, function (i, node) {
      BI.each(node.children, function (j, c) {
        track(c, 0);
      });

      if (BI.isArray(node.values)) {
        var next = [{
          type: "bi.table_style_cell",
          text: o.summaryText,
          title: o.summaryText,
          styleGetter: function styleGetter() {
            return o.summaryCellStyleGetter(true, BI.get(node, ["children", 0, "dId"]));
          },
          _store: o.tableStyleCellStoreGetter
        }].concat(node.values);
        o.rowPosition === "bottom" ? result.push(next) : result.unshift(next);
      }
    });
    return BI.DynamicSummaryTreeTable.formatSummaryItems(result, header, o.crossItems, 1);
  },
  _formatColumns: function _formatColumns(columns, deep) {
    if (BI.isNotEmptyArray(columns)) {
      deep = deep || this._getHDeep();
      return columns.slice(Math.max(0, deep - 1));
    }

    return columns;
  },
  _formatFreezeCols: function _formatFreezeCols() {
    if (this.options.freezeCols.length > 0) {
      return [0];
    }

    return [];
  },
  _formatColumnSize: function _formatColumnSize(columnSize, deep) {
    if (columnSize.length <= 0) {
      return [];
    }

    var result = [0];
    deep = deep || this._getHDeep();
    BI.each(columnSize, function (i, size) {
      if (i < deep) {
        result[0] += size;
        return;
      }

      result.push(size);
    });
    return result;
  },
  _recomputeColumnSize: function _recomputeColumnSize() {
    var o = this.options;
    o.regionColumnSize = this.table.getRegionColumnSize();
    var columnSize = this.table.getColumnSize().slice();

    if (o.freezeCols.length > 1) {
      for (var i = 0; i < o.freezeCols.length - 1; i++) {
        columnSize.splice(1, 0, 0);
      }
    }

    o.columnSize = columnSize;
  },
  _digest: function _digest() {
    var o = this.options;

    var deep = this._getHDeep();

    var vDeep = this._getVDeep();

    var header = this._createHeader(vDeep);

    var data = this._formatItems(o.items, header, deep);

    var columnSize = o.columnSize.slice();
    var minColumnSize = o.minColumnSize.slice();
    var maxColumnSize = o.maxColumnSize.slice();
    BI.removeAt(columnSize, data.deletedCols);
    BI.removeAt(minColumnSize, data.deletedCols);
    BI.removeAt(maxColumnSize, data.deletedCols);
    this.header = data.header;
    this.items = data.items;
    return {
      header: data.header,
      items: data.items,
      columnSize: this._formatColumnSize(columnSize, deep),
      minColumnSize: this._formatColumns(minColumnSize, deep),
      maxColumnSize: this._formatColumns(maxColumnSize, deep),
      freezeCols: this._formatFreezeCols()
    };
  },
  _init: function _init() {
    BI.DynamicSummaryLayerTreeTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;

    var data = this._digest();

    this.table = BI.createWidget(o.el, {
      type: "bi.resizable_table",
      element: this,
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: data.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: [],
      mergeRule: o.mergeRule,
      columnSize: data.columnSize,
      minColumnSize: data.minColumnSize,
      maxColumnSize: data.maxColumnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: o.regionColumnSize,
      header: data.header,
      items: data.items
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      self._recomputeColumnSize();

      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      self._recomputeColumnSize();

      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
  },
  setWidth: function setWidth(width) {
    BI.DynamicSummaryLayerTreeTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.DynamicSummaryLayerTreeTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    return this.table.getFirstColumnHeaderRowSize();
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    var rowHeights = this.table.getFirstColumnRowSize();
    var groupedHeight = [];
    BI.each(this.items, function (i, rows) {
      if (rows[0].layer > 0) {
        groupedHeight[groupedHeight.length - 1] += rowHeights[i];
      } else {
        groupedHeight.push(rowHeights[i]);
      }
    });
    return groupedHeight;
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.regionColumnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  attr: function attr(key, value) {
    BI.DynamicSummaryLayerTreeTable.superclass.attr.apply(this, arguments);

    switch (key) {
      case "columnSize":
      case "minColumnSize":
      case "maxColumnSize":
      case "freezeCols":
      case "mergeCols":
        return;
    }

    return this.table.attr.apply(this.table, [key, value]);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items, header, crossItems, crossHeader) {
    var o = this.options;

    if (items) {
      o.items = items;
    }

    if (header) {
      o.header = header;
    }

    if (crossItems) {
      o.crossItems = crossItems;
    }

    if (crossHeader) {
      o.crossHeader = crossHeader;
    }

    var data = this._digest();

    this.table.setColumnSize(data.columnSize);
    this.table.attr("minColumnSize", data.minColumnSize);
    this.table.attr("maxColumnSize", data.maxColumnSize);
    this.table.attr("freezeCols", data.freezeCols);
    this.table.populate(data.items, data.header);
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.DynamicSummaryLayerTreeTable.superclass.destroy.apply(this, arguments);
  }
});
BI.shortcut("bi.dynamic_summary_layer_tree_table", BI.DynamicSummaryLayerTreeTable);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 树状结构的表格
 *
 * Created by GUY on 2015/8/12.
 * @class BI.DynamicSummaryTreeTable
 * @extends BI.Widget
 */
BI.DynamicSummaryTreeTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.DynamicSummaryTreeTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-dynamic-summary-tree-table",
      el: {
        type: "bi.resizable_table"
      },
      isNeedResize: true,
      // 是否需要调整列宽
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      isNeedMergeCol: true,
      // 是否横向合并
      isNeedMergeRow: true,
      // 是否纵向合并
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      footerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      summaryCellCreator: undefined,
      header: [],
      footer: false,
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right",
      showInnerSummary: false
    });
  },
  _getVDeep: function _getVDeep() {
    return this.options.crossHeader.length; // 纵向深度
  },
  _getHDeep: function _getHDeep() {
    var o = this.options;
    return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
  },
  _init: function _init() {
    BI.DynamicSummaryTreeTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;

    var data = this._digest();

    this.table = BI.createWidget(o.el, {
      type: "bi.resizable_table",
      element: this,
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: o.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: o.mergeRule,
      columnSize: o.columnSize,
      minColumnSize: o.minColumnSize,
      maxColumnSize: o.maxColumnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: o.regionColumnSize,
      header: data.header,
      items: data.items
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      var columnSize = this.getColumnSize();
      var length = o.columnSize.length - columnSize.length;
      o.columnSize = columnSize.slice();
      o.columnSize = o.columnSize.concat(BI.makeArray(length, 0));
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      var columnSize = this.getColumnSize();
      var length = o.columnSize.length - columnSize.length;
      o.columnSize = columnSize.slice();
      o.columnSize = o.columnSize.concat(BI.makeArray(length, 0));
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
  },
  _digest: function _digest() {
    var o = this.options;

    var deep = this._getHDeep();

    var vDeep = this._getVDeep();

    var header = BI.TableTree.formatHeader(o.header, o.crossHeader, o.crossItems, deep, vDeep, o.headerCellStyleGetter, {
      sumPosition: o.colPosition === "right",
      summaryText: o.summaryText
    });
    var items = BI.DynamicSummaryTreeTable.formatHorizontalItems(o.items, deep, false, o.summaryCellStyleGetter, {
      sumPosition: o.rowPosition === "bottom",
      summaryText: o.summaryText,
      isNeedMergeRow: o.isNeedMergeRow,
      summaryCellCreator: o.summaryCellCreator,
      tableStyleCellStoreGetter: o.tableStyleCellStoreGetter
    });
    var data = BI.DynamicSummaryTreeTable.formatSummaryItems(items, header, o.crossItems, deep);
    var columnSize = o.columnSize.slice();
    var minColumnSize = o.minColumnSize.slice();
    var maxColumnSize = o.maxColumnSize.slice();
    BI.removeAt(columnSize, data.deletedCols);
    BI.removeAt(minColumnSize, data.deletedCols);
    BI.removeAt(maxColumnSize, data.deletedCols);
    return {
      header: data.header,
      items: data.items,
      columnSize: columnSize,
      minColumnSize: minColumnSize,
      maxColumnSize: maxColumnSize
    };
  },
  setWidth: function setWidth(width) {
    BI.DynamicSummaryTreeTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.DynamicSummaryTreeTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    return this.table.getFirstColumnHeaderRowSize();
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    var o = this.options;
    var rowHeight = this.table.getFirstColumnRowSize();

    if (o.isNeedMergeRow) {
      return rowHeight;
    } // 利用tableTree的能力算高度


    var items = BI.TableTree.formatItems(o.items, this._getHDeep(), false, o.summaryCellStyleGetter, {
      sumPosition: o.rowPosition === "bottom",
      summaryText: o.summaryText,
      isNeedMergeRow: o.isNeedMergeRow,
      summaryCellCreator: o.summaryCellCreator
    });
    var groupedHeight = [];
    var last = null;
    BI.each(items, function (i, rows) {
      if (rows[0] === last) {
        groupedHeight[groupedHeight.length - 1] += rowHeight[i];
      } else {
        last = rows[0];
        groupedHeight.push(rowHeight[i]);
      }
    });
    return groupedHeight;
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.regionColumnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  attr: function attr(key) {
    BI.DynamicSummaryTreeTable.superclass.attr.apply(this, arguments);

    switch (key) {
      case "minColumnSize":
      case "maxColumnSize":
        return;
    }

    return this.table.attr.apply(this.table, arguments);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items, header, crossItems, crossHeader) {
    var o = this.options;

    if (items) {
      o.items = items;
    }

    if (header) {
      o.header = header;
    }

    if (crossItems) {
      o.crossItems = crossItems;
    }

    if (crossHeader) {
      o.crossHeader = crossHeader;
    }

    var data = this._digest();

    this.table.setColumnSize(data.columnSize);
    this.table.attr("minColumnSize", data.minColumnSize);
    this.table.attr("maxColumnSize", data.maxColumnSize);
    this.table.populate(data.items, data.header);
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.DynamicSummaryTreeTable.superclass.destroy.apply(this, arguments);
  }
});
BI.extend(BI.DynamicSummaryTreeTable, {
  formatHorizontalItems: function formatHorizontalItems(nodes, deep, isCross, _styleGetter, options) {
    options = options || {};
    var result = [];

    var sumPosition = options.sumPosition,
        summaryText = options.summaryText,
        isNeedMergeRow = options.isNeedMergeRow,
        summaryCellCreator = options.summaryCellCreator || function (v) {
      return v;
    }; // 标识由原本需要合并的节点


    function cloneNode(node, tag) {
      if (isNeedMergeRow) {
        return node;
      }

      var result = BI.clone(node);

      if (tag) {
        result.clone = true;
      }

      return result;
    }

    function cloneArray(arr, tag) {
      if (isNeedMergeRow) {
        return arr.slice();
      }

      return BI.map(arr, function (i, item) {
        return cloneNode(item, tag);
      });
    }

    function track(store, node) {
      var next;

      if (BI.isArray(node.children)) {
        var totalLength = 0;
        BI.each(node.children, function (index, child) {
          var next;

          if (store != -1) {
            next = cloneArray(store, node.summaryClone ? node.children.length > 0 : index !== 0);
            next.push(cloneNode(node, node.summaryClone ? node.children.length > 0 : index !== 0));
          } else {
            next = [];
          }

          totalLength += track(next, child);
        });

        if (store != -1) {
          next = cloneArray(store, !node.summaryClone);
          next.push(cloneNode(node, !node.summaryClone));
        } else {
          next = [];
        }

        if (BI.isNotEmptyArray(node.values)) {
          var summary = summaryCellCreator({
            text: summaryText,
            title: summaryText,
            type: "bi.table_style_cell",
            styleGetter: function styleGetter() {
              return _styleGetter(store === -1, BI.get(node, ["children", 0, "dId"]));
            },
            _store: options.tableStyleCellStoreGetter
          }, node, store === -1);

          for (var i = next.length; i < deep; i++) {
            next.push(summary);
          }

          if (!isCross) {
            next = next.concat(BI.map(node.values, function (j, value) {
              var style = _styleGetter(store === -1);

              return summaryCellCreator(BI.extend({}, value, {
                styles: style
              }), node, store === -1);
            }));
          }

          if (next.length > 0) {
            if (!isCross) {
              sumPosition ? result.push(next) : result.splice(result.length - totalLength, 0, next);
            } else {
              for (var k = 0, l = node.values.length; k < l; k++) {
                sumPosition ? result.push(next) : result.splice(result.length - totalLength, 0, next);
              }
            }
          }

          return totalLength + 1;
        }

        return totalLength;
      }

      if (store != -1) {
        next = store.slice();

        for (var i = next.length; i < deep; i++) {
          next.push(node);
        }
      } else {
        next = [];
      }

      if (!isCross && BI.isArray(node.values)) {
        next = next.concat(node.values);
      }

      if (isCross && BI.isArray(node.values)) {
        for (var i = 0, len = node.values.length; i < len - 1; i++) {
          if (next.length > 0) {
            result.push(next);
          }
        }
      }

      if (next.length > 0) {
        result.push(next);
      }

      return node.values ? 1 : 0;
    }

    BI.each(nodes, function (i, node) {
      track(-1, node, 0);
    }); // 填充空位

    BI.each(result, function (i, line) {
      var last = BI.last(line);

      for (var j = line.length; j < deep; j++) {
        line.push(last);
      }
    });
    return result;
  },
  formatSummaryItems: function formatSummaryItems(items, header, crossItems, deep) {
    // 求纵向需要去除的列
    var cols = [];
    var leaf = 0;

    function track(node) {
      if (BI.isArray(node.children)) {
        BI.each(node.children, function (index, child) {
          track(child);
        });

        if (BI.isNotEmptyArray(node.values)) {
          if (node.children.length === 1) {
            for (var i = 0; i < node.values.length; i++) {
              cols.push(leaf + i + deep);
            }
          }

          leaf += node.values.length;
        }

        return;
      }

      if (node.values && node.values.length > 1) {
        leaf += node.values.length;
      } else {
        leaf++;
      }
    }

    BI.each(crossItems, function (i, node) {
      track(node);
    });

    if (cols.length > 0) {
      var nHeader = [],
          nItems = [];
      BI.each(header, function (i, node) {
        var nNode = node.slice();
        BI.removeAt(nNode, cols);
        nHeader.push(nNode);
      });
      BI.each(items, function (i, node) {
        var nNode = node.slice();
        BI.removeAt(nNode, cols);
        nItems.push(nNode);
      });
      header = nHeader;
      items = nItems;
    }

    return {
      items: items,
      header: header,
      deletedCols: cols
    };
  }
});
BI.shortcut("bi.dynamic_summary_tree_table", BI.DynamicSummaryTreeTable);

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by GUY on 2016/5/7.
 * @class BI.LayerTreeTableCell
 * @extends BI.Single
 */
BI.LayerTreeTableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.LayerTreeTableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-layer-tree-table-cell",
      layer: 0,
      text: ""
    });
  },
  _init: function _init() {
    BI.LayerTreeTableCell.superclass._init.apply(this, arguments);

    var o = this.options;
    BI.createWidget({
      type: "bi.label",
      element: this.element,
      textAlign: "left",
      whiteSpace: "nowrap",
      height: o.height,
      text: o.text,
      value: o.value,
      lgap: 5 + 30 * o.layer,
      rgap: 5
    });
  }
});
BI.shortcut("bi.layer_tree_table_cell", BI.LayerTreeTableCell);

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 层级树状结构的表格
 *
 * Created by GUY on 2016/5/7.
 * @class BI.LayerTreeTable
 * @extends BI.Widget
 */
BI.LayerTreeTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.LayerTreeTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-layer-tree-table",
      el: {
        type: "bi.resizable_table"
      },
      isNeedResize: false,
      // 是否需要调整列宽
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      rowHeaderCreator: null,
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      header: [],
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right",
      showInnerSummary: false
    });
  },
  _getVDeep: function _getVDeep() {
    return this.options.crossHeader.length; // 纵向深度
  },
  _getHDeep: function _getHDeep() {
    var o = this.options;
    return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
  },
  _createHeader: function _createHeader(vDeep) {
    var self = this,
        o = this.options;
    var header = o.header || [],
        crossHeader = o.crossHeader || [];
    var items = BI.TableTree.formatCrossItems(o.crossItems, vDeep, o.headerCellStyleGetter, {
      sumPosition: o.colPosition === "right",
      summaryText: o.summaryText
    });
    var result = [];
    BI.each(items, function (row, node) {
      var c = [crossHeader[row]];
      result.push(c.concat(node || []));
    });

    if (header && header.length > 0) {
      var newHeader = this._formatColumns(header);

      var deep = this._getHDeep();

      if (deep <= 0) {
        newHeader.unshift(o.rowHeaderCreator || {
          type: "bi.table_style_cell",
          text: BI.i18nText("BI-Row_Header"),
          styleGetter: o.headerCellStyleGetter,
          _store: o.tableStyleCellStoreGetter
        });
      } else {
        newHeader[0] = o.rowHeaderCreator || {
          type: "bi.table_style_cell",
          text: BI.i18nText("BI-Row_Header"),
          styleGetter: o.headerCellStyleGetter,
          _store: o.tableStyleCellStoreGetter
        };
      }

      result.push(newHeader);
    }

    return result;
  },
  _formatItems: function _formatItems(nodes) {
    var self = this,
        o = this.options;
    var result = [];

    function track(node, layer) {
      node.type || (node.type = "bi.layer_tree_table_cell");
      node.layer = layer;
      var next = [node];
      next = next.concat(node.values || []);

      if (next.length > 0) {
        result.push(next);
      }

      if (BI.isNotEmptyArray(node.children)) {
        BI.each(node.children, function (index, child) {
          track(child, layer + 1);
        });
      }
    }

    BI.each(nodes, function (i, node) {
      BI.each(node.children, function (j, c) {
        track(c, 0);
      });

      if (BI.isArray(node.values)) {
        var next = [{
          type: "bi.table_style_cell",
          text: BI.i18nText("BI-Summary_Values"),
          styleGetter: function styleGetter() {
            return o.summaryCellStyleGetter(true);
          },
          _store: o.tableStyleCellStoreGetter
        }].concat(node.values);
        result.push(next);
      }
    });
    return result;
  },
  _formatColumns: function _formatColumns(columns, deep) {
    if (BI.isNotEmptyArray(columns)) {
      deep = deep || this._getHDeep();
      return columns.slice(Math.max(0, deep - 1));
    }

    return columns;
  },
  _formatFreezeCols: function _formatFreezeCols() {
    if (this.options.freezeCols.length > 0) {
      return [0];
    }

    return [];
  },
  _formatColumnSize: function _formatColumnSize(columnSize, deep) {
    if (columnSize.length <= 0) {
      return [];
    }

    var result = [0];
    deep = deep || this._getHDeep();
    BI.each(columnSize, function (i, size) {
      if (i < deep) {
        result[0] += size;
        return;
      }

      result.push(size);
    });
    return result;
  },
  _digest: function _digest() {
    var o = this.options;

    var deep = this._getHDeep();

    var vDeep = this._getVDeep();

    this.header = this._createHeader(vDeep);
    this.items = this._formatItems(o.items);
    return {
      header: this.header,
      items: this.items,
      columnSize: this._formatColumnSize(o.columnSize, deep),
      minColumnSize: this._formatColumns(o.minColumnSize, deep),
      maxColumnSize: this._formatColumns(o.maxColumnSize, deep),
      freezeCols: this._formatFreezeCols()
    };
  },
  _init: function _init() {
    BI.LayerTreeTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;

    var data = this._digest();

    this.table = BI.createWidget(o.el, {
      type: "bi.resizable_table",
      element: this,
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: data.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: [],
      mergeRule: o.mergeRule,
      columnSize: data.columnSize,
      minColumnSize: data.minColumnSize,
      maxColumnSize: data.maxColumnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: o.regionColumnSize,
      header: data.header,
      items: data.items
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
  },
  setWidth: function setWidth(width) {
    BI.LayerTreeTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.LayerTreeTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
  },
  getColumnSize: function getColumnSize() {
    var columnSize = this.table.getColumnSize();

    var deep = this._getHDeep();

    var pre = [];

    if (deep > 0) {
      pre = BI.makeArray(deep, columnSize[0] / deep);
    }

    return pre.concat(columnSize.slice(1));
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    return this.table.getFirstColumnHeaderRowSize();
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    var rowHeights = this.table.getFirstColumnRowSize();
    var groupedHeight = [];
    BI.each(this.items, function (i, rows) {
      if (rows[0].layer > 0) {
        groupedHeight[groupedHeight.length - 1] += rowHeights[i];
      } else {
        groupedHeight.push(rowHeights[i]);
      }
    });
    return groupedHeight;
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.regionColumnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  attr: function attr(key, value) {
    BI.LayerTreeTable.superclass.attr.apply(this, arguments);

    switch (key) {
      case "columnSize":
      case "minColumnSize":
      case "maxColumnSize":
      case "freezeCols":
      case "mergeCols":
        return;
    }

    return this.table.attr.apply(this.table, [key, value]);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items, header, crossItems, crossHeader) {
    var o = this.options;
    o.items = items || [];

    if (header) {
      o.header = header;
    }

    if (crossItems) {
      o.crossItems = crossItems;
    }

    if (crossHeader) {
      o.crossHeader = crossHeader;
    }

    var data = this._digest();

    this.table.setColumnSize(data.columnSize);
    this.table.attr("freezeCols", data.freezeCols);
    this.table.attr("minColumnSize", data.minColumnSize);
    this.table.attr("maxColumnSize", data.maxColumnSize);
    this.table.populate(data.items, data.header);
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.LayerTreeTable.superclass.destroy.apply(this, arguments);
  }
});
BI.shortcut("bi.layer_tree_table", BI.LayerTreeTable);

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 *
 * Created by GUY on 2016/5/26.
 * @class BI.TableStyleCell
 * @extends BI.Single
 */
BI.TableStyleCell = BI.inherit(BI.Single, {
  props: {
    baseCls: "bi-table-style-cell",
    styleGetter: BI.emptyFn
  },
  mounted: function mounted() {
    var _style$fontSize, _style$fontSize2;

    var style = BI.extend({}, this.options.styleGetter());
    style.fontSize && this.text.element.css(_defineProperty({
      fontSize: "".concat((_style$fontSize = style.fontSize) !== null && _style$fontSize !== void 0 ? _style$fontSize : 12, "px")
    }, "fontSize", "calc(var(--css-scale, 1) * ".concat((_style$fontSize2 = style.fontSize) !== null && _style$fontSize2 !== void 0 ? _style$fontSize2 : 12, "px)")));
  },
  render: function render() {
    var o = this.options,
        self = this;
    var style = BI.extend({}, o.styleGetter(), {
      height: o.height - 1
    });
    return {
      type: "bi.adaptive",
      items: [{
        el: {
          type: "bi.label",
          textAlign: style.textAlign || "left",
          css: style,
          hgap: 5,
          text: o.text,
          title: o.text,
          belowMouse: true,
          ref: function ref(_ref) {
            self.text = _ref;
          }
        }
      }]
    };
  },
  _digestStyle: function _digestStyle() {
    var o = this.options;
    var style = o.styleGetter();

    if (style) {
      this.text.element.css(style);
    }
  },
  setText: function setText(text) {
    this.text.setText(text);
  },
  setHeight: function setHeight(height) {
    BI.TableStyleCell.superclass.setHeight.call(this, height);
    this.text.setHeight(height - 1);
  },
  populate: function populate() {
    this._digestStyle();
  }
});
BI.shortcut("bi.table_style_cell", BI.TableStyleCell);

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 树状结构的表格
 *
 * Created by GUY on 2015/9/22.
 * @class BI.TableTree
 * @extends BI.Widget
 */
BI.TableTree = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.TableTree.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-table-tree",
      el: {
        type: "bi.resizable_table"
      },
      isNeedResize: true,
      // 是否需要调整列宽
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      isNeedMergeCol: true,
      // 是否横向合并
      isNeedMergeRow: true,
      // 是否纵向合并
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      header: [],
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right",
      showInnerSummary: false
    });
  },
  _getVDeep: function _getVDeep() {
    return this.options.crossHeader.length; // 纵向深度
  },
  _getHDeep: function _getHDeep() {
    var o = this.options;
    return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
  },
  _init: function _init() {
    BI.TableTree.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;

    var data = this._digest();

    this.table = BI.createWidget(o.el, {
      type: "bi.resizable_table",
      element: this,
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: o.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: o.mergeRule,
      columnSize: o.columnSize,
      minColumnSize: o.minColumnSize,
      maxColumnSize: o.maxColumnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: o.regionColumnSize,
      header: data.header,
      items: data.items
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
  },
  _digest: function _digest() {
    var self = this,
        o = this.options;

    var deep = this._getHDeep();

    var vDeep = this._getVDeep();

    var header = BI.TableTree.formatHeader(o.header, o.crossHeader, o.crossItems, deep, vDeep, o.headerCellStyleGetter, {
      sumPosition: o.colPosition === "right",
      summaryText: o.summaryText
    });
    var items = BI.TableTree.formatItems(o.items, deep, false, o.summaryCellStyleGetter, {
      sumPosition: o.rowPosition === "bottom",
      summaryText: o.summaryText,
      isNeedMergeRow: o.isNeedMergeRow
    });
    return {
      header: header,
      items: items
    };
  },
  setWidth: function setWidth(width) {
    BI.TableTree.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.TableTree.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this.table.setColumnSize(columnSize);
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  getFirstColumnHeaderRowSize: function getFirstColumnHeaderRowSize() {
    return this.table.getFirstColumnHeaderRowSize();
  },
  getFirstColumnRowSize: function getFirstColumnRowSize() {
    return this.table.getFirstColumnRowSize();
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.regionColumnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  attr: function attr() {
    BI.TableTree.superclass.attr.apply(this, arguments);
    return this.table.attr.apply(this.table, arguments);
  },
  restore: function restore() {
    this.table.restore();
  },
  populate: function populate(items, header, crossItems, crossHeader) {
    var o = this.options;

    if (items) {
      o.items = items || [];
    }

    if (header) {
      o.header = header;
    }

    if (crossItems) {
      o.crossItems = crossItems;
    }

    if (crossHeader) {
      o.crossHeader = crossHeader;
    }

    var data = this._digest();

    this.table.populate(data.items, data.header);
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.TableTree.superclass.destroy.apply(this, arguments);
  }
});
BI.extend(BI.TableTree, {
  formatHeader: function formatHeader(header, crossHeader, crossItems, hDeep, vDeep, styleGetter, options) {
    var items = BI.isEmpty(header) ? BI.TableTree.formatCrossItems4Special(crossItems, vDeep, styleGetter, options) : BI.TableTree.formatCrossItems(crossItems, vDeep, styleGetter, options);
    var result = [];

    for (var i = 0; i < vDeep; i++) {
      var c = [];

      for (var j = 0; j < hDeep; j++) {
        c.push(crossHeader[i]);
      }

      result.push(c.concat(items[i] || []));
    }

    if (header && header.length > 0) {
      result.push(header);
    }

    return result;
  },
  formatItems: function formatItems(nodes, deep, isCross, _styleGetter, options) {
    options = options || {};

    var self = this,
        result = [],
        sumPosition = options.sumPosition,
        summaryText = options.summaryText || BI.i18nText("BI-Summary_Values"),
        summaryCellCreator = options.summaryCellCreator || function (v) {
      return v;
    };

    function track(store, node) {
      var next;

      if (BI.isArray(node.children)) {
        var totalLength = 0;
        BI.each(node.children, function (index, child) {
          var next;

          if (store != -1) {
            next = store.slice();
            next.push(node);
          } else {
            next = [];
          }

          totalLength += track(next, child);
        });

        if (store != -1) {
          next = store.slice();
          next.push(node);
        } else {
          next = [];
        }

        if (
        /** (store == -1 || node.children.length > 1) &&**/
        BI.isNotEmptyArray(node.values)) {
          var summary = summaryCellCreator({
            text: summaryText,
            title: summaryText,
            type: "bi.table_style_cell",
            styleGetter: function styleGetter() {
              return _styleGetter(store === -1);
            },
            _store: options.tableStyleCellStoreGetter
          }, node, store === -1);

          for (var i = next.length; i < deep; i++) {
            next.push(summary);
          }

          if (!isCross) {
            next = next.concat(node.values);
          }

          if (next.length > 0) {
            if (!isCross) {
              sumPosition ? result.push(next) : result.splice(result.length - totalLength, 0, next);
            } else {
              for (var k = 0, l = node.values.length; k < l; k++) {
                sumPosition ? result.push(next) : result.splice(result.length - totalLength, 0, next);
              }
            }
          }

          return totalLength + 1;
        }

        return totalLength;
      }

      if (store != -1) {
        next = store.slice();

        for (var i = next.length; i < deep; i++) {
          next.push(node);
        }
      } else {
        next = [];
      }

      if (!isCross && BI.isArray(node.values)) {
        next = next.concat(node.values);
      }

      if (isCross && BI.isArray(node.values)) {
        for (var i = 0, len = node.values.length; i < len - 1; i++) {
          if (next.length > 0) {
            result.push(next);
          }
        }
      }

      if (next.length > 0) {
        result.push(next);
      }

      return node.values ? 1 : 0;
    }

    BI.each(nodes, function (i, node) {
      track(-1, node);
    }); // 填充空位

    BI.each(result, function (i, line) {
      var last = BI.last(line);

      for (var j = line.length; j < deep; j++) {
        line.push(last);
      }
    });
    return result;
  },
  formatItems4Special: function formatItems4Special(nodes, deep, isCross, _styleGetter2, options) {
    options = options || {};
    var self = this,
        result = [],
        sumPosition = options.sumPosition,
        summaryText = options.summaryText || BI.i18nText("BI-Summary_Values");

    function track(store, node) {
      var next;

      if (BI.isArray(node.children)) {
        var totalLength = 0;
        BI.each(node.children, function (index, child) {
          var next;

          if (store != -1) {
            next = store.slice();
            next.push(node);
          } else {
            next = [];
          }

          totalLength += track(next, child);
        });

        if (store != -1) {
          next = store.slice();
          next.push(node);
        } else {
          next = [];
        }

        if (
        /** (store == -1 || node.children.length > 1) &&**/
        BI.isNotEmptyArray(node.values)) {
          var summary = {
            text: summaryText,
            title: summaryText,
            type: "bi.table_style_cell",
            styleGetter: function styleGetter() {
              return _styleGetter2(store === -1);
            },
            _store: options.tableStyleCellStoreGetter
          };

          for (var i = next.length; i < deep; i++) {
            next.push(summary);
          }

          if (next.length > 0) {
            if (!isCross) {
              sumPosition ? result.push(next) : result.splice(result.length - totalLength, 0, next);
            } else {
              for (var k = 0, l = node.values.length; k < l; k++) {
                sumPosition ? result.push(next) : result.splice(result.length - totalLength, 0, next);
              }
            }
          }

          return totalLength + node.values.length;
        }

        return totalLength;
      }

      if (store != -1) {
        next = store.slice();

        for (var i = next.length; i < deep; i++) {
          next.push(node);
        }
      } else {
        next = [];
      }

      if (next.length > 0) {
        result.push(next);
      }

      return node.values ? node.values.length : 0;
    }

    BI.each(nodes, function (i, node) {
      track(-1, node);
    }); // 填充空位

    BI.each(result, function (i, line) {
      var last = BI.last(line);

      for (var j = line.length; j < deep; j++) {
        line.push(last);
      }
    });
    return result;
  },
  formatCrossItems: function formatCrossItems(nodes, deep, styleGetter, options) {
    var items = BI.TableTree.formatItems(nodes, deep, true, styleGetter, options);
    return BI.unzip(items);
  },
  // 没有行维度时候格式化header，避免出现多个汇总
  formatCrossItems4Special: function formatCrossItems4Special(nodes, deep, styleGetter, options) {
    var items = BI.TableTree.formatItems4Special(nodes, deep, false, styleGetter, options);
    return BI.unzip(items);
  },
  maxDeep: function maxDeep(nodes) {
    function track(deep, node) {
      var d = deep;

      if (BI.isNotEmptyArray(node.children)) {
        BI.each(node.children, function (index, child) {
          d = Math.max(d, track(deep + 1, child));
        });
      }

      return d;
    }

    var deep = 1;

    if (BI.isObject(nodes)) {
      BI.each(nodes, function (i, node) {
        deep = Math.max(deep, track(1, node));
      });
    }

    return deep;
  }
});
BI.shortcut("bi.tree_table", BI.TableTree);

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @Author: Young
 * @CreationDate 2018-01-10 9:50

 */
!function () {
  var MIN_SIZE = 60;
  var TIP_HEIGHT = 30;
  BI.StyleTable = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-components-preview-table",
      $testId: "bi-components-preview-table",
      userSelectable: true,
      isNeedFreeze: true,
      showSequence: false,
      seqWidth: 60,
      sequenceCellStyleGetter: BI.emptyFn,
      headerCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      showPartData: false,
      columnSortable: false,
      columnSelectable: false,
      tipPosition: "bottom",
      zebraVeins: true,
      freezeCols: [],
      columnSize: [],
      columnGaps: [],
      headerRowSize: 30,
      rowSize: 30,
      header: [],
      items: [],
      watermark: {},
      needFormat: true,
      fontSize: 12,
      minSize: 60,
      regionColumnSize: [],
      isHeaderAutoHeight: false,
      isAutoHeight: false
    },
    mounted: function mounted() {
      var self = this;
      this._resizeHandler = BI.debounce(function () {
        var width = self._getTableWidth(),
            height = self._getTableHeight();

        if (self.table.getWidth() !== width || self.table.getHeight() !== height) {
          self.table.setWidth(width);
          self.table.setHeight(height);
          self.table.populate();
        }
      }, 30);
      this.removeListener = BI.ResizeDetector.addResizeListener(this.wrapper, function () {
        self._resizeHandler();
      });

      this._populate();
    },
    render: function render() {
      var self = this,
          o = this.options;
      var watermark = o.watermark;
      return {
        type: "bi.absolute",
        items: [{
          el: {
            type: "bi.vtape",
            cls: o.userSelectable ? "user-selectable" : "",
            items: this._createTable()
          },
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }, {
          el: {
            type: "bi.watermark",
            invisible: !watermark.valid,
            watermark: watermark
          },
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }],
        ref: function ref(_ref) {
          self.wrapper = _ref;
        }
      };
    },
    _createTable: function _createTable() {
      var o = this.options,
          self = this;
      var tip = {
        el: {
          type: "bi.label",
          cls: "bi-tips",
          text: BI.i18nText("BI-Conf_Current_Preview_Part_Data"),
          textAlign: "right"
        },
        height: o.showPartData ? TIP_HEIGHT : 0
      };
      var table = {
        type: "bi.page_table",
        rowSize: o.rowSize,
        headerRowSize: o.headerRowSize,
        isNeedFreeze: o.isNeedFreeze,
        freezeCols: o.freezeCols,
        showSequence: o.showSequence,
        seqWidth: o.seqWidth,
        sequenceCellStyleGetter: o.sequenceCellStyleGetter,
        headerCellStyleGetter: o.headerCellStyleGetter,
        tableStyleCellStoreGetter: o.tableStyleCellStoreGetter,
        ref: function ref(_ref) {
          self.table = _ref;
        },
        el: {
          type: "bi.sequence_table",
          el: {
            type: "bi.adaptive_table",
            el: o.columnSelectable || o.columnSortable ? {
              type: "bi.sortable_table",
              sortable: o.columnSortable,
              ref: function ref(_ref2) {
                self.sortableTable = _ref2;
              },
              el: {
                type: "bi.resizable_table",
                el: this._getGridConfig()
              },
              listeners: [{
                eventName: 'EVENT_TABLE_SELECT_COLUMN',
                action: function action(j) {
                  self.fireEvent('EVENT_TABLE_SELECT_COLUMN', j);
                }
              }, {
                eventName: 'EVENT_TABLE_SORT',
                action: function action() {
                  self.fireEvent('EVENT_TABLE_SORT', arguments);
                }
              }]
            } : {
              type: "bi.resizable_table",
              el: this._getGridConfig()
            },
            listeners: [{
              eventName: 'EVENT_TABLE_AFTER_COLUMN_RESIZE',
              action: function action() {
                self.fireEvent('EVENT_TABLE_AFTER_COLUMN_RESIZE');
              }
            }]
          }
        }
      };

      switch (o.tipPosition) {
        case "top":
          return [tip, table];

        case "bottom":
        default:
          return [table, tip];
      }
    },
    _getGridConfig: function _getGridConfig() {
      var o = this.options;
      return {
        type: 'bi.grid_auto_height_table',
        columnGaps: o.columnGaps,
        isAutoHeight: o.isAutoHeight,
        isHeaderAutoHeight: o.isHeaderAutoHeight,
        fontSize: o.fontSize,
        fontLineHeight: o.fontSize * 1.4,
        headerFontSize: o.fontSize,
        headerFontLineHeight: o.fontSize * 1.4
      };
    },
    _getTableWidth: function _getTableWidth() {
      if (this.options.width) {
        return this.options.width;
      }

      return this.element.width();
    },
    _getTableHeight: function _getTableHeight() {
      var height = this.element.height();
      return this.options.showPartData ? height - TIP_HEIGHT : height;
    },
    _populate: function _populate() {
      this.populate(this.options.items, this.options.header);
    },
    // a、一列中最大宽度；b、所有宽度的均值*2；c、80
    _calculateColumnSize: function _calculateColumnSize() {
      if (this.options.columnSize && this.options.columnSize.length > 0) {
        return this.options.columnSize;
      }

      var fontSize = this.options.fontSize;
      var minSize = this.options.minSize;
      /**
       * 获取某个单元的模拟宽度
       * @param {object} cell 单元
       */

      function getSimulationWidth(cell) {
        if (BI.isNumber(cell.width)) {
          return cell.width;
        }

        if (BI.isNotEmptyString(cell.text)) {
          return BI.Func.getGBWidth(cell.text) * fontSize * 1.2;
        }

        return 0;
      }
      /**
       * 用于统计各列宽度
       * @param {array} items 单元格
       * @param {array} columnSizes 单元格宽度存储
       */


      function getColumnSizes(items, columnSizes) {
        BI.each(items, function (i, row) {
          BI.each(row, function (j, cell) {
            var width = 0; // 针对于表格中的元素是布局组件

            if (BI.isNotEmptyArray(cell.items)) {
              BI.each(cell.items, function (idx, item) {
                width += getSimulationWidth(item);
              });
            } else {
              width += getSimulationWidth(cell);
            }

            columnSizes[j] = columnSizes[j] || [];
            columnSizes[j].push(width);
          });
        });
      }

      var sizes = [];
      getColumnSizes(this.options.header, sizes);
      getColumnSizes(this.options.items, sizes);
      /**
       * 规则:
       * 默认显示列宽最大值 = 当前字段名和字段值宽度均值*2
       * 默认显示列宽最小值 = 80PX
       * 如果计算出的最大值小于最小值时，显示最小值(交互后加的)
       */

      var columnSize = BI.map(sizes, function (i, column) {
        // 根据要求过滤掉为空，不参与计算平均宽度的过程，否则导致计算方差太大
        var avgSize = Math.ceil(BI.average(BI.filter(column, function (index, value) {
          return value >= 0;
        })));
        var maxSize = avgSize * 2;
        var adaptSize = Math.ceil(BI.max(column));

        if (maxSize < minSize) {
          return minSize;
        }

        return adaptSize < minSize ? minSize : adaptSize > maxSize ? maxSize : adaptSize;
      });
      /**
       * 列宽实际显示的宽度是在原规则基础上加上图标的宽度(交互后加的)
       */

      BI.each(this.options.header, function (i, row) {
        BI.each(row, function (j, cell) {
          columnSize[j] += BI.isNumber(cell.iconWidth) ? cell.iconWidth : 0;
          columnSize[j] += BI.isNumber(cell.lgap) ? cell.lgap : 0;
          columnSize[j] += BI.isNumber(cell.rgap) ? cell.rgap : 0;
          columnSize[j] += BI.isNumber(cell.hgap) ? cell.hgap * 2 : 0;
        });
      });
      /**
       * 当默认字段宽度总和小于组件宽度时，多余宽度按照各字段默认宽度的比例进行再分配
       */

      var tableWidth = this._getTableWidth() - 10;
      var totalColumnSize = columnSize.reduce(function (a, b) {
        return a + b;
      }, 0);

      if (totalColumnSize >= tableWidth) {
        return columnSize;
      }

      var surplus = tableWidth - totalColumnSize;
      return BI.map(columnSize, function (index, column) {
        if (index === columnSize.length - 1) {
          return column + surplus;
        }

        surplus -= Math.ceil((tableWidth - totalColumnSize) / columnSize.length);
        return column + Math.ceil((tableWidth - totalColumnSize) / columnSize.length);
      });
    },
    _formatItems: function _formatItems() {
      var self = this;
      var items = BI.deepClone(this.options.items);
      var zebraVeins = this.options.zebraVeins;
      BI.each(items, function (i, row) {
        BI.each(row, function (j, item) {
          if (BI.isNotNull(self.options.header[0]) && BI.isNotNull(self.options.header[0][j]) && self.options.header[0][j].iconCls === "number-field-font" && self.options.needFormat) {
            item.text = BI.Format.numberFormat(item.text);
          } // BI-65648 单元格定高的预览表格回车显示成转义\n


          item.text = BI.replaceAll(item.text || "", "\n", "\\n");
          var zebraVeinsCls = i % 2 !== 0 ? "even-row" : "odd-row";
          item.cls = (item.cls || "") + " body-row " + (zebraVeins ? zebraVeinsCls : "");
        });
      });
      return items;
    },
    _formatHeader: function _formatHeader() {
      var header = BI.deepClone(this.options.header);
      BI.each(header, function (i, row) {
        BI.each(row, function (j, item) {
          item.cls = (item.cls || "") + " header-row ";
        });
      });
      return header;
    },
    populate: function populate(items, header, opt) {
      this.options.items = items;
      this.options.header = header;

      var columnSize = this._calculateColumnSize();

      this.table.attr("columnSize", columnSize); // freezeScroll===true 不重置滚动条位置（默认重置）

      opt = opt || {};

      if (BI.isNull(opt.freezeScroll) || opt.freezeScroll === false) {
        this.table.attr('scrollTop', 0);
        this.table.attr('scrollLeft', BI.sum(columnSize.slice(0, opt.scrollLeftIndex || 0)));
      }

      this.table.restore();
      this.table.setWidth(this._getTableWidth());
      this.table.setHeight(this._getTableHeight());
      this.table.attr("regionColumnSize", this.options.regionColumnSize);
      this.table.attr("minColumnSize", columnSize);
      this.table.attr("isNeedFreeze", true);
      this.table.attr("freezeCols", this.options.freezeCols);
      this.table.attr("showSequence", this.options.showSequence);
      this.table.populate(this._formatItems(), this._formatHeader());
    },
    setHorizontalScroll: function setHorizontalScroll(v) {
      this.table.setRightHorizontalScroll(v);
    },
    setVerticalScroll: function setVerticalScroll(v) {
      this.table.setVerticalScroll(v);
    },
    selectColumns: function selectColumns(cols) {
      this.sortableTable && this.sortableTable.selectColumns(cols);
    },
    setSortable: function setSortable(sortable) {
      this.sortableTable && this.sortableTable.setSortable(sortable);
    },
    getSelectedColumns: function getSelectedColumns() {
      return this.sortableTable && this.sortableTable.getSelectedColumns();
    },
    destroyed: function destroyed() {
      this.removeListener && this.removeListener();
    },
    getColumnSize: function getColumnSize() {
      return this.table.getColumnSize();
    }
  });
  BI.shortcut("bi.components.style_table", BI.StyleTable);
}();

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  var clamp = function clamp(min, value, max) {
    if (value < min) {
      return min;
    }

    if (value > max) {
      return max;
    }

    return value;
  };

  var BUFFER_ROWS = 5;
  var NO_ROWS_SCROLL_RESULT = {
    index: 0,
    offset: 0,
    position: 0,
    contentHeight: 0
  };

  BI.TableScrollHelper = function (rowCount, defaultRowHeight, viewportHeight, rowHeightGetter) {
    this._rowOffsets = BI.PrefixIntervalTree.uniform(rowCount, defaultRowHeight);
    this._storedHeights = new Array(rowCount);

    for (var i = 0; i < rowCount; ++i) {
      this._storedHeights[i] = defaultRowHeight;
    }

    this._rowCount = rowCount;
    this._position = 0;
    this._contentHeight = rowCount * defaultRowHeight;
    this._defaultRowHeight = defaultRowHeight;
    this._rowHeightGetter = rowHeightGetter ? rowHeightGetter : function () {
      return defaultRowHeight;
    };
    this._viewportHeight = viewportHeight;

    this._updateHeightsInViewport(0, 0);
  };

  BI.TableScrollHelper.prototype = {
    constructor: BI.TableScrollHelper,
    setRowHeightGetter: function setRowHeightGetter(rowHeightGetter) {
      this._rowHeightGetter = rowHeightGetter;
    },
    setViewportHeight: function setViewportHeight(viewportHeight) {
      this._viewportHeight = viewportHeight;
    },
    getContentHeight: function getContentHeight() {
      return this._contentHeight;
    },
    _updateHeightsInViewport: function _updateHeightsInViewport(firstRowIndex, firstRowOffset) {
      var top = firstRowOffset;
      var index = firstRowIndex;

      while (top <= this._viewportHeight && index < this._rowCount) {
        this._updateRowHeight(index);

        top += this._storedHeights[index];
        index++;
      }
    },
    _updateHeightsAboveViewport: function _updateHeightsAboveViewport(firstRowIndex) {
      var index = firstRowIndex - 1;

      while (index >= 0 && index >= firstRowIndex - BUFFER_ROWS) {
        var delta = this._updateRowHeight(index);

        this._position += delta;
        index--;
      }
    },
    _updateRowHeight: function _updateRowHeight(rowIndex) {
      if (rowIndex < 0 || rowIndex >= this._rowCount) {
        return 0;
      }

      var newHeight = this._rowHeightGetter(rowIndex);

      if (newHeight !== this._storedHeights[rowIndex]) {
        var change = newHeight - this._storedHeights[rowIndex];

        this._rowOffsets.set(rowIndex, newHeight);

        this._storedHeights[rowIndex] = newHeight;
        this._contentHeight += change;
        return change;
      }

      return 0;
    },
    getRowPosition: function getRowPosition(rowIndex) {
      this._updateRowHeight(rowIndex);

      return this._rowOffsets.sumUntil(rowIndex);
    },
    scrollBy: function scrollBy(delta) {
      if (this._rowCount === 0) {
        return NO_ROWS_SCROLL_RESULT;
      }

      var firstRow = this._rowOffsets.greatestLowerBound(this._position);

      firstRow = clamp(firstRow, 0, Math.max(this._rowCount - 1, 0));

      var firstRowPosition = this._rowOffsets.sumUntil(firstRow);

      var rowIndex = firstRow;
      var position = this._position;

      var rowHeightChange = this._updateRowHeight(rowIndex);

      if (firstRowPosition !== 0) {
        position += rowHeightChange;
      }

      var visibleRowHeight = this._storedHeights[rowIndex] - (position - firstRowPosition);

      if (delta >= 0) {
        while (delta > 0 && rowIndex < this._rowCount) {
          if (delta < visibleRowHeight) {
            position += delta;
            delta = 0;
          } else {
            delta -= visibleRowHeight;
            position += visibleRowHeight;
            rowIndex++;
          }

          if (rowIndex < this._rowCount) {
            this._updateRowHeight(rowIndex);

            visibleRowHeight = this._storedHeights[rowIndex];
          }
        }
      } else if (delta < 0) {
        delta = -delta;
        var invisibleRowHeight = this._storedHeights[rowIndex] - visibleRowHeight;

        while (delta > 0 && rowIndex >= 0) {
          if (delta < invisibleRowHeight) {
            position -= delta;
            delta = 0;
          } else {
            position -= invisibleRowHeight;
            delta -= invisibleRowHeight;
            rowIndex--;
          }

          if (rowIndex >= 0) {
            var change = this._updateRowHeight(rowIndex);

            invisibleRowHeight = this._storedHeights[rowIndex];
            position += change;
          }
        }
      }

      var maxPosition = this._contentHeight - this._viewportHeight;
      position = clamp(position, 0, maxPosition);
      this._position = position;

      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);

      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));
      firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);
      var firstRowOffset = firstRowPosition - position;

      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);

      this._updateHeightsAboveViewport(firstRowIndex);

      return {
        index: firstRowIndex,
        offset: firstRowOffset,
        position: this._position,
        contentHeight: this._contentHeight
      };
    },
    _getRowAtEndPosition: function _getRowAtEndPosition(rowIndex) {
      // We need to update enough rows above the selected one to be sure that when
      // we scroll to selected position all rows between first shown and selected
      // one have most recent heights computed and will not resize
      this._updateRowHeight(rowIndex);

      var currentRowIndex = rowIndex;
      var top = this._storedHeights[currentRowIndex];

      while (top < this._viewportHeight && currentRowIndex >= 0) {
        currentRowIndex--;

        if (currentRowIndex >= 0) {
          this._updateRowHeight(currentRowIndex);

          top += this._storedHeights[currentRowIndex];
        }
      }

      var position = this._rowOffsets.sumTo(rowIndex) - this._viewportHeight;

      if (position < 0) {
        position = 0;
      }

      return position;
    },
    scrollTo: function scrollTo(position) {
      if (this._rowCount === 0) {
        return NO_ROWS_SCROLL_RESULT;
      }

      if (position <= 0) {
        // If position less than or equal to 0 first row should be fully visible
        // on top
        this._position = 0;

        this._updateHeightsInViewport(0, 0);

        return {
          index: 0,
          offset: 0,
          position: this._position,
          contentHeight: this._contentHeight
        };
      } else if (position >= this._contentHeight - this._viewportHeight) {
        // If position is equal to or greater than max scroll value, we need
        // to make sure to have bottom border of last row visible.
        var rowIndex = this._rowCount - 1;
        position = this._getRowAtEndPosition(rowIndex);
      }

      this._position = position;

      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);

      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));

      var firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);

      var firstRowOffset = firstRowPosition - position;

      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);

      this._updateHeightsAboveViewport(firstRowIndex);

      return {
        index: firstRowIndex,
        offset: firstRowOffset,
        position: this._position,
        contentHeight: this._contentHeight
      };
    },

    /**
     * Allows to scroll to selected row with specified offset. It always
     * brings that row to top of viewport with that offset
     */
    scrollToRow: function scrollToRow(rowIndex, offset) {
      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));
      offset = clamp(offset, -this._storedHeights[rowIndex], 0);

      var firstRow = this._rowOffsets.sumUntil(rowIndex);

      return this.scrollTo(firstRow - offset);
    },

    /**
     * Allows to scroll to selected row by bringing it to viewport with minimal
     * scrolling. This that if row is fully visible, scroll will not be changed.
     * If top border of row is above top of viewport it will be scrolled to be
     * fully visible on the top of viewport. If the bottom border of row is
     * below end of viewport, it will be scrolled up to be fully visible on the
     * bottom of viewport.
     */
    scrollRowIntoView: function scrollRowIntoView(rowIndex) {
      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));

      var rowBegin = this._rowOffsets.sumUntil(rowIndex);

      var rowEnd = rowBegin + this._storedHeights[rowIndex];

      if (rowBegin < this._position) {
        return this.scrollTo(rowBegin);
      } else if (this._position + this._viewportHeight < rowEnd) {
        var position = this._getRowAtEndPosition(rowIndex);

        return this.scrollTo(position);
      }

      return this.scrollTo(this._position);
    }
  };
})();

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2016/5/26.
 * @class BI.SequenceTableTreeNumber
 * @extends BI.Widget
 */
BI.SequenceTableTreeNumber = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.SequenceTableTreeNumber.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-sequence-table-tree-number",
      isNeedFreeze: false,
      startSequence: 1,
      // 开始的序号
      scrollTop: 0,
      headerRowSize: 25,
      rowSize: 25,
      rowSizeGetter: BI.emptyFn,
      headerRowSizeGetter: BI.emptyFn,
      sequenceHeaderCreator: BI.emptyFn,
      sequenceSummaryText: BI.i18nText("BI-Summary_Values"),
      header: [],
      items: [],
      // 二维数组
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      width: 60
    });
  },
  _init: function _init() {
    BI.SequenceTableTreeNumber.superclass._init.apply(this, arguments);

    var o = this.options;
    this.vCurr = 1;
    this.hCurr = 1;
    this.tasks = [];
    this.gridView = BI.createWidget({
      type: "bi.grid_view",
      overflowX: false,
      overflowY: false,
      scrollTop: o.scrollTop,
      columnCount: 1,
      estimatedColumnSize: o.width,
      width: o.width,
      rowHeightGetter: this._rowHeightGetter.bind(this),
      columnWidthGetter: function columnWidthGetter() {
        return o.width;
      }
    });
    this.headerContainer = BI.createWidget({
      type: "bi.absolute",
      cls: "sequence-table-header-cell bi-border-top bi-border-left bi-border-bottom bi-border-right",
      width: o.width,
      scrollable: false
    });
    this.layout = BI.createWidget({
      type: "bi.vtape",
      element: this,
      items: [{
        el: this.headerContainer,
        height: 2
      }, {
        el: this.gridView,
        height: "fill"
      }]
    }); // 缓存第一行对应的序号

    this.start = this.options.startSequence;
    this.cache = {};

    this._nextState();

    this.populate();
  },
  _rowHeightGetter: function _rowHeightGetter(i) {
    var o = this.options;

    var headerHeight = this._getHeaderHeight();

    if (headerHeight >= o.height) {
      if (i === 0) {
        return headerHeight;
      } else {
        if (this.rowHeights) {
          var rowHeight = this.rowHeights[i - 1];
          return BI.isNotNull(rowHeight) ? rowHeight : this.options.rowSize;
        }

        return this.options.rowSize;
      }
    }

    if (this.rowHeights) {
      var rowHeight = this.rowHeights[i];
      return BI.isNotNull(rowHeight) ? rowHeight : this.options.rowSize;
    }

    return this.options.rowSize;
  },
  _getNextSequence: function _getNextSequence(nodes) {
    var self = this;
    var start = this.start;
    var cnt = this.start;

    function track(node) {
      // 如果已经有缓存了就不改计数了，复杂表会出现这种情况
      var key = self._getCacheKey(node);

      self.cache[key] || (self.cache[key] = cnt);
      cnt++;
    }

    BI.each(nodes, function (i, node) {
      if (BI.isNotEmptyArray(node.children)) {
        BI.each(node.children, function (index, child) {
          if (index === 0) {
            var key = self._getCacheKey(child);

            if (self.cache[key]) {
              start = cnt = self.cache[key];
            }
          }

          track(child);
        });
      }
    });
    this.start = cnt;
    return start;
  },
  _getStart: function _getStart(nodes) {
    var self = this;
    var start = this.start;
    BI.some(nodes, function (i, node) {
      if (BI.isNotEmptyArray(node.children)) {
        return BI.some(node.children, function (index, child) {
          if (index === 0) {
            var key = self._getCacheKey(child);

            if (self.cache[key]) {
              start = self.cache[key];
              return true;
            }
          }
        });
      }
    });
    return start;
  },
  _formatNumber: function _formatNumber(nodes) {
    var o = this.options;
    var result = [];

    var count = this._getStart(nodes);

    function getLeafCount(node) {
      var cnt = 0;

      if (BI.isNotEmptyArray(node.children)) {
        BI.each(node.children, function (index, child) {
          cnt += getLeafCount(child);
        });
        cnt++;
      } else {
        cnt++;
      }

      return cnt;
    }

    var start = 0;
    var top = 0;
    BI.each(nodes, function (i, node) {
      if (BI.isArray(node.children)) {
        if (BI.isNotEmptyArray(node.values) && o.rowPosition === BICst.DESIGN.TABLE_ROW_SUM_POSITION.TOP) {
          result.push({
            text: o.sequenceSummaryText,
            start: start++,
            top: top,
            cnt: 1,
            isSummary: true,
            height: o.rowSize
          });
          top += o.rowSize;
        }

        BI.each(node.children, function (index, child) {
          var cnt = getLeafCount(child);
          result.push({
            text: count++,
            start: start,
            top: top,
            cnt: cnt,
            index: index,
            height: cnt * o.rowSize
          });
          start += cnt;
          top += cnt * o.rowSize;
        });

        if (BI.isNotEmptyArray(node.values) && o.rowPosition !== BICst.DESIGN.TABLE_ROW_SUM_POSITION.TOP) {
          result.push({
            text: o.sequenceSummaryText,
            start: start++,
            top: top,
            cnt: 1,
            isSummary: true,
            height: o.rowSize
          });
          top += o.rowSize;
        }
      }
    });
    var rowSize = this.rowHeights = o.rowSizeGetter();
    result = BI.map(result, function (key, item) {
      return [BI.extend({
        type: "bi.table_style_cell",
        cls: "sequence-table-number-cell bi-border-left bi-border-bottom bi-border-right",
        width: o.width,
        styleGetter: item.isSummary === true ? function () {
          return o.summaryCellStyleGetter(true);
        } : function (key) {
          return function () {
            return o.sequenceCellStyleGetter(key);
          };
        }(item.index),
        _store: o.tableStyleCellStoreGetter
      }, item, {
        height: rowSize[key] || item.height
      })];
    });
    return result;
  },
  _layout: function _layout() {
    var o = this.options;
    this.headerContainer.empty();

    var headerHeight = this._getHeaderHeight();

    var items = this.layout.attr("items");

    if (headerHeight >= o.height) {
      items[0].height = 0;
    } else {
      BI.createWidget({
        type: "bi.absolute",
        element: this.headerContainer,
        items: [{
          el: BI.extend({
            type: "bi.table_style_cell",
            height: headerHeight - 2,
            cls: "sequence-table-title-cell",
            styleGetter: o.headerCellStyleGetter,
            text: BI.i18nText("BI-Number_Index"),
            _store: o.tableStyleCellStoreGetter
          }, o.sequenceHeaderCreator()),
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }]
      });
      items[0].height = headerHeight;
    }

    this.layout.attr("items", items);
    this.layout.resize();
    this.numbers = this._formatNumber(o.items);

    if (headerHeight >= o.height) {
      this.numbers.unshift([BI.extend({
        type: "bi.table_style_cell",
        height: headerHeight - 2,
        cls: "sequence-table-title-cell",
        styleGetter: o.headerCellStyleGetter,
        text: BI.i18nText("BI-Number_Index"),
        _store: o.tableStyleCellStoreGetter
      }, o.sequenceHeaderCreator())]);
      var estimatedRowSize = BI.isArray(this.numbers) ? (BI.sum(this.rowHeights) + headerHeight) / (this.numbers.length + 1) : 0;
      this.gridView.setEstimatedRowSize(estimatedRowSize);
      this.gridView.setHeight(o.height);
      this.gridView.restore();
    } else {
      var estimatedRowSize = BI.isArray(this.numbers) && this.numbers.length > 0 ? BI.sum(this.rowHeights) / this.numbers.length : 0;
      this.gridView.setEstimatedRowSize(estimatedRowSize);
      this.gridView.setHeight(o.height - headerHeight);
      this.gridView.restore();
    }
  },
  _getHeaderHeight: function _getHeaderHeight() {
    var o = this.options;
    var headerHeights = o.headerRowSizeGetter();
    return BI.sum(headerHeights);
  },
  _nextState: function _nextState() {
    var o = this.options;

    this._getNextSequence(o.items);
  },
  _prevState: function _prevState() {
    var o = this.options;
    var firstChild;
    BI.some(o.items, function (i, node) {
      if (BI.isNotEmptyArray(node.children)) {
        return BI.some(node.children, function (j, child) {
          firstChild = child;
          return true;
        });
      }
    });

    if (firstChild && BI.isNotEmptyObject(this.cache)) {
      this.start = this.cache[this._getCacheKey(firstChild)];
    } else {
      this.start = 1;
    }

    this._nextState();
  },
  _calculateChildrenToRender: function _calculateChildrenToRender() {
    var o = this.options;

    this.gridView._populate(this.numbers);

    this.gridView.setScrollTop(o.scrollTop);
  },
  _getCacheKey: function _getCacheKey(node) {
    if (!this.nullKey) {
      this.nullKey = BI.UUID();
    }

    var text = BI.isNull(node.text) ? node.value : node.text;
    return BI.isNull(text) ? this.nullKey : text;
  },
  _restore: function _restore() {
    this.gridView.restore();
  },
  _populate: function _populate() {
    var self = this;
    BI.each(this.tasks, function (i, task) {
      task.apply(self);
    });
    this.tasks = [];

    this._layout();

    this._calculateChildrenToRender();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    var o = this.options;

    if (o.scrollTop !== scrollTop) {
      o.scrollTop = scrollTop;
      this.gridView.setScrollTop(o.scrollTop);
    }
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.options.scrollTop;
  },
  setVPage: function setVPage(v) {
    if (v <= 1) {
      this.cache = {};
      this.start = this.options.startSequence;

      this._restore();

      this.tasks.push(this._nextState);
    } else if (v === this.vCurr + 1) {
      this.tasks.push(this._nextState);
    } else if (v === this.vCurr - 1) {
      this.tasks.push(this._prevState);
    }

    this.vCurr = v;
  },
  setHPage: function setHPage(v) {
    if (v !== this.hCurr) {
      this.tasks.push(this._prevState);
    }

    this.hCurr = v;
  },
  setWidth: function setWidth(width) {
    BI.SequenceTableTreeNumber.superclass.setWidth.apply(this, arguments);
    this.gridView.setWidth(width);
    this.headerContainer.setWidth(width);
  },
  restore: function restore() {
    this._restore();
  },
  populate: function populate(items, header, crossItems, crossHeader) {
    var o = this.options;

    if (items && items !== this.options.items) {
      o.items = items;

      this._restore();

      this.tasks.push(this._prevState);
    }

    if (header && header !== this.options.header) {
      o.header = header;
    }

    if (crossItems && crossItems !== this.options.crossItems) {
      o.crossItems = crossItems;
    }

    if (crossHeader && crossHeader !== this.options.crossHeader) {
      o.crossHeader = crossHeader;
    }

    this._populate();
  }
});
BI.shortcut("bi.sequence_table_tree_number", BI.SequenceTableTreeNumber);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2016/8/10.
 * @class BI.SequenceTableDynamicNumber
 * @extends BI.SequenceTableTreeNumber
 */
BI.SequenceTableDynamicNumber = BI.inherit(BI.SequenceTableTreeNumber, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.SequenceTableDynamicNumber.superclass._defaultConfig.apply(this, arguments), {
      extraCls: 'bi-sequence-table-dynamic-number'
    });
  },
  _init: function _init() {
    BI.SequenceTableDynamicNumber.superclass._init.apply(this, arguments);
  },
  _formatNumber: function _formatNumber(nodes) {
    var o = this.options;
    var result = [];

    var count = this._getStart(nodes);

    function getLeafCount(node) {
      var cnt = 0;

      if (BI.isNotEmptyArray(node.children)) {
        BI.each(node.children, function (index, child) {
          cnt += getLeafCount(child);
        });

        if (BI.isNotEmptyArray(node.values)) {
          cnt++;
        }
      } else {
        cnt++;
      }

      return cnt;
    }

    var start = 0;
    var top = 0;
    BI.each(nodes, function (i, node) {
      if (BI.isArray(node.children)) {
        if (BI.isNotEmptyArray(node.values) && o.rowPosition === BICst.DESIGN.TABLE_ROW_SUM_POSITION.TOP) {
          result.push({
            text: o.sequenceSummaryText,
            title: o.sequenceSummaryText,
            start: start++,
            top: top,
            cnt: 1,
            isSummary: true,
            height: o.rowSize
          });
          top += o.rowSize;
        }

        BI.each(node.children, function (index, child) {
          var cnt = getLeafCount(child);
          var text = count++;
          result.push({
            text: text,
            title: text,
            start: start,
            top: top,
            cnt: cnt,
            index: index,
            height: cnt * o.rowSize
          });
          start += cnt;
          top += cnt * o.rowSize;
        });

        if (BI.isNotEmptyArray(node.values) && o.rowPosition !== BICst.DESIGN.TABLE_ROW_SUM_POSITION.TOP) {
          result.push({
            text: o.sequenceSummaryText,
            title: o.sequenceSummaryText,
            start: start++,
            top: top,
            cnt: 1,
            isSummary: true,
            height: o.rowSize
          });
          top += o.rowSize;
        }
      }
    });
    var rowSize = this.rowHeights = o.rowSizeGetter();
    result = BI.map(result, function (key, item) {
      return [BI.extend({
        type: "bi.table_style_cell",
        cls: "sequence-table-number-cell bi-border-left bi-border-bottom bi-border-right",
        width: o.width,
        styleGetter: item.isSummary === true ? function () {
          return o.summaryCellStyleGetter(true);
        } : function (key) {
          return function () {
            return o.sequenceCellStyleGetter(key);
          };
        }(item.index),
        _store: o.tableStyleCellStoreGetter
      }, item, {
        height: rowSize[key] || item.height
      })];
    });
    return result;
  }
});
BI.shortcut('bi.sequence_table_dynamic_number', BI.SequenceTableDynamicNumber);

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * 表格
 *
 * Created by GUY on 2015/9/22.
 * @class BI.PageTableCell
 * @extends BI.Single
 */
BI.PageTableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.PageTableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-page-table-cell",
      text: "",
      title: ""
    });
  },
  _init: function _init() {
    BI.PageTableCell.superclass._init.apply(this, arguments);

    BI.createWidget({
      type: "bi.label",
      element: this,
      textAlign: "left",
      whiteSpace: "nowrap",
      height: this.options.height,
      text: this.options.text,
      title: this.options.title,
      value: this.options.value,
      lgap: 5,
      rgap: 5
    });

    if (BI.isNotNull(this.options.styles) && BI.isObject(this.options.styles)) {
      this.element.css(this.options.styles);
    }
  }
});
BI.shortcut("bi.page_table_cell", BI.PageTableCell);

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 分页表格
 *
 * Created by GUY on 2016/2/15.
 * @class BI.PageTable
 * @extends BI.Widget
 */
BI.PageTable = BI.inherit(BI.Widget, {
  _const: {
    scrollWidth: 18,
    minScrollWidth: 100
  },
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.PageTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-page-table",
      el: {
        type: "bi.sequence_table"
      },
      pager: {
        horizontal: {
          pages: false,
          // 总页数
          curr: 1,
          // 初始化当前页， pages为数字时可用
          hasPrev: BI.emptyFn,
          hasNext: BI.emptyFn,
          firstPage: 1,
          lastPage: BI.emptyFn
        },
        vertical: {
          pages: false,
          // 总页数
          curr: 1,
          // 初始化当前页， pages为数字时可用
          hasPrev: BI.emptyFn,
          hasNext: BI.emptyFn,
          firstPage: 1,
          lastPage: BI.emptyFn
        }
      },
      itemsCreator: BI.emptyFn,
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为true时生效
      isNeedMerge: false,
      // 是否需要合并单元格
      mergeCols: [],
      // 合并的单元格列号
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      showSequence: false,
      seqWidth: 60,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      header: [],
      items: [],
      // 二维数组
      // 交叉表头
      crossHeader: [],
      crossItems: []
    });
  },
  _init: function _init() {
    BI.PageTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.hCurr = 1;
    this.vCurr = 1;
    this.table = BI.createWidget(o.el, {
      type: "bi.sequence_table",
      width: o.width,
      height: o.height && o.height - 30,
      isNeedResize: true,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: o.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: o.mergeRule,
      columnSize: o.columnSize,
      minColumnSize: o.minColumnSize,
      maxColumnSize: o.maxColumnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      showSequence: o.showSequence,
      seqWidth: o.seqWidth,
      regionColumnSize: o.regionColumnSize,
      headerCellStyleGetter: o.headerCellStyleGetter,
      summaryCellStyleGetter: o.summaryCellStyleGetter,
      sequenceCellStyleGetter: o.sequenceCellStyleGetter,
      tableStyleCellStoreGetter: o.tableStyleCellStoreGetter,
      header: o.header,
      items: o.items,
      // 交叉表头
      crossHeader: o.crossHeader,
      crossItems: o.crossItems
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
    this.pager = BI.createWidget(o.pager, {
      type: "bi.direction_pager",
      height: 24
    });
    this.pager.on(BI.Pager.EVENT_CHANGE, function () {
      var vpage = this.getVPage && this.getVPage();

      if (BI.isNull(vpage)) {
        vpage = this.getCurrentPage();
      }

      var hpage = this.getHPage && this.getHPage();
      o.itemsCreator({
        vpage: vpage,
        hpage: hpage
      }, function () {
        self.table.setVPage ? self.table.setVPage(vpage) : self.table.setValue(vpage);
        self.table.setHPage && self.table.setHPage(hpage);
        self.populate.apply(self, arguments);
      });
    });
    BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.table,
        left: 0,
        top: 0
      }, {
        el: this.pager,
        left: 0,
        right: 10,
        bottom: 3
      }]
    });
  },
  setHPage: function setHPage(v) {
    this.hCurr = v;
    this.pager.setHPage && this.pager.setHPage(v);
    this.table.setHPage && this.table.setHPage(v);
  },
  setVPage: function setVPage(v) {
    this.vCurr = v;
    this.pager.setVPage && this.pager.setVPage(v);
    this.table.setVPage && this.table.setVPage(v);
  },
  getHPage: function getHPage() {
    var hpage = this.pager.getHPage && this.pager.getHPage();

    if (BI.isNotNull(hpage)) {
      return hpage;
    }

    hpage = this.pager.getCurrentPage && this.pager.getCurrentPage();

    if (BI.isNotNull(hpage)) {
      return hpage;
    }

    return this.hpage;
  },
  getVPage: function getVPage() {
    var vpage = this.pager.getVPage && this.pager.getVPage();

    if (BI.isNotNull(vpage)) {
      return vpage;
    }

    vpage = this.pager.getCurrentPage && this.pager.getCurrentPage();

    if (BI.isNotNull(vpage)) {
      return vpage;
    }

    return this.vpage;
  },
  setWidth: function setWidth(width) {
    BI.PageTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    BI.PageTable.superclass.setHeight.apply(this, arguments);
    var o = this.options;
    var showPager = false;

    if (this.pager.isShowPager && this.pager.isShowPager()) {
      showPager = true;
    } else if (this.pager.hasHNext && this.pager.hasHNext()) {
      showPager = true;
    } else if (this.pager.hasHPrev && this.pager.hasHPrev()) {
      showPager = true;
    } else if (this.pager.hasVNext && this.pager.hasVNext()) {
      showPager = true;
    } else if (this.pager.hasVPrev && this.pager.hasVPrev()) {
      showPager = true;
    } else if (this.pager.hasNext && this.pager.hasNext()) {
      showPager = true;
    } else if (this.pager.hasPrev && this.pager.hasPrev()) {
      showPager = true;
    }

    this.table.setHeight(height - (showPager ? o.pager && o.pager.height || 30 : 0));
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this.table.setColumnSize(columnSize);
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
  },
  restore: function restore() {
    this.table.restore();
  },
  attr: function attr() {
    BI.PageTable.superclass.attr.apply(this, arguments);
    this.table.attr.apply(this.table, arguments);
  },
  populate: function populate() {
    this.pager.populate();
    this.table.populate.apply(this.table, arguments);
  },
  destroy: function destroy() {
    this.table.destroy();
    this.pager && this.pager.destroy();
    BI.PageTable.superclass.destroy.apply(this, arguments);
  }
});
BI.shortcut("bi.page_table", BI.PageTable);

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 预览表列
 *
 * Created by GUY on 2015/12/25.
 * @class BI.PreviewTableCell
 * @extends BI.Widget
 */
BI.PreviewTableCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.PreviewTableCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-preview-table-cell",
      text: ""
    });
  },
  _init: function _init() {
    BI.PreviewTableCell.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    BI.createWidget({
      type: "bi.label",
      element: this,
      textAlign: o.textAlign || "left",
      whiteSpace: o.whiteSpace || "normal",
      height: this.options.height,
      text: this.options.text,
      value: this.options.value,
      lgap: o.lgap,
      rgap: o.rgap,
      hgap: o.hgap || 5
    });
  }
});
BI.shortcut("bi.preview_table_cell", BI.PreviewTableCell);

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 预览表
 *
 * Created by GUY on 2015/12/25.
 * @class BI.PreviewTableHeaderCell
 * @extends BI.Widget
 */
BI.PreviewTableHeaderCell = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.PreviewTableHeaderCell.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-preview-table-header-cell",
      text: ""
    });
  },
  _init: function _init() {
    BI.PreviewTableHeaderCell.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    BI.createWidget({
      type: "bi.label",
      element: this,
      textAlign: o.textAlign || "left",
      whiteSpace: o.whiteSpace || "nowrap",
      height: this.options.height,
      text: this.options.text,
      value: this.options.value,
      lgap: o.lgap,
      rgap: o.rgap,
      hgap: o.hgap || 5
    });
  }
});
BI.shortcut("bi.preview_table_header_cell", BI.PreviewTableHeaderCell);

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 预览表
 *
 * Created by GUY on 2015/12/25.
 * @class BI.PreviewTable
 * @extends BI.Widget
 */
BI.PreviewTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.PreviewTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-preview-table",
      isNeedFreeze: false,
      freezeCols: [],
      rowSize: null,
      columnSize: [],
      headerRowSize: 30,
      header: [],
      items: []
    });
  },
  _init: function _init() {
    BI.PreviewTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.table = BI.createWidget({
      type: "bi.table_view",
      element: this,
      isNeedResize: false,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: o.freezeCols,
      rowSize: o.rowSize,
      columnSize: o.columnSize,
      headerRowSize: o.headerRowSize,
      header: BI.map(o.header, function (i, items) {
        return BI.map(items, function (j, item) {
          return BI.extend({
            type: "bi.preview_table_header_cell"
          }, item);
        });
      }),
      items: BI.map(o.items, function (i, items) {
        return BI.map(items, function (j, item) {
          return BI.extend({
            type: "bi.preview_table_cell"
          }, item);
        });
      })
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_INIT, function () {
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_INIT, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_RESIZE, function () {
      self._adjustColumns();
    });

    this._adjustColumns();
  },
  // 是否有自适应调节的列，即列宽为""
  _hasAdaptCol: function _hasAdaptCol(columnSize) {
    return BI.any(columnSize, function (i, size) {
      return size === "";
    });
  },
  _isPercentage: function _isPercentage(columnSize) {
    return columnSize[0] <= 1;
  },
  _adjustColumns: function _adjustColumns() {
    var self = this,
        o = this.options;

    if (o.isNeedFreeze === true) {
      // 如果存在百分比的情况
      if (this._isPercentage(o.columnSize)) {
        if (this._hasAdaptCol(o.columnSize)) {
          var findCols = [],
              remain = 0;
          BI.each(o.columnSize, function (i, size) {
            if (size === "") {
              findCols.push(i);
            } else {
              remain += size;
            }
          });
          remain = 1 - remain;
          var average = remain / findCols.length;
          BI.each(findCols, function (i, col) {
            o.columnSize[col] = average;
          });
        }

        var isRight = BI.first(o.freezeCols) !== 0;
        var freezeSize = [],
            notFreezeSize = [];
        BI.each(o.columnSize, function (i, size) {
          if (o.freezeCols.includes(i)) {
            freezeSize.push(size);
          } else {
            notFreezeSize.push(size);
          }
        });
        var sumFreezeSize = BI.sum(freezeSize),
            sumNotFreezeSize = BI.sum(notFreezeSize);
        BI.each(freezeSize, function (i, size) {
          freezeSize[i] = size / sumFreezeSize;
        });
        BI.each(notFreezeSize, function (i, size) {
          notFreezeSize[i] = size / sumNotFreezeSize;
        });
        this.table.setRegionColumnSize(isRight ? ["fill", sumFreezeSize] : [sumFreezeSize, "fill"]);
        this.table.setColumnSize(isRight ? notFreezeSize.concat(freezeSize) : freezeSize.concat(notFreezeSize));
      }
    } else {
      // 如果存在自适应宽度的列或者是百分比计算的列，需要将整个表宽设为100%
      if (this._hasAdaptCol(o.columnSize) || this._isPercentage(o.columnSize)) {
        this.table.setRegionColumnSize(["100%"]);
      }
    }
  },
  setColumnSize: function setColumnSize(columnSize) {
    return this.table.setColumnSize(columnSize);
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  getCalculateColumnSize: function getCalculateColumnSize() {
    return this.table.getCalculateColumnSize();
  },
  setHeaderColumnSize: function setHeaderColumnSize(columnSize) {
    return this.table.setHeaderColumnSize(columnSize);
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    return this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  getCalculateRegionColumnSize: function getCalculateRegionColumnSize() {
    return this.table.getCalculateRegionColumnSize();
  },
  getCalculateRegionRowSize: function getCalculateRegionRowSize() {
    return this.table.getCalculateRegionRowSize();
  },
  getClientRegionColumnSize: function getClientRegionColumnSize() {
    return this.table.getClientRegionColumnSize();
  },
  getScrollRegionColumnSize: function getScrollRegionColumnSize() {
    return this.table.getScrollRegionColumnSize();
  },
  getScrollRegionRowSize: function getScrollRegionRowSize() {
    return this.table.getScrollRegionRowSize();
  },
  hasVerticalScroll: function hasVerticalScroll() {
    return this.table.hasVerticalScroll();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    return this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    return this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    return this.table.setRightHorizontalScroll(scrollLeft);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getLeftHorizontalScroll: function getLeftHorizontalScroll() {
    return this.table.getLeftHorizontalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  getColumns: function getColumns() {
    return this.table.getColumns();
  },
  populate: function populate(items, header) {
    if (items) {
      items = BI.map(items, function (i, items) {
        return BI.map(items, function (j, item) {
          return BI.extend({
            type: "bi.preview_table_cell"
          }, item);
        });
      });
    }

    if (header) {
      header = BI.map(header, function (i, items) {
        return BI.map(items, function (j, item) {
          return BI.extend({
            type: "bi.preview_table_header_cell"
          }, item);
        });
      });
    }

    this.table.populate(items, header);

    this._adjustColumns();
  }
});
BI.PreviewTable.EVENT_CHANGE = "PreviewTable.EVENT_CHANGE";
BI.shortcut("bi.preview_table", BI.PreviewTable);

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2016/5/26.
 * @class BI.SequenceTableListNumber
 * @extends BI.Widget
 */
BI.SequenceTableListNumber = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.SequenceTableListNumber.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-sequence-table-list-number",
      isNeedFreeze: false,
      scrollTop: 0,
      startSequence: 1,
      // 开始的序号
      headerRowSize: 25,
      rowSize: 25,
      rowSizeGetter: BI.emptyFn,
      headerRowSizeGetter: BI.emptyFn,
      sequenceHeaderCreator: BI.emptyFn,
      header: [],
      items: [],
      // 二维数组
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      pageSize: 20,
      width: 60
    });
  },
  _init: function _init() {
    BI.SequenceTableListNumber.superclass._init.apply(this, arguments);

    var o = this.options;
    this.start = o.startSequence;
    this.gridView = BI.createWidget({
      type: "bi.grid_view",
      overflowX: false,
      overflowY: false,
      scrollTop: o.scrollTop,
      columnCount: 1,
      estimatedColumnSize: o.width,
      width: o.width,
      rowHeightGetter: this._rowHeightGetter.bind(this),
      columnWidthGetter: function columnWidthGetter() {
        return o.width;
      }
    });
    this.headerContainer = BI.createWidget({
      type: "bi.absolute",
      cls: "sequence-table-header-cell bi-border-top bi-border-left bi-border-bottom bi-border-right",
      width: o.width,
      scrollable: false
    });
    this.layout = BI.createWidget({
      type: "bi.vtape",
      element: this,
      items: [{
        el: this.headerContainer,
        height: 2
      }, {
        el: this.gridView,
        height: "fill"
      }]
    });
    this.populate();
  },
  _rowHeightGetter: function _rowHeightGetter(i) {
    if (this.rowHeights) {
      var rowHeight = this.rowHeights[i];
      return BI.isNotNull(rowHeight) ? rowHeight : this.options.rowSize;
    }

    return this.options.rowSize;
  },
  _layout: function _layout() {
    var o = this.options;
    this.headerContainer.empty();
    var headerHeights = o.headerRowSizeGetter();
    var headerHeight = BI.sum(headerHeights);
    BI.createWidget({
      type: "bi.absolute",
      element: this.headerContainer,
      items: [{
        el: BI.extend({
          type: "bi.table_style_cell",
          height: headerHeight - 2,
          cls: "sequence-table-title-cell",
          styleGetter: o.headerCellStyleGetter,
          text: BI.i18nText("BI-Number_Index"),
          _store: o.tableStyleCellStoreGetter
        }, o.sequenceHeaderCreator()),
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }]
    });
    var items = this.layout.attr("items");

    if (o.isNeedFreeze === false) {
      items[0].height = 0;
    } else if (o.isNeedFreeze === true) {
      items[0].height = headerHeight;
    }

    this.layout.attr("items", items);
    this.layout.resize();
    this.numbers = this._formatNumber(o.items);
    var estimatedRowSize = o.items.length > 0 ? BI.sum(this.rowHeights) / o.items.length : 0;
    this.gridView.setEstimatedRowSize(estimatedRowSize);
    this.gridView.setHeight(o.height - headerHeight);
  },
  _formatNumber: function _formatNumber(items) {
    var self = this,
        o = this.options;
    var rowSize = this.rowHeights = o.rowSizeGetter();
    var result = BI.map(items, function (i, row) {
      return BI.map(row, function (j, item) {
        return {
          type: "bi.table_style_cell",
          cls: "sequence-table-number-cell bi-border-left bi-border-bottom bi-border-right " + (i % 2 !== 0 ? "even-row" : "odd-row"),
          width: o.width,
          height: rowSize ? rowSize[i] : o.rowSize,
          text: self.start + i,
          styleGetter: function styleGetter() {
            return o.sequenceCellStyleGetter(self.start + i - 1);
          },
          _store: o.tableStyleCellStoreGetter
        };
      });
    });
    return result;
  },
  _calculateChildrenToRender: function _calculateChildrenToRender() {
    var self = this,
        o = this.options;

    this.gridView._populate(this.numbers);

    this.gridView.setScrollTop(o.scrollTop);
  },
  _populate: function _populate() {
    this._calculateChildrenToRender();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    var o = this.options;

    if (o.scrollTop !== scrollTop) {
      o.scrollTop = scrollTop;
      this.gridView.setScrollTop(o.scrollTop);
    }
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.options.scrollTop;
  },
  setVPage: function setVPage(v) {
    v = v < 1 ? 1 : v;
    var o = this.options;
    this.start = (v - 1) * o.pageSize + 1;
  },
  setWidth: function setWidth(width) {
    BI.SequenceTableListNumber.superclass.setWidth.apply(this, arguments);
    this.gridView.setWidth(width);
    this.headerContainer.setWidth(width);
  },
  _restore: function _restore() {
    this.gridView.restore();
  },
  restore: function restore() {
    this._restore();
  },
  setPagesize: function setPagesize(size) {
    this.options.pageSize = size;
  },
  populate: function populate(items, header) {
    var o = this.options;

    if (items && items !== this.options.items) {
      o.items = items;
    }

    if (header && header !== this.options.header) {
      o.header = header;
    }

    this._restore();

    this._layout();

    this._populate();
  }
});
BI.shortcut("bi.sequence_table_list_number", BI.SequenceTableListNumber);

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 带有序号的表格
 *
 * Created by GUY on 2016/5/26.
 * @class BI.SequenceTable
 * @extends BI.Widget
 */
BI.SequenceTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.SequenceTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-sequence-table",
      el: {
        type: "bi.adaptive_table"
      },
      sequence: {},
      isNeedResize: true,
      isNeedFreeze: false,
      // 是否需要冻结单元格
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为true时生效
      isNeedMerge: false,
      // 是否需要合并单元格
      mergeCols: [],
      // 合并的单元格列号
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      header: [],
      items: [],
      // 二维数组
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      showSequence: false,
      startSequence: 1,
      // 开始的序号
      seqWidth: 60
    });
  },
  _init: function _init() {
    BI.SequenceTable.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.table = BI.createWidget(o.el, {
      type: "bi.adaptive_table",
      width: o.showSequence === true ? o.width - o.seqWidth : o.width,
      height: o.height,
      isNeedResize: o.isNeedResize,
      isNeedFreeze: o.isNeedFreeze,
      freezeCols: o.freezeCols,
      isNeedMerge: o.isNeedMerge,
      mergeCols: o.mergeCols,
      mergeRule: o.mergeRule,
      columnSize: o.columnSize,
      minColumnSize: o.minColumnSize,
      maxColumnSize: o.maxColumnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      regionColumnSize: o.regionColumnSize,
      headerCellStyleGetter: o.headerCellStyleGetter,
      summaryCellStyleGetter: o.summaryCellStyleGetter,
      sequenceCellStyleGetter: o.sequenceCellStyleGetter,
      tableStyleCellStoreGetter: o.tableStyleCellStoreGetter,
      header: o.header,
      items: o.items,
      // 交叉表头
      crossHeader: o.crossHeader,
      crossItems: o.crossItems
    });
    this.sequence = BI.createWidget(o.sequence, {
      type: "bi.sequence_table_list_number",
      invisible: o.showSequence === false,
      startSequence: o.startSequence,
      isNeedFreeze: o.isNeedFreeze,
      header: o.header,
      items: o.items,
      crossHeader: o.crossHeader,
      crossItems: o.crossItems,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      rowSizeGetter: function rowSizeGetter() {
        return self.table.getFirstColumnRowSize();
      },
      headerRowSizeGetter: function headerRowSizeGetter() {
        return self.table.getFirstColumnHeaderRowSize();
      },
      width: o.seqWidth,
      height: o.height && o.height - BI.GridTableScrollbar.SIZE,
      headerCellStyleGetter: o.headerCellStyleGetter,
      summaryCellStyleGetter: o.summaryCellStyleGetter,
      sequenceCellStyleGetter: o.sequenceCellStyleGetter,
      tableStyleCellStoreGetter: o.tableStyleCellStoreGetter
    });
    this.table.on(BI.Table.EVENT_TABLE_SCROLL, function () {
      if (self.sequence.getVerticalScroll() !== this.getVerticalScroll()) {
        self.sequence.setVerticalScroll(this.getVerticalScroll()); // self.sequence._populate();
      }

      self.fireEvent(BI.Table.EVENT_TABLE_SCROLL, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.sequence.setVerticalScroll(this.getVerticalScroll());
      self.sequence.populate();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_REGION_RESIZE, arguments);
    });
    this.table.on(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, function () {
      o.regionColumnSize = this.getRegionColumnSize();
      o.columnSize = this.getColumnSize();
      self.sequence.setVerticalScroll(this.getVerticalScroll());
      self.sequence.populate();
      self.fireEvent(BI.Table.EVENT_TABLE_AFTER_COLUMN_RESIZE, arguments);
    });
    this.htape = BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.sequence,
        left: 0,
        top: 0
      }, {
        el: this.table,
        top: 0,
        left: o.showSequence === true ? o.seqWidth : 0
      }]
    });

    this._populate();
  },
  _populate: function _populate() {
    var o = this.options;

    if (o.showSequence === true) {
      this.sequence.setVisible(true);
      this.table.element.css("left", o.seqWidth + "px");
      this.table.setWidth(o.width - o.seqWidth);
      this.sequence.setWidth(o.seqWidth);
    } else {
      this.sequence.setVisible(false);
      this.table.element.css("left", "0px");
      this.table.setWidth(o.width);
    }
  },
  setWidth: function setWidth(width) {
    BI.PageTable.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(this.options.showSequence ? width - this.options.seqWidth : width);
  },
  setHeight: function setHeight(height) {
    BI.PageTable.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
    this.sequence.setHeight(height - BI.GridTableScrollbar.SIZE);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this.table.setColumnSize(columnSize);
  },
  getColumnSize: function getColumnSize() {
    return this.table.getColumnSize();
  },
  setRegionColumnSize: function setRegionColumnSize(columnSize) {
    this.options.columnSize = columnSize;
    this.table.setRegionColumnSize(columnSize);
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return this.table.getRegionColumnSize();
  },
  hasLeftHorizontalScroll: function hasLeftHorizontalScroll() {
    return this.table.hasLeftHorizontalScroll();
  },
  hasRightHorizontalScroll: function hasRightHorizontalScroll() {
    return this.table.hasRightHorizontalScroll();
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {
    this.table.setLeftHorizontalScroll(scrollLeft);
  },
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {
    this.table.setRightHorizontalScroll(scrollLeft);
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    this.table.setVerticalScroll(scrollTop);
    this.sequence.setVerticalScroll(scrollTop);
  },
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  setVPage: function setVPage(page) {
    this.sequence.setVPage && this.sequence.setVPage(page);
  },
  setHPage: function setHPage(page) {
    this.sequence.setHPage && this.sequence.setHPage(page);
  },
  attr: function attr() {
    BI.SequenceTable.superclass.attr.apply(this, arguments);
    this.table.attr.apply(this.table, arguments);
    this.sequence.attr.apply(this.sequence, arguments);
  },
  restore: function restore() {
    this.table.restore();
    this.sequence.restore();
  },
  populate: function populate(items, header, crossItems, crossHeader) {
    var o = this.options;

    if (items) {
      o.items = items;
    }

    if (header) {
      o.header = header;
    }

    if (crossItems) {
      o.crossItems = crossItems;
    }

    if (crossHeader) {
      o.crossHeader = crossHeader;
    }

    this._populate();

    this.table.populate.apply(this.table, arguments);
    this.sequence.populate.apply(this.sequence, arguments);
    this.sequence.setVerticalScroll(this.table.getVerticalScroll());
  },
  destroy: function destroy() {
    this.table.destroy();
    BI.SequenceTable.superclass.destroy.apply(this, arguments);
  }
});
BI.shortcut("bi.sequence_table", BI.SequenceTable);

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Widget = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-spread-sequence-grid-table",
      el: {},
      isNeedResize: true,
      // 是否需要调整列宽
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      sequenceHeaderCreator: BI.emptyFn,
      sequenceSummaryText: BI.i18nText("BI-Summary_Values"),
      header: [],
      items: [],
      showSequence: false,
      startSequence: 1,
      // 开始的序号
      seqWidth: 60
    },
    _getVDeep: function _getVDeep() {
      return this.options.crossHeader.length; // 纵向深度
    },
    _getHDeep: function _getHDeep() {
      var o = this.options;
      return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.contextLayout = BI.createWidget({
        type: "bi.vertical",
        element: this,
        scrolly: false,
        scrollable: true,
        items: []
      });
      this.header = this._getHeader();
      this.items = this._getItems();

      if (o.header.length > 0 || o.items.length > 0) {
        this._populate();
      }
    },
    _getFreezeColLength: function _getFreezeColLength() {
      var o = this.options;
      return o.isNeedFreeze === true ? BI.clamp(o.freezeCols.length, 0, o.columnSize.length) : 0;
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight() {
      var o = this.options;
      return o.header.length * o.headerRowSize;
    },
    _getActualItems: function _getActualItems() {
      var o = this.options;
      return o.items;
    },
    _getHeader: function _getHeader() {
      var o = this.options;
      var rightHeader = [];
      BI.each(o.header, function (i, cols) {
        rightHeader[i] = [];
        BI.each(cols, function (j, col) {
          var cell = {
            type: "bi.grid_table_cell",
            extraCls: (i === 0 ? "first-row" : "") + (j === 0 ? " first-col" : ""),
            cell: col
          };
          rightHeader[i].push(cell);
        });
      });
      return rightHeader;
    },
    _getItems: function _getItems() {
      var o = this.options;
      var rightItems = [];
      var firstRowTopLine = !(o.header && o.header.length > 0);
      BI.each(this._getActualItems(), function (i, cols) {
        rightItems[i] = [];
        BI.each(cols, function (j, col) {
          var cell;

          if (o.customCell) {
            col && (col.firstRowTopLine = firstRowTopLine);
            cell.extraCls = (i === 0 ? "first-row" : "") + (j === 0 ? " first-col" : "");
            cell = col;
          } else {
            cell = {
              type: "bi.grid_table_cell",
              cell: col,
              extraCls: (i === 0 ? "first-row" : "") + (j === 0 ? " first-col" : ""),
              firstRowTopLine: firstRowTopLine
            };
          }

          rightItems[i].push(cell);
        });
      });
      return rightItems;
    },
    _populateTable: function _populateTable() {
      var self = this,
          o = this.options;
      var regionSize = this.getRegionSize(),
          totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];

      var freezeColLength = this._getFreezeColLength();

      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      });
      this.contextLayout.populate(BI.map(this.header, function (i, lists) {
        var headerRow = {
          type: "bi.vertical_adapt",
          items: BI.map(lists, function (j, item) {
            return BI.extend({
              width: o.columnSize[j],
              height: o.headerRowSize
            }, item);
          })
        };
        return o.showSequence ? {
          type: "bi.vertical_adapt",
          items: [{
            type: "bi.table_style_cell",
            text: BI.i18nText("BI-Number_Index"),
            width: o.seqWidth,
            height: o.headerRowSize,
            styleGetter: o.headerCellStyleGetter,
            _store: o.tableStyleCellStoreGetter
          }, headerRow]
        } : headerRow;
      }).concat(BI.map(this.items, function (i, lists) {
        var row = {
          type: "bi.vertical_adapt",
          verticalAlign: "stretch",
          items: BI.map(lists, function (j, item) {
            return BI.extend({
              width: o.columnSize[j],
              height: o.rowSize
            }, item);
          })
        };
        return o.showSequence ? {
          type: "bi.vertical_adapt",
          verticalAlign: "stretch",
          items: [{
            type: "bi.table_style_cell",
            cls: "sequence-table-title-cell",
            width: o.seqWidth,
            styleGetter: function (key) {
              return function () {
                return o.sequenceCellStyleGetter(key);
              };
            }(i),
            text: i + 1,
            _store: o.tableStyleCellStoreGetter
          }, row]
        } : row;
      })));
    },
    _populate: function _populate() {
      this._populateTable();
    },
    getRegionSize: function getRegionSize() {
      var o = this.options;
      var regionSize = o.regionColumnSize[0] || 0;

      if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
        return 0;
      }

      if (!regionSize) {
        BI.each(o.freezeCols, function (i, col) {
          regionSize += o.columnSize[col];
        });
      }

      return regionSize;
    },
    setVerticalScroll: function setVerticalScroll(scrollTop) {},
    setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
    setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
    getVerticalScroll: function getVerticalScroll() {},
    getLeftHorizontalScroll: function getLeftHorizontalScroll() {},
    getRightHorizontalScroll: function getRightHorizontalScroll() {},
    setColumnSize: function setColumnSize(columnSize) {
      this.options.columnSize = columnSize;
      this._isNeedDigest = true;
    },
    setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
      this.options.regionColumnSize = regionColumnSize;
      this._isNeedDigest = true;
    },
    getColumnSize: function getColumnSize() {
      return this.options.columnSize;
    },
    getRegionColumnSize: function getRegionColumnSize() {
      return this.options.regionColumnSize;
    },
    populate: function populate(items, header) {
      var headerChanged = this.options.header !== header;
      var itemsChanged = this.options.items !== items;

      if (header && headerChanged) {
        this.options.header = header;
      }

      if (items && itemsChanged) {
        this.options.items = items;
      }

      if (items && itemsChanged) {
        this.items = this._getItems();
      }

      if (header && headerChanged) {
        this.header = this._getHeader();
      }

      this._populate();
    },
    restore: function restore() {}
  });
  BI.shortcut("bi.spread_sequence_grid_table", Widget);
}();

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Widget = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-spread-sequence-layer-tree-table",
      el: {},
      isNeedResize: true,
      // 是否需要调整列宽
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      isNeedMergeCol: true,
      // 是否横向合并
      isNeedMergeRow: true,
      // 是否纵向合并
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      sequenceHeaderCreator: BI.emptyFn,
      sequenceSummaryText: BI.i18nText("BI-Summary_Values"),
      header: [],
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right",
      showInnerSummary: false,
      showSequence: false,
      startSequence: 1,
      // 开始的序号
      seqWidth: 60
    },
    _getVDeep: function _getVDeep() {
      return this.options.crossHeader.length; // 纵向深度
    },
    _getHDeep: function _getHDeep() {
      var o = this.options;
      return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
    },
    _createHeader: function _createHeader(vDeep) {
      var self = this,
          o = this.options;
      var header = o.header || [],
          crossHeader = o.crossHeader || [];
      var items = BI.isEmpty(header) ? BI.TableTree.formatCrossItems4Special(o.crossItems, vDeep, o.headerCellStyleGetter, {
        sumPosition: this.options.colPosition === "right",
        summaryText: o.summaryText
      }) : BI.TableTree.formatCrossItems(o.crossItems, vDeep, o.headerCellStyleGetter, {
        sumPosition: this.options.colPosition === "right",
        summaryText: o.summaryText
      });
      var result = [];
      BI.each(items, function (row, node) {
        var c = [crossHeader[row]];
        result.push(c.concat(node || []));
      });
      var rowHeaderCreator = BI.isFunction(o.rowHeaderCreator) ? o.rowHeaderCreator() : o.rowHeaderCreator;

      if (header && header.length > 0) {
        var newHeader = this._formatColumns(header);

        var deep = this._getHDeep();

        if (deep <= 0) {
          newHeader.unshift(rowHeaderCreator || {
            type: "bi.table_style_cell",
            text: BI.i18nText("BI-Row_Header"),
            styleGetter: o.headerCellStyleGetter,
            _store: o.tableStyleCellStoreGetter
          });
        } else {
          newHeader[0] = rowHeaderCreator || {
            type: "bi.table_style_cell",
            text: BI.i18nText("BI-Row_Header"),
            styleGetter: o.headerCellStyleGetter,
            _store: o.tableStyleCellStoreGetter
          };
        }

        result.push(newHeader);
      }

      return result;
    },
    _formatItems: function _formatItems(nodes, header, deep) {
      var self = this,
          o = this.options;
      var result = [];

      function track(node, layer) {
        node.type || (node.type = "bi.layer_tree_table_cell");
        node.layer = layer;
        var next = [node];
        next = next.concat(node.values || []);

        if (next.length > 0) {
          result.push(next);
        }

        if (BI.isNotEmptyArray(node.children)) {
          BI.each(node.children, function (index, child) {
            track(child, layer + 1);
          });
        }
      }

      BI.each(nodes, function (i, node) {
        BI.each(node.children, function (j, c) {
          track(c, 0);
        });

        if (BI.isArray(node.values)) {
          var next = [{
            type: "bi.table_style_cell",
            text: o.summaryText,
            title: o.summaryText,
            styleGetter: function styleGetter() {
              return o.summaryCellStyleGetter(true, BI.get(node, ["children", 0, "dId"]));
            },
            _store: o.tableStyleCellStoreGetter
          }].concat(node.values);
          o.rowPosition === "bottom" ? result.push(next) : result.unshift(next);
        }
      });
      return BI.DynamicSummaryTreeTable.formatSummaryItems(result, header, o.crossItems, 1);
    },
    _formatColumns: function _formatColumns(columns, deep) {
      if (BI.isNotEmptyArray(columns)) {
        deep = deep || this._getHDeep();
        return columns.slice(Math.max(0, deep - 1));
      }

      return columns;
    },
    _formatFreezeCols: function _formatFreezeCols() {
      if (this.options.freezeCols.length > 0) {
        return [0];
      }

      return [];
    },
    _formatMergeCols: function _formatMergeCols() {
      if (this.options.mergeCols.length > 0) {
        return [0];
      }

      return [];
    },
    _formatColumnSize: function _formatColumnSize(columnSize, deep) {
      if (columnSize.length <= 0) {
        return [];
      }

      var result = [0];
      deep = deep || this._getHDeep();
      BI.each(columnSize, function (i, size) {
        if (i < deep) {
          result[0] += size;
          return;
        }

        result.push(size);
      });
      return result;
    },
    _digest: function _digest() {
      var o = this.options;

      var deep = this._getHDeep();

      var vDeep = this._getVDeep();

      var header = this._createHeader(vDeep);

      var data = this._formatItems(o.items, header, deep);

      var columnSize = o.columnSize.slice();
      var minColumnSize = o.minColumnSize.slice();
      var maxColumnSize = o.maxColumnSize.slice();
      BI.removeAt(columnSize, data.deletedCols);
      BI.removeAt(minColumnSize, data.deletedCols);
      BI.removeAt(maxColumnSize, data.deletedCols);
      return {
        header: data.header,
        items: data.items,
        columnSize: this._formatColumnSize(columnSize, deep),
        minColumnSize: this._formatColumns(minColumnSize, deep),
        maxColumnSize: this._formatColumns(maxColumnSize, deep),
        freezeCols: this._formatFreezeCols(),
        mergeCols: this._formatMergeCols()
      };
    },
    render: function render() {
      var self = this,
          o = this.options;
      this._width = 0;
      this._height = 0;

      var data = this._digest();

      this.topRightCollection = BI.createWidget({
        type: "bi.collection_view",
        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
          return self.topRightItems[index];
        }
      });
      this.bottomRight = BI.createWidget({
        type: "bi.vertical",
        scrolly: false
      });
      this.contextLayout = BI.createWidget({
        type: "bi.vertical",
        element: this,
        scrolly: false,
        scrollable: true,
        items: [o.showSequence ? {
          type: "bi.vertical_adapt",
          items: [BI.extend({
            type: "bi.table_style_cell",
            text: BI.i18nText("BI-Number_Index"),
            width: o.seqWidth,
            height: this._getFreezeHeaderHeight(data.header),
            styleGetter: o.headerCellStyleGetter,
            ref: function ref(_ref) {
              self.headerSeq = _ref;
            },
            _store: o.tableStyleCellStoreGetter
          }, o.sequenceHeaderCreator()), this.topRightCollection]
        } : {
          el: this.topRightCollection
        }, {
          el: this.bottomRight
        }]
      });

      if (data.header.length > 0 || data.items.length > 0) {
        this._digestTable(data.header, data.items, data);

        this._populate(data.header, data.items, data);
      }
    },
    populate: function populate(items, header, crossItems, crossHeader) {
      var o = this.options;

      if (items) {
        o.items = items;
      }

      if (header) {
        o.header = header;
      }

      if (crossItems) {
        o.crossItems = crossItems;
      }

      if (crossHeader) {
        o.crossHeader = crossHeader;
      }

      var data = this._digest(); // 表头所展示“序号”高度由headers决定，render的时候不一定传了header, 在populate的时候setHeight


      this.headerSeq && this.headerSeq.setHeight(this._getFreezeHeaderHeight(data.header));
      items = data.items;
      header = data.header;

      if (items && items !== this.options.items) {
        this._isNeedDigest = true;
        this.options.items = items;

        this._restore();
      }

      if (header && header !== this.options.header) {
        this._isNeedDigest = true;
        this.options.header = header;

        this._restore();
      }

      this._populate(header, items, data);
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight(header) {
      var o = this.options;
      return header.length * o.headerRowSize;
    },
    _populateTable: function _populateTable(header, items, data) {
      var self = this,
          o = this.options;
      var regionSize = this.getRegionSize(),
          totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      }); // var otlw = regionSize;
      // var otlh = this._getFreezeHeaderHeight(header);
      // var otrw = this._width - regionSize;
      // var otrh = this._getFreezeHeaderHeight(header);
      // var oblw = regionSize;
      // var oblh = this._height - otlh;
      // var obrw = this._width - regionSize;
      // var obrh = this._height - otrh;
      // var scrollBarSize = BI.DOM.getScrollWidth();
      // var tlw = otlw + scrollBarSize;
      // var tlh = otlh + scrollBarSize;
      // var trw = otrw + scrollBarSize;
      // var trh = otrh + scrollBarSize;
      // var blw = oblw + scrollBarSize;
      // var blh = oblh + scrollBarSize;
      // var brw = obrw + scrollBarSize;
      // var brh = obrh + scrollBarSize;
      //
      // var digest = function (el) {
      //     el.element.css({
      //         overflow: "scroll",
      //         overflowX: "scroll",
      //         overflowY: "scroll"
      //     });
      // };
      // this.topLeft.setWidth(otlw);
      // this.topLeft.setHeight(otlh);
      // this.topRight.setWidth(otrw);
      // this.topRight.setHeight(otrh);
      // this.bottomLeft.setWidth(oblw);
      // this.bottomLeft.setHeight(oblh);
      // this.bottomRight.setWidth(obrw);
      // this.bottomRight.setHeight(obrh);
      // this.topLeftCollection.setWidth(tlw);
      // this.topLeftCollection.setHeight(tlh);

      this.topRightCollection.setWidth(totalColumnSize);
      this.topRightCollection.setHeight(this._getFreezeHeaderHeight(header)); // this.bottomLeftCollection.setWidth(blw);
      // this.bottomLeftCollection.setHeight(blh);
      // this.bottomRightCollection.setWidth(brw);
      // this.bottomRightCollection.setHeight(brh);
      // digest(this.topLeftCollection);
      // digest(this.topRightCollection);
      // digest(this.bottomLeftCollection);
      // digest(this.bottomRightCollection);
      // var items = this.contextLayout.attr("items");
      // items[1].left = regionSize;
      // items[1].top = this._getFreezeHeaderHeight(header);
      // items[3].left = regionSize;
      // items[3].top = this._getFreezeHeaderHeight();
      // this.contextLayout.attr("items", items);
      // this.contextLayout.resize();

      var leftHeader = [],
          rightHeader = [],
          leftItems = [],
          rightItems = [];

      var run = function run(positions, items, rendered, firstRowTopLine, firstColumnLeftLine) {
        BI.each(positions, function (i, item) {
          if (!firstRowTopLine && o.customCell) {
            items[item.row][item.col]._rowIndex = item.row;
            items[item.row][item.col]._columnIndex = item.col;
            items[item.row][item.col].firstRowTopLine = firstRowTopLine;
            items[item.row][item.col].firstColumnLeftLine = firstColumnLeftLine;
            rendered.push(items[item.row][item.col]);
            return;
          }

          var cell = {
            type: "bi.collection_table_cell",
            cell: items[item.row][item.col],
            _rowIndex: item.row,
            _columnIndex: item.col,
            firstRowTopLine: firstRowTopLine,
            firstColumnLeftLine: firstColumnLeftLine
          };
          rendered.push(cell);
        });
      }; // run(this.topLeftItems, header, leftHeader, true, true);


      run(this.topRightItems, header, rightHeader, true, true); // run(this.bottomLeftItems, this._getActualItems(), leftItems, this.topRightItems.length <= 0, true);
      // run(this.bottomRightItems, this._getActualItems(), rightItems, this.topRightItems.length <= 0, this.topLeftItems.length <= 0);
      // this.topLeftCollection._populate(leftHeader);

      this.topRightCollection._populate(rightHeader); // this.bottomLeftCollection._populate(leftItems);
      // this.bottomRightCollection._populate(rightItems);


      this.bottomRight.populate(this.bottomRightItems);
    },
    _digestTable: function _digestTable(header, items, data) {
      var o = this.options;
      var freezeColLength = o.isNeedMerge === true ? BI.clamp(data.mergeCols.length, 0, data.columnSize.length) : 0; // // 如果表头位置不够，取消表头冻结
      // if (this._getFreezeHeaderHeight() <= 0) {
      //     this.topLeftItems = [];
      //     this.topRightItems = [];
      //     this.bottomLeftItems = this._serialize(this._getActualItems(), 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length));
      //     this.bottomRightItems = this._serialize(this._getActualItems(), freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length));
      // } else {
      // this.topLeftItems = this._serialize(header, 0, freezeColLength, o.headerRowSize, o.columnSize, o.mergeCols);

      this.topRightItems = BI.CollectionTable.serialize(header, 0, data.columnSize.length, o.headerRowSize, data.columnSize, true, [], o.mergeRule); // this.bottomLeftItems = this._serialize(o.items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols);
      // this.bottomRightItems = this._serialize(o.items, freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols);
      // }

      this.bottomRightItems = this._serializeItems(items, 0, freezeColLength, o.rowSize, data.columnSize, data.mergeCols);
    },
    _serializeItems: function _serializeItems(items, startCol, endCol, rowHeight, columnSize, mergeCols, mergeRows) {
      mergeCols = mergeCols || [];
      mergeRows = mergeRows || [];
      var self = this,
          o = this.options;
      var count = o.startSequence;
      var result = [],
          cache = {},
          preCol = {},
          preRow = {},
          map = {};
      var summaryColumnSize = [];

      for (var i = startCol; i < endCol; i++) {
        if (i === startCol) {
          summaryColumnSize[i] = columnSize[i];
        } else {
          summaryColumnSize[i] = summaryColumnSize[i - 1] + columnSize[i];
        }
      }

      var mergeRow = function mergeRow(i, j) {
        preCol[j]._height += rowHeight;

        preCol[j].__mergeRows.push(i); //指向前一列


        preRow[i] = preCol[j];
      };

      var mergeCol = function mergeCol(i, j) {
        preRow[i]._width += columnSize[j];

        preRow[i].__mergeCols.push(j);
      };

      var createOneEl = function createOneEl(r, c) {
        var width = columnSize[c];
        var height = rowHeight;
        map[r][c]._row = r;
        map[r][c]._col = c;
        map[r][c]._width = width;
        map[r][c]._height = height;
        var el = {
          x: summaryColumnSize[c] - columnSize[c],
          y: +r * rowHeight,
          item: map[r][c]
        };
        preCol[c] = map[r][c];
        preCol[c].__mergeRows = [r];
        preRow[r] = map[r][c];
        preRow[r].__mergeCols = [c];
        result.push(el);
      };

      BI.each(items, function (i, cols) {
        for (var j = startCol; j < endCol; j++) {
          if (!cache[i]) {
            cache[i] = {};
          }

          if (!map[i]) {
            map[i] = {};
          }

          cache[i][j] = cols[j];
          map[i][j] = {};

          if (mergeCols === true || mergeCols.indexOf(j) > -1 || mergeRows === true || mergeRows.indexOf(i) > -1) {
            if (i === 0 && j === startCol) {
              createOneEl(0, startCol);
            } else if (j === startCol && i > 0) {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);

              if (isNeedMergeRow === true) {
                mergeRow(i, j);
                preRow[i] = preCol[j];
              } else {
                createOneEl(i, j);
              }
            } else if (i === 0 && j > startCol) {
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol === true) {
                mergeCol(i, j);
                preCol[j] = preRow[i];
              } else {
                createOneEl(i, j);
              }
            } else {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol && isNeedMergeRow) {
                continue; // mergeRow(i, j);//优先合并列
              }

              if (isNeedMergeCol) {
                mergeCol(i, j);
              }

              if (isNeedMergeRow) {
                mergeRow(i, j);
              }

              if (!isNeedMergeCol && !isNeedMergeRow) {
                createOneEl(i, j);
              }
            }
          } else {
            createOneEl(i, j);
          }
        }
      }); // 构建父子之间的关系

      var stacks = [],
          lastLayer;
      BI.each(result, function (i, item) {
        var node = items[item.item._row][item.item._col];

        if (!node.layer || node.layer <= lastLayer) {
          stacks = stacks.slice(0, node.layer || 0);
        }

        item.parent = stacks[stacks.length - 1];

        if (!node.children || node.children.length === 0) {
          item.isLastNode = true;
          return;
        }

        stacks.push(item);
        lastLayer = node.layer;
      });
      var tree = [];
      var prefix = BI.UUID();
      BI.each(result, function (i, item) {
        // 序号显示逐行递增，但最后一行的序号样式和文本需要由summaryCellStyleGetter和summaryText决定
        var isSummarySeq = items.length - 1 === item.item._row;
        var layout = {
          type: "bi.vertical",
          scrolly: false,
          items: [{
            type: "bi.layout",
            tagName: "input",
            cls: "spread-sequence-table-checkbox",
            invisible: true,
            attributes: {
              type: "checkbox",
              id: prefix + "-" + item.item._row + "-" + item.item._col
            }
          }, !items[item.item._row][item.item._col].children ? {
            type: "bi.layout"
          } : {
            type: "bi.vertical_adapt",
            cls: "summary-line",
            verticalAlign: "stretch",
            items: [!item.parent && o.showSequence === true ? {
              type: "bi.table_style_cell",
              cls: "sequence-table-title-cell",
              width: o.seqWidth,
              styleGetter: function (key) {
                return function () {
                  return isSummarySeq ? o.summaryCellStyleGetter(true) : o.sequenceCellStyleGetter(key);
                };
              }(count),
              text: isSummarySeq ? o.summaryText : count,
              _store: o.tableStyleCellStoreGetter
            } : {
              type: "bi.layout"
            }, {
              el: createNode(item, {
                width: summaryColumnSize[endCol - 1] - (item.item._col > 0 ? summaryColumnSize[item.item._col - 1] : 0) // height: o.rowSize

              }, true)
            }, getLeaves(getSummaryRow(item.item._row, item.item._col))]
          }, {
            type: "bi.vertical_adapt",
            cls: "expand-line",
            verticalAlign: "stretch",
            items: [!item.parent && o.showSequence === true ? {
              type: "bi.table_style_cell",
              cls: "sequence-table-title-cell",
              width: o.seqWidth,
              styleGetter: function (key) {
                return function () {
                  return isSummarySeq ? o.summaryCellStyleGetter(true) : o.sequenceCellStyleGetter(key);
                };
              }(count),
              text: isSummarySeq ? o.summaryText : count++,
              _store: o.tableStyleCellStoreGetter
            } : {
              type: "bi.layout"
            }, {
              type: "bi.vertical",
              items: [{
                el: {
                  type: "bi.vertical_adapt",
                  verticalAlign: "stretch",
                  items: [{
                    el: createNode(item)
                  }, getLeaves(getSummaryRow(item.item._row, item.item._col))]
                }
              }, {
                type: "bi.vertical",
                scrolly: false,
                items: []
              }]
            }]
          }]
        };
        item.layout = layout;

        if (item.parent) {
          getNext(item.parent).push(layout);
        }
      });

      function createNode(item, options, isPlus) {
        var node = BI.extend({
          type: "bi.label",
          textAlign: "left",
          lgap: 25,
          width: item.item._width,
          // height: item.item._height,
          _columnIndex: item.item._col,
          _rowIndex: item.item._row,
          firstRowTopLine: false,
          firstColumnLeftLine: true,
          extraCls: "collection-cell" + (item.item._row === 0 ? " first-row" : "") + (item.item._col === 0 ? " first-col" : ""),
          mounted: function mounted() {
            if (!item.isLastNode) {
              BI.createWidget({
                type: "bi.absolute_vertical_adapt",
                element: this,
                lgap: 6,
                items: [{
                  type: "bi.icon_button",
                  tagName: "label",
                  attributes: {
                    "for": prefix + "-" + item.item._row + "-" + item.item._col
                  },
                  cls: (isPlus ? "plus-font" : "minus-font") + " icon-size-12",
                  iconWidth: 12,
                  iconHeight: 12,
                  width: 12,
                  height: 12
                }]
              });
            }
          } // height: item.item._height

        }, options, items[item.item._row][item.item._col]);
        return node;
      }

      function getSummaryRow(i, j) {
        var item = map[i][j];

        if (o.rowPosition === "bottom") {
          return i + item.__mergeRows.length - 1;
        } else {
          return i;
        }
      }

      function getNext(item) {
        return item.layout.items[2].items[1].items[1].items;
      }

      function getLeaves(row) {
        var leaves = items[row].slice(endCol);
        return {
          type: "bi.vertical_adapt",
          items: BI.map(leaves, function (i, leaf) {
            return BI.extend({
              type: "bi.label",
              width: columnSize[endCol + i],
              height: rowHeight,
              extraCls: "collection-cell"
            }, leaf);
          })
        };
      }

      BI.each(result, function (i, item) {
        if (!item.parent) {
          tree.push(item.layout);
        }
      });
      return tree;
    },
    _populate: function _populate(header, items, data) {
      if (this._isNeedDigest === true) {
        this._digestTable(header, items, data);
      }

      this._isNeedDigest = false;

      this._populateTable(header, items, data);
    },
    getRegionSize: function getRegionSize() {
      var o = this.options;
      var regionSize = o.regionColumnSize[0] || 0;

      if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
        return 0;
      }

      if (!regionSize) {
        BI.each(o.freezeCols, function (i, col) {
          regionSize += o.columnSize[col];
        });
      }

      return regionSize;
    },
    setVerticalScroll: function setVerticalScroll(scrollTop) {},
    setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
    setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
    getVerticalScroll: function getVerticalScroll() {},
    getLeftHorizontalScroll: function getLeftHorizontalScroll() {},
    getRightHorizontalScroll: function getRightHorizontalScroll() {},
    setColumnSize: function setColumnSize(columnSize) {
      this._isNeedDigest = true;
      this.options.columnSize = columnSize;
    },
    setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
      this._isNeedDigest = true;
      this.options.regionColumnSize = regionColumnSize;
    },
    getColumnSize: function getColumnSize() {
      return this.options.columnSize;
    },
    getRegionColumnSize: function getRegionColumnSize() {
      return this.options.regionColumnSize;
    },
    _restore: function _restore() {
      // this.topLeftCollection.restore();
      this.topRightCollection.restore(); // this.bottomLeftCollection.restore();
      // this.bottomRightCollection.restore();
    },
    restore: function restore() {
      this._restore();
    }
  });
  BI.shortcut("bi.spread_sequence_layer_tree_table", Widget);
}();

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Widget = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-spread-sequence-list-table",
      el: {},
      isNeedResize: true,
      // 是否需要调整列宽
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      isNeedMergeCol: true,
      // 是否横向合并
      isNeedMergeRow: true,
      // 是否纵向合并
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      sequenceHeaderCreator: BI.emptyFn,
      sequenceSummaryText: BI.i18nText("BI-Summary_Values"),
      header: [],
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right",
      showInnerSummary: false,
      showSequence: false,
      startSequence: 1,
      // 开始的序号
      seqWidth: 60
    },
    _getVDeep: function _getVDeep() {
      return this.options.crossHeader.length; // 纵向深度
    },
    _getHDeep: function _getHDeep() {
      var o = this.options;
      return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
    },
    render: function render() {
      var self = this,
          o = this.options;
      this._width = 0;
      this._height = 0;

      var data = this._digest();

      this.topRightCollection = BI.createWidget({
        type: "bi.collection_view",
        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
          return self.topRightItems[index];
        }
      });
      this.bottomRight = BI.createWidget({
        type: "bi.vertical",
        scrolly: false
      });
      this.contextLayout = BI.createWidget({
        type: "bi.vertical",
        element: this,
        scrolly: false,
        scrollable: true,
        items: [o.showSequence ? {
          type: "bi.vertical_adapt",
          items: [BI.extend({
            type: "bi.table_style_cell",
            text: BI.i18nText("BI-Number_Index"),
            width: o.seqWidth,
            height: this._getFreezeHeaderHeight(data.header),
            styleGetter: o.headerCellStyleGetter,
            ref: function ref(_ref) {
              self.headerSeq = _ref;
            },
            _store: o.tableStyleCellStoreGetter
          }, o.sequenceHeaderCreator()), this.topRightCollection]
        } : {
          el: this.topRightCollection
        }, {
          el: this.bottomRight
        }]
      });

      if (data.header.length > 0 || data.items.length > 0) {
        this._digestTable(data.header, data.items);

        this._populate(data.header, data.items);
      }
    },
    _digest: function _digest() {
      var o = this.options;

      var deep = this._getHDeep();

      var vDeep = this._getVDeep();

      var header = BI.TableTree.formatHeader(o.header, o.crossHeader, o.crossItems, deep, vDeep, o.headerCellStyleGetter, {
        sumPosition: o.colPosition === "right",
        summaryText: o.summaryText
      });
      var items = BI.DynamicSummaryTreeTable.formatHorizontalItems(o.items, deep, false, o.summaryCellStyleGetter, {
        sumPosition: o.rowPosition === "bottom",
        summaryText: o.summaryText,
        isNeedMergeRow: o.isNeedMergeRow,
        tableStyleCellStoreGetter: o.tableStyleCellStoreGetter
      });
      var data = BI.DynamicSummaryTreeTable.formatSummaryItems(items, header, o.crossItems, deep);
      var columnSize = o.columnSize.slice();
      var minColumnSize = o.minColumnSize.slice();
      var maxColumnSize = o.maxColumnSize.slice();
      BI.removeAt(columnSize, data.deletedCols);
      BI.removeAt(minColumnSize, data.deletedCols);
      BI.removeAt(maxColumnSize, data.deletedCols);
      return {
        header: data.header,
        items: data.items,
        columnSize: columnSize,
        minColumnSize: minColumnSize,
        maxColumnSize: maxColumnSize
      };
    },
    populate: function populate(items, header, crossItems, crossHeader) {
      var o = this.options;

      if (items) {
        o.items = items;
      }

      if (header) {
        o.header = header;
      }

      if (crossItems) {
        o.crossItems = crossItems;
      }

      if (crossHeader) {
        o.crossHeader = crossHeader;
      }

      var data = this._digest(); // 表头所展示“序号”高度由headers决定，render的时候不一定传了header, 在populate的时候setHeight


      this.headerSeq && this.headerSeq.setHeight(this._getFreezeHeaderHeight(data.header));
      this.setColumnSize(data.columnSize);
      o.minColumnSize = data.minColumnSize;
      o.maxColumnSize = data.maxColumnSize;
      items = data.items;
      header = data.header;

      if (items && items !== this.options.items) {
        this._isNeedDigest = true;
        this.options.items = items;

        this._restore();
      }

      if (header && header !== this.options.header) {
        this._isNeedDigest = true;
        this.options.header = header;

        this._restore();
      }

      this._populate(header, items);
    },
    _getFreezeColLength: function _getFreezeColLength() {
      var o = this.options;
      return o.isNeedMerge === true ? BI.clamp(o.mergeCols.length, 0, o.columnSize.length) : 0;
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight(header) {
      var o = this.options;
      return header.length * o.headerRowSize;
    },
    _populateTable: function _populateTable(header, items) {
      var self = this,
          o = this.options;
      var regionSize = this.getRegionSize(),
          totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      }); // var otlw = regionSize;
      // var otlh = this._getFreezeHeaderHeight(header);
      // var otrw = this._width - regionSize;
      // var otrh = this._getFreezeHeaderHeight(header);
      // var oblw = regionSize;
      // var oblh = this._height - otlh;
      // var obrw = this._width - regionSize;
      // var obrh = this._height - otrh;
      // var scrollBarSize = BI.DOM.getScrollWidth();
      // var tlw = otlw + scrollBarSize;
      // var tlh = otlh + scrollBarSize;
      // var trw = otrw + scrollBarSize;
      // var trh = otrh + scrollBarSize;
      // var blw = oblw + scrollBarSize;
      // var blh = oblh + scrollBarSize;
      // var brw = obrw + scrollBarSize;
      // var brh = obrh + scrollBarSize;
      //
      // var digest = function (el) {
      //     el.element.css({
      //         overflow: "scroll",
      //         overflowX: "scroll",
      //         overflowY: "scroll"
      //     });
      // };
      // this.topLeft.setWidth(otlw);
      // this.topLeft.setHeight(otlh);
      // this.topRight.setWidth(otrw);
      // this.topRight.setHeight(otrh);
      // this.bottomLeft.setWidth(oblw);
      // this.bottomLeft.setHeight(oblh);
      // this.bottomRight.setWidth(obrw);
      // this.bottomRight.setHeight(obrh);
      // this.topLeftCollection.setWidth(tlw);
      // this.topLeftCollection.setHeight(tlh);

      this.topRightCollection.setWidth(totalColumnSize);
      this.topRightCollection.setHeight(this._getFreezeHeaderHeight(header)); // this.bottomLeftCollection.setWidth(blw);
      // this.bottomLeftCollection.setHeight(blh);
      // this.bottomRightCollection.setWidth(brw);
      // this.bottomRightCollection.setHeight(brh);
      // digest(this.topLeftCollection);
      // digest(this.topRightCollection);
      // digest(this.bottomLeftCollection);
      // digest(this.bottomRightCollection);
      // var items = this.contextLayout.attr("items");
      // items[1].left = regionSize;
      // items[1].top = this._getFreezeHeaderHeight(header);
      // items[3].left = regionSize;
      // items[3].top = this._getFreezeHeaderHeight();
      // this.contextLayout.attr("items", items);
      // this.contextLayout.resize();

      var leftHeader = [],
          rightHeader = [],
          leftItems = [],
          rightItems = [];

      var run = function run(positions, items, rendered, firstRowTopLine, firstColumnLeftLine) {
        BI.each(positions, function (i, item) {
          if (!firstRowTopLine && o.customCell) {
            items[item.row][item.col]._rowIndex = item.row;
            items[item.row][item.col]._columnIndex = item.col;
            items[item.row][item.col].firstRowTopLine = firstRowTopLine;
            items[item.row][item.col].firstColumnLeftLine = firstColumnLeftLine;
            rendered.push(items[item.row][item.col]);
            return;
          }

          var cell = {
            type: "bi.collection_table_cell",
            cell: items[item.row][item.col],
            _rowIndex: item.row,
            _columnIndex: item.col,
            firstRowTopLine: firstRowTopLine,
            firstColumnLeftLine: firstColumnLeftLine
          };
          rendered.push(cell);
        });
      }; // run(this.topLeftItems, header, leftHeader, true, true);


      run(this.topRightItems, header, rightHeader, true, true); // run(this.bottomLeftItems, this._getActualItems(), leftItems, this.topRightItems.length <= 0, true);
      // run(this.bottomRightItems, this._getActualItems(), rightItems, this.topRightItems.length <= 0, this.topLeftItems.length <= 0);
      // this.topLeftCollection._populate(leftHeader);

      this.topRightCollection._populate(rightHeader); // this.bottomLeftCollection._populate(leftItems);
      // this.bottomRightCollection._populate(rightItems);


      this.bottomRight.populate(this.bottomRightItems);
    },
    _digestTable: function _digestTable(header, items) {
      var o = this.options;

      var freezeColLength = this._getFreezeColLength(); // // 如果表头位置不够，取消表头冻结
      // if (this._getFreezeHeaderHeight() <= 0) {
      //     this.topLeftItems = [];
      //     this.topRightItems = [];
      //     this.bottomLeftItems = this._serialize(this._getActualItems(), 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length));
      //     this.bottomRightItems = this._serialize(this._getActualItems(), freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length));
      // } else {
      // this.topLeftItems = this._serialize(header, 0, freezeColLength, o.headerRowSize, o.columnSize, o.mergeCols);


      this.topRightItems = BI.CollectionTable.serialize(header, 0, o.columnSize.length, o.headerRowSize, o.columnSize, true, [], o.mergeRule); // this.bottomLeftItems = this._serialize(o.items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols);
      // this.bottomRightItems = this._serialize(o.items, freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols);
      // }

      this.bottomRightItems = this._serializeItems(items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols);
    },
    _serializeItems: function _serializeItems(items, startCol, endCol, rowHeight, columnSize, mergeCols, mergeRows) {
      mergeCols = mergeCols || [];
      mergeRows = mergeRows || [];
      var self = this,
          o = this.options;
      var count = o.startSequence;
      var result = [],
          cache = {},
          preCol = {},
          preRow = {},
          map = {};
      var summaryColumnSize = [];

      for (var i = startCol; i < endCol; i++) {
        if (i === startCol) {
          summaryColumnSize[i] = columnSize[i];
        } else {
          summaryColumnSize[i] = summaryColumnSize[i - 1] + columnSize[i];
        }
      }

      var mergeRow = function mergeRow(i, j) {
        preCol[j]._height += rowHeight;

        preCol[j].__mergeRows.push(i); //指向前一列


        preRow[i] = preCol[j];
      };

      var mergeCol = function mergeCol(i, j) {
        preRow[i]._width += columnSize[j];

        preRow[i].__mergeCols.push(j);
      };

      var createOneEl = function createOneEl(r, c) {
        var width = columnSize[c];
        var height = rowHeight;
        map[r][c]._row = r;
        map[r][c]._col = c;
        map[r][c]._width = width;
        map[r][c]._height = height;
        var el = {
          x: summaryColumnSize[c] - columnSize[c],
          y: +r * rowHeight,
          item: map[r][c],
          parent: preRow[r] && preRow[r].el
        };
        preCol[c] = map[r][c];
        preCol[c].__mergeRows = [r];
        preRow[r] = map[r][c];
        preRow[r].__mergeCols = [c];
        preRow[r].el = el;
        result.push(el);
      };

      BI.each(items, function (i, cols) {
        for (var j = startCol; j < endCol; j++) {
          if (!cache[i]) {
            cache[i] = {};
          }

          if (!map[i]) {
            map[i] = {};
          }

          cache[i][j] = cols[j];
          map[i][j] = {};

          if (mergeCols === true || mergeCols.indexOf(j) > -1 || mergeRows === true || mergeRows.indexOf(i) > -1) {
            if (i === 0 && j === startCol) {
              createOneEl(0, startCol);
            } else if (j === startCol && i > 0) {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);

              if (isNeedMergeRow === true) {
                mergeRow(i, j);
                preRow[i] = preCol[j];
              } else {
                createOneEl(i, j);
              }
            } else if (i === 0 && j > startCol) {
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol === true) {
                mergeCol(i, j);
                preCol[j] = preRow[i];
              } else {
                createOneEl(i, j);
              }
            } else {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol && isNeedMergeRow) {
                continue; // mergeRow(i, j);//优先合并列
              }

              if (isNeedMergeCol) {
                mergeCol(i, j);
              }

              if (isNeedMergeRow) {
                mergeRow(i, j);
              }

              if (!isNeedMergeCol && !isNeedMergeRow) {
                createOneEl(i, j);
              }
            }
          } else {
            createOneEl(i, j);
          }
        }
      });
      var tree = [];
      var prefix = BI.UUID();
      BI.each(result, function (i, item) {
        var layout = {
          type: "bi.vertical",
          scrolly: false,
          items: [{
            type: "bi.layout",
            tagName: "input",
            cls: "spread-sequence-table-checkbox",
            invisible: true,
            attributes: {
              type: "checkbox",
              id: prefix + "-" + item.item._row + "-" + item.item._col
            }
          }, !items[item.item._row][item.item._col].children ? {
            type: "bi.layout"
          } : {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            cls: "summary-line",
            items: [{
              el: createNode(item, {
                width: summaryColumnSize[endCol - 1] - (item.item._col > 0 ? summaryColumnSize[item.item._col - 1] : 0) // height: o.rowSize

              }, true)
            }, getLeaves(getSummaryRow(item.item._row, item.item._col))]
          }, {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            cls: "expand-line",
            items: [{
              el: !item.parent && o.showSequence === true ? createNodes(item) : {
                type: "bi.vtape",
                width: item.item._width,
                scrolly: false,
                scrollable: false,
                items: createNodes(item)
              }
            }, {
              type: "bi.vertical",
              scrolly: false,
              items: []
            }]
          }]
        };
        item.layout = layout;

        if (item.parent) {
          getNext(item.parent).push(layout);
        }
      });

      function _createNode(item, options, isPlus, hasIcon) {
        return BI.extend({
          type: "bi.label",
          textAlign: "left",
          lgap: 25,
          width: item.item._width,
          height: rowHeight,
          _columnIndex: item.item._col,
          _rowIndex: item.item._row,
          firstRowTopLine: false,
          firstColumnLeftLine: true,
          extraCls: "collection-cell" + (item.item._row === 0 ? " first-row" : "") + (item.item._col === 0 ? " first-col" : ""),
          mounted: function mounted() {
            if (hasIcon && !item.isLastNode) {
              BI.createWidget({
                type: "bi.absolute_vertical_adapt",
                element: this,
                lgap: 6,
                items: [{
                  type: "bi.icon_button",
                  tagName: "label",
                  attributes: {
                    "for": prefix + "-" + item.item._row + "-" + item.item._col
                  },
                  cls: (isPlus ? "plus-font" : "minus-font") + " icon-size-12",
                  iconWidth: 12,
                  iconHeight: 12,
                  width: 12,
                  height: 12
                }]
              });
            }
          } // height: item.item._height

        }, options, items[item.item._row][item.item._col]);
      }

      function createNode(item, options, isPlus) {
        var node = _createNode(item, options, isPlus, true);

        if (!item.parent && o.showSequence === true) {
          // 序号显示逐行递增，但最后一行的序号样式和文本需要由summaryCellStyleGetter和summaryText决定
          var isSummarySeq = items.length - 1 === item.item._row;
          return {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            items: [{
              type: "bi.table_style_cell",
              cls: "sequence-table-title-cell",
              width: o.seqWidth,
              styleGetter: function (key) {
                return function () {
                  return isSummarySeq ? o.summaryCellStyleGetter(true) : o.sequenceCellStyleGetter(key);
                };
              }(count),
              text: isPlus ? count : isSummarySeq ? o.summaryText : count++,
              _store: o.tableStyleCellStoreGetter
            }, {
              el: node
            }]
          };
        }

        return node;
      }

      function createNodes(item, options, isPlus) {
        var node = _createNode(item, options, isPlus, true);

        var current = items[item.item._row][item.item._col];
        var isLastNode = !current.children || current.children.length === 0;

        if (!item.parent && o.showSequence === true) {
          var isSummarySeq = items.length - 1 === item.item._row;
          return {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            items: [{
              type: "bi.table_style_cell",
              cls: "sequence-table-title-cell",
              width: o.seqWidth,
              styleGetter: function (key) {
                return function () {
                  return isSummarySeq ? o.summaryCellStyleGetter(true) : o.sequenceCellStyleGetter(key);
                };
              }(count),
              text: isPlus ? count : isSummarySeq ? o.summaryText : count++,
              _store: o.tableStyleCellStoreGetter
            }, {
              el: {
                type: "bi.vtape",
                width: item.item._width,
                scrolly: false,
                scrollable: false,
                items: isLastNode ? [{
                  el: node
                }] : BI.map([node].concat(BI.map(BI.range(item.item.__mergeRows.length - 1), function () {
                  return _createNode(item, options, isPlus, false);
                })), function (i, node) {
                  return {
                    el: node,
                    height: rowHeight
                  };
                })
              }
            }]
          };
        }

        return isLastNode ? [{
          el: node
        }] : BI.map([node].concat(BI.map(BI.range(item.item.__mergeRows.length - 1), function () {
          return _createNode(item, options, isPlus, false);
        })), function (i, node) {
          return {
            el: node,
            height: rowHeight
          };
        });
      }

      function getSummaryRow(i, j) {
        var item = map[i][j];

        if (o.rowPosition === "bottom") {
          return i + item.__mergeRows.length - 1;
        } else {
          return i;
        }
      }

      function getNext(item) {
        return item.layout.items[2].items[1].items;
      }

      function getLeaves(row) {
        var leaves = items[row].slice(endCol);
        return {
          type: "bi.vertical_adapt",
          items: BI.map(leaves, function (i, leaf) {
            return BI.extend({
              type: "bi.label",
              width: columnSize[endCol + i],
              height: rowHeight,
              extraCls: "collection-cell"
            }, leaf);
          })
        };
      }

      BI.each(result, function (i, item) {
        // 叶子节点
        if (getNext(item).length === 0) {
          var leaves = getLeaves(item.item._row);
          item.isLastNode = true;
          getNext(item).push(leaves);
        }

        if (!item.parent) {
          tree.push(item.layout);
        }
      });
      return tree;
    },
    _populate: function _populate(header, items) {
      if (this._isNeedDigest === true) {
        this._digestTable(header, items);
      }

      this._isNeedDigest = false;

      this._populateTable(header, items);
    },
    getRegionSize: function getRegionSize() {
      var o = this.options;
      var regionSize = o.regionColumnSize[0] || 0;

      if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
        return 0;
      }

      if (!regionSize) {
        BI.each(o.freezeCols, function (i, col) {
          regionSize += o.columnSize[col];
        });
      }

      return regionSize;
    },
    setVerticalScroll: function setVerticalScroll(scrollTop) {},
    setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
    setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
    getVerticalScroll: function getVerticalScroll() {},
    getLeftHorizontalScroll: function getLeftHorizontalScroll() {},
    getRightHorizontalScroll: function getRightHorizontalScroll() {},
    setColumnSize: function setColumnSize(columnSize) {
      this._isNeedDigest = true;
      this.options.columnSize = columnSize;
    },
    setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
      this._isNeedDigest = true;
      this.options.regionColumnSize = regionColumnSize;
    },
    getColumnSize: function getColumnSize() {
      return this.options.columnSize;
    },
    getRegionColumnSize: function getRegionColumnSize() {
      return this.options.regionColumnSize;
    },
    _restore: function _restore() {
      // this.topLeftCollection.restore();
      this.topRightCollection.restore(); // this.bottomLeftCollection.restore();
      // this.bottomRightCollection.restore();
    },
    restore: function restore() {
      this._restore();
    }
  });
  BI.shortcut("bi.spread_sequence_list_table", Widget);
}();

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Widget = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-spread-sequence-table",
      el: {},
      isNeedResize: true,
      // 是否需要调整列宽
      freezeCols: [],
      // 冻结的列号,从0开始,isNeedFreeze为tree时生效
      isNeedMerge: true,
      // 是否需要合并单元格
      mergeCols: [],
      mergeRule: BI.emptyFn,
      isNeedMergeCol: true,
      // 是否横向合并
      isNeedMergeRow: true,
      // 是否纵向合并
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 25,
      rowSize: 25,
      regionColumnSize: [],
      headerCellStyleGetter: BI.emptyFn,
      summaryCellStyleGetter: BI.emptyFn,
      sequenceCellStyleGetter: BI.emptyFn,
      // 传给汇总、序号单元格的store，能在单元格绘制时使用上下文中的cssScale
      tableStyleCellStoreGetter: null,
      sequenceHeaderCreator: BI.emptyFn,
      sequenceSummaryText: BI.i18nText("BI-Summary_Values"),
      header: [],
      items: [],
      // 交叉表头
      crossHeader: [],
      crossItems: [],
      // 汇总行位置
      summaryText: BI.i18nText("BI-Summary_Values"),
      rowPosition: "bottom",
      colPosition: "right",
      showInnerSummary: false,
      showSequence: false,
      startSequence: 1,
      // 开始的序号
      seqWidth: 60
    },
    _getVDeep: function _getVDeep() {
      return this.options.crossHeader.length; // 纵向深度
    },
    _getHDeep: function _getHDeep() {
      var o = this.options;
      return Math.max(o.mergeCols.length, o.freezeCols.length, BI.TableTree.maxDeep(o.items) - 1);
    },
    render: function render() {
      var self = this,
          o = this.options;
      this._width = 0;
      this._height = 0;

      var data = this._digest();

      this.topRightCollection = BI.createWidget({
        type: "bi.collection_view",
        cellSizeAndPositionGetter: function cellSizeAndPositionGetter(index) {
          return self.topRightItems[index];
        }
      });
      this.bottomRight = BI.createWidget({
        type: "bi.vertical",
        scrolly: false
      });
      this.contextLayout = BI.createWidget({
        type: "bi.vertical",
        element: this,
        scrolly: false,
        scrollable: true,
        items: [o.showSequence ? {
          type: "bi.vertical_adapt",
          items: [BI.extend({
            type: "bi.table_style_cell",
            text: BI.i18nText("BI-Number_Index"),
            width: o.seqWidth,
            height: this._getFreezeHeaderHeight(data.header),
            styleGetter: o.headerCellStyleGetter,
            ref: function ref(_ref) {
              self.headerSeq = _ref;
            },
            _store: o.tableStyleCellStoreGetter
          }, o.sequenceHeaderCreator()), this.topRightCollection]
        } : {
          el: this.topRightCollection
        }, {
          el: this.bottomRight
        }]
      });

      if (data.header.length > 0 || data.items.length > 0) {
        this._digestTable(data.header, data.items);

        this._populate(data.header, data.items);
      }
    },
    _digest: function _digest() {
      var o = this.options;

      var deep = this._getHDeep();

      var vDeep = this._getVDeep();

      var header = BI.TableTree.formatHeader(o.header, o.crossHeader, o.crossItems, deep, vDeep, o.headerCellStyleGetter, {
        sumPosition: o.colPosition === "right",
        summaryText: o.summaryText
      });
      var items = BI.DynamicSummaryTreeTable.formatHorizontalItems(o.items, deep, false, o.summaryCellStyleGetter, {
        sumPosition: o.rowPosition === "bottom",
        summaryText: o.summaryText,
        isNeedMergeRow: o.isNeedMergeRow,
        tableStyleCellStoreGetter: o.tableStyleCellStoreGetter
      });
      var data = BI.DynamicSummaryTreeTable.formatSummaryItems(items, header, o.crossItems, deep);
      var columnSize = o.columnSize.slice();
      var minColumnSize = o.minColumnSize.slice();
      var maxColumnSize = o.maxColumnSize.slice();
      BI.removeAt(columnSize, data.deletedCols);
      BI.removeAt(minColumnSize, data.deletedCols);
      BI.removeAt(maxColumnSize, data.deletedCols);
      return {
        header: data.header,
        items: data.items,
        columnSize: columnSize,
        minColumnSize: minColumnSize,
        maxColumnSize: maxColumnSize
      };
    },
    populate: function populate(items, header, crossItems, crossHeader) {
      var o = this.options;

      if (items) {
        o.items = items;
      }

      if (header) {
        o.header = header;
      }

      if (crossItems) {
        o.crossItems = crossItems;
      }

      if (crossHeader) {
        o.crossHeader = crossHeader;
      }

      var data = this._digest(); // 表头所展示“序号”高度由headers决定，render的时候不一定传了header, 在populate的时候setHeight


      this.headerSeq && this.headerSeq.setHeight(this._getFreezeHeaderHeight(data.header));
      this.setColumnSize(data.columnSize);
      o.minColumnSize = data.minColumnSize;
      o.maxColumnSize = data.maxColumnSize;
      items = data.items;
      header = data.header;

      if (items && items !== this.options.items) {
        this._isNeedDigest = true;
        this.options.items = items;

        this._restore();
      }

      if (header && header !== this.options.header) {
        this._isNeedDigest = true;
        this.options.header = header;

        this._restore();
      }

      this._populate(header, items);
    },
    _getFreezeColLength: function _getFreezeColLength() {
      var o = this.options;
      return o.isNeedMerge === true ? BI.clamp(o.mergeCols.length, 0, o.columnSize.length) : 0;
    },
    _getFreezeHeaderHeight: function _getFreezeHeaderHeight(header) {
      var o = this.options;
      return header.length * o.headerRowSize;
    },
    _populateTable: function _populateTable(header, items) {
      var self = this,
          o = this.options;
      var regionSize = this.getRegionSize(),
          totalLeftColumnSize = 0,
          totalRightColumnSize = 0,
          totalColumnSize = 0,
          summaryColumnSizeArray = [];
      BI.each(o.columnSize, function (i, size) {
        if (o.isNeedFreeze === true && o.freezeCols.includes(i)) {
          totalLeftColumnSize += size;
        } else {
          totalRightColumnSize += size;
        }

        totalColumnSize += size;

        if (i === 0) {
          summaryColumnSizeArray[i] = size;
        } else {
          summaryColumnSizeArray[i] = summaryColumnSizeArray[i - 1] + size;
        }
      }); // var otlw = regionSize;
      // var otlh = this._getFreezeHeaderHeight(header);
      // var otrw = this._width - regionSize;
      // var otrh = this._getFreezeHeaderHeight(header);
      // var oblw = regionSize;
      // var oblh = this._height - otlh;
      // var obrw = this._width - regionSize;
      // var obrh = this._height - otrh;
      // var scrollBarSize = BI.DOM.getScrollWidth();
      // var tlw = otlw + scrollBarSize;
      // var tlh = otlh + scrollBarSize;
      // var trw = otrw + scrollBarSize;
      // var trh = otrh + scrollBarSize;
      // var blw = oblw + scrollBarSize;
      // var blh = oblh + scrollBarSize;
      // var brw = obrw + scrollBarSize;
      // var brh = obrh + scrollBarSize;
      //
      // var digest = function (el) {
      //     el.element.css({
      //         overflow: "scroll",
      //         overflowX: "scroll",
      //         overflowY: "scroll"
      //     });
      // };
      // this.topLeft.setWidth(otlw);
      // this.topLeft.setHeight(otlh);
      // this.topRight.setWidth(otrw);
      // this.topRight.setHeight(otrh);
      // this.bottomLeft.setWidth(oblw);
      // this.bottomLeft.setHeight(oblh);
      // this.bottomRight.setWidth(obrw);
      // this.bottomRight.setHeight(obrh);
      // this.topLeftCollection.setWidth(tlw);
      // this.topLeftCollection.setHeight(tlh);

      this.topRightCollection.setWidth(totalColumnSize);
      this.topRightCollection.setHeight(this._getFreezeHeaderHeight(header)); // this.bottomLeftCollection.setWidth(blw);
      // this.bottomLeftCollection.setHeight(blh);
      // this.bottomRightCollection.setWidth(brw);
      // this.bottomRightCollection.setHeight(brh);
      // digest(this.topLeftCollection);
      // digest(this.topRightCollection);
      // digest(this.bottomLeftCollection);
      // digest(this.bottomRightCollection);
      // var items = this.contextLayout.attr("items");
      // items[1].left = regionSize;
      // items[1].top = this._getFreezeHeaderHeight(header);
      // items[3].left = regionSize;
      // items[3].top = this._getFreezeHeaderHeight();
      // this.contextLayout.attr("items", items);
      // this.contextLayout.resize();

      var leftHeader = [],
          rightHeader = [],
          leftItems = [],
          rightItems = [];

      var run = function run(positions, items, rendered, firstRowTopLine, firstColumnLeftLine) {
        BI.each(positions, function (i, item) {
          if (!firstRowTopLine && o.customCell) {
            items[item.row][item.col]._rowIndex = item.row;
            items[item.row][item.col]._columnIndex = item.col;
            items[item.row][item.col].firstRowTopLine = firstRowTopLine;
            items[item.row][item.col].firstColumnLeftLine = firstColumnLeftLine;
            rendered.push(items[item.row][item.col]);
            return;
          }

          var cell = {
            type: "bi.collection_table_cell",
            cell: items[item.row][item.col],
            _rowIndex: item.row,
            _columnIndex: item.col,
            firstRowTopLine: firstRowTopLine,
            firstColumnLeftLine: firstColumnLeftLine
          };
          rendered.push(cell);
        });
      }; // run(this.topLeftItems, header, leftHeader, true, true);


      run(this.topRightItems, header, rightHeader, true, true); // run(this.bottomLeftItems, this._getActualItems(), leftItems, this.topRightItems.length <= 0, true);
      // run(this.bottomRightItems, this._getActualItems(), rightItems, this.topRightItems.length <= 0, this.topLeftItems.length <= 0);
      // this.topLeftCollection._populate(leftHeader);

      this.topRightCollection._populate(rightHeader); // this.bottomLeftCollection._populate(leftItems);
      // this.bottomRightCollection._populate(rightItems);


      this.bottomRight.populate(this.bottomRightItems);
    },
    _digestTable: function _digestTable(header, items) {
      var o = this.options;

      var freezeColLength = this._getFreezeColLength(); // // 如果表头位置不够，取消表头冻结
      // if (this._getFreezeHeaderHeight() <= 0) {
      //     this.topLeftItems = [];
      //     this.topRightItems = [];
      //     this.bottomLeftItems = this._serialize(this._getActualItems(), 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length));
      //     this.bottomRightItems = this._serialize(this._getActualItems(), freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length));
      // } else {
      // this.topLeftItems = this._serialize(header, 0, freezeColLength, o.headerRowSize, o.columnSize, o.mergeCols);


      this.topRightItems = BI.CollectionTable.serialize(header, 0, o.columnSize.length, o.headerRowSize, o.columnSize, true, [], o.mergeRule); // this.bottomLeftItems = this._serialize(o.items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols);
      // this.bottomRightItems = this._serialize(o.items, freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols);
      // }

      this.bottomRightItems = this._serializeItems(items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols);
    },
    _serializeItems: function _serializeItems(items, startCol, endCol, rowHeight, columnSize, mergeCols, mergeRows) {
      mergeCols = mergeCols || [];
      mergeRows = mergeRows || [];
      var self = this,
          o = this.options;
      var count = o.startSequence;
      var result = [],
          cache = {},
          preCol = {},
          preRow = {},
          map = {};
      var summaryColumnSize = [];

      for (var i = startCol; i < endCol; i++) {
        if (i === startCol) {
          summaryColumnSize[i] = columnSize[i];
        } else {
          summaryColumnSize[i] = summaryColumnSize[i - 1] + columnSize[i];
        }
      }

      var mergeRow = function mergeRow(i, j) {
        preCol[j]._height += rowHeight;

        preCol[j].__mergeRows.push(i); //指向前一列


        preRow[i] = preCol[j];
      };

      var mergeCol = function mergeCol(i, j) {
        preRow[i]._width += columnSize[j];

        preRow[i].__mergeCols.push(j);
      };

      var createOneEl = function createOneEl(r, c) {
        var width = columnSize[c];
        var height = rowHeight;
        map[r][c]._row = r;
        map[r][c]._col = c;
        map[r][c]._width = width;
        map[r][c]._height = height;
        var el = {
          x: summaryColumnSize[c] - columnSize[c],
          y: +r * rowHeight,
          item: map[r][c],
          parent: preRow[r] && preRow[r].el
        };
        preCol[c] = map[r][c];
        preCol[c].__mergeRows = [r];
        preRow[r] = map[r][c];
        preRow[r].__mergeCols = [c];
        preRow[r].el = el;
        result.push(el);
      };

      BI.each(items, function (i, cols) {
        for (var j = startCol; j < endCol; j++) {
          if (!cache[i]) {
            cache[i] = {};
          }

          if (!map[i]) {
            map[i] = {};
          }

          cache[i][j] = cols[j];
          map[i][j] = {};

          if (mergeCols === true || mergeCols.indexOf(j) > -1 || mergeRows === true || mergeRows.indexOf(i) > -1) {
            if (i === 0 && j === startCol) {
              createOneEl(0, startCol);
            } else if (j === startCol && i > 0) {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);

              if (isNeedMergeRow === true) {
                mergeRow(i, j);
                preRow[i] = preCol[j];
              } else {
                createOneEl(i, j);
              }
            } else if (i === 0 && j > startCol) {
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol === true) {
                mergeCol(i, j);
                preCol[j] = preRow[i];
              } else {
                createOneEl(i, j);
              }
            } else {
              var isNeedMergeRow = o.mergeRule(cache[i][j], cache[i - 1][j]);
              var isNeedMergeCol = o.mergeRule(cache[i][j], cache[i][j - 1]);

              if (isNeedMergeCol && isNeedMergeRow) {
                continue; // mergeRow(i, j);//优先合并列
              }

              if (isNeedMergeCol) {
                mergeCol(i, j);
              }

              if (isNeedMergeRow) {
                mergeRow(i, j);
              }

              if (!isNeedMergeCol && !isNeedMergeRow) {
                createOneEl(i, j);
              }
            }
          } else {
            createOneEl(i, j);
          }
        }
      });
      var tree = [];
      var prefix = BI.UUID();
      BI.each(result, function (i, item) {
        var layout = {
          type: "bi.vertical",
          scrolly: false,
          items: [{
            type: "bi.layout",
            tagName: "input",
            cls: "spread-sequence-table-checkbox",
            invisible: true,
            attributes: {
              type: "checkbox",
              id: prefix + "-" + item.item._row + "-" + item.item._col
            }
          }, !items[item.item._row][item.item._col].children ? {
            type: "bi.layout"
          } : {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            cls: "summary-line",
            items: [{
              el: createNode(item, {
                width: summaryColumnSize[endCol - 1] - (item.item._col > 0 ? summaryColumnSize[item.item._col - 1] : 0) // height: o.rowSize

              }, true)
            }, getLeaves(getSummaryRow(item.item._row, item.item._col))]
          }, {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            cls: "expand-line",
            items: [{
              el: createNode(item)
            }, {
              type: "bi.vertical",
              scrolly: false,
              items: []
            }]
          }]
        };
        item.layout = layout;

        if (item.parent) {
          getNext(item.parent).push(layout);
        }
      });

      function createNode(item, options, isPlus) {
        var node = BI.extend({
          type: "bi.label",
          textAlign: "left",
          lgap: 25,
          width: item.item._width,
          // height: item.item._height,
          _columnIndex: item.item._col,
          _rowIndex: item.item._row,
          firstRowTopLine: false,
          firstColumnLeftLine: true,
          extraCls: "collection-cell" + (item.item._row === 0 ? " first-row" : "") + (item.item._col === 0 ? " first-col" : ""),
          mounted: function mounted() {
            if (!item.isLastNode) {
              BI.createWidget({
                type: "bi.absolute_vertical_adapt",
                element: this,
                lgap: 6,
                items: [{
                  type: "bi.icon_button",
                  tagName: "label",
                  attributes: {
                    "for": prefix + "-" + item.item._row + "-" + item.item._col
                  },
                  cls: (isPlus ? "plus-font" : "minus-font") + " icon-size-12",
                  iconWidth: 12,
                  iconHeight: 12,
                  width: 12,
                  height: 12
                }]
              });
            }
          } // height: item.item._height

        }, options, items[item.item._row][item.item._col]);

        if (!item.parent && o.showSequence === true) {
          // 序号显示逐行递增，但最后一行的序号的样式和文本需要由summaryCellStyleGetter和summaryText决定
          var isSummarySeq = items.length - 1 === item.item._row;
          return {
            type: "bi.vertical_adapt",
            verticalAlign: "stretch",
            items: [{
              type: "bi.table_style_cell",
              cls: "sequence-table-title-cell",
              width: o.seqWidth,
              styleGetter: function (key) {
                return function () {
                  return isSummarySeq ? o.summaryCellStyleGetter(true) : o.sequenceCellStyleGetter(key);
                };
              }(count),
              text: isPlus ? count : isSummarySeq ? o.summaryText : count++,
              _store: o.tableStyleCellStoreGetter
            }, {
              el: node
            }]
          };
        }

        return node;
      }

      function getSummaryRow(i, j) {
        var item = map[i][j];

        if (o.rowPosition === "bottom") {
          return i + item.__mergeRows.length - 1;
        } else {
          return i;
        }
      }

      function getNext(item) {
        return item.layout.items[2].items[1].items;
      }

      function getLeaves(row) {
        var leaves = items[row].slice(endCol);
        return {
          type: "bi.vertical_adapt",
          items: BI.map(leaves, function (i, leaf) {
            return BI.extend({
              type: "bi.label",
              width: columnSize[endCol + i],
              height: rowHeight,
              extraCls: "collection-cell"
            }, leaf);
          })
        };
      }

      BI.each(result, function (i, item) {
        // 叶子节点
        if (getNext(item).length === 0) {
          var leaves = getLeaves(item.item._row);
          item.isLastNode = true;
          getNext(item).push(leaves);
        }

        if (!item.parent) {
          tree.push(item.layout);
        }
      });
      return tree;
    },
    _populate: function _populate(header, items) {
      if (this._isNeedDigest === true) {
        this._digestTable(header, items);
      }

      this._isNeedDigest = false;

      this._populateTable(header, items);
    },
    getRegionSize: function getRegionSize() {
      var o = this.options;
      var regionSize = o.regionColumnSize[0] || 0;

      if (o.isNeedFreeze === false || o.freezeCols.length === 0) {
        return 0;
      }

      if (!regionSize) {
        BI.each(o.freezeCols, function (i, col) {
          regionSize += o.columnSize[col];
        });
      }

      return regionSize;
    },
    setVerticalScroll: function setVerticalScroll(scrollTop) {},
    setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
    setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
    getVerticalScroll: function getVerticalScroll() {},
    getLeftHorizontalScroll: function getLeftHorizontalScroll() {},
    getRightHorizontalScroll: function getRightHorizontalScroll() {},
    setColumnSize: function setColumnSize(columnSize) {
      this._isNeedDigest = true;
      this.options.columnSize = columnSize;
    },
    setRegionColumnSize: function setRegionColumnSize(regionColumnSize) {
      this._isNeedDigest = true;
      this.options.regionColumnSize = regionColumnSize;
    },
    getColumnSize: function getColumnSize() {
      return this.options.columnSize;
    },
    getRegionColumnSize: function getRegionColumnSize() {
      return this.options.regionColumnSize;
    },
    _restore: function _restore() {
      // this.topLeftCollection.restore();
      this.topRightCollection.restore(); // this.bottomLeftCollection.restore();
      // this.bottomRightCollection.restore();
    },
    restore: function restore() {
      this._restore();
    }
  });
  BI.shortcut("bi.spread_sequence_table", Widget);
}();

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(42);

var _stickytable2 = __webpack_require__(72);

__webpack_require__(71);

var _excluded = ["items", "id", "pId", "layer", "isParent", "draggable", "checkable", "open", "prevComponent"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * StickyTable
 *
 * Created by GUY on 2022/9/24.
 * @class StickyTable
 * @extends BI.Widget
 */
var FreezeTable = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(FreezeTable.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-sticky-table",
      headerRowSize: 30,
      rowSize: 30,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      freezeCols: [0],
      scrollLeft: 0,
      scrollTop: 0,
      sortable: true,
      checkable: true,
      bordered: false,
      stripe: false,
      hover: false,
      header: [],
      items: [],
      itemsCreator: BI.emptyFn
    });
  },
  // attr: function (key, value) {
  //     var v = FreezeTable.superclass.attr.apply(this, arguments);
  //     if (!value) {
  //         return v;
  //     }
  //     return this.tableColletion.attr.apply(this.tableColletion, arguments);
  // },
  render: function render() {
    var _this = this,
        _listeners;

    var self = this,
        o = this.options;
    this.headerColletion = BI.createWidget({
      type: "bi.sticky_table_header",
      css: {
        overflowY: "scroll",
        overflowX: "hidden"
      },
      columnSize: o.columnSize,
      minColumnSize: o.minColumnSize,
      maxColumnSize: o.maxColumnSize,
      freezeCols: o.freezeCols.slice(),
      header: o.header,
      headerRowSize: o.headerRowSize
    });
    this.bottomRightCollection = BI.createWidget({
      type: "bi.virtual_tree_list",
      css: {
        overflowY: "scroll",
        overflowX: "auto"
      },
      items: this._formatItems(o.items),
      itemsCreator: function itemsCreator(op, callback) {
        o.itemsCreator(op, function (items) {
          callback(_this._formatItems(items));
        });
      },
      el: {
        type: 'bi.virtual_group_list',
        configRender: function configRender(render) {
          return _objectSpread(_objectSpread({}, render), {}, {
            scrolly: false
          });
        },
        listeners: [{
          eventName: "EVENT_CHANGE",
          action: function action() {
            self.fireEvent("EVENT_CHANGE", arguments);
          }
        }],
        rowHeight: o.rowSize,
        el: {
          type: "bi.sticky_table_layout",
          ref: function ref(_ref) {
            _this.tableColletion = _ref;
          },
          mirror: {
            appendTo: this.element[0]
          },
          columnSize: o.columnSize,
          minColumnSize: o.minColumnSize,
          maxColumnSize: o.maxColumnSize,
          isNeedFreeze: o.isNeedFreeze,
          freezeCols: o.freezeCols.slice(),
          sortable: o.sortable,
          checkable: o.checkable,
          listeners: (_listeners = {}, _defineProperty(_listeners, _stickytable2.StickyTableLayout.EVENT_STOP_DRAG, function (move) {
            BI.nextTick(function () {
              _this.bottomRightCollection.move(move[0], move[1]);

              _this.fireEvent("EVENT_STOP_DRAG", _this.bottomRightCollection.getTree(), move[0], move[1]);

              _this.fireEvent("EVENT_SORT", _this.bottomRightCollection.getTree(), move[0], move[1]);
            });
          }), _defineProperty(_listeners, _stickytable2.StickyTableLayout.EVENT_START_DRAG, function (sourceId) {
            o.scrollLeft = 0;

            _this._scrollHandler();

            _this.bottomRightCollection.element.scrollLeft(0);

            _this.headerColletion.element.scrollLeft(0);

            _this.fireEvent("EVENT_START_DRAG", _this.bottomRightCollection.getTree(), sourceId);
          }), _listeners)
        }
      }
    });
    this.contextLayout = BI.createWidget({
      type: "bi.vertical_fill",
      rowSize: ["", "fill"],
      cls: "".concat(o.bordered ? "bordered" : "", " ").concat(o.stripe ? "stripe" : "", " ").concat(o.hover ? "hover" : ""),
      element: this,
      items: [{
        el: this.headerColletion
      }, {
        el: this.bottomRightCollection
      }]
    });
  },
  _scrollHandler: function _scrollHandler() {
    var o = this.options;

    if (o.scrollLeft > 0) {
      this.element.addClass("fixed-left-scroll");
    } else {
      this.element.removeClass("fixed-left-scroll");
    }

    var containerWidth = this.tableColletion.table.element.width();
    var clientWidth = this.element.width();

    if (containerWidth - (o.scrollLeft + clientWidth - BI.GridTableScrollbar.SIZE) < 1) {
      this.element.removeClass("fixed-right-scroll");
    } else {
      this.element.addClass("fixed-right-scroll");
    }
  },
  _freeHandler: function _freeHandler() {
    var _this2 = this;

    // 冻结列不止第一列和最后一列
    if (this._hasOtherFreezeCol()) {
      var realColumnSize = this.headerColletion.getRealColumnSize();
      this.options.freezeCols.forEach(function (col) {
        var firstRowLength = _this2.options.header[0].length;

        if (col !== 0 && col !== firstRowLength - 1) {
          _this2.element[0].style.setProperty("--index-".concat(col, "-left"), "".concat(realColumnSize.slice(0, col).reduce(function (item, sum) {
            return sum + item;
          }, 0), "px"));
        }
      });
    }
  },
  _handleResize: function _handleResize() {
    this.options.scrollLeft = this.bottomRightCollection.element.scrollLeft();

    this._scrollHandler();

    this._freeHandler();
  },
  _hasOtherFreezeCol: function _hasOtherFreezeCol() {
    var o = this.options;
    return BI.some(o.freezeCols, function (i, col) {
      var firstRowLength = o.header[0].length;

      if (col !== 0 && col !== firstRowLength - 1) {
        return true;
      }
    });
  },
  mounted: function mounted() {
    var _this3 = this;

    var o = this.options;

    if (o.header.length > 0 || o.items.length > 0) {
      this._digest();

      this._populate();
    }

    this._scrollHandler();

    this._freeHandler();

    this.bottomRightCollection.element.scroll(function () {
      o.scrollTop = _this3.bottomRightCollection.element.scrollTop();
      o.scrollLeft = _this3.bottomRightCollection.element.scrollLeft();

      _this3._scrollHandler();

      _this3.headerColletion.element.scrollLeft(o.scrollLeft);
    });
    this.resizeObserver = BI.ResizeDetector.addResizeListener(this, this._handleResize.bind(this)); // this.headerColletion.element.scroll(() => {
    //     o.scrollLeft = this.headerColletion.element.scrollLeft();
    //     this.bottomRightCollection.element.scrollLeft(o.scrollLeft);
    // });
  },
  destroyed: function destroyed() {
    this.resizeObserver();
  },
  _populateTable: function _populateTable() {
    var self = this,
        o = this.options;
    this.headerColletion.populate(o.header);
    this.bottomRightCollection.populate(this._formatItems(o.items));
  },
  _formatItems: function _formatItems(items) {
    var _this4 = this;

    return items.map(function (_ref2) {
      var items = _ref2.items,
          id = _ref2.id,
          pId = _ref2.pId,
          layer = _ref2.layer,
          isParent = _ref2.isParent,
          draggable = _ref2.draggable,
          checkable = _ref2.checkable,
          open = _ref2.open,
          prevComponent = _ref2.prevComponent,
          others = _objectWithoutProperties(_ref2, _excluded);

      return {
        type: "bi.sticky_table_row",
        id: id,
        pId: pId,
        layer: layer,
        isParent: isParent,
        draggable: draggable,
        checkable: checkable,
        prevComponent: prevComponent,
        open: open,
        height: _this4.options.rowSize,
        dimension: others,
        items: items
      };
    });
  },
  _digest: function _digest() {
    var o = this.options; // var freezeColLength = this._getFreezeColLength();
    // 如果表头位置不够，取消表头冻结
    // if (this._getFreezeHeaderHeight() <= 0) {
    //     this.topLeftItems = [];
    //     this.topRightItems = [];
    //     this.bottomLeftItems = BI.CollectionTable.serialize(this._getActualItems(), 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule);
    //     this.bottomRightItems = BI.CollectionTable.serialize(this._getActualItems(), freezeColLength, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, BI.range(o.header.length), o.mergeRule);
    // } else {
    // this.topRightItems = BI.CollectionTable.serialize(o.header, freezeColLength, o.columnSize.length, o.headerRowSize, o.columnSize, true, [], o.mergeRule);
    // this.bottomLeftItems = BI.CollectionTable.serialize(o.items, 0, freezeColLength, o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
    // this.bottomRightItems = BI.CollectionTable.serialize(o.items, 0, o.columnSize.length, o.rowSize, o.columnSize, o.mergeCols, [], o.mergeRule);
    // }
  },
  _populate: function _populate() {
    this._populateTable();
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    return this.bottomRightCollection.scrollTo(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
  getVerticalScroll: function getVerticalScroll() {
    return this.options.scrollTop;
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.options.scrollLeft;
  },
  setWidth: function setWidth(width) {
    FreezeTable.superclass.setWidth.apply(this, arguments);
    this._width = this.options.width - BI.GridTableScrollbar.SIZE;
  },
  setHeight: function setHeight(height) {
    FreezeTable.superclass.setHeight.apply(this, arguments);
    this._height = this.options.height - BI.GridTableScrollbar.SIZE;
  },
  setColumnSize: function setColumnSize(columnSize) {
    var o = this.options;
    this._isNeedDigest = true;
    this.options.columnSize = columnSize;
    this.headerColletion.setColumnSize(columnSize);
    this.tableColletion.setColumnSize(columnSize);

    this._scrollHandler();

    this._freeHandler();
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  getRegionSize: function getRegionSize() {
    return 0;
  },
  getRegionColumnSize: function getRegionColumnSize() {
    return [];
  },
  setRegionColumnSize: function setRegionColumnSize() {},
  getValue: function getValue() {
    return this.bottomRightCollection.getValue();
  },
  populate: function populate(items, header) {
    if (items && items !== this.options.items) {
      this._isNeedDigest = true;
      this.options.items = items;

      this._restore();
    }

    if (header && header !== this.options.header) {
      this._isNeedDigest = true;
      this.options.header = header;

      this._restore();
    }

    this._populate();
  },
  _restore: function _restore() {},
  restore: function restore() {
    this._restore();
  }
});
BI.shortcut("bi.freeze_table", FreezeTable);
var Table = BI.TableComponnet = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(Table.superclass._defaultConfig.apply(this, arguments), {
      freezeCols: [],
      // 冻结的列号,从0开始
      isNeedMerge: false,
      mergeRule: BI.emptyFn,
      columnSize: [],
      minColumnSize: [],
      maxColumnSize: [],
      headerRowSize: 30,
      rowSize: 30,
      sortable: true,
      resizable: true,
      // API保持统一用这个
      checkable: true,
      bordered: false,
      stripe: true,
      hover: true,
      header: [],
      // 二维数组
      items: [],
      itemsCreator: BI.emptyFn
    });
  },
  attr: function attr(key, value) {
    var v = Table.superclass.attr.apply(this, arguments);

    if (BI.isNull(value)) {
      return v;
    }

    return this.table.attr.apply(this.table, arguments);
  },
  render: function render() {
    var _this5 = this;

    var o = this.options;

    if (o.items[0] && o.items[0].length > 0) {
      return {
        type: "bi.resizable_table",
        ref: function ref(_ref) {
          _this5.table = _ref;
        },
        el: {
          type: "bi.table_view",
          bordered: o.bordered,
          stripe: o.stripe,
          hover: o.hover
        },
        width: o.width,
        height: o.height,
        isNeedFreeze: true,
        freezeCols: o.freezeCols,
        isNeedResize: o.isNeedResize || o.resizable,
        minColumnSize: o.minColumnSize,
        maxColumnSize: o.maxColumnSize,
        columnSize: o.columnSize,
        headerRowSize: o.headerRowSize,
        rowSize: o.rowSize,
        isNeedMerge: o.isNeedMerge,
        mergeRule: o.mergeRule,
        header: o.header,
        items: o.items
      };
    }

    return {
      type: "bi.resizable_table",
      ref: function ref(_ref) {
        _this5.table = _ref;
      },
      el: {
        type: "bi.freeze_table",
        ref: function ref(_ref) {
          _this5.innerTable = _ref;
        },
        listeners: [{
          eventName: "EVENT_SORT",
          action: function action() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this5.fireEvent.apply(_this5, ["EVENT_SORT"].concat(args));
          }
        }, {
          eventName: "EVENT_START_DRAG",
          action: function action() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            _this5.fireEvent.apply(_this5, ["EVENT_START_DRAG"].concat(args));
          }
        }, {
          eventName: "EVENT_STOP_DRAG",
          action: function action() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            _this5.fireEvent.apply(_this5, ["EVENT_STOP_DRAG"].concat(args));
          }
        }, {
          eventName: "EVENT_CHANGE",
          action: function action() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            _this5.fireEvent.apply(_this5, ["EVENT_CHANGE"].concat(args));
          }
        }],
        freezeCols: o.freezeCols,
        itemsCreator: o.itemsCreator,
        sortable: o.sortable,
        checkable: o.checkable,
        bordered: o.bordered,
        stripe: o.stripe,
        hover: o.hover
      },
      width: o.width,
      height: o.height,
      isNeedResize: o.isNeedResize || o.resizable,
      minColumnSize: o.minColumnSize,
      maxColumnSize: o.maxColumnSize,
      columnSize: o.columnSize,
      headerRowSize: o.headerRowSize,
      rowSize: o.rowSize,
      header: o.header,
      items: o.items
    };
  },
  setVerticalScroll: function setVerticalScroll(scrollTop) {
    return this.table.setVerticalScroll(scrollTop);
  },
  setLeftHorizontalScroll: function setLeftHorizontalScroll(scrollLeft) {},
  setRightHorizontalScroll: function setRightHorizontalScroll(scrollLeft) {},
  getVerticalScroll: function getVerticalScroll() {
    return this.table.getVerticalScroll();
  },
  getRightHorizontalScroll: function getRightHorizontalScroll() {
    return this.table.getRightHorizontalScroll();
  },
  setWidth: function setWidth(width) {
    Table.superclass.setWidth.apply(this, arguments);
    this.table.setWidth(width);
  },
  setHeight: function setHeight(height) {
    Table.superclass.setHeight.apply(this, arguments);
    this.table.setHeight(height);
  },
  setColumnSize: function setColumnSize(columnSize) {
    this.table.setColumnSize(columnSize);
  },
  getColumnSize: function getColumnSize() {
    return this.options.columnSize;
  },
  populate: function populate(items, header) {
    this.table.populate(items, header);
  },
  getValue: function getValue() {
    return this.innerTable.getValue();
  },
  restore: function restore() {
    this.table.restore();
  }
});
BI.shortcut("bi.components.table", Table);

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by astronaut007 on 2018/10/23
 */
!function () {
  BI.WaterMark = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-watermark",
      watermark: {},
      angle: 20 // 水印倾斜度数

    },
    mounted: function mounted() {
      var self = this;
      BI.$(this.container.paper.canvas).css({
        position: "absolute",
        zIndex: "99999",
        pointerEvents: "none"
      });
      this.canvas = BI.Func.createEmptyCanvas();

      this._paint();

      BI.ResizeDetector.addResizeListener(this, function () {
        self._paint();
      });
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.value = BI.extend({
        text: "",
        fontSize: 12,
        color: "#999",
        horizontalGap: 200,
        verticalGap: 100
      }, o.watermark);
      return {
        type: "bi.svg",
        ref: function ref(_ref) {
          self.container = _ref;
        }
      };
    },
    _initCanvas: function _initCanvas() {
      var containerWidth = this.container.element.width(),
          containerHeight = this.container.element.height();

      if (containerHeight === 0 || containerWidth === 0) {
        return false;
      }

      this.canvas.width = containerWidth;
      this.canvas.height = containerHeight;
      return true;
    },
    _initSvg: function _initSvg() {
      if (this.svgImage) {
        this.container.clear();
      }
    },
    _paint: function _paint() {
      if (this._initCanvas()) {
        this._initSvg(); // 将离屏canvas绘制的水印转为svg中的image元素


        BI.Func.paintWaterMark(this.canvas, this.value);
        var imgURL = this.canvas.toDataURL("image/png");
        this.svgImage = this.container.image(imgURL, 0, 0, this.canvas.width, this.canvas.height);
      }
    },
    setValue: function setValue(value) {
      this.value = BI.extend(this.value, value);

      this._paint();
    }
  });
  BI.shortcut("bi.watermark", BI.WaterMark);
}();

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by astronaut007 on 2018/10/23
 */
!function () {
  BI.DivWaterMark = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-div-watermark",
      watermark: {},
      angle: 20 // 水印倾斜度数

    },
    mounted: function mounted() {
      var self = this,
          o = this.options;
      this.element.css({
        fontSize: this.value.fontSize + "px",
        color: this.value.color
      });

      this._showWatermark();

      BI.ResizeDetector.addResizeListener(this, function () {
        self._showWatermark();
      });
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.value = BI.extend({
        text: "",
        fontSize: 12,
        color: "#999",
        horizontalGap: 200,
        verticalGap: 100
      }, o.watermark);
      this.deg = Math.PI / 180 * this.options.angle;
      this.markWidth = BI.DOM.getTextSizeWidth(this.value.text, this.value.fontSize) + this.value.horizontalGap;
      return {
        type: "bi.absolute",
        ref: function ref(_ref) {
          self.container = _ref;
        },
        items: [{
          el: {
            type: "bi.button_group",
            layouts: [{
              type: "bi.vertical",
              bgap: this.value.verticalGap
            }],
            cls: "watermark-container",
            ref: function ref(_ref2) {
              self.watermarkContainer = _ref2;
            }
          },
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }]
      };
    },
    setValue: function setValue(value) {
      this.value = BI.extend(this.value, value);

      this._showWatermark();
    },
    _showWatermark: function _showWatermark() {
      var self = this,
          o = this.options;
      var hgap = this.value.horizontalGap;
      this.markWidth = BI.DOM.getTextSizeWidth(this.value.text, this.value.fontSize) + hgap;

      var items = [],
          actualSize = this._getContainerSize();

      var textHeight = BI.DOM.getTextSizeHeight(this.value.text, this.value.fontSize);
      var watermarkHeight = textHeight + this.value.verticalGap;
      var col = BI.parseInt(actualSize.width / this.markWidth);
      var row = BI.parseInt(actualSize.height / watermarkHeight);

      var style = this._addFilterForOldIE();

      var texts = (this.value.text + "").split("\n");

      for (var r = 0; r < row + 3; r++) {
        var rowItems = [];

        for (var c = 0; c < col + 3; c++) {
          var markItem;

          if (texts.length > 1) {
            markItem = BI.createWidget({
              type: "bi.vertical",
              hgap: hgap / 2,
              items: BI.map(texts, function (i, text) {
                return {
                  type: "bi.label",
                  cls: "watermark-text",
                  text: text
                };
              })
            });
          } else {
            markItem = BI.createWidget({
              type: "bi.label",
              hgap: hgap / 2,
              cls: "watermark-text",
              text: this.value.text
            });
          }

          markItem.element.css(BI.extend({
            fontSize: self.value.fontSize + "px",
            color: self.value.color
          }, style));
          rowItems.push(markItem);
        }

        items.push({
          el: {
            type: "bi.horizontal",
            scrollx: false,
            items: rowItems
          },
          lgap: r % 2 === 0 ? -(this.markWidth / 2) : 0
        });
      }

      this.watermarkContainer.populate(items);
      this.container.attr("items")[0].left = -this._getContainerLeft();
      this.container.attr("items")[0].right = -this.markWidth;
      this.container.attr("items")[0].bottom = -this._getContainerBottom();
      this.container.resize();
    },
    _addFilterForOldIE: function _addFilterForOldIE() {
      if (BI.isIE9Below()) {
        var rad = -this.deg;
        var m11 = Math.cos(rad),
            m12 = -1 * Math.sin(rad),
            m21 = Math.sin(rad),
            m22 = m11;
        var filters = "progid:DXImageTransform.Microsoft.Chroma(color='white') progid:DXImageTransform.Microsoft.Matrix(M11=" + m11 + ",M12=" + m12 + ",M21=" + m21 + ",M22=" + m22 + ",SizingMethod='auto expand')";
        return {
          filter: filters
        };
      }

      return {};
    },
    _getContainerSize: function _getContainerSize() {
      var height = this.element.height(),
          width = this.element.width();
      return {
        width: width * Math.cos(this.deg) + height * Math.sin(this.deg),
        height: width * Math.sin(this.deg) + height / Math.cos(this.deg)
      };
    },
    _getContainerLeft: function _getContainerLeft() {
      var height = this.element.height();
      return height * Math.tan(Math.PI / 180 * 20);
    },
    _getContainerBottom: function _getContainerBottom() {
      return this._getContainerSize().height - this.element.height();
    }
  });
  BI.shortcut("bi.div.watermark", BI.DivWaterMark);
}();

/***/ }),
/* 207 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0; // needs a separate module as this is required inside chevrotain productive code
// and also in the entry point for webpack(api.ts).
// A separate file avoids cyclic dependencies and webpack errors.

exports.VERSION = "10.3.0";

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(68)))

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19),
    root = __webpack_require__(10);
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqualDeep = __webpack_require__(426),
    isObjectLike = __webpack_require__(12);
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SetCache = __webpack_require__(79),
    arraySome = __webpack_require__(215),
    cacheHas = __webpack_require__(80);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(10);
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetAllKeys = __webpack_require__(218),
    getSymbols = __webpack_require__(83),
    keys = __webpack_require__(5);
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(82),
    isArray = __webpack_require__(0);
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTimes = __webpack_require__(432),
    isArguments = __webpack_require__(48),
    isArray = __webpack_require__(0),
    isBuffer = __webpack_require__(49),
    isIndex = __webpack_require__(55),
    isTypedArray = __webpack_require__(76);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(11);
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseToString = __webpack_require__(438);
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(56),
    isArguments = __webpack_require__(48),
    isArray = __webpack_require__(0),
    isIndex = __webpack_require__(55),
    isLength = __webpack_require__(75),
    toKey = __webpack_require__(34);
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(82),
    getPrototype = __webpack_require__(229),
    getSymbols = __webpack_require__(83),
    stubArray = __webpack_require__(219);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var overArg = __webpack_require__(209);
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetAllKeys = __webpack_require__(218),
    getSymbolsIn = __webpack_require__(228),
    keysIn = __webpack_require__(59);
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsRegExp = __webpack_require__(480),
    baseUnary = __webpack_require__(31),
    nodeUtil = __webpack_require__(50);
/* Node.js helper references. */


var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */

var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
module.exports = isRegExp;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(32),
    baseIteratee = __webpack_require__(13),
    basePickBy = __webpack_require__(481),
    getAllKeysIn = __webpack_require__(230);
/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */


function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }

  var props = arrayMap(getAllKeysIn(object), function (prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function (value, path) {
    return predicate(value, path[0]);
  });
}

module.exports = pickBy;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.firstForTerminal = exports.firstForBranching = exports.firstForSequence = exports.first = void 0;

var flatten_1 = __importDefault(__webpack_require__(16));

var uniq_1 = __importDefault(__webpack_require__(98));

var map_1 = __importDefault(__webpack_require__(4));

var gast_1 = __webpack_require__(2);

var gast_2 = __webpack_require__(2);

function first(prod) {
  /* istanbul ignore else */
  if (prod instanceof gast_1.NonTerminal) {
    // this could in theory cause infinite loops if
    // (1) prod A refs prod B.
    // (2) prod B refs prod A
    // (3) AB can match the empty set
    // in other words a cycle where everything is optional so the first will keep
    // looking ahead for the next optional part and will never exit
    // currently there is no safeguard for this unique edge case because
    // (1) not sure a grammar in which this can happen is useful for anything (productive)
    return first(prod.referencedRule);
  } else if (prod instanceof gast_1.Terminal) {
    return firstForTerminal(prod);
  } else if ((0, gast_2.isSequenceProd)(prod)) {
    return firstForSequence(prod);
  } else if ((0, gast_2.isBranchingProd)(prod)) {
    return firstForBranching(prod);
  } else {
    throw Error("non exhaustive match");
  }
}

exports.first = first;

function firstForSequence(prod) {
  var firstSet = [];
  var seq = prod.definition;
  var nextSubProdIdx = 0;
  var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
  var currSubProd; // so we enter the loop at least once (if the definition is not empty

  var isLastInnerProdOptional = true; // scan a sequence until it's end or until we have found a NONE optional production in it

  while (hasInnerProdsRemaining && isLastInnerProdOptional) {
    currSubProd = seq[nextSubProdIdx];
    isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
    firstSet = firstSet.concat(first(currSubProd));
    nextSubProdIdx = nextSubProdIdx + 1;
    hasInnerProdsRemaining = seq.length > nextSubProdIdx;
  }

  return (0, uniq_1["default"])(firstSet);
}

exports.firstForSequence = firstForSequence;

function firstForBranching(prod) {
  var allAlternativesFirsts = (0, map_1["default"])(prod.definition, function (innerProd) {
    return first(innerProd);
  });
  return (0, uniq_1["default"])((0, flatten_1["default"])(allAlternativesFirsts));
}

exports.firstForBranching = firstForBranching;

function firstForTerminal(terminal) {
  return [terminal.terminalType];
}

exports.firstForTerminal = firstForTerminal;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIndexOf = __webpack_require__(96);
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IN = void 0; // TODO: can this be removed? where is it used?

exports.IN = "_~IN~_";

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.charCodeToOptimizedIndex = exports.minOptimizationVal = exports.buildLineBreakIssueMessage = exports.LineTerminatorOptimizedTester = exports.isShortPattern = exports.isCustomPattern = exports.cloneEmptyGroups = exports.performWarningRuntimeChecks = exports.performRuntimeChecks = exports.addStickyFlag = exports.addStartOfInput = exports.findUnreachablePatterns = exports.findModesThatDoNotExist = exports.findInvalidGroupType = exports.findDuplicatePatterns = exports.findUnsupportedFlags = exports.findStartOfInputAnchor = exports.findEmptyMatchRegExps = exports.findEndOfInputAnchor = exports.findInvalidPatterns = exports.findMissingPatterns = exports.validatePatterns = exports.analyzeTokenTypes = exports.enableSticky = exports.disableSticky = exports.SUPPORT_STICKY = exports.MODES = exports.DEFAULT_MODE = void 0;

var regexp_to_ast_1 = __webpack_require__(100);

var lexer_public_1 = __webpack_require__(63);

var first_1 = __importDefault(__webpack_require__(40));

var isEmpty_1 = __importDefault(__webpack_require__(9));

var compact_1 = __importDefault(__webpack_require__(64));

var isArray_1 = __importDefault(__webpack_require__(0));

var values_1 = __importDefault(__webpack_require__(15));

var flatten_1 = __importDefault(__webpack_require__(16));

var reject_1 = __importDefault(__webpack_require__(101));

var difference_1 = __importDefault(__webpack_require__(102));

var indexOf_1 = __importDefault(__webpack_require__(504));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var isString_1 = __importDefault(__webpack_require__(39));

var isFunction_1 = __importDefault(__webpack_require__(30));

var isUndefined_1 = __importDefault(__webpack_require__(22));

var find_1 = __importDefault(__webpack_require__(103));

var has_1 = __importDefault(__webpack_require__(7));

var keys_1 = __importDefault(__webpack_require__(5));

var isRegExp_1 = __importDefault(__webpack_require__(231));

var filter_1 = __importDefault(__webpack_require__(104));

var defaults_1 = __importDefault(__webpack_require__(241));

var reduce_1 = __importDefault(__webpack_require__(23));

var includes_1 = __importDefault(__webpack_require__(18));

var utils_1 = __webpack_require__(37);

var reg_exp_1 = __webpack_require__(508);

var reg_exp_parser_1 = __webpack_require__(105);

var PATTERN = "PATTERN";
exports.DEFAULT_MODE = "defaultMode";
exports.MODES = "modes";
exports.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";

function disableSticky() {
  exports.SUPPORT_STICKY = false;
}

exports.disableSticky = disableSticky;

function enableSticky() {
  exports.SUPPORT_STICKY = true;
}

exports.enableSticky = enableSticky;

function analyzeTokenTypes(tokenTypes, options) {
  options = (0, defaults_1["default"])(options, {
    useSticky: exports.SUPPORT_STICKY,
    debug: false,
    safeMode: false,
    positionTracking: "full",
    lineTerminatorCharacters: ["\r", "\n"],
    tracer: function tracer(msg, action) {
      return action();
    }
  });
  var tracer = options.tracer;
  tracer("initCharCodeToOptimizedIndexMap", function () {
    initCharCodeToOptimizedIndexMap();
  });
  var onlyRelevantTypes;
  tracer("Reject Lexer.NA", function () {
    onlyRelevantTypes = (0, reject_1["default"])(tokenTypes, function (currType) {
      return currType[PATTERN] === lexer_public_1.Lexer.NA;
    });
  });
  var hasCustom = false;
  var allTransformedPatterns;
  tracer("Transform Patterns", function () {
    hasCustom = false;
    allTransformedPatterns = (0, map_1["default"])(onlyRelevantTypes, function (currType) {
      var currPattern = currType[PATTERN];
      /* istanbul ignore else */

      if ((0, isRegExp_1["default"])(currPattern)) {
        var regExpSource = currPattern.source;

        if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
        regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
          return regExpSource;
        } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
        !(0, includes_1["default"])(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], regExpSource[1])) {
          // escaped meta Characters: /\+/ /\[/
          // or redundant escaping: /\a/
          // without the escaping "\"
          return regExpSource[1];
        } else {
          return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
        }
      } else if ((0, isFunction_1["default"])(currPattern)) {
        hasCustom = true; // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object

        return {
          exec: currPattern
        };
      } else if (_typeof(currPattern) === "object") {
        hasCustom = true; // ICustomPattern

        return currPattern;
      } else if (typeof currPattern === "string") {
        if (currPattern.length === 1) {
          return currPattern;
        } else {
          var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
          var wrappedRegExp = new RegExp(escapedRegExpString);
          return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
        }
      } else {
        throw Error("non exhaustive match");
      }
    });
  });
  var patternIdxToType;
  var patternIdxToGroup;
  var patternIdxToLongerAltIdxArr;
  var patternIdxToPushMode;
  var patternIdxToPopMode;
  tracer("misc mapping", function () {
    patternIdxToType = (0, map_1["default"])(onlyRelevantTypes, function (currType) {
      return currType.tokenTypeIdx;
    });
    patternIdxToGroup = (0, map_1["default"])(onlyRelevantTypes, function (clazz) {
      var groupName = clazz.GROUP;
      /* istanbul ignore next */

      if (groupName === lexer_public_1.Lexer.SKIPPED) {
        return undefined;
      } else if ((0, isString_1["default"])(groupName)) {
        return groupName;
      } else if ((0, isUndefined_1["default"])(groupName)) {
        return false;
      } else {
        throw Error("non exhaustive match");
      }
    });
    patternIdxToLongerAltIdxArr = (0, map_1["default"])(onlyRelevantTypes, function (clazz) {
      var longerAltType = clazz.LONGER_ALT;

      if (longerAltType) {
        var longerAltIdxArr = (0, isArray_1["default"])(longerAltType) ? (0, map_1["default"])(longerAltType, function (type) {
          return (0, indexOf_1["default"])(onlyRelevantTypes, type);
        }) : [(0, indexOf_1["default"])(onlyRelevantTypes, longerAltType)];
        return longerAltIdxArr;
      }
    });
    patternIdxToPushMode = (0, map_1["default"])(onlyRelevantTypes, function (clazz) {
      return clazz.PUSH_MODE;
    });
    patternIdxToPopMode = (0, map_1["default"])(onlyRelevantTypes, function (clazz) {
      return (0, has_1["default"])(clazz, "POP_MODE");
    });
  });
  var patternIdxToCanLineTerminator;
  tracer("Line Terminator Handling", function () {
    var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
    patternIdxToCanLineTerminator = (0, map_1["default"])(onlyRelevantTypes, function (tokType) {
      return false;
    });

    if (options.positionTracking !== "onlyOffset") {
      patternIdxToCanLineTerminator = (0, map_1["default"])(onlyRelevantTypes, function (tokType) {
        if ((0, has_1["default"])(tokType, "LINE_BREAKS")) {
          return !!tokType.LINE_BREAKS;
        } else {
          return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
        }
      });
    }
  });
  var patternIdxToIsCustom;
  var patternIdxToShort;
  var emptyGroups;
  var patternIdxToConfig;
  tracer("Misc Mapping #2", function () {
    patternIdxToIsCustom = (0, map_1["default"])(onlyRelevantTypes, isCustomPattern);
    patternIdxToShort = (0, map_1["default"])(allTransformedPatterns, isShortPattern);
    emptyGroups = (0, reduce_1["default"])(onlyRelevantTypes, function (acc, clazz) {
      var groupName = clazz.GROUP;

      if ((0, isString_1["default"])(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
        acc[groupName] = [];
      }

      return acc;
    }, {});
    patternIdxToConfig = (0, map_1["default"])(allTransformedPatterns, function (x, idx) {
      return {
        pattern: allTransformedPatterns[idx],
        longerAlt: patternIdxToLongerAltIdxArr[idx],
        canLineTerminator: patternIdxToCanLineTerminator[idx],
        isCustom: patternIdxToIsCustom[idx],
        "short": patternIdxToShort[idx],
        group: patternIdxToGroup[idx],
        push: patternIdxToPushMode[idx],
        pop: patternIdxToPopMode[idx],
        tokenTypeIdx: patternIdxToType[idx],
        tokenType: onlyRelevantTypes[idx]
      };
    });
  });
  var canBeOptimized = true;
  var charCodeToPatternIdxToConfig = [];

  if (!options.safeMode) {
    tracer("First Char Optimization", function () {
      charCodeToPatternIdxToConfig = (0, reduce_1["default"])(onlyRelevantTypes, function (result, currTokType, idx) {
        if (typeof currTokType.PATTERN === "string") {
          var charCode = currTokType.PATTERN.charCodeAt(0);
          var optimizedIdx = charCodeToOptimizedIndex(charCode);
          addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
        } else if ((0, isArray_1["default"])(currTokType.START_CHARS_HINT)) {
          var lastOptimizedIdx_1;
          (0, forEach_1["default"])(currTokType.START_CHARS_HINT, function (charOrInt) {
            var charCode = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
            var currOptimizedIdx = charCodeToOptimizedIndex(charCode); // Avoid adding the config multiple times

            /* istanbul ignore else */
            // - Difficult to check this scenario effects as it is only a performance
            //   optimization that does not change correctness

            if (lastOptimizedIdx_1 !== currOptimizedIdx) {
              lastOptimizedIdx_1 = currOptimizedIdx;
              addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
            }
          });
        } else if ((0, isRegExp_1["default"])(currTokType.PATTERN)) {
          if (currTokType.PATTERN.unicode) {
            canBeOptimized = false;

            if (options.ensureOptimizations) {
              (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "\tUnable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n" + "\tThis will disable the lexer's first char optimizations.\n" + "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
            }
          } else {
            var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
            /* istanbul ignore if */
            // start code will only be empty given an empty regExp or failure of regexp-to-ast library
            // the first should be a different validation and the second cannot be tested.

            if ((0, isEmpty_1["default"])(optimizedCodes)) {
              // we cannot understand what codes may start possible matches
              // The optimization correctness requires knowing start codes for ALL patterns.
              // Not actually sure this is an error, no debug message
              canBeOptimized = false;
            }

            (0, forEach_1["default"])(optimizedCodes, function (code) {
              addToMapOfArrays(result, code, patternIdxToConfig[idx]);
            });
          }
        } else {
          if (options.ensureOptimizations) {
            (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "\tTokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "\tThis will disable the lexer's first char optimizations.\n" + "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
          }

          canBeOptimized = false;
        }

        return result;
      }, []);
    });
  }

  return {
    emptyGroups: emptyGroups,
    patternIdxToConfig: patternIdxToConfig,
    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,
    hasCustom: hasCustom,
    canBeOptimized: canBeOptimized
  };
}

exports.analyzeTokenTypes = analyzeTokenTypes;

function validatePatterns(tokenTypes, validModesNames) {
  var errors = [];
  var missingResult = findMissingPatterns(tokenTypes);
  errors = errors.concat(missingResult.errors);
  var invalidResult = findInvalidPatterns(missingResult.valid);
  var validTokenTypes = invalidResult.valid;
  errors = errors.concat(invalidResult.errors);
  errors = errors.concat(validateRegExpPattern(validTokenTypes));
  errors = errors.concat(findInvalidGroupType(validTokenTypes));
  errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
  errors = errors.concat(findUnreachablePatterns(validTokenTypes));
  return errors;
}

exports.validatePatterns = validatePatterns;

function validateRegExpPattern(tokenTypes) {
  var errors = [];
  var withRegExpPatterns = (0, filter_1["default"])(tokenTypes, function (currTokType) {
    return (0, isRegExp_1["default"])(currTokType[PATTERN]);
  });
  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
  return errors;
}

function findMissingPatterns(tokenTypes) {
  var tokenTypesWithMissingPattern = (0, filter_1["default"])(tokenTypes, function (currType) {
    return !(0, has_1["default"])(currType, PATTERN);
  });
  var errors = (0, map_1["default"])(tokenTypesWithMissingPattern, function (currType) {
    return {
      message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
      type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
      tokenTypes: [currType]
    };
  });
  var valid = (0, difference_1["default"])(tokenTypes, tokenTypesWithMissingPattern);
  return {
    errors: errors,
    valid: valid
  };
}

exports.findMissingPatterns = findMissingPatterns;

function findInvalidPatterns(tokenTypes) {
  var tokenTypesWithInvalidPattern = (0, filter_1["default"])(tokenTypes, function (currType) {
    var pattern = currType[PATTERN];
    return !(0, isRegExp_1["default"])(pattern) && !(0, isFunction_1["default"])(pattern) && !(0, has_1["default"])(pattern, "exec") && !(0, isString_1["default"])(pattern);
  });
  var errors = (0, map_1["default"])(tokenTypesWithInvalidPattern, function (currType) {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a" + " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
      type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
      tokenTypes: [currType]
    };
  });
  var valid = (0, difference_1["default"])(tokenTypes, tokenTypesWithInvalidPattern);
  return {
    errors: errors,
    valid: valid
  };
}

exports.findInvalidPatterns = findInvalidPatterns;
var end_of_input = /[^\\][$]/;

function findEndOfInputAnchor(tokenTypes) {
  var EndAnchorFinder =
  /** @class */
  function (_super) {
    __extends(EndAnchorFinder, _super);

    function EndAnchorFinder() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.found = false;
      return _this;
    }

    EndAnchorFinder.prototype.visitEndAnchor = function (node) {
      this.found = true;
    };

    return EndAnchorFinder;
  }(regexp_to_ast_1.BaseRegExpVisitor);

  var invalidRegex = (0, filter_1["default"])(tokenTypes, function (currType) {
    var pattern = currType.PATTERN;

    try {
      var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
      var endAnchorVisitor = new EndAnchorFinder();
      endAnchorVisitor.visit(regexpAst);
      return endAnchorVisitor.found;
    } catch (e) {
      // old behavior in case of runtime exceptions with regexp-to-ast.

      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
      return end_of_input.test(pattern.source);
    }
  });
  var errors = (0, map_1["default"])(invalidRegex, function (currType) {
    return {
      message: "Unexpected RegExp Anchor Error:\n" + "\tToken Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n" + "\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS" + "\tfor details.",
      type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}

exports.findEndOfInputAnchor = findEndOfInputAnchor;

function findEmptyMatchRegExps(tokenTypes) {
  var matchesEmptyString = (0, filter_1["default"])(tokenTypes, function (currType) {
    var pattern = currType.PATTERN;
    return pattern.test("");
  });
  var errors = (0, map_1["default"])(matchesEmptyString, function (currType) {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
      type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
      tokenTypes: [currType]
    };
  });
  return errors;
}

exports.findEmptyMatchRegExps = findEmptyMatchRegExps;
var start_of_input = /[^\\[][\^]|^\^/;

function findStartOfInputAnchor(tokenTypes) {
  var StartAnchorFinder =
  /** @class */
  function (_super) {
    __extends(StartAnchorFinder, _super);

    function StartAnchorFinder() {
      var _this = _super !== null && _super.apply(this, arguments) || this;

      _this.found = false;
      return _this;
    }

    StartAnchorFinder.prototype.visitStartAnchor = function (node) {
      this.found = true;
    };

    return StartAnchorFinder;
  }(regexp_to_ast_1.BaseRegExpVisitor);

  var invalidRegex = (0, filter_1["default"])(tokenTypes, function (currType) {
    var pattern = currType.PATTERN;

    try {
      var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
      var startAnchorVisitor = new StartAnchorFinder();
      startAnchorVisitor.visit(regexpAst);
      return startAnchorVisitor.found;
    } catch (e) {
      // old behavior in case of runtime exceptions with regexp-to-ast.

      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
      return start_of_input.test(pattern.source);
    }
  });
  var errors = (0, map_1["default"])(invalidRegex, function (currType) {
    return {
      message: "Unexpected RegExp Anchor Error:\n" + "\tToken Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n" + "\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS" + "\tfor details.",
      type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}

exports.findStartOfInputAnchor = findStartOfInputAnchor;

function findUnsupportedFlags(tokenTypes) {
  var invalidFlags = (0, filter_1["default"])(tokenTypes, function (currType) {
    var pattern = currType[PATTERN];
    return pattern instanceof RegExp && (pattern.multiline || pattern.global);
  });
  var errors = (0, map_1["default"])(invalidFlags, function (currType) {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
      type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}

exports.findUnsupportedFlags = findUnsupportedFlags; // This can only test for identical duplicate RegExps, not semantically equivalent ones.

function findDuplicatePatterns(tokenTypes) {
  var found = [];
  var identicalPatterns = (0, map_1["default"])(tokenTypes, function (outerType) {
    return (0, reduce_1["default"])(tokenTypes, function (result, innerType) {
      if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1["default"])(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
        // this avoids duplicates in the result, each Token Type may only appear in one "set"
        // in essence we are creating Equivalence classes on equality relation.
        found.push(innerType);
        result.push(innerType);
        return result;
      }

      return result;
    }, []);
  });
  identicalPatterns = (0, compact_1["default"])(identicalPatterns);
  var duplicatePatterns = (0, filter_1["default"])(identicalPatterns, function (currIdenticalSet) {
    return currIdenticalSet.length > 1;
  });
  var errors = (0, map_1["default"])(duplicatePatterns, function (setOfIdentical) {
    var tokenTypeNames = (0, map_1["default"])(setOfIdentical, function (currType) {
      return currType.name;
    });
    var dupPatternSrc = (0, first_1["default"])(setOfIdentical).PATTERN;
    return {
      message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
      type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
      tokenTypes: setOfIdentical
    };
  });
  return errors;
}

exports.findDuplicatePatterns = findDuplicatePatterns;

function findInvalidGroupType(tokenTypes) {
  var invalidTypes = (0, filter_1["default"])(tokenTypes, function (clazz) {
    if (!(0, has_1["default"])(clazz, "GROUP")) {
      return false;
    }

    var group = clazz.GROUP;
    return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1["default"])(group);
  });
  var errors = (0, map_1["default"])(invalidTypes, function (currType) {
    return {
      message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
      type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
      tokenTypes: [currType]
    };
  });
  return errors;
}

exports.findInvalidGroupType = findInvalidGroupType;

function findModesThatDoNotExist(tokenTypes, validModes) {
  var invalidModes = (0, filter_1["default"])(tokenTypes, function (clazz) {
    return clazz.PUSH_MODE !== undefined && !(0, includes_1["default"])(validModes, clazz.PUSH_MODE);
  });
  var errors = (0, map_1["default"])(invalidModes, function (tokType) {
    var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
    return {
      message: msg,
      type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
      tokenTypes: [tokType]
    };
  });
  return errors;
}

exports.findModesThatDoNotExist = findModesThatDoNotExist;

function findUnreachablePatterns(tokenTypes) {
  var errors = [];
  var canBeTested = (0, reduce_1["default"])(tokenTypes, function (result, tokType, idx) {
    var pattern = tokType.PATTERN;

    if (pattern === lexer_public_1.Lexer.NA) {
      return result;
    } // a more comprehensive validation for all forms of regExps would require
    // deeper regExp analysis capabilities


    if ((0, isString_1["default"])(pattern)) {
      result.push({
        str: pattern,
        idx: idx,
        tokenType: tokType
      });
    } else if ((0, isRegExp_1["default"])(pattern) && noMetaChar(pattern)) {
      result.push({
        str: pattern.source,
        idx: idx,
        tokenType: tokType
      });
    }

    return result;
  }, []);
  (0, forEach_1["default"])(tokenTypes, function (tokType, testIdx) {
    (0, forEach_1["default"])(canBeTested, function (_a) {
      var str = _a.str,
          idx = _a.idx,
          tokenType = _a.tokenType;

      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
        var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\n" + "See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
        errors.push({
          message: msg,
          type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
          tokenTypes: [tokType, tokenType]
        });
      }
    });
  });
  return errors;
}

exports.findUnreachablePatterns = findUnreachablePatterns;

function testTokenType(str, pattern) {
  /* istanbul ignore else */
  if ((0, isRegExp_1["default"])(pattern)) {
    var regExpArray = pattern.exec(str);
    return regExpArray !== null && regExpArray.index === 0;
  } else if ((0, isFunction_1["default"])(pattern)) {
    // maintain the API of custom patterns
    return pattern(str, 0, [], {});
  } else if ((0, has_1["default"])(pattern, "exec")) {
    // maintain the API of custom patterns
    return pattern.exec(str, 0, [], {});
  } else if (typeof pattern === "string") {
    return pattern === str;
  } else {
    throw Error("non exhaustive match");
  }
}

function noMetaChar(regExp) {
  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
  var metaChars = [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"];
  return (0, find_1["default"])(metaChars, function (_char) {
    return regExp.source.indexOf(_char) !== -1;
  }) === undefined;
}

function addStartOfInput(pattern) {
  var flags = pattern.ignoreCase ? "i" : ""; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)

  return new RegExp("^(?:".concat(pattern.source, ")"), flags);
}

exports.addStartOfInput = addStartOfInput;

function addStickyFlag(pattern) {
  var flags = pattern.ignoreCase ? "iy" : "y"; // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)

  return new RegExp("".concat(pattern.source), flags);
}

exports.addStickyFlag = addStickyFlag;

function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
  var errors = []; // some run time checks to help the end users.

  if (!(0, has_1["default"])(lexerDefinition, exports.DEFAULT_MODE)) {
    errors.push({
      message: "A MultiMode Lexer cannot be initialized without a <" + exports.DEFAULT_MODE + "> property in its definition\n",
      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
    });
  }

  if (!(0, has_1["default"])(lexerDefinition, exports.MODES)) {
    errors.push({
      message: "A MultiMode Lexer cannot be initialized without a <" + exports.MODES + "> property in its definition\n",
      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
    });
  }

  if ((0, has_1["default"])(lexerDefinition, exports.MODES) && (0, has_1["default"])(lexerDefinition, exports.DEFAULT_MODE) && !(0, has_1["default"])(lexerDefinition.modes, lexerDefinition.defaultMode)) {
    errors.push({
      message: "A MultiMode Lexer cannot be initialized with a ".concat(exports.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
    });
  }

  if ((0, has_1["default"])(lexerDefinition, exports.MODES)) {
    (0, forEach_1["default"])(lexerDefinition.modes, function (currModeValue, currModeName) {
      (0, forEach_1["default"])(currModeValue, function (currTokType, currIdx) {
        if ((0, isUndefined_1["default"])(currTokType)) {
          errors.push({
            message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
            type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
          });
        } else if ((0, has_1["default"])(currTokType, "LONGER_ALT")) {
          var longerAlt = (0, isArray_1["default"])(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
          (0, forEach_1["default"])(longerAlt, function (currLongerAlt) {
            if (!(0, isUndefined_1["default"])(currLongerAlt) && !(0, includes_1["default"])(currModeValue, currLongerAlt)) {
              errors.push({
                message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
              });
            }
          });
        }
      });
    });
  }

  return errors;
}

exports.performRuntimeChecks = performRuntimeChecks;

function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
  var warnings = [];
  var hasAnyLineBreak = false;
  var allTokenTypes = (0, compact_1["default"])((0, flatten_1["default"])((0, values_1["default"])(lexerDefinition.modes)));
  var concreteTokenTypes = (0, reject_1["default"])(allTokenTypes, function (currType) {
    return currType[PATTERN] === lexer_public_1.Lexer.NA;
  });
  var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);

  if (trackLines) {
    (0, forEach_1["default"])(concreteTokenTypes, function (tokType) {
      var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);

      if (currIssue !== false) {
        var message = buildLineBreakIssueMessage(tokType, currIssue);
        var warningDescriptor = {
          message: message,
          type: currIssue.issue,
          tokenType: tokType
        };
        warnings.push(warningDescriptor);
      } else {
        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.
        if ((0, has_1["default"])(tokType, "LINE_BREAKS")) {
          if (tokType.LINE_BREAKS === true) {
            hasAnyLineBreak = true;
          }
        } else {
          if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
            hasAnyLineBreak = true;
          }
        }
      }
    });
  }

  if (trackLines && !hasAnyLineBreak) {
    warnings.push({
      message: "Warning: No LINE_BREAKS Found.\n" + "\tThis Lexer has been defined to track line and column information,\n" + "\tBut none of the Token Types can be identified as matching a line terminator.\n" + "\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n" + "\tfor details.",
      type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
    });
  }

  return warnings;
}

exports.performWarningRuntimeChecks = performWarningRuntimeChecks;

function cloneEmptyGroups(emptyGroups) {
  var clonedResult = {};
  var groupKeys = (0, keys_1["default"])(emptyGroups);
  (0, forEach_1["default"])(groupKeys, function (currKey) {
    var currGroupValue = emptyGroups[currKey];
    /* istanbul ignore else */

    if ((0, isArray_1["default"])(currGroupValue)) {
      clonedResult[currKey] = [];
    } else {
      throw Error("non exhaustive match");
    }
  });
  return clonedResult;
}

exports.cloneEmptyGroups = cloneEmptyGroups; // TODO: refactor to avoid duplication

function isCustomPattern(tokenType) {
  var pattern = tokenType.PATTERN;
  /* istanbul ignore else */

  if ((0, isRegExp_1["default"])(pattern)) {
    return false;
  } else if ((0, isFunction_1["default"])(pattern)) {
    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
    return true;
  } else if ((0, has_1["default"])(pattern, "exec")) {
    // ICustomPattern
    return true;
  } else if ((0, isString_1["default"])(pattern)) {
    return false;
  } else {
    throw Error("non exhaustive match");
  }
}

exports.isCustomPattern = isCustomPattern;

function isShortPattern(pattern) {
  if ((0, isString_1["default"])(pattern) && pattern.length === 1) {
    return pattern.charCodeAt(0);
  } else {
    return false;
  }
}

exports.isShortPattern = isShortPattern;
/**
 * Faster than using a RegExp for default newline detection during lexing.
 */

exports.LineTerminatorOptimizedTester = {
  // implements /\n|\r\n?/g.test
  test: function test(text) {
    var len = text.length;

    for (var i = this.lastIndex; i < len; i++) {
      var c = text.charCodeAt(i);

      if (c === 10) {
        this.lastIndex = i + 1;
        return true;
      } else if (c === 13) {
        if (text.charCodeAt(i + 1) === 10) {
          this.lastIndex = i + 2;
        } else {
          this.lastIndex = i + 1;
        }

        return true;
      }
    }

    return false;
  },
  lastIndex: 0
};

function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
  if ((0, has_1["default"])(tokType, "LINE_BREAKS")) {
    // if the user explicitly declared the line_breaks option we will respect their choice
    // and assume it is correct.
    return false;
  } else {
    /* istanbul ignore else */
    if ((0, isRegExp_1["default"])(tokType.PATTERN)) {
      try {
        // TODO: why is the casting suddenly needed?
        (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
      } catch (e) {
        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */
        return {
          issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
          errMsg: e.message
        };
      }

      return false;
    } else if ((0, isString_1["default"])(tokType.PATTERN)) {
      // string literal patterns can always be analyzed to detect line terminator usage
      return false;
    } else if (isCustomPattern(tokType)) {
      // custom token types
      return {
        issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK
      };
    } else {
      throw Error("non exhaustive match");
    }
  }
}

function buildLineBreakIssueMessage(tokType, details) {
  /* istanbul ignore else */
  if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
    return "Warning: unable to identify line terminator usage in pattern.\n" + "\tThe problem is in the <".concat(tokType.name, "> Token Type\n") + "\t Root cause: ".concat(details.errMsg, ".\n") + "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
  } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
    return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "\tThe problem is in the <".concat(tokType.name, "> Token Type\n") + "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
  } else {
    throw Error("non exhaustive match");
  }
}

exports.buildLineBreakIssueMessage = buildLineBreakIssueMessage;

function getCharCodes(charsOrCodes) {
  var charCodes = (0, map_1["default"])(charsOrCodes, function (numOrString) {
    if ((0, isString_1["default"])(numOrString)) {
      return numOrString.charCodeAt(0);
    } else {
      return numOrString;
    }
  });
  return charCodes;
}

function addToMapOfArrays(map, key, value) {
  if (map[key] === undefined) {
    map[key] = [value];
  } else {
    map[key].push(value);
  }
}

exports.minOptimizationVal = 256;
/**
 * We are mapping charCode above ASCI (256) into buckets each in the size of 256.
 * This is because ASCI are the most common start chars so each one of those will get its own
 * possible token configs vector.
 *
 * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"
 * to place these into buckets of possible token configs, What we gain from
 * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'
 * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).
 * Our 'charCodeToPatternIdxToConfig' max size will now be:
 * 256 + (2^16 / 2^8) - 1 === 511
 *
 * note the hack for fast division integer part extraction
 * See: https://stackoverflow.com/a/4228528
 */

var charCodeToOptimizedIdxMap = [];

function charCodeToOptimizedIndex(charCode) {
  return charCode < exports.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
}

exports.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
/**
 * This is a compromise between cold start / hot running performance
 * Creating this array takes ~3ms on a modern machine,
 * But if we perform the computation at runtime as needed the CSS Lexer benchmark
 * performance degrades by ~10%
 *
 * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.
 */

function initCharCodeToOptimizedIndexMap() {
  if ((0, isEmpty_1["default"])(charCodeToOptimizedIdxMap)) {
    charCodeToOptimizedIdxMap = new Array(65536);

    for (var i = 0; i < 65536; i++) {
      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
    }
  }
}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(21);
/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */


function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function (value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFindIndex = __webpack_require__(233),
    baseIteratee = __webpack_require__(13),
    toInteger = __webpack_require__(38);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */

function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return -1;
  }

  var index = fromIndex == null ? 0 : toInteger(fromIndex);

  if (index < 0) {
    index = nativeMax(length + index, 0);
  }

  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseRest = __webpack_require__(94),
    eq = __webpack_require__(33),
    isIterateeCall = __webpack_require__(61),
    keysIn = __webpack_require__(59);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var defaults = baseRest(function (object, sources) {
  object = Object(object);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        object[key] = source[key];
      }
    }
  }

  return object;
});
module.exports = defaults;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultLexerErrorProvider = void 0;
exports.defaultLexerErrorProvider = {
  buildUnableToPopLexerModeMessage: function buildUnableToPopLexerModeMessage(token) {
    return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
  },
  buildUnexpectedCharactersMessage: function buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {
    return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
  }
};

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;

var first_1 = __importDefault(__webpack_require__(40));

var isEmpty_1 = __importDefault(__webpack_require__(9));

var drop_1 = __importDefault(__webpack_require__(91));

var flatten_1 = __importDefault(__webpack_require__(16));

var filter_1 = __importDefault(__webpack_require__(104));

var reject_1 = __importDefault(__webpack_require__(101));

var difference_1 = __importDefault(__webpack_require__(102));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var groupBy_1 = __importDefault(__webpack_require__(244));

var reduce_1 = __importDefault(__webpack_require__(23));

var pickBy_1 = __importDefault(__webpack_require__(232));

var values_1 = __importDefault(__webpack_require__(15));

var includes_1 = __importDefault(__webpack_require__(18));

var flatMap_1 = __importDefault(__webpack_require__(514));

var clone_1 = __importDefault(__webpack_require__(17));

var parser_1 = __webpack_require__(6);

var gast_1 = __webpack_require__(2);

var lookahead_1 = __webpack_require__(66);

var interpreter_1 = __webpack_require__(67);

var gast_2 = __webpack_require__(2);

var gast_3 = __webpack_require__(2);

var dropRight_1 = __importDefault(__webpack_require__(107));

var compact_1 = __importDefault(__webpack_require__(64));

var tokens_1 = __webpack_require__(27);

function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {
  var duplicateErrors = (0, flatMap_1["default"])(topLevels, function (currTopLevel) {
    return validateDuplicateProductions(currTopLevel, errMsgProvider);
  });
  var leftRecursionErrors = (0, flatMap_1["default"])(topLevels, function (currTopRule) {
    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
  });
  var emptyAltErrors = [];
  var ambiguousAltsErrors = [];
  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.
  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.

  if ((0, isEmpty_1["default"])(leftRecursionErrors)) {
    emptyAltErrors = (0, flatMap_1["default"])(topLevels, function (currTopRule) {
      return validateEmptyOrAlternative(currTopRule, errMsgProvider);
    });
    ambiguousAltsErrors = (0, flatMap_1["default"])(topLevels, function (currTopRule) {
      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);
    });
    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
  }

  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
  var tooManyAltsErrors = (0, flatMap_1["default"])(topLevels, function (curRule) {
    return validateTooManyAlts(curRule, errMsgProvider);
  });
  var duplicateRulesError = (0, flatMap_1["default"])(topLevels, function (curRule) {
    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
  });
  return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
}

exports.validateGrammar = validateGrammar;

function validateDuplicateProductions(topLevelRule, errMsgProvider) {
  var collectorVisitor = new OccurrenceValidationCollector();
  topLevelRule.accept(collectorVisitor);
  var allRuleProductions = collectorVisitor.allProductions;
  var productionGroups = (0, groupBy_1["default"])(allRuleProductions, identifyProductionForDuplicates);
  var duplicates = (0, pickBy_1["default"])(productionGroups, function (currGroup) {
    return currGroup.length > 1;
  });
  var errors = (0, map_1["default"])((0, values_1["default"])(duplicates), function (currDuplicates) {
    var firstProd = (0, first_1["default"])(currDuplicates);
    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
    var dslName = (0, gast_1.getProductionDslName)(firstProd);
    var defError = {
      message: msg,
      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
      ruleName: topLevelRule.name,
      dslName: dslName,
      occurrence: firstProd.idx
    };
    var param = getExtraProductionArgument(firstProd);

    if (param) {
      defError.parameter = param;
    }

    return defError;
  });
  return errors;
}

function identifyProductionForDuplicates(prod) {
  return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
}

exports.identifyProductionForDuplicates = identifyProductionForDuplicates;

function getExtraProductionArgument(prod) {
  if (prod instanceof gast_2.Terminal) {
    return prod.terminalType.name;
  } else if (prod instanceof gast_2.NonTerminal) {
    return prod.nonTerminalName;
  } else {
    return "";
  }
}

var OccurrenceValidationCollector =
/** @class */
function (_super) {
  __extends(OccurrenceValidationCollector, _super);

  function OccurrenceValidationCollector() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.allProductions = [];
    return _this;
  }

  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {
    this.allProductions.push(subrule);
  };

  OccurrenceValidationCollector.prototype.visitOption = function (option) {
    this.allProductions.push(option);
  };

  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
    this.allProductions.push(manySep);
  };

  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
    this.allProductions.push(atLeastOne);
  };

  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
    this.allProductions.push(atLeastOneSep);
  };

  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {
    this.allProductions.push(many);
  };

  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {
    this.allProductions.push(or);
  };

  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {
    this.allProductions.push(terminal);
  };

  return OccurrenceValidationCollector;
}(gast_3.GAstVisitor);

exports.OccurrenceValidationCollector = OccurrenceValidationCollector;

function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
  var errors = [];
  var occurrences = (0, reduce_1["default"])(allRules, function (result, curRule) {
    if (curRule.name === rule.name) {
      return result + 1;
    }

    return result;
  }, 0);

  if (occurrences > 1) {
    var errMsg = errMsgProvider.buildDuplicateRuleNameError({
      topLevelRule: rule,
      grammarName: className
    });
    errors.push({
      message: errMsg,
      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
      ruleName: rule.name
    });
  }

  return errors;
}

exports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?
// This is not part of the IGrammarErrorProvider because the validation cannot be performed on
// The grammar structure, only at runtime.

function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
  var errors = [];
  var errMsg;

  if (!(0, includes_1["default"])(definedRulesNames, ruleName)) {
    errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
    errors.push({
      message: errMsg,
      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
      ruleName: ruleName
    });
  }

  return errors;
}

exports.validateRuleIsOverridden = validateRuleIsOverridden;

function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
  if (path === void 0) {
    path = [];
  }

  var errors = [];
  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);

  if ((0, isEmpty_1["default"])(nextNonTerminals)) {
    return [];
  } else {
    var ruleName = topRule.name;
    var foundLeftRecursion = (0, includes_1["default"])(nextNonTerminals, topRule);

    if (foundLeftRecursion) {
      errors.push({
        message: errMsgProvider.buildLeftRecursionError({
          topLevelRule: topRule,
          leftRecursionPath: path
        }),
        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
        ruleName: ruleName
      });
    } // we are only looking for cyclic paths leading back to the specific topRule
    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...


    var validNextSteps = (0, difference_1["default"])(nextNonTerminals, path.concat([topRule]));
    var errorsFromNextSteps = (0, flatMap_1["default"])(validNextSteps, function (currRefRule) {
      var newPath = (0, clone_1["default"])(path);
      newPath.push(currRefRule);
      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
    });
    return errors.concat(errorsFromNextSteps);
  }
}

exports.validateNoLeftRecursion = validateNoLeftRecursion;

function getFirstNoneTerminal(definition) {
  var result = [];

  if ((0, isEmpty_1["default"])(definition)) {
    return result;
  }

  var firstProd = (0, first_1["default"])(definition);
  /* istanbul ignore else */

  if (firstProd instanceof gast_2.NonTerminal) {
    result.push(firstProd.referencedRule);
  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
    result = result.concat(getFirstNoneTerminal(firstProd.definition));
  } else if (firstProd instanceof gast_2.Alternation) {
    // each sub definition in alternation is a FLAT
    result = (0, flatten_1["default"])((0, map_1["default"])(firstProd.definition, function (currSubDef) {
      return getFirstNoneTerminal(currSubDef.definition);
    }));
  } else if (firstProd instanceof gast_2.Terminal) {// nothing to see, move along
  } else {
    throw Error("non exhaustive match");
  }

  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
  var hasMore = definition.length > 1;

  if (isFirstOptional && hasMore) {
    var rest = (0, drop_1["default"])(definition);
    return result.concat(getFirstNoneTerminal(rest));
  } else {
    return result;
  }
}

exports.getFirstNoneTerminal = getFirstNoneTerminal;

var OrCollector =
/** @class */
function (_super) {
  __extends(OrCollector, _super);

  function OrCollector() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.alternations = [];
    return _this;
  }

  OrCollector.prototype.visitAlternation = function (node) {
    this.alternations.push(node);
  };

  return OrCollector;
}(gast_3.GAstVisitor);

function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
  var orCollector = new OrCollector();
  topLevelRule.accept(orCollector);
  var ors = orCollector.alternations;
  var errors = (0, flatMap_1["default"])(ors, function (currOr) {
    var exceptLast = (0, dropRight_1["default"])(currOr.definition);
    return (0, flatMap_1["default"])(exceptLast, function (currAlternative, currAltIdx) {
      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);

      if ((0, isEmpty_1["default"])(possibleFirstInAlt)) {
        return [{
          message: errMsgProvider.buildEmptyAlternationError({
            topLevelRule: topLevelRule,
            alternation: currOr,
            emptyChoiceIdx: currAltIdx
          }),
          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
          ruleName: topLevelRule.name,
          occurrence: currOr.idx,
          alternative: currAltIdx + 1
        }];
      } else {
        return [];
      }
    });
  });
  return errors;
}

exports.validateEmptyOrAlternative = validateEmptyOrAlternative;

function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
  var orCollector = new OrCollector();
  topLevelRule.accept(orCollector);
  var ors = orCollector.alternations; // New Handling of ignoring ambiguities
  // - https://github.com/chevrotain/chevrotain/issues/869

  ors = (0, reject_1["default"])(ors, function (currOr) {
    return currOr.ignoreAmbiguities === true;
  });
  var errors = (0, flatMap_1["default"])(ors, function (currOr) {
    var currOccurrence = currOr.idx;
    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
  });
  return errors;
}

exports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;

var RepetitionCollector =
/** @class */
function (_super) {
  __extends(RepetitionCollector, _super);

  function RepetitionCollector() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.allProductions = [];
    return _this;
  }

  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
    this.allProductions.push(manySep);
  };

  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
    this.allProductions.push(atLeastOne);
  };

  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
    this.allProductions.push(atLeastOneSep);
  };

  RepetitionCollector.prototype.visitRepetition = function (many) {
    this.allProductions.push(many);
  };

  return RepetitionCollector;
}(gast_3.GAstVisitor);

exports.RepetitionCollector = RepetitionCollector;

function validateTooManyAlts(topLevelRule, errMsgProvider) {
  var orCollector = new OrCollector();
  topLevelRule.accept(orCollector);
  var ors = orCollector.alternations;
  var errors = (0, flatMap_1["default"])(ors, function (currOr) {
    if (currOr.definition.length > 255) {
      return [{
        message: errMsgProvider.buildTooManyAlternativesError({
          topLevelRule: topLevelRule,
          alternation: currOr
        }),
        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
        ruleName: topLevelRule.name,
        occurrence: currOr.idx
      }];
    } else {
      return [];
    }
  });
  return errors;
}

exports.validateTooManyAlts = validateTooManyAlts;

function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
  var errors = [];
  (0, forEach_1["default"])(topLevelRules, function (currTopRule) {
    var collectorVisitor = new RepetitionCollector();
    currTopRule.accept(collectorVisitor);
    var allRuleProductions = collectorVisitor.allProductions;
    (0, forEach_1["default"])(allRuleProductions, function (currProd) {
      var prodType = (0, lookahead_1.getProdType)(currProd);
      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
      var currOccurrence = currProd.idx;
      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
      var pathsInsideProduction = paths[0];

      if ((0, isEmpty_1["default"])((0, flatten_1["default"])(pathsInsideProduction))) {
        var errMsg = errMsgProvider.buildEmptyRepetitionError({
          topLevelRule: currTopRule,
          repetition: currProd
        });
        errors.push({
          message: errMsg,
          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
          ruleName: currTopRule.name
        });
      }
    });
  });
  return errors;
}

exports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;

function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
  var foundAmbiguousPaths = [];
  var identicalAmbiguities = (0, reduce_1["default"])(alternatives, function (result, currAlt, currAltIdx) {
    // ignore (skip) ambiguities with this alternative
    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
      return result;
    }

    (0, forEach_1["default"])(currAlt, function (currPath) {
      var altsCurrPathAppearsIn = [currAltIdx];
      (0, forEach_1["default"])(alternatives, function (currOtherAlt, currOtherAltIdx) {
        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
          altsCurrPathAppearsIn.push(currOtherAltIdx);
        }
      });

      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
        foundAmbiguousPaths.push(currPath);
        result.push({
          alts: altsCurrPathAppearsIn,
          path: currPath
        });
      }
    });
    return result;
  }, []);
  var currErrors = (0, map_1["default"])(identicalAmbiguities, function (currAmbDescriptor) {
    var ambgIndices = (0, map_1["default"])(currAmbDescriptor.alts, function (currAltIdx) {
      return currAltIdx + 1;
    });
    var currMessage = errMsgProvider.buildAlternationAmbiguityError({
      topLevelRule: rule,
      alternation: alternation,
      ambiguityIndices: ambgIndices,
      prefixPath: currAmbDescriptor.path
    });
    return {
      message: currMessage,
      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
      ruleName: rule.name,
      occurrence: alternation.idx,
      alternatives: currAmbDescriptor.alts
    };
  });
  return currErrors;
}

function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
  // flatten
  var pathsAndIndices = (0, reduce_1["default"])(alternatives, function (result, currAlt, idx) {
    var currPathsAndIdx = (0, map_1["default"])(currAlt, function (currPath) {
      return {
        idx: idx,
        path: currPath
      };
    });
    return result.concat(currPathsAndIdx);
  }, []);
  var errors = (0, compact_1["default"])((0, flatMap_1["default"])(pathsAndIndices, function (currPathAndIdx) {
    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative

    if (alternativeGast.ignoreAmbiguities === true) {
      return [];
    }

    var targetIdx = currPathAndIdx.idx;
    var targetPath = currPathAndIdx.path;
    var prefixAmbiguitiesPathsAndIndices = (0, filter_1["default"])(pathsAndIndices, function (searchPathAndIdx) {
      // prefix ambiguity can only be created from lower idx (higher priority) path
      return (// ignore (skip) ambiguities with this "other" alternative
        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
        // will be be detected using a different validation.
        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
      );
    });
    var currPathPrefixErrors = (0, map_1["default"])(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {
      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
      var occurrence = alternation.idx === 0 ? "" : alternation.idx;
      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
        topLevelRule: rule,
        alternation: alternation,
        ambiguityIndices: ambgIndices,
        prefixPath: currAmbPathAndIdx.path
      });
      return {
        message: message,
        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
        ruleName: rule.name,
        occurrence: occurrence,
        alternatives: ambgIndices
      };
    });
    return currPathPrefixErrors;
  }));
  return errors;
}

exports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;

function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
  var errors = [];
  var tokenNames = (0, map_1["default"])(tokenTypes, function (currToken) {
    return currToken.name;
  });
  (0, forEach_1["default"])(topLevels, function (currRule) {
    var currRuleName = currRule.name;

    if ((0, includes_1["default"])(tokenNames, currRuleName)) {
      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
      errors.push({
        message: errMsg,
        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
        ruleName: currRuleName
      });
    }
  });
  return errors;
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseAssignValue = __webpack_require__(88),
    createAggregator = __webpack_require__(511);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */

var groupBy = createAggregator(function (result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    baseAssignValue(result, key, [value]);
  }
});
module.exports = groupBy;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attemptInRepetitionRecovery = exports.Recoverable = exports.InRuleRecoveryException = exports.IN_RULE_RECOVERY_EXCEPTION = exports.EOF_FOLLOW_KEY = void 0;

var tokens_public_1 = __webpack_require__(26);

var isEmpty_1 = __importDefault(__webpack_require__(9));

var dropRight_1 = __importDefault(__webpack_require__(107));

var flatten_1 = __importDefault(__webpack_require__(16));

var map_1 = __importDefault(__webpack_require__(4));

var find_1 = __importDefault(__webpack_require__(103));

var has_1 = __importDefault(__webpack_require__(7));

var includes_1 = __importDefault(__webpack_require__(18));

var clone_1 = __importDefault(__webpack_require__(17));

var exceptions_public_1 = __webpack_require__(41);

var constants_1 = __webpack_require__(237);

var parser_1 = __webpack_require__(6);

exports.EOF_FOLLOW_KEY = {};
exports.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";

var InRuleRecoveryException =
/** @class */
function (_super) {
  __extends(InRuleRecoveryException, _super);

  function InRuleRecoveryException(message) {
    var _this = _super.call(this, message) || this;

    _this.name = exports.IN_RULE_RECOVERY_EXCEPTION;
    return _this;
  }

  return InRuleRecoveryException;
}(Error);

exports.InRuleRecoveryException = InRuleRecoveryException;
/**
 * This trait is responsible for the error recovery and fault tolerant logic
 */

var Recoverable =
/** @class */
function () {
  function Recoverable() {}

  Recoverable.prototype.initRecoverable = function (config) {
    this.firstAfterRepMap = {};
    this.resyncFollows = {};
    this.recoveryEnabled = (0, has_1["default"])(config, "recoveryEnabled") ? config.recoveryEnabled // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled; // performance optimization, NOOP will be inlined which
    // effectively means that this optional feature does not exist
    // when not used.

    if (this.recoveryEnabled) {
      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
    }
  };

  Recoverable.prototype.getTokenToInsert = function (tokType) {
    var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
    tokToInsert.isInsertedInRecovery = true;
    return tokToInsert;
  };

  Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {
    return true;
  };

  Recoverable.prototype.canTokenTypeBeDeletedInRecovery = function (tokType) {
    return true;
  };

  Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
    var _this = this; // TODO: can the resyncTokenType be cached?


    var reSyncTokType = this.findReSyncTokenType();
    var savedLexerState = this.exportLexerState();
    var resyncedTokens = [];
    var passedResyncPoint = false;
    var nextTokenWithoutResync = this.LA(1);
    var currToken = this.LA(1);

    var generateErrorMessage = function generateErrorMessage() {
      var previousToken = _this.LA(0); // we are preemptively re-syncing before an error has been detected, therefor we must reproduce
      // the error that would have been thrown


      var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
        expected: expectedTokType,
        actual: nextTokenWithoutResync,
        previous: previousToken,
        ruleName: _this.getCurrRuleFullName()
      });

      var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0)); // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.

      error.resyncedTokens = (0, dropRight_1["default"])(resyncedTokens);

      _this.SAVE_ERROR(error);
    };

    while (!passedResyncPoint) {
      // re-synced to a point where we can safely exit the repetition/
      if (this.tokenMatcher(currToken, expectedTokType)) {
        generateErrorMessage();
        return; // must return here to avoid reverting the inputIdx
      } else if (lookAheadFunc.call(this)) {
        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule
        generateErrorMessage(); // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule

        grammarRule.apply(this, grammarRuleArgs);
        return; // must return here to avoid reverting the inputIdx
      } else if (this.tokenMatcher(currToken, reSyncTokType)) {
        passedResyncPoint = true;
      } else {
        currToken = this.SKIP_TOKEN();
        this.addToResyncTokens(currToken, resyncedTokens);
      }
    } // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.
    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by
    // "between rules" resync recovery later in the flow.


    this.importLexerState(savedLexerState);
  };

  Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {
    // Edge case of arriving from a MANY repetition which is stuck
    // Attempting recovery in this case could cause an infinite loop
    if (notStuck === false) {
      return false;
    } // no need to recover, next token is what we expect...


    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
      return false;
    } // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path
    // and prefer some backtracking path that includes recovered errors.


    if (this.isBackTracking()) {
      return false;
    } // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm
    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)
    //noinspection RedundantIfStatementJS


    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
      return false;
    }

    return true;
  }; // Error Recovery functionality


  Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {
    var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
    var follows = this.getNextPossibleTokenTypes(grammarPath);
    return follows;
  };

  Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {
    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
      var tokToInsert = this.getTokenToInsert(expectedTokType);
      return tokToInsert;
    }

    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
      var nextTok = this.SKIP_TOKEN();
      this.consumeToken();
      return nextTok;
    }

    throw new InRuleRecoveryException("sad sad panda");
  };

  Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {
    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
  };

  Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {
    var _this = this;

    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
      return false;
    } // must know the possible following tokens to perform single token insertion


    if ((0, isEmpty_1["default"])(follows)) {
      return false;
    }

    var mismatchedTok = this.LA(1);
    var isMisMatchedTokInFollows = (0, find_1["default"])(follows, function (possibleFollowsTokType) {
      return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
    }) !== undefined;
    return isMisMatchedTokInFollows;
  };

  Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {
    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
      return false;
    }

    var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
    return isNextTokenWhatIsExpected;
  };

  Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {
    var followKey = this.getCurrFollowKey();
    var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
    return (0, includes_1["default"])(currentRuleReSyncSet, tokenTypeIdx);
  };

  Recoverable.prototype.findReSyncTokenType = function () {
    var allPossibleReSyncTokTypes = this.flattenFollowSet(); // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input

    var nextToken = this.LA(1);
    var k = 2;

    while (true) {
      var foundMatch = (0, find_1["default"])(allPossibleReSyncTokTypes, function (resyncTokType) {
        var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
        return canMatch;
      });

      if (foundMatch !== undefined) {
        return foundMatch;
      }

      nextToken = this.LA(k);
      k++;
    }
  };

  Recoverable.prototype.getCurrFollowKey = function () {
    // the length is at least one as we always add the ruleName to the stack before invoking the rule.
    if (this.RULE_STACK.length === 1) {
      return exports.EOF_FOLLOW_KEY;
    }

    var currRuleShortName = this.getLastExplicitRuleShortName();
    var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
    var prevRuleShortName = this.getPreviousExplicitRuleShortName();
    return {
      ruleName: this.shortRuleNameToFullName(currRuleShortName),
      idxInCallingRule: currRuleIdx,
      inRule: this.shortRuleNameToFullName(prevRuleShortName)
    };
  };

  Recoverable.prototype.buildFullFollowKeyStack = function () {
    var _this = this;

    var explicitRuleStack = this.RULE_STACK;
    var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
    return (0, map_1["default"])(explicitRuleStack, function (ruleName, idx) {
      if (idx === 0) {
        return exports.EOF_FOLLOW_KEY;
      }

      return {
        ruleName: _this.shortRuleNameToFullName(ruleName),
        idxInCallingRule: explicitOccurrenceStack[idx],
        inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
      };
    });
  };

  Recoverable.prototype.flattenFollowSet = function () {
    var _this = this;

    var followStack = (0, map_1["default"])(this.buildFullFollowKeyStack(), function (currKey) {
      return _this.getFollowSetFromFollowKey(currKey);
    });
    return (0, flatten_1["default"])(followStack);
  };

  Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {
    if (followKey === exports.EOF_FOLLOW_KEY) {
      return [tokens_public_1.EOF];
    }

    var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
    return this.resyncFollows[followName];
  }; // It does not make any sense to include a virtual EOF token in the list of resynced tokens
  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)


  Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {
    if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
      resyncTokens.push(token);
    }

    return resyncTokens;
  };

  Recoverable.prototype.reSyncTo = function (tokType) {
    var resyncedTokens = [];
    var nextTok = this.LA(1);

    while (this.tokenMatcher(nextTok, tokType) === false) {
      nextTok = this.SKIP_TOKEN();
      this.addToResyncTokens(nextTok, resyncedTokens);
    } // the last token is not part of the error.


    return (0, dropRight_1["default"])(resyncedTokens);
  };

  Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {// by default this is a NO-OP
    // The actual implementation is with the function(not method) below
  };

  Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {
    var pathRuleStack = this.getHumanReadableRuleStack();
    var pathOccurrenceStack = (0, clone_1["default"])(this.RULE_OCCURRENCE_STACK);
    var grammarPath = {
      ruleStack: pathRuleStack,
      occurrenceStack: pathOccurrenceStack,
      lastTok: tokType,
      lastTokOccurrence: tokIdxInRule
    };
    return grammarPath;
  };

  Recoverable.prototype.getHumanReadableRuleStack = function () {
    var _this = this;

    return (0, map_1["default"])(this.RULE_STACK, function (currShortName) {
      return _this.shortRuleNameToFullName(currShortName);
    });
  };

  return Recoverable;
}();

exports.Recoverable = Recoverable;

function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
  var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
  var firstAfterRepInfo = this.firstAfterRepMap[key];

  if (firstAfterRepInfo === undefined) {
    var currRuleName = this.getCurrRuleFullName();
    var ruleGrammar = this.getGAstProductions()[currRuleName];
    var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
    firstAfterRepInfo = walker.startWalking();
    this.firstAfterRepMap[key] = firstAfterRepInfo;
  }

  var expectTokAfterLastMatch = firstAfterRepInfo.token;
  var nextTokIdx = firstAfterRepInfo.occurrence;
  var isEndOfRule = firstAfterRepInfo.isEndOfRule; // special edge case of a TOP most repetition after which the input should END.
  // this will force an attempt for inRule recovery in that scenario.

  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {
    expectTokAfterLastMatch = tokens_public_1.EOF;
    nextTokIdx = 1;
  } // We don't have anything to re-sync to...
  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard


  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {
    return;
  }

  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
    // TODO: performance optimization: instead of passing the original args here, we modify
    // the args param (or create a new one) and make sure the lookahead func is explicitly provided
    // to avoid searching the cache for it once more.
    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
  }
}

exports.attemptInRepetitionRecovery = attemptInRepetitionRecovery;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.BICst = window.BICst || {};
BICst.FORMULA_STATE = BICst.FORMULA_STATE || {};
BICst.FORMULA_STATE.VALID = "valid";
BICst.FORMULA_STATE.INVALID = "invalid";
BICst.FORMULA_STATE.AGG_INVALID = "aggInvalid";
BICst.FORMULA_STATE.FIXED_INVALID = "fixedInvalid";
BICst.FORMULA_STATE.RAPID_INVALID = "rapidInvalid";
BICst.FORMULA_STATE.FIELD_MISS = "field_miss";
BICst.FORMULA_STATE.NOT_SUPPORT_STRING_OR_DATE = "no_string_or_date";
BICst.FORMULA_STATE.DETAIL_FILTER_NOT_SUPPORT = "detail filter not support";
BICst.FORMULA_WIDGET_FIELD_TYPE = BICst.FORMULA_WIDGET_FIELD_TYPE || {};
BICst.FORMULA_WIDGET_FIELD_TYPE.DATE = 1;
BICst.FORMULA_WIDGET_FIELD_TYPE.STRING = 2;
BICst.FORMULA_WIDGET_FIELD_TYPE.NUMBER = 3;
BICst.DESIGN = BICst.DESIGN || {};
BICst.DESIGN.TABLE_ROW_SUM_POSITION = BICst.DESIGN.TABLE_ROW_SUM_POSITION || {};
BICst.DESIGN.TABLE_ROW_SUM_POSITION.TOP = "top";
BICst.DESIGN.TABLE_ROW_SUM_POSITION.BOTTOM = "bottom";
BICst.FORMULA_KEYWORD_TYPE = {};
BICst.FORMULA_KEYWORD_TYPE.KEYWORD = 1;
BICst.FORMULA_KEYWORD_TYPE.FUNCTION = 2;
BICst.FORMULA_KEYWORD_TYPE.PARAM = 3;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// 工程配置
(function () {
  // 注册滚动条
  BI.config("bi.grid_table_scrollbar", function (ob) {
    if (BI.isIE9Below()) {
      return BI.extend(ob, {
        type: "bi.native_table_scrollbar"
      });
    }

    return ob;
  });
  BI.config("bi.grid_table_horizontal_scrollbar", function (ob) {
    if (BI.isIE9Below()) {
      return BI.extend(ob, {
        type: "bi.native_table_horizontal_scrollbar"
      });
    }

    return ob;
  }); // 注册控件
  // BI.Plugin.registerWidget("bi.grid_table", function (ob) {
  //     // 非chrome下滚动条滑动效果不好，禁止掉
  //     if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
  //         return BI.extend(ob, {type: "bi.quick_grid_table"});
  //     }
  //     return ob;
  // });
  // BI.Plugin.registerWidget("bi.collection_table", function (ob) {
  //     // 非chrome下滚动条滑动效果不好，禁止掉
  //     if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
  //         return BI.extend(ob, {type: "bi.quick_collection_table"});
  //     }
  //     return ob;
  // });
  // BI.Plugin.registerWidget("bi.dynamic_collection_table", function (ob) {
  //     // 非chrome下滚动条滑动效果不好，禁止掉
  //     if (!(BI.isChrome() && BI.isWindows() && !BI.isEdge())) {
  //         return BI.extend(ob, {type: "bi.quick_dynamic_collection_table"});
  //     }
  //     return ob;
  //
  // });

  BI.config("bi.watermark", function (ob) {
    if (BI.isIE9Below()) {
      return BI.extend(ob, {
        type: "bi.div.watermark"
      });
    }

    return ob;
  }); // IE8下滚动条用原生的

  _global.BI.$ && BI.$(function () {
    if (BI.isIE9Below()) {
      BI.GridTableScrollbar.SIZE = 18;
    }
  });
})();

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var require;var require;

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _typeof2(obj) { "@babel/helpers - typeof"; return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof2(obj); }

/* !
 * clipboard.js v1.6.1
 * https://zenorocha.github.io/clipboard.js
 *
 * Licensed MIT © Zeno Rocha
 */
try {
  // IE8下会抛错
  (function (f) {
    var g;

    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }

    g.Clipboard = f();
  })(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require === "function" && require;
            if (!u && a) return require(o, !0);
            if (i) return i(o, !0);
            var f = new Error("Cannot find module '" + o + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }

          var l = n[o] = {
            exports: {}
          };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }

        return n[o].exports;
      }

      var i = typeof require === "function" && require;

      for (var o = 0; o < r.length; o++) {
        s(r[o]);
      }

      return s;
    }({
      1: [function (require, module, exports) {
        var DOCUMENT_NODE_TYPE = 9;
        /**
         * A polyfill for Element.matches()
         */

        if (typeof Element !== "undefined" && !Element.prototype.matches) {
          var proto = Element.prototype;
          proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
        }
        /**
         * Finds the closest parent that matches a selector.
         *
         * @param {Element} element
         * @param {String} selector
         * @return {Function}
         */


        function closest(element, selector) {
          while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
            if (element.matches(selector)) return element;
            element = element.parentNode;
          }
        }

        module.exports = closest;
      }, {}],
      2: [function (require, module, exports) {
        var closest = require("./closest");
        /**
         * Delegates event to a selector.
         *
         * @param {Element} element
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @param {Boolean} useCapture
         * @return {Object}
         */


        function delegate(element, selector, type, callback, useCapture) {
          var listenerFn = listener.apply(this, arguments);
          element.addEventListener(type, listenerFn, useCapture);
          return {
            destroy: function destroy() {
              element.removeEventListener(type, listenerFn, useCapture);
            }
          };
        }
        /**
         * Finds closest match and invokes callback.
         *
         * @param {Element} element
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @return {Function}
         */


        function listener(element, selector, type, callback) {
          return function (e) {
            e.delegateTarget = closest(e.target, selector);

            if (e.delegateTarget) {
              callback.call(element, e);
            }
          };
        }

        module.exports = delegate;
      }, {
        "./closest": 1
      }],
      3: [function (require, module, exports) {
        /**
         * Check if argument is a HTML element.
         *
         * @param {Object} value
         * @return {Boolean}
         */
        exports.node = function (value) {
          return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;
        };
        /**
         * Check if argument is a list of HTML elements.
         *
         * @param {Object} value
         * @return {Boolean}
         */


        exports.nodeList = function (value) {
          var type = Object.prototype.toString.call(value);
          return value !== undefined && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports.node(value[0]));
        };
        /**
         * Check if argument is a string.
         *
         * @param {Object} value
         * @return {Boolean}
         */


        exports.string = function (value) {
          return typeof value === "string" || value instanceof String;
        };
        /**
         * Check if argument is a function.
         *
         * @param {Object} value
         * @return {Boolean}
         */


        exports.fn = function (value) {
          var type = Object.prototype.toString.call(value);
          return type === "[object Function]";
        };
      }, {}],
      4: [function (require, module, exports) {
        var is = require("./is");

        var delegate = require("delegate");
        /**
         * Validates all params and calls the right
         * listener function based on its target type.
         *
         * @param {String|HTMLElement|HTMLCollection|NodeList} target
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */


        function listen(target, type, callback) {
          if (!target && !type && !callback) {
            throw new Error("Missing required arguments");
          }

          if (!is.string(type)) {
            throw new TypeError("Second argument must be a String");
          }

          if (!is.fn(callback)) {
            throw new TypeError("Third argument must be a Function");
          }

          if (is.node(target)) {
            return listenNode(target, type, callback);
          } else if (is.nodeList(target)) {
            return listenNodeList(target, type, callback);
          } else if (is.string(target)) {
            return listenSelector(target, type, callback);
          }

          throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
        }
        /**
         * Adds an event listener to a HTML element
         * and returns a remove listener function.
         *
         * @param {HTMLElement} node
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */


        function listenNode(node, type, callback) {
          node.addEventListener(type, callback);
          return {
            destroy: function destroy() {
              node.removeEventListener(type, callback);
            }
          };
        }
        /**
         * Add an event listener to a list of HTML elements
         * and returns a remove listener function.
         *
         * @param {NodeList|HTMLCollection} nodeList
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */


        function listenNodeList(nodeList, type, callback) {
          Array.prototype.forEach.call(nodeList, function (node) {
            node.addEventListener(type, callback);
          });
          return {
            destroy: function destroy() {
              Array.prototype.forEach.call(nodeList, function (node) {
                node.removeEventListener(type, callback);
              });
            }
          };
        }
        /**
         * Add an event listener to a selector
         * and returns a remove listener function.
         *
         * @param {String} selector
         * @param {String} type
         * @param {Function} callback
         * @return {Object}
         */


        function listenSelector(selector, type, callback) {
          return delegate(document.body, selector, type, callback);
        }

        module.exports = listen;
      }, {
        "./is": 3,
        delegate: 2
      }],
      5: [function (require, module, exports) {
        function select(element) {
          var selectedText;

          if (element.nodeName === "SELECT") {
            element.focus();
            selectedText = element.value;
          } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
            var isReadOnly = element.hasAttribute("readonly");

            if (!isReadOnly) {
              element.setAttribute("readonly", "");
            }

            element.select();
            element.setSelectionRange(0, element.value.length);

            if (!isReadOnly) {
              element.removeAttribute("readonly");
            }

            selectedText = element.value;
          } else {
            if (element.hasAttribute("contenteditable")) {
              element.focus();
            }

            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
            selectedText = selection.toString();
          }

          return selectedText;
        }

        module.exports = select;
      }, {}],
      6: [function (require, module, exports) {
        function E() {// Keep this empty so it's easier to inherit from
          // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
        }

        E.prototype = {
          on: function on(name, callback, ctx) {
            var e = this.e || (this.e = {});
            (e[name] || (e[name] = [])).push({
              fn: callback,
              ctx: ctx
            });
            return this;
          },
          once: function once(name, callback, ctx) {
            var self = this;

            function listener() {
              self.off(name, listener);
              callback.apply(ctx, arguments);
            }

            listener._ = callback;
            return this.on(name, listener, ctx);
          },
          emit: function emit(name) {
            var data = [].slice.call(arguments, 1);
            var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
            var i = 0;
            var len = evtArr.length;

            for (i; i < len; i++) {
              evtArr[i].fn.apply(evtArr[i].ctx, data);
            }

            return this;
          },
          off: function off(name, callback) {
            var e = this.e || (this.e = {});
            var evts = e[name];
            var liveEvents = [];

            if (evts && callback) {
              for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback) {
                  liveEvents.push(evts[i]);
                }
              }
            } // Remove event from queue to prevent memory leak
            // Suggested by https://github.com/lazd
            // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910


            liveEvents.length ? e[name] = liveEvents : delete e[name];
            return this;
          }
        };
        module.exports = E;
      }, {}],
      7: [function (require, module, exports) {
        (function (global, factory) {
          if (typeof define === "function" && define.amd) {
            define(["module", "select"], factory);
          } else if (typeof exports !== "undefined") {
            factory(module, require("select"));
          } else {
            var mod = {
              exports: {}
            };
            factory(mod, global.select);
            global.clipboardAction = mod.exports;
          }
        })(this, function (module, _select) {
          "use strict";

          var _select2 = _interopRequireDefault(_select);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              "default": obj
            };
          }

          var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
            return _typeof2(obj);
          } : function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
          };

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          var ClipboardAction = function () {
            /**
             * @param {Object} options
             */
            function ClipboardAction(options) {
              _classCallCheck(this, ClipboardAction);

              this.resolveOptions(options);
              this.initSelection();
            }
            /**
             * Defines base properties passed from constructor.
             * @param {Object} options
             */


            _createClass(ClipboardAction, [{
              key: "resolveOptions",
              value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                this.action = options.action;
                this.emitter = options.emitter;
                this.target = options.target;
                this.text = options.text;
                this.trigger = options.trigger;
                this.selectedText = "";
              }
            }, {
              key: "initSelection",
              value: function initSelection() {
                if (this.text) {
                  this.selectFake();
                } else if (this.target) {
                  this.selectTarget();
                }
              }
            }, {
              key: "selectFake",
              value: function selectFake() {
                var _this = this;

                var isRTL = document.documentElement.getAttribute("dir") == "rtl";
                this.removeFake();

                this.fakeHandlerCallback = function () {
                  return _this.removeFake();
                };

                this.fakeHandler = document.body.addEventListener("click", this.fakeHandlerCallback) || true;
                this.fakeElem = document.createElement("textarea"); // Prevent zooming on iOS

                this.fakeElem.style.fontSize = "12pt"; // Reset box model

                this.fakeElem.style.border = "0";
                this.fakeElem.style.padding = "0";
                this.fakeElem.style.margin = "0"; // Move element out of screen horizontally

                this.fakeElem.style.position = "absolute";
                this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px"; // Move element to the same position vertically

                var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                this.fakeElem.style.top = yPosition + "px";
                this.fakeElem.setAttribute("readonly", "");
                this.fakeElem.value = this.text;
                document.body.appendChild(this.fakeElem);
                this.selectedText = (0, _select2["default"])(this.fakeElem);
                this.copyText();
              }
            }, {
              key: "removeFake",
              value: function removeFake() {
                if (this.fakeHandler) {
                  document.body.removeEventListener("click", this.fakeHandlerCallback);
                  this.fakeHandler = null;
                  this.fakeHandlerCallback = null;
                }

                if (this.fakeElem) {
                  document.body.removeChild(this.fakeElem);
                  this.fakeElem = null;
                }
              }
            }, {
              key: "selectTarget",
              value: function selectTarget() {
                this.selectedText = (0, _select2["default"])(this.target);
                this.copyText();
              }
            }, {
              key: "copyText",
              value: function copyText() {
                var succeeded = void 0;

                try {
                  succeeded = document.execCommand(this.action);
                } catch (err) {
                  succeeded = false;
                }

                this.handleResult(succeeded);
              }
            }, {
              key: "handleResult",
              value: function handleResult(succeeded) {
                this.emitter.emit(succeeded ? "success" : "error", {
                  action: this.action,
                  text: this.selectedText,
                  trigger: this.trigger,
                  clearSelection: this.clearSelection.bind(this)
                });
              }
            }, {
              key: "clearSelection",
              value: function clearSelection() {
                if (this.target) {
                  this.target.blur();
                }

                window.getSelection().removeAllRanges();
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.removeFake();
              }
            }, {
              key: "action",
              set: function set() {
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "copy";
                this._action = action;

                if (this._action !== "copy" && this._action !== "cut") {
                  throw new Error("Invalid \"action\" value, use either \"copy\" or \"cut\"");
                }
              },
              get: function get() {
                return this._action;
              }
            }, {
              key: "target",
              set: function set(target) {
                if (target !== undefined) {
                  if (target && (typeof target === "undefined" ? "undefined" : _typeof(target)) === "object" && target.nodeType === 1) {
                    if (this.action === "copy" && target.hasAttribute("disabled")) {
                      throw new Error("Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute");
                    }

                    if (this.action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                      throw new Error("Invalid \"target\" attribute. You can't cut text from elements with \"readonly\" or \"disabled\" attributes");
                    }

                    this._target = target;
                  } else {
                    throw new Error("Invalid \"target\" value, use a valid Element");
                  }
                }
              },
              get: function get() {
                return this._target;
              }
            }]);

            return ClipboardAction;
          }();

          module.exports = ClipboardAction;
        });
      }, {
        select: 5
      }],
      8: [function (require, module, exports) {
        (function (global, factory) {
          if (typeof define === "function" && define.amd) {
            define(["module", "./clipboard-action", "tiny-emitter", "good-listener"], factory);
          } else if (typeof exports !== "undefined") {
            factory(module, require("./clipboard-action"), require("tiny-emitter"), require("good-listener"));
          } else {
            var mod = {
              exports: {}
            };
            factory(mod, global.clipboardAction, global.tinyEmitter, global.goodListener);
            global.clipboard = mod.exports;
          }
        })(this, function (module, _clipboardAction, _tinyEmitter, _goodListener) {
          "use strict";

          var _clipboardAction2 = _interopRequireDefault(_clipboardAction);

          var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);

          var _goodListener2 = _interopRequireDefault(_goodListener);

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
              "default": obj
            };
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function (Constructor, protoProps, staticProps) {
              if (protoProps) defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();

          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return call && (_typeof2(call) === "object" || typeof call === "function") ? call : self;
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
          }

          var Clipboard = function (_Emitter) {
            _inherits(Clipboard, _Emitter);
            /**
             * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
             * @param {Object} options
             */


            function Clipboard(trigger, options) {
              _classCallCheck(this, Clipboard);

              var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));

              _this.resolveOptions(options);

              _this.listenClick(trigger);

              return _this;
            }
            /**
             * Defines if attributes would be resolved using internal setter functions
             * or custom functions that were passed in the constructor.
             * @param {Object} options
             */


            _createClass(Clipboard, [{
              key: "resolveOptions",
              value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                this.text = typeof options.text === "function" ? options.text : this.defaultText;
              }
            }, {
              key: "listenClick",
              value: function listenClick(trigger) {
                var _this2 = this;

                this.listener = (0, _goodListener2["default"])(trigger, "click", function (e) {
                  return _this2.onClick(e);
                });
              }
            }, {
              key: "onClick",
              value: function onClick(e) {
                var trigger = e.delegateTarget || e.currentTarget;

                if (this.clipboardAction) {
                  this.clipboardAction = null;
                }

                this.clipboardAction = new _clipboardAction2["default"]({
                  action: this.action(trigger),
                  target: this.target(trigger),
                  text: this.text(trigger),
                  trigger: trigger,
                  emitter: this
                });
              }
            }, {
              key: "defaultAction",
              value: function defaultAction(trigger) {
                return getAttributeValue("action", trigger);
              }
            }, {
              key: "defaultTarget",
              value: function defaultTarget(trigger) {
                var selector = getAttributeValue("target", trigger);

                if (selector) {
                  return document.querySelector(selector);
                }
              }
            }, {
              key: "defaultText",
              value: function defaultText(trigger) {
                return getAttributeValue("text", trigger);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.listener.destroy();

                if (this.clipboardAction) {
                  this.clipboardAction.destroy();
                  this.clipboardAction = null;
                }
              }
            }], [{
              key: "isSupported",
              value: function isSupported() {
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ["copy", "cut"];
                var actions = typeof action === "string" ? [action] : action;
                var support = !!document.queryCommandSupported;
                actions.forEach(function (action) {
                  support = support && !!document.queryCommandSupported(action);
                });
                return support;
              }
            }]);

            return Clipboard;
          }(_tinyEmitter2["default"]);
          /**
           * Helper function to retrieve attribute value.
           * @param {String} suffix
           * @param {Element} element
           */


          function getAttributeValue(suffix, element) {
            var attribute = "data-clipboard-" + suffix;

            if (!element.hasAttribute(attribute)) {
              return;
            }

            return element.getAttribute(attribute);
          }

          module.exports = Clipboard;
        });
      }, {
        "./clipboard-action": 7,
        "good-listener": 4,
        "tiny-emitter": 6
      }]
    }, {}, [8])(8);
  });
} catch (e) {}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(68)))

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 复制
 * Created by GUY on 2016/2/16.
 * @class BI.ClipBoard
 * @extends BI.BasicButton
 */
BI.ClipBoard = BI.inherit(BI.BasicButton, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.ClipBoard.superclass._defaultConfig.apply(this, arguments), {
      extraCls: "bi-clipboard",
      el: {
        type: "bi.layout"
      },
      copy: BI.emptyFn,
      afterCopy: BI.emptyFn
    });
  },
  render: function render() {
    return this.options.el;
  },
  mounted: function mounted() {
    var self = this,
        o = this.options;

    if (window.Clipboard) {
      this.clipboard = new Clipboard(this.element[0], {
        text: function text() {
          return BI.isFunction(o.copy) ? o.copy() : o.copy;
        }
      });
      this.clipboard.on("success", o.afterCopy);
    } else if (window.clipboardData) {
      // IE8下支持复制功能
      this.element.on("click", function () {
        var result = window.clipboardData.setData("Text", BI.isFunction(o.copy) ? o.copy() : o.copy);

        if (result) {
          o.afterCopy();
        }
      });
    } else {
      throw new Error("not support");
    }
  },
  destroyed: function destroyed() {
    this.clipboard && this.clipboard.destroy();
  }
});
BI.shortcut("bi.clipboard", BI.ClipBoard);

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  BI.Draggable = BI.inherit(BI.Widget, {
    props: {
      baseCls: "bi-materials-draggable",
      onDragStart: BI.emptyFn,
      onDrag: BI.emptyFn,
      onDragEnd: BI.emptyFn,
      el: {}
    },
    render: function render() {
      var self = this,
          o = this.options;
      this.startX = 0;
      this.startY = 0;
      this.tracker = new BI.MouseMoveTracker(function (deltaX, deltaY) {
        var W = BI.$("body").width(),
            H = BI.$("body").height();
        var size = self.element.bounds();
        self.startX += deltaX;
        self.startY += deltaY;
        var left = BI.clamp(self.startX, 0, W - size.width);
        var top = BI.clamp(self.startY, 0, H - size.height);
        self.element.css({
          left: left + "px",
          top: top + "px"
        });
        o.onDrag({
          left: left,
          top: top
        });
      }, function () {
        self.tracker.releaseMouseMoves();
        o.onDragEnd();
      }, window);
      return this.options.el;
    },
    mounted: function mounted() {
      var self = this,
          o = this.options;
      this.element.mousedown(function (e) {
        var pos = self.element.offset();
        self.startX = pos.left;
        self.startY = pos.top;
        self.tracker.captureMouseMoves(e);
        o.onDragStart();
      });
    }
  });
  BI.shortcut("bi.materials.draggable", BI.Draggable);
}();

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2016/1/15.
 * @class BI.CodeEditor
 * @extends BI.Single
 */
BI.CodeEditor = BI.inherit(BI.Single, {
  props: {
    baseCls: "bi-code-editor",
    value: "",
    watermark: "",
    lineHeight: 2,
    readOnly: false,
    lineNumbers: false,
    paramMatch: true,
    // 用来判断是否需要在代码中匹配参数，默认为true, R语言是不需要匹配参数
    // 参数显示值构造函数
    paramFormatter: function paramFormatter(v) {
      return v;
    }
  },
  render: function render() {
    var o = this.options,
        self = this;
    var conf = {
      lineWrapping: true,
      lineNumbers: o.lineNumbers,
      readOnly: o.readOnly,
      // 解决插入字段由括号或其他特殊字符包围时分裂的bug
      specialChars: /[\u0000-\u001f\u007f\u00ad\u200c-\u200f\u2028\u2029\ufeff]/,
      mode: o.mode
    };
    o.readOnly && (conf.cursorBlinkRate = -1);
    this.editor = BI.CodeMirror(this.element[0], conf);
    o.lineHeight === 1 ? this.element.addClass("codemirror-low-line-height") : this.element.addClass("codemirror-high-line-height");
    this.editor.on("change", function (cm, change) {
      if (cm.options.readOnly === true && change.origin === "paste") {
        self.editor.setValue(o.value);
      }

      self._checkWaterMark();

      BI.nextTick(function () {
        self.fireEvent(BI.CodeEditor.EVENT_CHANGE);
      });
    });
    this.editor.on("focus", function () {
      self._checkWaterMark(false);

      self.fireEvent(BI.CodeEditor.EVENT_FOCUS);
    });
    this.editor.on("blur", function () {
      self.watermark.setVisible(BI.isEmptyString(self.getValue()));
      self.fireEvent(BI.CodeEditor.EVENT_BLUR);
    }); // this.editor.on("mousedown", function (cm, e) {
    //     //IE下mousedown之后会触发blur,所以nextTick后再做focus
    //     BI.nextTick(function () {
    //         self.fireEvent(BI.CodeEditor.EVENT_FOCUS);
    //     });
    //     //e.stopPropagation();
    // });
    // this.editor.on("blur", function () {
    //     self.editor.execCommand("goLineEnd");
    // });
    // BI-39228 这边是codemirror的bug, 在设置了lineWrapping的情况下，paste文本会出现定位不准
    // 这边采用paste之后重新插入字符来解决一下

    this.editor.on("inputRead", function (cm, info) {
      if (info.origin === "paste") {
        BI.nextTick(function () {
          self.editor.replaceSelection(" ");
          var endPos = self.editor.getDoc().getCursor();
          self.editor.getDoc().replaceRange("", {
            line: endPos.line,
            ch: endPos.ch - 1
          }, endPos);
        });
      }
    }); // 水印

    this.watermark = BI.createWidget({
      type: "bi.label",
      text: o.watermark,
      cls: "bi-water-mark",
      whiteSpace: "normal",
      textAlign: "left"
    });
    this.watermark.element.bind("mousedown", function (e) {
      self.insertString("");
      self.editor.focus();
      e.stopEvent();
    });
    this.watermark.element.bind("click", function (e) {
      self.editor.focus();
      e.stopEvent();
    });
    BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.watermark,
        top: 3,
        left: o.lineNumbers ? 30 + 6 : 6,
        right: o.lineNumbers ? 30 + 6 : 6
      }]
    });
  },
  mounted: function mounted() {
    var o = this.options;

    if (BI.isNumber(o.value) || BI.isString(o.value)) {
      this.setValue(o.value);
    }

    if (BI.isNotNull(o.style)) {
      this.setStyle(o.style);
    }
  },
  _setEnable: function _setEnable(b) {
    BI.CodeEditor.superclass._setEnable.apply(this, arguments);

    this.editor.setOption("readOnly", b === true ? false : "nocursor");
  },
  _checkWaterMark: function _checkWaterMark() {
    var o = this.options;

    if (BI.isEmptyString(this.editor.getValue()) && BI.isKey(o.watermark)) {
      this.watermark && this.watermark.visible();
    } else {
      this.watermark && this.watermark.invisible();
    }
  },
  _insertParam: function _insertParam(param) {
    var value = param;
    var className = "param";
    param = this.options.paramFormatter(param);

    if (BI.isNotNull(param.match(/^<!.*!>$/))) {
      className = "error-param";
    } // 如果有选中，则先删除选中部分的文本，防止光标位置计算出错(有可能会算入应当被删除的文本的length)


    if (BI.isNotEmptyString(this.editor.getSelection())) {
      this.editor.replaceSelection("");
    }

    var from = this.editor.getCursor(); // 解决插入字段由括号或其他特殊字符包围时分裂的bug,在两端以不可见字符包裹一下

    this.editor.replaceSelection("\u200B" + param + "\u200B");
    var to = this.editor.getCursor();
    var options = {
      className: className,
      atomic: true,
      replacedWith: BI.$("<span class='" + className + " start end' />").text(param)[0]
    };
    options.value = value;
    this.editor.markText(from, to, options);
  },
  _insertString: function _insertString(str) {
    this.editor.replaceSelection(str);
  },
  _analyzeContent: function _analyzeContent(v) {
    var regx = /\n|\$[\{][^\}]*[\}]|((?!\$\{).)*((?!\$\{).)|\$[^\{]*[^\$\{]/g;
    return v.match(regx);
  },
  getValue: function getValue() {
    return this.editor.getValue("\n", function (line) {
      var value = line.text,
          num = 0; // 根据插入位置不同，line.markedSpan可能是乱序的

      _.forEach(_.sortBy(line.markedSpans, "from"), function (i, ms) {
        switch (i.marker.className) {
          case "param":
          case "error-param":
            var fieldNameLength = i.to - i.from;
            value = value.substr(0, i.from + num) + "$\{" + i.marker.value + "\}" + value.substr(i.to + num, value.length); // 加上${}的偏移

            num += 3; // 加上实际值和显示值的长度差的偏移

            num += i.marker.value.length - fieldNameLength;
            break;
        }
      });

      return value;
    });
  },
  setValue: function setValue(v) {
    var self = this,
        o = this.options,
        result;
    this.refresh();
    this.options.value = v;
    self.editor.setValue("");

    if (o.paramMatch) {
      result = this._analyzeContent(v || "");
      BI.each(result, function (i, item) {
        var fieldRegx = /\$[\{][^\}]*[\}]/;
        var str = item.match(fieldRegx);

        if (BI.isNotEmptyArray(str)) {
          self._insertParam(str[0].substring(2, item.length - 1));
        } else {
          self._insertString(item);
        }
      });
    } else {
      self.editor.setValue(v);
    }

    this._checkWaterMark();
  },
  insertParam: function insertParam(param) {
    this._insertParam(param);

    this.editor.focus();
  },
  insertString: function insertString(str) {
    this._insertString(str);

    this.editor.focus();
  },
  focus: function focus() {
    this.editor.focus();
  },
  blur: function blur() {
    this.editor.getInputField().blur();
  },
  setStyle: function setStyle(style) {
    this.style = style;
    this.element.css(style);
  },
  getStyle: function getStyle() {
    return this.style;
  },
  refresh: function refresh() {
    var self = this;
    BI.nextTick(function () {
      self.editor.refresh();
    });
  },
  setVisible: function setVisible(visible) {
    BI.CodeEditor.superclass.setVisible.apply(this, arguments);
    visible && this.refresh();
  }
});
BI.CodeEditor.EVENT_CHANGE = "EVENT_CHANGE";
BI.CodeEditor.EVENT_BLUR = "EVENT_BLUR";
BI.CodeEditor.EVENT_FOCUS = "EVENT_FOCUS";
BI.shortcut("bi.code_editor", BI.CodeEditor);

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/8/2
 */
!function () {
  function Beautify(tokens, cm, options) {
    options = options || {};
    this.tokens = tokens;
    this.flags = {
      lastToken: null,
      indentationLevel: 0
    };
    this.flagsStore = [];
    this.valueGetter = options.valueGetter;
    this.output = cm.getOutput();
  }

  Beautify.prototype.beautify = function () {
    var currentToken = this.tokens.next();

    while (currentToken) {
      this.handleToken(currentToken);
      this.flags.lastToken = currentToken;
      currentToken = this.tokens.next();
    }

    return this.output.getResult();
  };

  Beautify.prototype.handleToken = function (currentToken) {
    switch (currentToken.type) {
      case 'string':
        this.handleString(currentToken);
        break;

      case 'field':
        this.handleField(currentToken);
        break;

      case 'comma':
        // 函数参数分割
        this.handleComma(currentToken);
        break;

      case 'bracket':
        this.handleBracket(currentToken);
        break;

      case 'atom':
        this.handleWord(currentToken);
        break;

      case 'word':
        this.handleWord(currentToken);
        break;

      case 'keyword':
        this.handleKeyword(currentToken);
        break;

      case 'operator':
        this.handleOperator(currentToken);
        break;

      default:
        this.handleCommon(currentToken);
        break;
    }
  };

  Beautify.prototype.handleCommon = function (currentToken) {
    this.checkNeedSpace();
    this.output.addToken(currentToken);
  };

  Beautify.prototype.handleOperator = function (currentToken) {
    this.output.addSpaceBeforeToken();
    this.output.addToken(currentToken);
  };

  Beautify.prototype.handleKeyword = function (currentToken) {
    this.checkNeedSpace();
    this.output.addToken(currentToken);
  };

  Beautify.prototype.handleBracket = function (currentToken) {
    this.checkNeedSpace();

    if (currentToken.string === '(') {
      this.flagsStore.push(this.flags);
      this.flags = {
        lastToken: null,
        indentationLevel: this.flags.indentationLevel
      };
      this.output.addToken(currentToken);
      this.indent();
      this.output.addNewLine();
    }

    if (currentToken.string === ')') {
      if (this.flagsStore.length > 0) {
        this.flags = this.flagsStore.pop();
        this.setIndent();
        this.output.addNewLine();
        this.output.addToken(currentToken);
      }
    }
  };

  Beautify.prototype.checkNeedSpace = function () {
    if (this.flags.lastToken && this.flags.lastToken.type === 'operator') {
      this.output.addSpaceBeforeToken();
    }
  };

  Beautify.prototype.handleComma = function (currentToken) {
    this.output.addToken(currentToken);
    this.output.addNewLine();
  };

  Beautify.prototype.handleString = function (currentToken) {
    this.checkNeedSpace();
    this.output.addToken(currentToken);
  };

  Beautify.prototype.handleField = function (currentToken) {
    this.checkNeedSpace();
    this.output.addToken(currentToken, {
      valueGetter: this.valueGetter
    });
  };

  Beautify.prototype.handleWord = function (currentToken) {
    this.checkNeedSpace();
    this.output.addToken(currentToken);
  };

  Beautify.prototype.indent = function () {
    this.flags.indentationLevel += 1;
    this.output.setIndent(this.flags.indentationLevel);
  };

  Beautify.prototype.setIndent = function () {
    this.output.setIndent(this.flags.indentationLevel);
  };

  Beautify.prototype.deIndent = function () {
    this.flags.indentationLevel = this.flags.indentationLevel < 0 ? 0 : this.flags.indentationLevel - 1;
    this.output.setIndent(this.flags.indentationLevel);
  };

  BI.CodeMirror.defineExtension("beautify", function (options) {
    var beautify = new Beautify(this.getTokens(), this, options);
    return beautify.beautify();
  });
}();

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/8/3
 */
!function () {
  function Output() {
    this.lines = [];
    this.previousLine = null;
    this.currentLine = null;
    this.nextLine = new Line();
    this.addOutputLine();
  }

  Output.prototype.addToken = function (token, options) {
    options = options || {};
    this.currentLine.addText(options.valueGetter ? options.valueGetter(token.string) : token.string);
  };

  Output.prototype.addNewLine = function (force) {
    if (this.isEmpty() || !force && this.justAddedNewline()) {
      return false;
    }

    this.addOutputLine();
    return true;
  };

  Output.prototype.addNewLine = function (force) {
    if (this.isEmpty() || !force && this.justAddedNewline()) {
      return false;
    }

    this.addOutputLine();
    return true;
  };

  Output.prototype.addOutputLine = function () {
    this.previousLine = this.currentLine;
    this.currentLine = this.nextLine.cloneEmpty();
    this.lines.push(this.currentLine);
  };

  Output.prototype.justAddedNewline = function () {
    return this.currentLine.isEmpty();
  };

  Output.prototype.isEmpty = function () {
    return !this.previousLine && this.currentLine.isEmpty();
  };

  Output.prototype.setIndent = function (indent) {
    indent = indent || 0;
    this.nextLine.setIndent(indent);
  };

  Output.prototype.addSpaceBeforeToken = function () {
    if (!this.justAddedNewline()) {
      this.currentLine.addText(' ');
    }
  };

  Output.prototype.getResult = function (indent) {
    return this.lines.join('\n');
  };

  function Line() {
    this._indent_count = 0;
    this.items = [];
  }

  Line.prototype.setIndent = function (indent) {
    if (this.isEmpty()) {
      this._indent_count = indent || 0;
    }
  };

  Line.prototype.addText = function (text) {
    this.items.push(text);
  };

  Line.prototype.cloneEmpty = function () {
    var line = new Line();
    line.setIndent(this._indent_count);
    return line;
  };

  Line.prototype.isEmpty = function () {
    return this.items.length === 0;
  };

  Line.prototype.toString = function () {
    var result = "";

    for (var i = 0; i < this._indent_count; i++) {
      result += '\t';
    }

    return result + this.items.join('');
  };

  BI.CodeMirror.defineExtension("getOutput", function () {
    return new Output();
  });
}();

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 2.0
 * Created by windy on 2021/8/2
 * 利用下codemirror内置的tokens,以后有需要再看看是不是实现一下
 */
!function () {
  function Token(tokens) {
    this.tokens = tokens.filter(function (token) {
      return !token.string.match(/\s/);
    }) || [];
    this.position = -1;
  }

  Token.prototype.hasNext = function () {
    return this.tokens.length > 0 && this.position < this.tokens.length - 1;
  };

  Token.prototype.next = function () {
    var token = null;

    if (this.hasNext()) {
      token = this.tokens[++this.position];
    }

    return token;
  };

  Token.prototype.peek = function (index) {
    var token = null;
    index = index || 0;
    index += this.position;

    if (index >= 0 && index < this.tokens.length) {
      token = this.tokens[index];
    }

    return token;
  };

  BI.CodeMirror.defineExtension("getTokens", function () {
    var self = this;
    var tokens = BI.flatten(BI.map(BI.range(0, this.getDoc().lineCount()), function (idx) {
      return self.getLineTokens(idx);
    }));
    return new Token(tokens);
  });
}();

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function (mod) {
  mod(BI.CodeMirror);
})(function (CodeMirror) {
  var Pos = CodeMirror.Pos;

  function forEach(arr, f) {
    for (var i = 0, e = arr.length; i < e; ++i) {
      f(arr[i]);
    }
  }

  function scriptHint(editor, keywords, getToken, options) {
    // Find the token at the cursor
    var cur = editor.getCursor(),
        token = getToken(editor, cur);

    if (/\b(?:string)\b/.test(token.type)) {
      return;
    }

    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;

    if (!/^[\w$_\u4e00-\u9fa5]*$/.test(token.string)) {
      token = {
        start: cur.ch,
        end: cur.ch,
        string: "",
        state: token.state,
        type: token.string == "." ? "property" : null
      };
    } else if (token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }

    var tprop = token; // If it is a property, find out what it is a property of.

    while (tprop.type == "property") {
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (tprop.string != ".") return;
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (!context) var context = [];
      context.push(tprop);
    }

    return {
      list: getCompletions(token, context, keywords, options),
      from: Pos(cur.line, token.start),
      to: Pos(cur.line, token.end)
    };
  }

  function formulaHint(editor, options) {
    return scriptHint(editor, editor.keywordsGetter(), function (e, cur) {
      return e.getTokenAt(cur);
    }, options);
  }

  CodeMirror.registerHelper("hint", "formula", formulaHint);

  function getCompletions(token, context, keywords, options) {
    var found = [],
        foundText = [],
        start = token.string;

    if (!start) {
      return found;
    }

    function maybeAdd(obj) {
      // 首字母也可搜出中文函数或者字段
      var text = [obj.text];

      if (obj.type === BICst.FORMULA_KEYWORD_TYPE.PARAM) {
        var py = BI.makeFirstPY(obj.text, {
          splitChar: "\u200B"
        });
        var upperPy = py.toUpperCase();
        text = py.split("\u200B").concat(upperPy.split("\u200B"));
        text.push(obj.text);
      }

      var searched = BI.some(text, function (idx, s) {
        return s.lastIndexOf(start, 0) == 0;
      });

      if (searched) {
        var results = BI.filter(found, function (idx, item) {
          return item.value === obj.value;
        });
        var typeExist = BI.some(results, function (idx, result) {
          return result.type === obj.type;
        });

        if (BI.isEmptyArray(results) || !typeExist) {
          foundText.push(obj.text);
          found.push(obj);
        }
      }
    }

    if (context && context.length) {
      context.pop();
    } else {
      forEach(keywords, maybeAdd);
    }

    return found;
  }
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
// version 5.42.2
(function (mod) {
  mod(BI.CodeMirror);
})(function (CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active"; // This is the old interface, kept around for now to stay
  // backwards-compatible.

  CodeMirror.showHint = function (cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {
      hint: getHints
    };
    if (options) for (var prop in options) {
      newOpts[prop] = options[prop];
    }
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function (options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections();
    if (selections.length > 1) return; // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.

    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return; // Don't try with cross-line selections

      for (var i = 0; i < selections.length; i++) {
        if (selections[i].head.line != selections[i].anchor.line) return;
      }
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;
    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });
  CodeMirror.defineExtension("closeHint", function () {
    if (this.state.completionActive) this.state.completionActive.close();
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
    var self = this;
    cm.on("cursorActivity", this.activityFunc = function () {
      self.cursorActivity();
    });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function (fn) {
    return setTimeout(fn, 1000 / 60);
  };

  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
  Completion.prototype = {
    close: function close() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);
      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },
    active: function active() {
      return this.cm.state.completionActive == this;
    },
    pick: function pick(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);else {
        switch (completion.type) {
          case BICst.FORMULA_KEYWORD_TYPE.KEYWORD:
            this.cm.replaceRange(getText(completion).toUpperCase(), completion.from || data.from, completion.to || data.to, "complete"); // 插入关键字添加空格

            this.cm.replaceSelection(" ");
            break;

          case BICst.FORMULA_KEYWORD_TYPE.FUNCTION:
            this.cm.replaceRange(getText(completion).toUpperCase(), completion.from || data.from, completion.to || data.to, "complete");
            var to = this.cm.getCursor();
            this.cm.markText(completion.from || data.from, to, {
              className: "#function",
              atomic: true
            });
            this.cm.replaceSelection("()");
            to = this.cm.getCursor();
            to.ch = to.ch - 1;
            this.cm.setCursor(to);
            this.cm.focus();
            break;

          case BICst.FORMULA_KEYWORD_TYPE.PARAM:
            var value = completion.value;
            var fieldFormattedName = completion.text;
            var from = data.from; // // 解决插入字段由括号或其他特殊字符包围时分裂的bug,在两端以不可见字符包裹一下

            var showName = fieldFormattedName.replaceAll("^<!.*!>$", function (str) {
              return str.substring(2, str.length - 2);
            });
            this.cm.replaceRange("\u200B" + showName + "\u200B", from, data.to, "complete");
            var to = this.cm.getCursor("to");
            var className = "fieldName"; // // handleMouseEvents和replacedWith需要搭配使用，让codemirror接管鼠标事件

            this.cm.markText(from, to, {
              className: className,
              handleMouseEvents: true,
              atomic: true,
              startStyle: "start",
              endStyle: "end",
              value: value,
              replacedWith: BI.$("<span class='" + className + "  start end' />").text(showName)[0]
            });
            break;

          default:
            break;
        }
      }
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },
    cursorActivity: function cursorActivity() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(),
          line = this.cm.getLine(pos.line);

      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < this.startPos.ch || this.cm.somethingSelected() || !pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function () {
          self.update();
        });
        if (this.widget) this.widget.disable();
      }
    },
    update: function update(first) {
      if (this.tick == null) return;
      var self = this,
          myTick = ++this.tick;
      fetchHints(this.options.hint, this.cm, this.options, function (data) {
        if (self.tick == myTick) self.finishUpdate(data, first);
      });
    },
    finishUpdate: function finishUpdate(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");
      var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
      if (this.widget) this.widget.close();
      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};

    for (var prop in defaultOptions) {
      out[prop] = defaultOptions[prop];
    }

    if (editor) for (var prop in editor) {
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    }
    if (options) for (var prop in options) {
      if (options[prop] !== undefined) out[prop] = options[prop];
    }
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos);
    return out;
  }

  function getText(completion) {
    if (typeof completion === "string") return completion;
    return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function Up() {
        handle.moveFocus(-1);
      },
      Down: function Down() {
        handle.moveFocus(1);
      },
      PageUp: function PageUp() {
        handle.moveFocus(-handle.menuSize() + 1, true);
      },
      PageDown: function PageDown() {
        handle.moveFocus(handle.menuSize() - 1, true);
      },
      Home: function Home() {
        handle.setFocus(0);
      },
      End: function End() {
        handle.setFocus(handle.length - 1);
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;

    function addBinding(key, val) {
      var bound;

      if (typeof val !== "string") {
        bound = function bound(cm) {
          return val(cm, handle);
        };
      } // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val)) {
        bound = baseMap[val];
      } else {
        bound = val;
      }

      ourMap[key] = bound;
    }

    if (custom) {
      for (var key in custom) {
        if (custom.hasOwnProperty(key)) {
          addBinding(key, custom[key]);
        }
      }
    }

    var extra = completion.options.extraKeys;

    if (extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key)) {
          addBinding(key, extra[key]);
        }
      }
    }

    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "DIV" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this,
        cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;
    var hints = this.hints = ownerDocument.createElement("div"); // 主题不给配, 恁地?
    // var theme = completion.cm.options.theme;

    var hintsWidget = BI.createWidget({
      type: "bi.button_group",
      cls: "CodeMirror-hints bi-card",
      element: hints,
      layouts: [{
        type: "bi.vertical"
      }]
    });
    this.selectedHint = data.selectedHint || 0;
    var completions = data.list;
    var eltLists = [];

    for (var i = 0; i < completions.length; ++i) {
      var elt = ownerDocument.createElement("div"),
          cur = completions[i];
      var eltObj = {};
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;

      if (cur.render) {
        eltObj = BI.createWidget(cur.render(elt, data, cur));
      } else {
        var text = cur.displayText || getText(cur);
        eltObj = BI.createWidget({
          type: BI.isNotNull(cur.iconCls) ? "bi.icon_text_item" : "bi.single_select_item",
          logic: {
            dynamic: true
          },
          height: 24,
          cls: BI.isNotNull(cur.iconCls) ? className + ' ' + cur.iconCls : className,
          textAlign: "left",
          text: text,
          title: text
        });
      }

      eltObj.element[0].hintId = i;
      eltLists.push(eltObj);
    }

    hintsWidget.populate(eltLists);
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left,
        top = pos.bottom,
        below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px"; // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.

    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    (completion.options.container || ownerDocument.body).appendChild(hints);
    var box = hints.getBoundingClientRect(),
        overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1;
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = box.bottom - box.top,
          curTop = pos.top - (pos.bottom - box.top);

      if (curTop - height > 0) {
        // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = winH - 5 + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();

        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }

    var overlapX = box.right - winW;

    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px";
        overlapX -= box.right - box.left - winW;
      }

      hints.style.left = (left = pos.left - overlapX) + "px";
    }

    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling) {
      node.style.paddingRight = cm.display.nativeBarWidth + "px";
    }
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function moveFocus(n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function setFocus(n) {
        widget.changeActive(n);
      },
      menuSize: function menuSize() {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function close() {
        completion.close();
      },
      pick: function pick() {
        widget.pick();
      },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function () {
        closingOnBlur = setTimeout(function () {
          completion.close();
        }, 100);
      });
      cm.on("focus", this.onFocus = function () {
        clearTimeout(closingOnBlur);
      });
    }

    cm.on("scroll", this.onScroll = function () {
      var curScroll = cm.getScrollInfo(),
          editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = left + startScroll.left - curScroll.left + "px";
    });
    CodeMirror.on(hints, "dblclick", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);

      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror.on(hints, "click", function (e) {
      var t = getHintElement(hints, e.target || e.srcElement);

      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });
    CodeMirror.on(hints, "mousedown", function () {
      setTimeout(function () {
        cm.focus();
      }, 20);
    });
    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function close() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var cm = this.completion.cm;

      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }

      cm.off("scroll", this.onScroll);
    },
    disable: function disable() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {
        Enter: function Enter() {
          widget.picked = true;
        }
      };
      this.completion.cm.addKeyMap(this.keyMap);
    },
    pick: function pick() {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function changeActive(i, avoidWrap) {
      if (i >= this.data.list.length) i = avoidWrap ? this.data.list.length - 1 : 0;else if (i < 0) i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop) this.hints.scrollTop = node.offsetTop - 3;else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight) this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },
    screenAmount: function screenAmount() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers;
    var result = [];

    for (var i = 0; i < helpers.length; i++) {
      if (helpers[i].supportsSelection) result.push(helpers[i]);
    }

    return result;
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options);
    } else {
      var result = hint(cm, options);
      if (result && result.then) result.then(callback);else callback(result);
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"),
        words;

    if (helpers.length) {
      var resolved = function resolved(cm, callback, options) {
        var app = applicableHelpers(cm, helpers);

        function run(i) {
          if (i == app.length) return callback(null);
          fetchHints(app[i], cm, options, function (result) {
            if (result && result.list.length > 0) callback(result);else run(i + 1);
          });
        }

        run(0);
      };

      resolved.async = true;
      resolved.supportsSelection = true;
      return resolved;
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function (cm) {
        return CodeMirror.hint.fromList(cm, {
          words: words
        });
      };
    } else if (CodeMirror.hint.anyword) {
      return function (cm, options) {
        return CodeMirror.hint.anyword(cm, options);
      };
    } else {
      return function () {};
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });
  CodeMirror.registerHelper("hint", "fromList", function (cm, options) {
    var cur = cm.getCursor(),
        token = cm.getTokenAt(cur);
    var term,
        from = CodeMirror.Pos(cur.line, token.start),
        to = cur;

    if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start);
    } else {
      term = "";
      from = cur;
    }

    var found = [];

    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term) found.push(word);
    }

    if (found.length) return {
      list: found,
      from: from,
      to: to
    };
  });
  CodeMirror.commands.autocomplete = CodeMirror.showHint;
  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };
  CodeMirror.defineOption("hintOptions", null);
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
// version 5.42.2
(function (mod) {
  mod(BI.CodeMirror);
})(function (CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
  var Pos = CodeMirror.Pos;
  var matching = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<",
    "<": ">>",
    ">": "<<"
  };

  function bracketRegex(config) {
    return config && config.bracketRegex || /[(){}[\]]/;
  }

  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line),
        pos = where.ch - 1;
    var afterCursor = config && config.afterCursor;
    if (afterCursor == null) afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
    var re = bracketRegex(config); // A cursor is defined as between two characters, but in in vim command mode
    // (i.e. not insert mode), the cursor is visually represented as a
    // highlighted box on top of the 2nd character. Otherwise, we allow matches
    // from before or after the cursor.

    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {
      from: Pos(where.line, pos),
      to: found && found.pos,
      match: found && found.ch == match.charAt(0),
      forward: dir > 0
    };
  } // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up


  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = config && config.maxScanLineLength || 10000;
    var maxScanLines = config && config.maxScanLines || 1000;
    var stack = [];
    var re = bracketRegex(config);
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);

    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1,
          end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);

      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);

        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if (match.charAt(1) == ">" == dir > 0) stack.push(ch);else if (!stack.length) return {
            pos: Pos(lineNo, pos),
            ch: ch
          };else stack.pop();
        }
      }
    }

    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [],
        ranges = cm.listSelections();

    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);

      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {
          className: style
        }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen) marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {
          className: style
        }));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.focus();

      var clear = function clear() {
        cm.operation(function () {
          for (var i = 0; i < marks.length; i++) {
            marks[i].clear();
          }
        });
      };

      if (autoclear) setTimeout(clear, 800);else return clear;
    }
  }

  function doMatchBrackets(cm) {
    cm.operation(function () {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }

      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function (cm, val, old) {
    // matchBrackets的默认配置会使得上层接收到的e.target在父亲中无法找到
    // 可以看到matchBrackets的逻辑是将括号重新做了markText,这一步操作可能与鼠标的focus相冲突(标记后再focus,对象不一致？)
    // 既然是冲突的，那么就先让鼠标focus之后, 再去做markText
    var func = function func() {
      var args = arguments;
      BI.defer(function () {
        doMatchBrackets.apply(null, args);
      });
    };

    if (old && old != CodeMirror.Init) {
      cm.off("cursorActivity", func);

      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }

    if (val) {
      cm.state.matchBrackets = _typeof(val) == "object" ? val : {};
      cm.on("cursorActivity", func);
    }
  });
  CodeMirror.defineExtension("matchBrackets", function () {
    matchBrackets(this, true);
  });
  CodeMirror.defineExtension("findMatchingBracket", function (pos, config, oldConfig) {
    // Backwards-compatibility kludge
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? {
          strict: true
        } : null;
      } else {
        oldConfig.strict = config;
        config = oldConfig;
      }
    }

    return findMatchingBracket(this, pos, config);
  });
  CodeMirror.defineExtension("scanForBracket", function (pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  });
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function (mod) {
  mod(BI.CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("formula", function (options) {
    function wordObj(words) {
      var o = {};

      for (var i = 0, e = words.length; i < e; ++i) {
        o[words[i]] = true;
      }

      return o;
    }

    var atoms = wordObj(["false", "true"]);
    var keywords = wordObj(BI.map(options.keywordsGetter(), "text"));

    function tokenBase(stream, state) {
      if (stream.eatSpace()) {
        return null;
      }

      var ch = stream.next();

      if (ch === "\"" || ch === "'") {
        nextUntilUnescaped(stream, ch);
        return "string";
      } // if (ch === "{") {
      //     nextUntilUnescaped(stream, "}");
      //     return "string";
      // }


      if (ch === "\u200B") {
        nextUntilUnescaped(stream, ch);
        return "field";
      }

      if (/,/.test(ch)) {
        return "comma";
      }

      if (/[()\[\]]/.test(ch)) {
        return "bracket";
      }

      if (/[+\-*\/=<>!&\^|]/.test(ch)) {
        return "operator";
      } // richie：暂时不需要解析操作符号
      // if (/[+\-*\/=<>!&|]/.test(ch)) {
      //  return 'operator';
      // }
      // if (/\d|\d./.test(ch)) {
      //    stream.eatWhile(/\d|\./);
      //    if (stream.eol() || !/\w/.test(stream.peek())) {
      //        return 'number';
      //    }
      // }
      // 汉字和英文单词都吞一下


      stream.eatWhile(/[\u4e00-\u9fa5\w-.]/);
      var word = stream.current();

      if (atoms.hasOwnProperty(word)) {
        return "atom";
      }

      if (keywords.hasOwnProperty(word)) {
        return "keyword";
      }

      return 'word';
    }

    function nextUntilUnescaped(stream, end) {
      var escaped = false,
          next;

      while ((next = stream.next()) != null) {
        if (next === end && !escaped) {
          return false;
        }

        escaped = !escaped && next === "\\";
      }

      return escaped;
    }

    function tokenize(stream, state) {
      return (state.tokens[0] || tokenBase)(stream, state);
    }

    return {
      startState: function startState() {
        return {
          tokens: []
        };
      },
      token: function token(stream, state) {
        return tokenize(stream, state);
      },
      fold: "brace"
    };
  });
  CodeMirror.defineMIME("text/fx-formula", "formula");
  CodeMirror.defineOption("keywordsGetter", false, function (cm, val) {
    cm.keywordsGetter = BI.isFunction(val) ? val : function (v) {
      return v;
    };
  });
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by User on 2017/3/21.
 */
BI.FormulaCollections = ["abs", "ABS", "acos", "ACOS", "acosh", "ACOSH", "add2array", "ADD2ARRAY", "and", "AND", "array", "ARRAY", "asin", "ASIN", "asinh", "ASINH", "atan", "ATAN", "atan2", "ATAN2", "atanh", "ATANH", "average", "AVERAGE", "bitnot", "BITNOT", "bitoperation", "BITOPERATION", "ceiling", "CEILING", "char", "CHAR", "circular", "CIRCULAR", "class", "CLASS", "cnmoney", "CNMONEY", "code", "CODE", "col", "COL", "colcount", "COLCOUNT", "colname", "COLNAME", "combin", "COMBIN", "concatenate", "CONCATENATE", "correl", "CORREL", "cos", "COS", "cosh", "COSH", "count", "COUNT", "crosslayertotal", "CROSSLAYERTOTAL", "date", "DATE", "datedelta", "DATEDELTA", "datedif", "DATEDIF", "dateinmonth", "DATEINMONTH", "dateinquarter", "DATEINQUARTER", "dateinweek", "DATEINWEEK", "dateinyear", "DATEINYEAR", "datesubdate", "DATESUBDATE", "datetime", "DATETIME", "datetonumber", "DATETONUMBER", "day", "DAY", "days360", "DAYS360", "daysofmonth", "DAYSOFMONTH", "daysofquarter", "DAYSOFQUARTER", "daysofyear", "DAYSOFYEAR", "dayvalue", "DAYVALUE", "decimal", "DECIMAL", "decode", "DECODE", "degrees", "DEGREES", "encode", "ENCODE", "endwith", "ENDWITH", "enmoney", "ENMONEY", "ennumber", "ENNUMBER", "eval", "EVAL", "even", "EVEN", "exact", "EXACT", "exp", "EXP", "fact", "FACT", "fields", "FIELDS", "filename", "FILENAME", "filesize", "FILESIZE", "filetype", "FILETYPE", "find", "FIND", "floor", "FLOOR", "format", "FORMAT", "getuserdepartments", "GETUSERDEPARTMENTS", "getuserjobtitles", "GETUSERJOBTITLES", "greparray", "GREPARRAY", "hierarchy", "HIERARCHY", "hour", "HOUR", "i18n", "I18N", "if", "IF", "inarray", "INARRAY", "index", "INDEX", "indexof", "INDEXOF", "indexofarray", "INDEXOFARRAY", "int", "INT", "isnull", "ISNULL", "joinarray", "JOINARRAY", "jvm", "JVM", "layertotal", "LAYERTOTAL", "left", "LEFT", "len", "LEN", "let", "LET", "ln", "LN", "log", "LOG", "log10", "LOG10", "lower", "LOWER", "lunar", "LUNAR", "map", "MAP", "maparray", "MAPARRAY", "max", "MAX", "median", "MEDIAN", "mid", "MID", "min", "MIN", "minute", "MINUTE", "mod", "MOD", "mom", "MOM", "month", "MONTH", "monthdelta", "MONTHDELTA", "now", "NOW", "numto", "NUMTO", "nvl", "NVL", "odd", "ODD", "or", "OR", "pi", "PI", "power", "POWER", "product", "PRODUCT", "promotion", "PROMOTION", "proper", "PROPER", "proportion", "PROPORTION", "radians", "RADIANS", "rand", "RAND", "randbetween", "RANDBETWEEN", "range", "RANGE", "rank", "RANK", "records", "RECORDS", "regexp", "REGEXP", "removearray", "REMOVEARRAY", "repeat", "REPEAT", "replace", "REPLACE", "reverse", "REVERSE", "reversearray", "REVERSEARRAY", "right", "RIGHT", "round", "ROUND", "round5", "ROUND5", "rounddown", "ROUNDDOWN", "roundup", "ROUNDUP", "row", "ROW", "rowcount", "ROWCOUNT", "second", "SECOND", "seq", "SEQ", "sign", "SIGN", "sin", "SIN", "sinh", "SINH", "slicearray", "SLICEARRAY", "sort", "SORT", "sortarray", "SORTARRAY", "split", "SPLIT", "sql", "SQL", "sqrt", "SQRT", "startwith", "STARTWITH", "stdev", "STDEV", "substitute", "SUBSTITUTE", "sum", "SUM", "sumsq", "SUMSQ", "switch", "SWITCH", "tabledatafields", "TABLEDATAFIELDS", "tabledatas", "TABLEDATAS", "tables", "TABLES", "tan", "TAN", "tanh", "TANH", "time", "TIME", "tobigdecimal", "TOBIGDECIMAL", "tobinary", "TOBINARY", "todate", "TODATE", "today", "TODAY", "todouble", "TODOUBLE", "tohex", "TOHEX", "toimage", "TOIMAGE", "tointeger", "TOINTEGER", "tooctal", "TOOCTAL", "totext", "TOTEXT", "treelayer", "TREELAYER", "trim", "TRIM", "trunc", "TRUNC", "uniquearray", "UNIQUEARRAY", "upper", "UPPER", "uuid", "UUID", "value", "VALUE", "webimage", "WEBIMAGE", "week", "WEEK", "weekdate", "WEEKDATE", "weekday", "WEEKDAY", "weightedaverage", "WEIGHTEDAVERAGE", "year", "YEAR", "yeardelta", "YEARDELTA"];

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _FormulaCheck = _interopRequireDefault(__webpack_require__(111));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Provider = function Provider() {
  var checkers = {};

  this.addChecker = function (checker) {
    BI.extend(checkers, checker);
  };

  this.$get = function () {
    return function () {
      return checkers;
    };
  };
};

BI.provider("bi.formula_editor.checker", Provider);
/**
 * 公式编辑控件
 * @class BI.FormulaEditor
 * @extends BI.Widget
 */

BI.FormulaEditor = BI.inherit(BI.Single, {
  constants: {
    paramRegex: /(\$[\{][^\}]*[\}])/
  },
  props: {
    baseCls: "bi-formula-editor",
    watermark: "",
    value: "",
    showHint: true,
    showTip: true,
    lineHeight: 2,
    lineWrapping: true,
    lineNumbers: false,
    paramFormatter: function paramFormatter(v) {
      return v;
    },
    valueGetter: function valueGetter(text) {
      return text;
    },
    keywordsGetter: function keywordsGetter() {
      return BI.FormulaCollections;
    },
    // 公式校验时用到的两个函数
    formulaChecker: BI.emptyFn,
    paramTypeGetter: BI.emptyFn
  },
  render: function render() {
    var o = this.options,
        self = this;
    this.errorTipText = "";
    this._isEditing = false;
    this.formulaEditor = BI.createWidget({
      type: "bi.default"
    });
    var formulaHint = BI.CodeMirror.hint.formula;

    BI.CodeMirror.hint.formula = function (cm, options) {
      var result = formulaHint(cm, options);

      if (result) {
        BI.CodeMirror.on(result, "shown", function () {
          self.fireEvent("EVENT_SHOW_HINT", BI.get(result, "list", []));
        });
        BI.CodeMirror.on(result, "select", function (comp) {
          self.fireEvent("EVENT_SELECT_HINT", comp);
        });
        BI.CodeMirror.on(result, "pick", function (comp) {
          self.fireEvent("EVENT_PICK_HINT", comp);
        });
      }

      return result;
    };

    this.editor = BI.CodeMirror(this.formulaEditor.element[0], {
      lineWrapping: o.lineWrapping,
      lineNumbers: o.lineNumbers,
      mode: "formula",
      // 解决插入字段由括号或其他特殊字符包围时分裂的bug
      specialChars: /[\u0000-\u001f\u007f\u00ad\u200c-\u200f\u2028\u2029\ufeff]/,
      // 光标旁的括号对高亮标记, 极限搜索范围2000个字符
      // DEC-7094 IE下高亮括号会使得鼠标无法框选文本, 目前实在看不出来是为什么, 先在IE下取消使用了
      matchBrackets: BI.isIE() ? null : {
        maxScanLines: 2e3,
        maxHighlightLineLength: 2e3
      },
      keywordsGetter: function keywordsGetter() {
        var keywords = o.keywordsGetter();
        return BI.map(keywords, function (idx, obj) {
          if (BI.isKey(obj)) {
            return {
              text: obj,
              value: obj,
              type: BICst.FORMULA_KEYWORD_TYPE.FUNCTION,
              iconCls: "formula-function-font"
            };
          }

          return obj;
        });
      },
      configureMouse: function configureMouse() {
        return {
          addNew: false
        };
      }
    });
    o.lineHeight === 1 ? this.element.addClass("codemirror-low-line-height") : this.element.addClass("codemirror-high-line-height");
    var func = BI.debounce(function () {
      BI.nextTick(function () {
        self.fireEvent(BI.FormulaEditor.EVENT_CHANGE);
      });
    }, 300);
    this.editor.on("change", function (cm, change) {
      self._checkWaterMark(); // 调用setValue也会触发change, 提示框只需要在编辑的时候触发


      if (o.showHint && self.editor.hasFocus()) {
        BI.CodeMirror.showHint(cm, BI.CodeMirror.formulaHint, {
          completeSingle: false
        });
      } // 与input一样, 防止抖动


      func();
    }); // 拦截ctrl + X, ctrl + C, 重新处理选中文本到剪贴板

    this.editor.setOption("extraKeys", {
      "Ctrl-X": function CtrlX(cm) {
        self._getSelection(cm);

        cm.replaceSelection("");
        cm.focus();
      },
      "Cmd-X": function CmdX(cm) {
        self._getSelection(cm);

        cm.replaceSelection("");
        cm.focus();
      },
      "Cmd-C": function CmdC(cm) {
        self._getSelection(cm);
      },
      "Ctrl-C": function CtrlC(cm) {
        self._getSelection(cm);
      }
    });
    var KEYMAP = {
      "（）": "()",
      "【】": "[]",
      "｛｝": "{}",
      "「」": "{}",
      "『』": "{}",
      "，": ",",
      "（": "(",
      "【": "[",
      "｛": "{",
      "）": ")",
      "】": "]",
      "｝": "}",
      "「": "{",
      "」": "}",
      "『": "{",
      "』": "}",
      "“”": "\"\"",
      "‘’": "''",
      "“": "\"",
      "‘": "'",
      "”": "\"",
      "’": "'"
    }; // 不知道为啥copy和paste事件都触发不了

    this.editor.on("inputRead", function (cm, info) {
      if (info.origin === "*compose" || info.origin === "+input") {
        if (KEYMAP[info.text[0]]) {
          var cur = cm.getCursor(),
              token = cm.getTokenAt(cur);

          if (/\b(?:string)\b/.test(token.type)) {
            var length = token["string"].length;

            if (token["string"].length > 2 && token["string"].charAt(0) === '"' && token["string"].charAt(length - 1) === '"') {
              return;
            }
          }

          var fromPos = BI.clone(info.from);
          BI.nextTick(function () {
            // 把默认粘贴进去的文本删除掉
            var endPos = self.editor.getDoc().getCursor();
            self.editor.getDoc().replaceRange("", fromPos, endPos); // 使用一般的方法重新插入value值

            self._setValue(KEYMAP[info.text[0]], fromPos);

            func();
          });
        }
      }

      if (info.origin === "paste") {
        var fromPos = BI.clone(info.from); // TODO 因为无法阻止默认的文本粘贴，此处先把粘贴的文本删掉，再次插入format的文本

        BI.nextTick(function () {
          // 把默认粘贴进去的文本删除掉
          var endPos = self.editor.getDoc().getCursor();
          self.editor.getDoc().replaceRange("", fromPos, endPos); // 使用一般的方法重新插入value值

          self._setValue(self._removeInvisibleChar(info.text.join("\n")), fromPos);

          func();
        });
      }
    });
    this.editor.on("focus", function () {
      self._isEditing = true;

      self._checkWaterMark();

      self.fireEvent(BI.FormulaEditor.EVENT_FOCUS);
    });
    this.editor.on("blur", function () {
      self._isEditing = false;
      self.fireEvent(BI.FormulaEditor.EVENT_BLUR);
    });
    this.editor.on("keyup", function (cm, keyboard) {
      self.fireEvent(BI.FormulaEditor.EVENT_KEY_UP, keyboard.key);
    });
    this.editor.on("cursorActivity", function (cm) {
      self.fireEvent(BI.FormulaEditor.EVENT_CURSOR_ACTIVITY, cm);
    });
    var tips = [{
      el: {
        type: "bi.vertical",
        invisible: true,
        items: [{
          type: "bi.label",
          cls: "error-tip",
          hgap: 5,
          vgap: 2,
          ref: function ref(_ref) {
            self.errorText = _ref;
          },
          text: ""
        }],
        ref: function ref(_ref) {
          self.errorTip = _ref;
        }
      },
      left: 0,
      bottom: 0
    }, {
      el: {
        type: "bi.vertical",
        invisible: !o.showTip,
        items: [{
          type: "bi.label",
          hgap: 5,
          vgap: 2,
          cls: "bi-tips",
          text: BI.i18nText("BI-Basic_Formula_Valid")
        }],
        ref: function ref(_ref) {
          self.normalTip = _ref;
        }
      },
      left: 0,
      bottom: 0
    }];

    if (BI.isKey(this.options.watermark)) {
      var self = this;
      this.watermark = BI.createWidget({
        type: "bi.text",
        cls: "bi-water-mark",
        text: this.options.watermark,
        whiteSpace: "normal",
        textAlign: "left"
      });
      BI.createWidget({
        type: "bi.absolute",
        element: self,
        items: [{
          el: this.formulaEditor,
          left: 0,
          right: 0,
          top: 0,
          bottom: o.showTip ? 24 : 0
        }, {
          el: self.watermark,
          left: 6,
          right: 6,
          top: 3
        }].concat(tips)
      });
      this.watermark.element.bind("mousedown", function (e) {
        self.insertString("");
        self.editor.focus();
        e.stopEvent();
      });
      this.watermark.element.bind("click", function (e) {
        self.editor.focus();
        e.stopEvent();
      });
    } else {
      BI.createWidget({
        type: "bi.absolute",
        element: self,
        items: [{
          el: this.formulaEditor,
          left: 0,
          right: 0,
          top: 0,
          bottom: o.showTip ? 24 : 0
        }].concat(tips)
      });
    }
  },
  mounted: function mounted() {
    var o = this.options;

    if (BI.isNotNull(o.value)) {
      this.setValue(o.value);
    }
  },
  _removeInvisibleChar: function _removeInvisibleChar(v) {
    return BI.replaceAll(v || "", "\u200B", "");
  },
  _getSelection: function _getSelection(cm) {
    var self = this;

    if (!this.clipboard) {
      var adaptCopyWidget = BI.createWidget({
        type: "bi.layout",
        invisible: true
      });
      this.clipboard = BI.createWidget({
        type: "bi.clipboard",
        el: adaptCopyWidget,
        copy: function copy() {
          return selectString;
        },
        afterCopy: function afterCopy() {
          self.clipboard.destroy();
          self.clipboard = null;
        }
      });
      BI.createWidget({
        type: "bi.absolute",
        element: "body",
        items: [{
          el: this.clipboard
        }]
      });
    }

    var selectString = cm.getDoc().getSelection() || "";
    var allParams = BI.filter(selectString.split("\u200B"), function (idx) {
      return idx % 2 === 1;
    }); // BI-79714 需要优先匹配最长的

    var paramArray = allParams.sort(function (a, b) {
      return b.length - a.length;
    }); // BI-82911 转义正则的特殊字符

    paramArray = BI.map(paramArray, function (idx, param) {
      return param.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    });
    selectString = selectString.replaceAll(BI.concat(paramArray, "\u200B").join("|"), function (matchStr, index) {
      switch (matchStr) {
        case "\u200B":
          return "";

        default:
          return index === 0 || selectString[index - 1] !== "\u200B" ? matchStr : "${" + matchStr + "}";
      }
    });
    this.clipboard.element.click();
  },
  _checkWaterMark: function _checkWaterMark() {
    var o = this.options;

    if (!this.disabledWaterMark && BI.isEmptyString(this.editor.getValue()) && BI.isKey(o.watermark)) {
      this.watermark && this.watermark.visible();
    } else {
      this.watermark && this.watermark.invisible();
    }
  },
  _setEnable: function _setEnable(b) {
    BI.FormulaEditor.superclass._setEnable.apply(this, arguments);

    this.editor.setOption("readOnly", b === true ? false : "nocursor");
  },
  _analyzeContent: function _analyzeContent(v) {
    // \w*\w 这是干啥呢, 至少匹配一次\w ? 那可以用\w+
    var regx = /\$[\{][^\}]*[\}]|(\w|\.)+|\$\{[^\$\(\)\+\-\*\/)\$,]*\w\}|\$\{[^\$\(\)\+\-\*\/]*\w\}|\$\{[^\$\(\)\+\-\*\/]*[\u4e00-\u9fa5]\}|\w|(.)|\n/g;
    return v.match(regx);
  },
  selectAll: function selectAll() {
    this.editor.execCommand("selectAll");
    this._isEditing = true;
  },
  disableWaterMark: function disableWaterMark() {
    this.disabledWaterMark = true;

    this._checkWaterMark();
  },
  focus: function focus() {
    if (!this._isEditing === true) {
      this.editor.focus();
      this.selectAll();
    }
  },
  showTip: function showTip(v) {
    this.normalTip.setVisible(false);
    this.errorTip.setVisible(true);
    v && this.errorText.setText(v);
  },
  hideTip: function hideTip() {
    this.normalTip.setVisible(true);
    this.errorTip.setVisible(false);
  },
  getTip: function getTip() {
    return this.errorTipText;
  },

  /**
   * 添加字段
   * @param fieldId
   * @param force, 判断是否强制不标红
   */
  _insertField: function _insertField(fieldId, force) {
    var value = fieldId;
    var fieldFormattedName = this.options.paramFormatter(fieldId) || "undefined";
    var from = BI.clone(this.editor.getCursor("from")); // 解决插入字段由括号或其他特殊字符包围时分裂的bug,在两端以不可见字符包裹一下

    var showName = fieldFormattedName.replaceAll("^<!.*!>$", function (str) {
      return str.substring(2, str.length - 2);
    });
    this.editor.replaceSelection("\u200B" + showName + "\u200B");
    var to = this.editor.getCursor("to");
    var className = "fieldName";

    if (BI.isNotNull(fieldFormattedName.match("^<!.*!>$")) && !force) {
      className = "error-field";
    } // handleMouseEvents和replacedWith需要搭配使用，让codemirror接管鼠标事件


    this.editor.markText(from, to, {
      className: className,
      handleMouseEvents: true,
      atomic: true,
      startStyle: "start",
      endStyle: "end",
      value: value,
      replacedWith: BI.$("<span class='" + className + "  start end' />").text(showName)[0]
    });
  },
  insertField: function insertField(fieldId, force) {
    this._insertField(fieldId, force);

    this.editor.focus();
  },
  _insertFunction: function _insertFunction(fn) {
    var from = BI.clone(this.editor.getCursor("from"));
    this.editor.replaceSelection(fn);
    var to = this.editor.getCursor("to");
    this.editor.markText(from, to, {
      className: "#function",
      atomic: true
    });
    this.editor.replaceSelection("()");
    to = this.editor.getCursor();
    to.ch = to.ch - 1;
    this.editor.setCursor(to);
  },
  _isFunction: function _isFunction(str) {
    return BI.some(this.options.keywordsGetter(), function (idx, obj) {
      var text = obj.text || obj;
      return str === text.toLowerCase() || str === text.toUpperCase();
    });
  },
  _setFunction: function _setFunction(v) {
    var from = this.editor.getCursor();
    this.editor.replaceSelection(v);
    var to = this.editor.getCursor();
    this.editor.markText(from, to, {
      className: "#function",
      atomic: true
    });
  },
  insertFunction: function insertFunction(fn) {
    this._insertFunction(fn);

    this.editor.focus();
  },
  _insertOperator: function _insertOperator(op) {
    var from = this.editor.getCursor();
    this.editor.replaceSelection(op);
    var to = this.editor.getCursor();
    this.editor.markText(from, to, {
      className: "%operator",
      atomic: true
    });
  },
  insertOperator: function insertOperator(op) {
    this._insertOperator(op);

    this.editor.focus();
  },
  _insertString: function _insertString(str) {
    this.editor.replaceSelection(str);
  },
  insertString: function insertString(str) {
    this._insertString(str);

    this.editor.focus();
  },
  getFormulaString: function getFormulaString() {
    return this.editor.getValue();
  },
  getUsedFields: function getUsedFields() {
    var fields = [];
    this.editor.getValue(true, function (line) {
      _.forEach(line.markedSpans, function (i, ms) {
        switch (i.marker.className) {
          case "fieldName":
          case "error-field":
            // 因为插入字段的时候首尾加了不可见字符，所以首尾缩进一个字符
            var dId = i.marker.value;

            if (!BI.contains(fields, dId)) {
              fields.push(dId);
            }

        }
      });
    });
    return fields;
  },
  getCheckString: function getCheckString() {
    return this.editor.getValue(true, function (line) {
      var value = line.text,
          num = 0;
      var markedSpans = _.clone(line.markedSpans) || [];
      markedSpans.sort(function (a, b) {
        return a.from - b.from;
      });

      _.forEach(markedSpans, function (i, ms) {
        switch (i.marker.className) {
          case "fieldName":
          case "error-field":
            var fieldNameLength = i.to - i.from;
            value = value.substr(0, i.from + num) + "$a" + value.substr(i.to + num, value.length);
            num = num + 2 - fieldNameLength;
            break;

          default:
        }
      });

      return value;
    }).replaceAll("(\\$\\{.*?\\})\\s*|\u200B", function (matchStr, groupStr) {
      switch (matchStr) {
        case "\u200B":
          return "";

        default:
          return groupStr;
      }
    });
  },
  getValue: function getValue() {
    var v = this.editor.getValue("\n", function (line) {
      var value = line.text,
          num = 0;
      var markedSpans = _.clone(line.markedSpans) || [];
      markedSpans.sort(function (a, b) {
        return a.from - b.from;
      });

      _.forEach(markedSpans, function (i, ms) {
        switch (i.marker.className) {
          case "fieldName":
          case "error-field":
            var fieldNameLength = i.to - i.from;
            var fieldId = i.marker.value; // 这边直接跳过了不可见字符

            value = value.substr(0, i.from + num) + "$\{" + fieldId + "\}" + value.substr(i.to + num, value.length);
            num += fieldId.length - fieldNameLength + 3;
            break;

          default:
        }
      });

      return value;
    });
    return v.replaceAll("(\\$\\{.*?\\})\\s*|\u200B", function (matchStr, groupStr) {
      switch (matchStr) {
        case "\u200B":
          return "";

        default:
          return groupStr;
      }
    });
  },
  markField: function markField(field) {
    var className = field.invalid ? "error-field" : "fieldName";
    this.editor.markText(field.from, field.to, {
      handleMouseEvents: true,
      className: className,
      atomic: true,
      startStyle: "start",
      endStyle: "end",
      value: field.value,
      replacedWith: BI.$("<span class='" + className + "  start end' />").text(field.text)[0]
    });
  },
  markFunction: function markFunction(func) {
    this.editor.markText(func.from, func.to, {
      className: "#function",
      atomic: true
    });
  },
  getParamWrap: function getParamWrap() {
    return "\u200B";
  },
  beautify: function beautify() {
    var self = this,
        o = this.options;
    var v = this.editor.beautify({
      valueGetter: function valueGetter(v) {
        return "${" + o.valueGetter(self._removeInvisibleChar(v)) + "}";
      }
    });
    this.setValue(v);
  },

  /**
   * 原来的setValue是按照编辑公式的模式, 循环插字符，插字段，插公式一个个步骤做的，在长公式的情况下性能很差
   * 现在采用以下方式做优化:
   *      1、整个公式当成字符串直接setValue进去
   *      2、对其中的字段和函数进行标记
   */
  _setValue: function _setValue(value, position) {
    var self = this,
        c = this.constants,
        o = this.options;
    value = value || "";

    var result = this._analyzeContent(value);

    var fieldArray = [],
        functionArray = [];
    var lineNum = 0;
    var offset = 0;
    var valueString = "";

    if (BI.isNotNull(position)) {
      lineNum = position.line;
      offset = position.ch;
    }

    var wrapChar = self.getParamWrap();
    BI.each(result, function (i, str) {
      var nextStr = i === result.length - 1 ? "" : result[i + 1];

      if (c.paramRegex.test(str)) {
        var fieldId = str.substring(2, str.length - 1);
        var fieldFormattedName = o.paramFormatter(fieldId); // fieldId未匹配到报错字段和正常字段

        if (BI.isNull(fieldFormattedName)) {
          // 尝试以fieldId作为显示值匹配
          if (o.valueGetter(fieldId)) {
            // 匹配到则转化为正常的字段参数格式
            fieldFormattedName = fieldId;
            fieldId = o.valueGetter(fieldFormattedName);
            fieldFormattedName = o.paramFormatter(fieldId);
          } else {
            // 未匹配到标红显示显示值字段
            fieldFormattedName = "<!" + fieldId + "!>";
          }
        }

        var showName = fieldFormattedName.replaceAll("^<!.*!>$", function (str) {
          return str.substring(2, str.length - 2);
        });
        showName = wrapChar + showName + wrapChar;
        var fromPos = BI.CodeMirror.Pos(lineNum, offset);
        valueString += showName;
        offset += showName.length;
        var endPos = BI.CodeMirror.Pos(lineNum, offset);
        fieldArray.push({
          from: fromPos,
          to: endPos,
          value: fieldId,
          invalid: /^<!.*!>$/.test(fieldFormattedName),
          text: showName
        });
      } else {
        // 是函数
        if (nextStr[0] === "(" && self._isFunction(str)) {
          var fromPos = BI.CodeMirror.Pos(lineNum, offset);
          var endPos = BI.CodeMirror.Pos(lineNum, offset + str.length);
          functionArray.push({
            from: fromPos,
            to: endPos,
            value: str
          });
        }

        if (str === "\n") {
          lineNum++;
          offset = 0;
        }

        valueString += str;
        str !== "\n" && (offset += str.length);
      }
    });
    this.insertString(valueString);
    BI.each(fieldArray, function (idx, field) {
      self.markField(field);
    });
    BI.each(functionArray, function (idx, field) {
      self.markFunction(field);
    });
  },
  setValue: function setValue(v) {
    this.editor.setValue("");

    this._setValue(v);
  },
  refresh: function refresh() {
    var self = this;
    BI.nextTick(function () {
      self.editor.refresh();
    });
  },
  setVisible: function setVisible(visible) {
    BI.FormulaEditor.superclass.setVisible.apply(this, arguments);
    visible && this.refresh();
  },
  check: function check(value) {
    var _this = this;

    var formulaCheck = new _FormulaCheck["default"](this.options.formulaChecker());
    var formula = value || this.getValue();

    if (!formula) {
      return;
    }

    var error;

    try {
      formulaCheck.parse(formula.replace(/\$\{.*?\}/g, function (matchStr) {
        var field = matchStr.substring(2, matchStr.length - 1);

        var paramType = _this.options.paramTypeGetter(field);

        switch (paramType) {
          case "number":
            return 1;

          case "boolean":
            return true;

          case "date":
            return "\"bi-date-place-holder\"";

          default:
            return "\"" + field + "\"";
        }
      }));
    } catch (err) {
      error = err;
    }

    return error;
  }
});
BI.FormulaEditor.EVENT_CHANGE = "EVENT_CHANGE";
BI.FormulaEditor.EVENT_BLUR = "EVENT_BLUR";
BI.FormulaEditor.EVENT_FOCUS = "EVENT_FOCUS";
BI.FormulaEditor.EVENT_KEY_UP = "EVENT_KEY_UP";
BI.FormulaEditor.EVENT_CURSOR_ACTIVITY = "EVENT_CURSOR_ACTIVITY";
BI.shortcut("bi.formula_editor", BI.FormulaEditor);

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2017/09/18.
 * @class BI.TextToolbar
 * @extends BI.Widget
 */
BI.RichEditorAction = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorAction.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "",
      used: true
    });
  },
  _init: function _init() {
    BI.RichEditorAction.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    o.editor.on(BI.NicEditor.EVENT_SELECTED, function (e) {
      BI.defer(function () {
        if (o.used === true) {
          var focus = window.getSelection().focusNode;
          self.setEnable(true);
          self.checkNodes(focus || e.target);
          self.key(e);
        }
      });
    }); // o.editor.on(BI.NicEditor.EVENT_BLUR, function () {
    //     self.setEnable(false);
    // });
    // o.editor.on(BI.NicEditor.EVENT_KEYDOWN, BI.bind(this.keydown, this));
    // if (o.used === false) {
    //     this.setEnable(false);
    // }
  },
  checkNodes: function checkNodes(e) {
    if (!e) {
      return false;
    }

    var elm = e,
        self = this;

    do {
      if (this.options.tags && BI.contains(this.options.tags, elm.nodeName)) {
        this.activate();
        return true;
      }
    } while (elm = elm.parentNode && elm.className && elm.className.indexOf("bi-nic-editor") >= -1);

    elm = e;

    while (elm.nodeType == 3) {
      elm = elm.parentNode;
    }

    if (this.options.css) {
      for (var itm in this.options.css) {
        if (this.options.css[itm] == null) {
          this.activate(self._getDomStyle(elm, itm), e);
          return true;
        }

        if (BI.$(elm).css(itm) == this.options.css[itm]) {
          this.activate();
          return true;
        }
      }
    }

    this.deactivate();
    return false;
  },
  start: function start() {},
  key: function key() {},
  keydown: function keydown() {},
  hideIf: function hideIf(e) {},
  activate: function activate() {},
  deactivate: function deactivate() {},
  restoreRng: function restoreRng() {
    this.options.editor.restoreRng();
  },
  doCommand: function doCommand(args) {
    // 执行命令前先恢复选区
    this.restoreRng();

    if (this.options.command) {
      this.options.editor.nicCommand(this.options.command, args);
    }
  },
  getValue: function getValue() {},
  _getDomStyle: function _getDomStyle(el, itm) {
    var self = this;

    if (itm === "color") {
      return self._getDomColor(el);
    }

    var nodeStyle = BI.$(el).css(itm); // 只有一个子元素时直接使用字元素的fontSize

    if (el.children && el.children.length === 1) {
      return self._getDomStyle(el.children[0], itm) || nodeStyle;
    }

    var style = null;
    BI.each(el.children, function (idx, child) {
      if (child.innerText !== "") {
        var s = self._getDomStyle(child, itm) || nodeStyle;

        if (!style) {
          style = s;
        } else if (style !== s) {
          style = nodeStyle;
        }
      }
    });
    return style || nodeStyle;
  },
  _getDomColor: function _getDomColor(el) {
    var color = BI.get(el, ["style", "color"], BI.DOM.hex2rgb(el.getAttribute("color")));

    while (BI.isEmpty(color) && el.tagName !== "P") {
      el = el.parentNode;
      color = BI.get(el, ["style", "color"], BI.DOM.hex2rgb(el.getAttribute("color")));
    }

    if (color === "" || color === "inherit") {
      color = "";
    }

    if (color === "transparent") {
      color = "rgba(0, 0, 0, 0)";
    }

    return color;
  }
});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2017/09/18.
 * @class BI.RichEditorParamAction
 * @extends BI.Widget
 */
BI.RichEditorParamAction = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorParamAction.superclass._defaultConfig.apply(this, arguments), {
      paramFormatter: function paramFormatter(v) {
        return v;
      }
    });
  },
  _init: function _init() {
    BI.RichEditorParamAction.superclass._init.apply(this, arguments);
  },
  // _createBlankNode: function () {
  //     return BI.$("<span>").html("&nbsp;");
  // },
  // _addBlank: function ($param) {
  //     var o = this.options;
  //     var instance = o.editor.selectedInstance;
  //     var next = $param.next();
  //     if (next.length === 0) {
  //         var nextNode = this._createBlankNode();
  //         $param.after(nextNode);
  //         instance.setFocus(nextNode[0]);
  //     } else {
  //         instance.setFocus(next[0]);
  //     }
  // },
  //
  // _get$Sel: function () {
  //     var o = this.options;
  //     var instance = o.editor.selectedInstance;
  //     var sel = BI.$(instance.selElm());
  //     return sel;
  // },
  addParam: function addParam(param, encodeFn) {
    var o = this.options;
    var instance = o.editor.instance;
    var image = new Image();
    var name = o.paramFormatter(param);
    var attrs = BI.DOM.getImage(name);
    image.src = attrs.src;
    image.alt = BI.isFunction(encodeFn) ? encodeFn(param) : param;
    BI.$(image).addClass("rich-editor-param");
    BI.$(image).attr("style", attrs.style);
    BI.$(image).attr("name", window.encodeURIComponent(name));
    instance.insertHTML(BI.$("<div>").append(image).html(), true); // var sel = this._get$Sel();
    // var wrapper = o.editor.instance.getElm().element;
    // if (wrapper.find(sel).length <= 0) {
    //     wrapper.append(image);
    // } else {
    //     sel.after(image);
    // }
    // this._addBlank(BI.$(image));
  }
}); // /**
//  *
//  * Created by GUY on 2017/09/18.
//  * @class BI.RichEditorParamAction
//  * @extends BI.Widget
//  */
// BI.RichEditorParamAction = BI.inherit(BI.RichEditorAction, {
//     _defaultConfig: function () {
//         return BI.extend(BI.RichEditorParamAction.superclass._defaultConfig.apply(this, arguments), {});
//     },
//
//     _init: function () {
//         BI.RichEditorParamAction.superclass._init.apply(this, arguments);
//     },
//
//     _isParam: function (sel) {
//         return sel.attr("data-type") === "param";
//     },
//
//     _createBlankNode: function () {
//         return BI.$("<span>").html("&nbsp;");
//     },
//
//     _addBlank: function ($param) {
//         var o = this.options;
//         var instance = o.editor.selectedInstance;
//         var next = $param.next();
//         if (next.length === 0 || this._isParam(next)) {
//             var preNode = this._createBlankNode();
//             var nextNode = this._createBlankNode();
//             $param.before(preNode);
//             $param.after(nextNode);
//             instance.setFocus(nextNode[0]);
//         } else {
//             instance.setFocus(next[0]);
//         }
//     },
//
//     _get$Sel: function () {
//         var o = this.options;
//         var instance = o.editor.selectedInstance;
//         var sel = $(instance.selElm());
//         if (sel[0].nodeType === 3 && this._isParam(sel.parent())) {
//             sel = sel.parent();
//         }
//         return sel;
//     },
//
//     addParam: function (param) {
//         var o = this.options;
//         var sel = this._get$Sel();
//         var $param = BI.$("<span>").attr({
//             "data-type": "param",
//             "data-value": param
//         }).css({
//             color: "white",
//             backgroundColor: "#009de3",
//             padding: "0 5px"
//         }).text(param).keydown(function (e) {
//             if (e.keyCode === BI.KeyCode.BACKSPACE || e.keyCode === BI.KeyCode.DELETE) {
//                 $param.destroy();
//             }
//             e.stopEvent();
//             return false;
//         });
//         var wrapper = o.editor.instance.getElm().element;
//         if (wrapper.find(sel).length <= 0) {
//             wrapper.append($param);
//         } else {
//             sel.after($param);
//         }
//         this._addBlank($param);
//     },
//
//     keydown: function (e) {
//         var o = this.options;
//         var sel = this._get$Sel();
//         if (e.keyCode === 229) {// 中文输入法
//             if (this._isParam(sel)) {
//                 this._addBlank(sel);
//                 e.stopEvent();
//                 return false;
//             }
//         }
//         if (BI.Key[e.keyCode] || e.keyCode === BI.KeyCode.TAB || e.keyCode === BI.KeyCode.ENTER || e.keyCode === BI.KeyCode.SPACE) {
//             if (this._isParam(sel)) {
//                 e.stopEvent();
//                 return false;
//             }
//         }
//         if (e.keyCode === BI.KeyCode.BACKSPACE || e.keyCode === BI.KeyCode.DELETE) {
//             if (this._isParam(sel)) {
//                 sel.destroy();
//                 e.preventDefault();
//                 return false;
//             }
//         }
//     },
//
//     key: function (e) {
//     }
// });

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 颜色选择
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorTextToolbar
 * @extends BI.Widget
 */
BI.RichEditorTextToolbar = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorTextToolbar.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-rich-editor-text-toolbar",
      buttons: [{
        type: "bi.rich_editor_font_chooser"
      }, {
        type: "bi.rich_editor_size_chooser"
      }, {
        type: "bi.rich_editor_bold_button"
      }, {
        type: "bi.rich_editor_italic_button"
      }, {
        type: "bi.rich_editor_underline_button"
      }, {
        type: "bi.rich_editor_color_chooser"
      }, {
        type: "bi.rich_editor_background_color_chooser"
      }, {
        type: "bi.rich_editor_align_left_button"
      }, {
        type: "bi.rich_editor_align_center_button"
      }, {
        type: "bi.rich_editor_align_right_button"
      }, {
        type: "bi.rich_editor_param_button"
      }],
      height: 34
    });
  },
  _init: function _init() {
    BI.RichEditorTextToolbar.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    var buttons = BI.createWidgets(BI.map(o.buttons, function (i, btn) {
      return BI.extend(btn, {
        editor: o.editor,
        height: 24
      });
    }));
    BI.createWidget({
      type: "bi.horizontal",
      element: this,
      items: buttons,
      hgap: 3,
      vgap: 5
    });
  },
  mounted: function mounted() {
    var self = this;

    if (BI.isIE9Below()) {
      // IE8下必须要设置unselectable才能不blur输入框
      this.element.mousedown(function () {
        self._noSelect(self.element[0]);
      });

      this._noSelect(this.element[0]);
    }
  },
  _noSelect: function _noSelect(element) {
    if (element.setAttribute && element.nodeName.toLowerCase() != "input" && element.nodeName.toLowerCase() != "textarea") {
      element.setAttribute("unselectable", "on");
    }

    for (var i = 0; i < element.childNodes.length; i++) {
      this._noSelect(element.childNodes[i]);
    }
  }
});
BI.shortcut("bi.rich_editor_text_toolbar", BI.RichEditorTextToolbar);

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 富文本编辑器
 *
 * Created by GUY on 2017/9/15.
 * @class BI.NicEditor
 * @extends BI.Widget
 */
!function () {
  function isIE11Below() {
    if (!BI.isIE()) {
      return false;
    }

    return BI.getIEVersion() < 11;
  }

  function clearSelectionRange() {
    var selection = window.getSelection ? window.getSelection() : document.selection;
    selection.removeAllRanges();
  }

  var SPECIAL_TAGS = {
    "&": "&amp;",
    "$": "&dollar;",
    "{": "&lcub;",
    "}": "&rcub;",
    "\"": "&quot;",
    "<": "&lt;",
    ">": "&gt;"
  };

  function htmlEncode(text) {
    return BI.isNull(text) ? "" : BI.replaceAll(text + "", "&|\\$|{|}|\"|<|>", function (v) {
      return SPECIAL_TAGS[v] ? SPECIAL_TAGS[v] : "&nbsp;";
    });
  }

  function htmlDecode(text) {
    return BI.isNull(text) ? "" : BI.replaceAll(text + "", "&amp;|&dollar;|&lcub;|&rcub;|&quot;|&lt;|&gt;|&nbsp;", function (v) {
      switch (v) {
        case "&amp;":
          return "&";

        case "&dollar;":
          return "$";

        case "&lcub;":
          return "{";

        case "&rcub;":
          return "}";

        case "&quot;":
          return "\"";

        case "&lt;":
          return "<";

        case "&gt;":
          return ">";

        case "&nbsp;":
        default:
          return " ";
      }
    });
  }

  function convert2HTML(input) {
    var singleTag = ["img", "br", "input", "hr", "meta", "link", "param"];
    var propFix = {
      "for": "htmlFor",
      "class": "className"
    };
    var prefix = "",
        suffix = "",
        child = "";
    var obj = input;
    var nodeType = obj.nodeType;
    var tag = String.prototype.toLowerCase.call(obj.tagName || "");

    switch (nodeType) {
      case 1:
        var attrs = obj.attributes;
        var result = "";

        if (attrs) {
          var attrNames = {};

          for (var i = 0; i < attrs.length; i++) {
            attrNames[attrs[i].nodeName] = undefined;
          }

          if (obj.tagName === "input") {
            if (obj.type === "checkbox" || obj.type === "radio") {
              attrNames.checked = false;
            } else if (obj.type !== "file") {
              attrNames.value = "";
            }
          } else if (tag === "option") {
            attrNames.selected = false;
          } else if (tag === "textarea") {
            attrNames.value = "";
          }

          BI.each(attrNames, function (name, defaultValue) {
            var propName = propFix[name] || name;
            var value = obj.getAttribute ? obj.getAttribute(name) : obj[propName];

            if (value !== defaultValue) {
              result = result + " " + name + "=\"" + htmlEncode(obj.getAttribute(name)) + "\"";
            }
          });
        }

        prefix = "<" + tag + result + ">";

        if (!BI.contains(singleTag, tag)) {
          suffix = "</" + tag + ">";
        }

        break;

      case 3:
        prefix = htmlEncode(obj.nodeValue) || "";
        break;
    }

    BI.each(obj.childNodes, function (idx, childNode) {
      child += convert2HTML(childNode);
    });
    return prefix + child + suffix;
  }

  function dom2JSON(node) {
    var propFix = {
      "for": "htmlFor",
      "class": "className"
    };
    var obj = {
      nodeType: node.nodeType
    };

    if (node.tagName) {
      obj.tagName = node.tagName.toLowerCase();
    } else if (node.nodeName) {
      obj.nodeName = node.nodeName;
    }

    if (node.nodeValue) {
      obj.nodeValue = node.nodeValue;
    }

    var attrs = node.attributes;

    if (attrs) {
      var attrNames = {};

      for (var i = 0; i < attrs.length; i++) {
        attrNames[attrs[i].nodeName] = undefined;
      }

      if (obj.tagName === "input") {
        if (node.type === "checkbox" || node.type === "radio") {
          attrNames.checked = false;
        } else if (node.type !== "file") {
          attrNames.value = "";
        }
      } else if (obj.tagName === "option") {
        attrNames.selected = false;
      } else if (obj.tagName === "textarea") {
        attrNames.value = "";
      }

      var arr = [];
      BI.each(attrNames, function (name, defaultValue) {
        var propName = propFix[name] || name;
        var value = node.getAttribute ? node.getAttribute(name) : node[propName];

        if (value !== defaultValue) {
          arr.push([name, value]);
        }
      });

      if (arr.length) {
        obj.attributes = arr;
      }
    }

    var childNodes = node.childNodes;

    if (obj.tagName !== "textarea" && childNodes && childNodes.length) {
      var arr = obj.childNodes = [];

      for (var i = 0; i < childNodes.length; i++) {
        arr[i] = dom2JSON(childNodes[i]);
      }
    }

    return obj;
  }

  function JSON2HTML(input) {
    var singleTag = ["img", "br", "input", "hr", "meta", "link", "param"];
    var prefix = "",
        suffix = "",
        child = "";
    var obj = typeof input === "string" ? JSON.parse(input) : input;
    var nodeType = obj.nodeType;
    var tag = obj.tagName;

    switch (nodeType) {
      case 1:
        prefix = "<" + tag + BI.reduce(obj.attributes, function (attr, result) {
          return result + " " + htmlEncode(attr[0]) + "=\"" + htmlEncode(attr[1]) + "\"";
        }, "") + ">";

        if (!BI.contains(singleTag, tag)) {
          suffix = "</" + tag + ">";
        }

        break;

      case 3:
        prefix = htmlEncode(obj.nodeValue) || "";
        break;
    }

    BI.each(obj.childNodes, function (idx, childNode) {
      child += JSON2HTML(childNode);
    });
    return prefix + child + suffix;
  }

  var formatType = {
    NORMAL: "normal",
    ESCAPE: "escape",
    JSON: "json"
  };
  BI.NicEditor = BI.inherit(BI.Widget, {
    _defaultConfig: function _defaultConfig() {
      return BI.extend(BI.NicEditor.superclass._defaultConfig.apply(this, arguments), {
        baseCls: "bi-nic-editor",
        $testId: "bi-nic-editor",
        scrollable: true
      });
    },
    _init: function _init() {
      BI.NicEditor.superclass._init.apply(this, arguments);

      var o = this.options;
      BI.$(document).bind("mousedown." + this.getName(), BI.bind(this.selectCheck, this));
      var scrollOpt = o.scrollable ? {} : {
        scrollable: false,
        scrolly: false
      };
      BI.createWidget(BI.extend(scrollOpt, {
        type: "bi.vertical",
        element: this,
        items: [this.instance = this.addInstance()]
      }));
    },
    addInstance: function addInstance() {
      var o = this.options;
      var conf = {
        type: "bi.nic_editor_instance",
        ne: this,
        height: o.height,
        maxHeight: o.maxHeight ? o.maxHeight : null,
        readOnly: o.readOnly,
        singleLine: o.singleLine
      };

      if (this.element[0].contentEditable || !!window.opera) {
        var newInstance = BI.createWidget(conf);
      } else {
        console.error("不支持此浏览器");
      }

      return newInstance;
    },
    insertElem: function insertElem($elem) {
      if (this.selectedInstance) {
        this.selectedInstance.insertElem($elem);
      }
    },
    insertHTML: function insertHTML(html) {
      if (this.selectedInstance) {
        this.selectedInstance.insertHTML(html);
      }
    },
    nicCommand: function nicCommand(cmd, args) {
      if (this.selectedInstance) {
        this.selectedInstance.nicCommand(cmd, args);
      }
    },
    selectCheck: function selectCheck(e) {
      var t = e.target;

      do {
        if ( // 当前元素或不可见元素不触发 blur
        t === this.instance.element[0] || !this.instance.element.is(':visible')) {
          return;
        }

        if (this.instance.checkToolbar(t)) {
          this.instance.saveRng();
          return;
        }
      } while (t = t.parentNode);

      this.instance.saveRng();
      this.fireEvent("blur", t);
      this.lastSelectedInstance = this.selectedInstance || this.lastSelectedInstance;
      this.selectedInstance = null; // return false;
    },
    blur: function blur() {
      this.instance.blur();
      this.instance.nicCommand("UnSelect");
    },
    focus: function focus() {
      this.instance.focus();
    },
    bindToolbar: function bindToolbar(toolbar) {
      this.instance.bindToolbar(toolbar);
    },
    setValue: function setValue(v) {
      if (BI.isString(v)) {
        this.instance.setContent(v);
      } else {
        this.instance.setJSONValue(v);
      }
    },
    getValue: function getValue(type) {
      switch (type) {
        case formatType.ESCAPE:
          return this.instance.getEscapeContent();

        case formatType.JSON:
          return this.instance.getJSONValue();

        case formatType.NORMAL:
        default:
          return this.instance.getContent();
      }
    },
    getContentHeight: function getContentHeight() {
      return this.instance.getContentHeight();
    },
    getInstance: function getInstance() {
      return this.instance;
    },
    restoreRng: function restoreRng() {
      this.selectedInstance = this.instance;
      this.selectedInstance.restoreRng();
    },
    destroyed: function destroyed() {
      clearSelectionRange();
      BI.$(document).unbind("mousedown." + this.getName());
    }
  });
  BI.NicEditor.EVENT_SELECTED = "selected";
  BI.NicEditor.EVENT_BLUR = "blur";
  BI.NicEditor.EVENT_FOCUS = "focus";
  BI.NicEditor.EVENT_KEYDOWN = "keydown";
  BI.NicEditor.EVENT_KEYUP = "keyup";
  BI.NicEditor.htmlEncode = htmlEncode;
  BI.NicEditor.htmlDecode = htmlDecode;
  BI.NicEditor.FormatType = formatType;
  BI.shortcut("bi.nic_editor", BI.NicEditor);
  var prefix = "niceditor-"; // attr白名单阻止复制或者篡改富文本内容

  var attrWhiteList = ["class", "style", "color", "face", "name", "width", "height", "alt", "src", "align", "href", "target"];
  var sizeMap = {
    1: 12,
    2: 13,
    3: 16,
    4: 18,
    5: 24,
    6: 32,
    7: 48
  };
  var SUPPORTED_TAGS = ["div", "p", "span", "font", "b", "strong", "i", "u", "em", "br"];
  var SUPPORTED_STYLE = ["color", "font-family", "font-size", "font-weight"];
  var SUPPORTED_ATTR = ["style", "face", "color"];

  var cleanNode = function cleanNode(node) {
    if (node.nodeType === 3) {
      return node;
    }

    if (node.nodeType === 1 && node.tagName.toLowerCase() !== "img") {
      node.style.cssText = BI.reduce(node.style.cssText.split(";"), function (cssText, result) {
        var key = BI.replaceAll(cssText.split(":")[0], " ", "");
        var curr = "";

        if (SUPPORTED_STYLE.includes(key)) {
          curr = key + ":" + cssText.split(":")[1];
        }

        return result + curr + ";";
      }, "");
      BI.each(Object.values(node.attributes), function (idx, attr) {
        if (attr && !SUPPORTED_ATTR.includes(attr.name)) {
          node.removeAttribute(attr.name);
        }
      });
    }

    return node;
  };

  var formatNode = function formatNode(node) {
    if (!node) {
      return node;
    }

    if (node.nodeType === 3) {
      return node;
    }

    if (node.nodeType === 1) {
      var tagName = node.tagName.toLowerCase();

      if (SUPPORTED_TAGS.includes(tagName) || tagName === "img" && node.className.includes("rich-editor-param")) {
        cleanNode(node);
      } else {
        // 目前不支持的dom节点，全部转化成textNode
        try {
          var text = node.innerText;

          if (tagName === 'style' || tagName === 'script' || tagName === 'title') {
            text = '';
          }

          node.parentNode.replaceChild(document.createTextNode(text), node);
          return node;
        } catch (e) {
          console.log(e);
        }
      }
    }

    for (var j = node.childNodes.length - 1; j >= 0; j--) {
      if (node.childNodes[j].nodeType !== 1 && node.childNodes[j].nodeType !== 3) {
        node.removeChild(node.childNodes[j]);
      } else {
        formatNode(node.childNodes[j]);
      }
    }

    return node;
  };

  var pasteHandler = {
    replaceHtmlSymbol: function replaceHtmlSymbol(html) {
      if (html == null) {
        return "";
      }

      return html.replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/(\r\n|\r|\n)/g, "<br/>");
    },
    _cleanBlockAttr: function _cleanBlockAttr(content, styleFilterConfig) {
      function cleanNode(node) {
        var jNode = BI.$(node),
            allAttributes = BI.map(node.attributes, function (idx, attribute) {
          return attribute.nodeName;
        });

        if (jNode[0] && jNode[0].tagName === "SCRIPT") {
          jNode.destroy();
          return null;
        }

        if (jNode[0] && jNode[0].nodeType === 3) {
          return jNode[0];
        }

        BI.each(styleFilterConfig, function (style, value) {
          if (value) {
            if (style === "fontSize" && jNode[0].style && jNode[0].style.fontSize) {
              var size = jNode[0].style.fontSize;
              var scale = size.indexOf("pt") > -1 ? 4 / 3 : 1;
              var range = BI.Constants.getConstant("bi.constant.materials.rich_editor.font_size_range");
              jNode.css(style, BI.clamp(parseInt(size) * scale, range.MIN, range.MAX) + "px");
            } else {
              jNode.css(style, "");
            }
          }
        });
        BI.each(allAttributes, function (idx, attribute) {
          try {
            if (attribute === "size" && jNode[0].tagName === "FONT") {
              jNode.css("fontSize", sizeMap[jNode.attr("size")]);
            }

            !BI.contains(attrWhiteList, attribute) && jNode.removeAttr(attribute);
          } catch (error) {// 无效的attr，继续运行
          }
        });
        BI.each(node.children, function (idx, childNode) {
          cleanNode(childNode);
        });
        return node;
      }

      return cleanNode(content);
    },
    _formatAttr: function _formatAttr(node) {
      var isIE = BI.isIE();

      function formatAttr(node) {
        if (isIE && node.style && node.style.textAlign !== "") {
          node.align = node.style.textAlign;
          node.style.textAlign = "";
        }

        BI.each(node.children, function (idx, childNode) {
          formatAttr(childNode);
        });
        return node;
      }

      return formatAttr(node);
    },
    getPasteHtml: function getPasteHtml(pasteContent, pasteText) {
      if (!pasteContent && pasteText) {
        pasteContent = BI.$("<p>" + pasteHandler.replaceHtmlSymbol(pasteText) + "</p>");
      }

      if (!pasteContent) {
        return "";
      } // 放在一个div上，父元素在DocumentFragment上时无法replaceChild


      var parent = document.createElement('div');
      BI.each(pasteContent, function (idx, content) {
        parent.appendChild(content);
      });
      formatNode(parent); // 清除部分样式(可能造成问题的样式)

      return BI.reduce(parent.childNodes, function (node, result) {
        return result += (node.nodeType === 3 ? node.nodeValue : node.outerHTML) || "";
      }, "");
    },
    getFormatHtml: function getFormatHtml(content) {
      return BI.reduce(content, function (node, result) {
        var cleanNode = pasteHandler._cleanBlockAttr(node, {
          fontSize: true
        });

        cleanNode = pasteHandler._formatAttr(cleanNode);
        return result += (cleanNode.nodeType === 3 ? cleanNode.nodeValue : cleanNode.outerHTML) || "";
      }, "");
    }
  };
  var nicEditorInstance = BI.inherit(BI.Layout, {
    isSelected: false,
    _init: function _init() {
      nicEditorInstance.superclass._init.apply(this, arguments);

      var o = this.options;
      var initValue = o.value || "<br>";
      initValue = initValue.startWith("<p>") ? initValue : "<p>" + initValue + "</p>";
      this.ne = this.options.ne;
      this.elm = BI.createWidget({
        type: "bi.layout",
        width: o.width - 8,
        scrollable: false
      });
      this.elm.element.css({
        minHeight: BI.isNumber(o.height) ? o.height - 8 + "px" : o.height,
        outline: "none",
        padding: "0 10px",
        wordBreak: "break-all"
      }).html(o.readOnly ? BI.Text.formatText(initValue) : initValue);

      if (o.readOnly) {
        this.elm.element.attr("contentEditable", false);
      }

      this.element.css("maxHeight", o.maxHeight ? o.maxHeight + "px" : null);
      this.e = BI.createWidget({
        type: "bi.layout",
        invisible: true,
        tagName: "textarea"
      });
      BI.createWidget({
        type: "bi.default",
        element: this,
        scrolly: true,
        items: [this.elm, this.e]
      });
      this.ne.on("blur", BI.bind(this.blur, this));
      this.start();
      this.blur();
    },
    start: function start() {
      this.elm.element.attr("contentEditable", this.options.readOnly !== true);

      if (this.getContent() == "") {// this.setContent("<br />");
      }

      this.instanceDoc = document.defaultView;
      this.elm.element.on("mousedown", BI.bind(this.selected, this));
      this.elm.element.on("keydown", BI.bind(this.keyDown, this));
      this.elm.element.on("focus", BI.bind(this.selected, this));
      this.elm.element.on("blur", BI.bind(this.blur, this));
      this.elm.element.on("keyup", BI.bind(this.selected, this));
      this.elm.element.on("paste", BI.bind(this.paste, this));
      this.ne.fireEvent("add");
    },
    getSel: function getSel() {
      return window.getSelection ? window.getSelection() : document.selection;
    },
    getRng: function getRng() {
      var s = this.getSel();

      if (!s || s.rangeCount === 0) {
        return;
      }

      return s.rangeCount > 0 ? s.getRangeAt(0) : s.createRange();
    },
    getSavedRng: function getSavedRng() {
      return this.savedRange;
    },
    selRng: function selRng(rng, s) {
      if (window.getSelection) {
        s.removeAllRanges();
        s.addRange(rng);
      } else {
        rng.select();
      }
    },
    selElm: function selElm() {
      var r = this.getRng();

      if (!r) {
        return;
      }

      if (r.startContainer) {
        var contain = r.startContainer;

        if (r.cloneContents().childNodes.length == 1) {
          for (var i = 0; i < contain.childNodes.length; i++) {
            var rng = contain.childNodes[i].ownerDocument.createRange();
            rng.selectNode(contain.childNodes[i]);

            if (r.compareBoundaryPoints(Range.START_TO_START, rng) != 1 && r.compareBoundaryPoints(Range.END_TO_END, rng) != -1) {
              return contain.childNodes[i];
            }
          }
        }

        return contain;
      }

      return this.getSel().type == "Control" ? r.item(0) : r.parentElement();
    },
    saveRng: function saveRng(force) {
      try {
        var range = this.getRng();

        if ((!this._isChildOf(this.getSelectionContainerElem(range), this.element[0]) || this.savedRange && !this.savedRange.collapsed) && !force) {
          return;
        }

        this.savedRange = range;
        this.savedSel = this.getSel();
      } catch (e) {// 不支持IE8及以下浏览器
      }
    },
    getSelectionContainerElem: function getSelectionContainerElem(range) {
      if (range) {
        var elem = range.commonAncestorContainer;
        return elem.nodeType === 1 ? elem : elem.parentNode;
      }
    },
    setFocus: function setFocus(el) {
      try {
        el.focus();
      } catch (e) {}

      if (!window.getSelection) {
        var rng;

        try {
          el.focus();
        } catch (e) {}

        rng = document.selection.createRange();
        rng.moveStart("character", -el.innerText.length);
        var text = rng.text;

        for (var i = 0; i < el.innerText.length; i++) {
          if (el.innerText.substring(0, i + 1) == text.substring(text.length - i - 1, text.length)) {
            result = i + 1;
          }
        }
      } else {
        var nodeLenght = getNodeLenght(el);
        var lastNode = BI.$(el).contents().last();
        var range = document.createRange();

        if (lastNode.is("br")) {
          nodeLenght -= 1;
        } else if (!lastNode[0] && el.nodeType !== 3) {
          nodeLenght = 0;
        }

        if (BI.$(el).is("img")) {
          range.setEndAfter(el, nodeLenght);
        } else {
          range.setEnd(el, nodeLenght);
        }

        range.collapse(false);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      }

      function getNodeLenght(el) {
        var node = BI.$(el)[0];

        if (!node) {
          return 0;
        }

        switch (node.nodeType) {
          case 7:
          case 10:
            return 0;

          case 3:
          case 8:
            return node.length;

          default:
            return node.childNodes.length;
        }
      }
    },
    removeRng: function removeRng() {
      this.savedRange = null;
    },
    restoreRng: function restoreRng() {
      if (this.savedRange) {
        this.selRng(this.savedRange, this.savedSel);
      }

      this.savedRange = null;
    },
    restoreRngAndClearRange: function restoreRngAndClearRange() {
      if (this.savedRange) {
        this.savedRange.setStart(this.savedRange.endContainer, this.savedRange.endOffset);
        this.selRng(this.savedRange, this.savedSel);
      }
    },
    keyDown: function keyDown(e, t) {
      if (e.keyCode === 8) {
        var html = this.elm.element.html().toLowerCase().trim();

        if (html === "<p><br></p>" || html === "<p></p>") {
          e.preventDefault();
          return;
        }
      }

      if (e.keyCode === 13 && this.options.singleLine) {
        e.preventDefault();
        return;
      }

      this.ne.fireEvent("keydown", e);
    },
    selected: function selected(e) {
      // BI-84171 在mousedown事件时删除已保存的选区，防止有新选区后恢复到上次的选区
      // 选区域A，点击外部，再选区域B进行设置时恢复到了A
      if (e.type === "mousedown") {
        this.removeRng();
      }

      var t = e.target;

      if (!t && !(t = this.selElm())) {
        t = this.selElm();
      }

      if (!e.ctrlKey) {
        var selInstance = this.ne.selectedInstance;

        if (selInstance != this) {
          if (selInstance) {
            this.ne.fireEvent("blur", e);
          }

          this.ne.selectedInstance = this;
          this.ne.fireEvent("focus", e);
        }

        this.ne.fireEvent("selected", e);
        this.isFocused = true;
        this.elm.element.addClass(prefix + "selected");
      }

      this.ne.fireEvent("keyup", e);

      if (e.keyCode !== 8) {
        return;
      }

      var newLine;
      var html = this.elm.element.html().toLowerCase().trim();

      if (!html || html === "<br>") {
        newLine = BI.$(this._getNewLine());
        this.elm.element.html("");
        this.elm.element.append(newLine);
        this.setFocus(newLine[0]);
      } // return false;

    },
    focus: function focus() {
      var self = this;

      try {
        this.removeRng();
        this.setFocus(this.elm.element[0]);
        this.nicCommand("selectAll");
      } catch (e) {
        setTimeout(function () {
          self.focus();
        });
      }
    },
    blur: function blur() {
      this.isFocused = false;
      this.elm.element.removeClass(prefix + "selected");
    },
    paste: function paste(e) {
      var pasteHtml = "",
          pasteText = "";

      if (e.originalEvent.clipboardData && !BI.isIE()) {
        pasteHtml = e.originalEvent.clipboardData.getData("text/html");
        pasteText = e.originalEvent.clipboardData.getData("text/plain");
      }

      if (pasteHtml) {
        try {
          this.saveRng();
          this.insertHTML(pasteHandler.getPasteHtml(BI.$(pasteHtml), pasteText));
          e.preventDefault();
        } catch (e) {
          this._pasteByBin();
        }
      } else if (BI.isEmpty(pasteText)) {
        this._pasteByBin();
      }
    },
    // 为了兼容IE采取这样的方案，创建一个div用于存放插入的html，之后再格式化html放到真正的editor中
    _pasteByBin: function _pasteByBin() {
      var self = this;
      var pasteBin = BI.$("<div contenteditable='true' />").addClass("bi-paste-bin").attr("tabIndex", "-1").appendTo(this.element);
      this.savedRange = null;
      this.saveRng(true);
      pasteBin.focus();
      BI.defer(function () {
        self.restoreRng();
        var pasteContent = BI.$("<div />").append(pasteBin.contents());
        var pasteText = pasteBin[0].innerText;
        var pasteHtml = pasteHandler.getPasteHtml(pasteContent, pasteText); // firefox插入没<ul>的<li>使用pasteText兼容

        try {
          self.insertHTML(pasteHtml);
        } catch (ex) {
          self.insertHTML("<p>" + pasteText + "</p>");
        }

        pasteBin.remove();
      });
    },
    saveContent: function saveContent() {
      this.ne.fireEvent("save");
      this.e.element.value(this.getContent());
    },
    getElm: function getElm() {
      return this.elm;
    },
    getEscapeContent: function getEscapeContent() {
      this.ne.fireEvent("get");
      return this.elm.element ? BI.reduce(this.elm.element.contents(), function (el, html) {
        return html + convert2HTML(el);
      }, "") : "";
    },
    getContent: function getContent() {
      this.content = this.getElm().element.html();
      this.ne.fireEvent("get");
      return this.content;
    },
    getParseContent: function getParseContent() {},
    getContentHeight: function getContentHeight() {
      return this.elm.element.height();
    },
    getJSONValue: function getJSONValue() {
      this.getContent();
      return {
        tagName: "root",
        childNodes: BI.map(this.getElm().element.contents(), function (el, html) {
          return dom2JSON(html);
        })
      };
    },
    setJSONValue: function setJSONValue(v) {
      v = v || {};
      var nodes;
      var content = "";

      if (v.tagName === "root") {
        nodes = v.childNodes;
      } else {
        nodes = BI.isArray(v) ? v : [v];
      }

      BI.each(nodes, function (idx, node) {
        content += JSON2HTML(node);
      });
      this.setContent(content);
    },
    setContent: function setContent(v) {
      // 格式化成 <p>---</p> 形式
      v = v || (isIE11Below() ? "" : "<br>");
      v = v.startWith("<p") ? v : "<p>" + v;
      v = v.endWith("</p>") ? v : v + "</p>";
      this.content = pasteHandler.getFormatHtml(BI.$(v));
      this.ne.fireEvent("set");
      this.elm.element.html(this.content);
    },
    insertElem: function insertElem($elem) {
      var range = this.getRng();

      if (range.insertNode) {
        range.deleteContents();
        range.insertNode($elem);
      }
    },
    insertHTML: function insertHTML(html, force) {
      this.restoreRng();
      var selection = this.getSel();
      var range = this.savedRange || this.getRng();

      if (!range) {
        return;
      } // CHART-9028 原生接口插入图片是会出现一些问题,所以添加一个参数强制使用兼容方法插入img


      if (force) {
        return insert(html);
      }

      try {
        // w3c
        if (document.queryCommandSupported("insertHTML")) {
          this.nicCommand("insertHTML", html);
        } else {
          throw new Error("Does not support this command");
        }
      } catch (e) {
        insert(html);
      }

      function insert(html) {
        if (range.insertNode) {
          // IE
          var nodes = BI.$(html);
          range.deleteContents(); // CHART-9564 如果是插入的是br标签，需要把range的选中元素变成其父亲

          if (range.startContainer && range.endContainer && range.endContainer === range.startContainer && range.startContainer.tagName === "BR") {
            try {
              range.setStart(range.startContainer.parentNode, range.startContainer.parentNode.childNodes.length - 1);
              range.setEnd(range.endContainer.parentNode, range.endContainer.parentNode.childNodes.length);
            } catch (e) {
              range.setStart(range.startContainer.parentNode, 0);
              range.setEnd(range.endContainer.parentNode, 0);
            }
          }

          for (var i = 0; i < nodes.length; i++) {
            range.insertNode(nodes[i]);
          }

          if (range.endContainer) {
            selection.removeAllRanges();
            range.setStart(range.endContainer, range.endOffset);
            range.setEnd(range.endContainer, range.endOffset);
            selection.addRange(range);
          }
        } else if (range.pasteHTML) {
          // IE <= 10
          range.pasteHTML(html);
        }
      }
    },
    bindToolbar: function bindToolbar(toolbar) {
      this.toolbar = toolbar;
    },
    checkToolbar: function checkToolbar(element) {
      return this.toolbar && this.toolbar.element[0] === element;
    },
    nicCommand: function nicCommand(cmd, args) {
      document.execCommand(cmd, false, args);
    },
    initSelection: function initSelection(newLine) {
      var newLineHtml = this._getNewLine();

      var el = this.elm.element;
      var children = el.children();

      if (!children.length) {
        // 如果编辑器区域无内容，添加一个空行，重新设置选区
        el.append(newLineHtml);
        this.initSelection();
        return;
      }

      var last = children.last();

      if (newLine) {
        // 新增一个空行
        var html = last.html().toLowerCase();
        var nodeName = last.nodeName;

        if (html !== "<br>" && html !== "<br/>" || nodeName !== "P") {
          // 最后一个元素不是空行，添加一个空行，重新设置选区
          el.append(newLineHtml);
          this.initSelection();
          return;
        }
      }

      var lastNode = last[0];
      var focus;

      while (lastNode) {
        focus = lastNode;

        if (lastNode.childNodes) {
          lastNode = lastNode.childNodes[lastNode.childNodes.length - 1];
        } else {
          lastNode = null;
        }
      }

      this.setFocus(focus);
    },
    _getNewLine: function _getNewLine() {
      return isIE11Below() ? "<p>&nbsp;</p>" : "<p><br></p>";
    },
    _isChildOf: function _isChildOf(child, parent) {
      var parentNode;

      if (child && parent) {
        parentNode = child.parentNode;

        while (parentNode) {
          if (parent === parentNode) {
            return true;
          }

          parentNode = parentNode.parentNode;
        }
      }

      return false;
    }
  });
  BI.shortcut("bi.nic_editor_instance", nicEditorInstance);
}();

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 颜色选择trigger
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorBackgroundChooserTrigger
 * @extends BI.Widget
 */
BI.RichEditorBackgroundChooserTrigger = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    var conf = BI.RichEditorBackgroundChooserTrigger.superclass._defaultConfig.apply(this, arguments);

    return BI.extend(conf, {
      width: 20,
      height: 20
    });
  },
  _init: function _init() {
    BI.RichEditorBackgroundChooserTrigger.superclass._init.apply(this, arguments);

    this.font = BI.createWidget({
      type: "bi.icon_button",
      title: BI.i18nText("BI-Basic_Background_Color"),
      cls: "text-background-font"
    });
    this.underline = BI.createWidget({
      type: "bi.icon_button",
      cls: "text-color-underline-font"
    });
    BI.createWidget({
      type: "bi.absolute_center_adapt",
      element: this,
      items: [{
        el: this.underline
      }, {
        el: this.font
      }]
    });
  },
  setValue: function setValue(color) {
    this.underline.element.css("color", color);
  },
  getValue: function getValue() {
    return this.underline.element.css("color");
  }
});
BI.shortcut("bi.rich_editor_background_color_chooser_trigger", BI.RichEditorBackgroundChooserTrigger);

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorAlignCenterButton
 * @extends BI.RichEditorAction
 */
BI.RichEditorAlignCenterButton = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorAlignCenterButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "justifycenter"
    });
  },
  _init: function _init() {
    BI.RichEditorAlignCenterButton.superclass._init.apply(this, arguments);

    var self = this;
    var o = this.options;
    this.align = BI.createWidget({
      type: "bi.icon_button",
      element: this,
      title: BI.i18nText("BI-Word_Align_Center"),
      height: o.height,
      width: o.width,
      cls: "text-toolbar-button bi-list-item-active text-align-center-font"
    });
    this.align.on(BI.IconButton.EVENT_CHANGE, function () {
      self.doCommand();
    });
  },
  checkNodes: function checkNodes(e) {
    var self = this;
    var elm = e;

    while (elm.nodeType === 3) {
      elm = elm.parentNode;
    }

    while (elm.nodeType === 1 && elm.tagName.toLowerCase() === "div") {
      // 兼容ie。div获取textAlign不正确。
      elm = elm.firstChild;
    } // 一些特殊情况：div直接包裹文字,此时textAlign属性在div上，可直接获取。


    if (!(elm && elm.nodeType === 1) && !BI.isNotNull(elm.tagName)) {
      elm = elm.parentNode;
    }

    try {
      BI.defer(function () {
        // 火狐下获取到-moz-center
        if (BI.get(getComputedStyle(elm), "textAlign") === "center" || BI.get(getComputedStyle(elm), "textAlign") === "-moz-center") {
          self.activate();
        } else {
          self.deactivate();
        }
      });
    } catch (error) {
      BI.RichEditorBoldButton.superclass.checkNodes(e);
    }
  },
  activate: function activate() {
    this.align.setSelected(true);
  },
  deactivate: function deactivate() {
    this.align.setSelected(false);
  }
});
BI.shortcut("bi.rich_editor_align_center_button", BI.RichEditorAlignCenterButton);

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorAlignLeftButton
 * @extends BI.RichEditorAction
 */
BI.RichEditorAlignLeftButton = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorAlignLeftButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "justifyleft"
    });
  },
  _init: function _init() {
    BI.RichEditorAlignLeftButton.superclass._init.apply(this, arguments);

    var self = this;
    var o = this.options;
    this.align = BI.createWidget({
      type: "bi.icon_button",
      element: this,
      title: BI.i18nText("BI-Word_Align_Left"),
      height: o.height,
      width: o.width,
      cls: "text-toolbar-button bi-list-item-active text-align-left-font"
    });
    this.align.on(BI.IconButton.EVENT_CHANGE, function () {
      self.doCommand();
    });
  },
  checkNodes: function checkNodes(e) {
    var self = this;
    var elm = e;

    while (elm.nodeType === 3) {
      elm = elm.parentNode;
    }

    while (elm.nodeType === 1 && elm.tagName.toLowerCase() === "div") {
      // 兼容ie。div获取textAlign不正确。
      elm = elm.firstChild;
    } // 一些特殊情况：div直接包裹文字,此时textAlign属性在div上，可直接获取。


    if (!(elm && elm.nodeType === 1) && !BI.isNotNull(elm.tagName)) {
      elm = elm.parentNode;
    }

    try {
      BI.defer(function () {
        if (BI.get(getComputedStyle(elm), "textAlign") === "left" || BI.get(getComputedStyle(elm), "textAlign") === "start" || BI.get(getComputedStyle(elm), "textAlign") === "-moz-left") {
          self.activate();
        } else {
          self.deactivate();
        }
      });
    } catch (error) {
      BI.RichEditorBoldButton.superclass.checkNodes(e);
    }
  },
  activate: function activate() {
    this.align.setSelected(true);
  },
  deactivate: function deactivate() {
    this.align.setSelected(false);
  }
});
BI.shortcut("bi.rich_editor_align_left_button", BI.RichEditorAlignLeftButton);

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorAlignRightButton
 * @extends BI.RichEditorAction
 */
BI.RichEditorAlignRightButton = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorAlignRightButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "justifyright"
    });
  },
  _init: function _init() {
    BI.RichEditorAlignRightButton.superclass._init.apply(this, arguments);

    var self = this;
    var o = this.options;
    this.align = BI.createWidget({
      type: "bi.icon_button",
      element: this,
      title: BI.i18nText("BI-Word_Align_Right"),
      height: o.height,
      width: o.width,
      cls: "text-toolbar-button bi-list-item-active text-align-right-font"
    });
    this.align.on(BI.IconButton.EVENT_CHANGE, function () {
      self.doCommand();
    });
  },
  checkNodes: function checkNodes(e) {
    var self = this;
    var elm = e;

    while (elm.nodeType === 3) {
      elm = elm.parentNode;
    }

    while (elm.nodeType === 1 && elm.tagName.toLowerCase() === "div") {
      // 兼容ie。div获取textAlign不正确。
      elm = elm.firstChild;
    } // 一些特殊情况：div直接包裹文字,此时textAlign属性在div上，可直接获取。


    if (!(elm && elm.nodeType === 1) && !BI.isNotNull(elm.tagName)) {
      elm = elm.parentNode;
    }

    try {
      BI.defer(function () {
        if (BI.get(getComputedStyle(elm), "textAlign") === "right" || BI.get(getComputedStyle(elm), "textAlign") === "-moz-right") {
          self.activate();
        } else {
          self.deactivate();
        }
      });
    } catch (error) {
      BI.RichEditorBoldButton.superclass.checkNodes(e);
    }
  },
  activate: function activate() {
    this.align.setSelected(true);
  },
  deactivate: function deactivate() {
    this.align.setSelected(false);
  }
});
BI.shortcut("bi.rich_editor_align_right_button", BI.RichEditorAlignRightButton);

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorBoldButton
 * @extends BI.RichEditorAction
 */
BI.RichEditorBoldButton = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorBoldButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "Bold",
      tags: ["B", "STRONG"],
      css: {}
    });
  },
  _init: function _init() {
    BI.RichEditorBoldButton.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.bold = BI.createWidget({
      type: "bi.icon_button",
      element: this,
      title: BI.i18nText("BI-Basic_Bold"),
      height: o.height,
      width: o.width,
      cls: "text-toolbar-button bi-list-item-active text-bold-font"
    });
    this.bold.on(BI.IconButton.EVENT_CHANGE, function () {
      self.doCommand();
    });
  },
  checkNodes: function checkNodes(e) {
    var self = this;

    try {
      BI.defer(function () {
        if (document.queryCommandState("bold")) {
          self.activate();
        } else {
          self.deactivate();
        }
      });
    } catch (error) {
      BI.RichEditorBoldButton.superclass.checkNodes(e);
    }
  },
  activate: function activate() {
    this.bold.setSelected(true);
  },
  deactivate: function deactivate() {
    this.bold.setSelected(false);
  }
});
BI.shortcut("bi.rich_editor_bold_button", BI.RichEditorBoldButton);

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorItalicButton
 * @extends BI.RichEditorAction
 */
BI.RichEditorItalicButton = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorItalicButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "Italic",
      tags: ["EM", "I"],
      css: {
        fontStyle: "italic"
      }
    });
  },
  _init: function _init() {
    BI.RichEditorItalicButton.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.italic = BI.createWidget({
      type: "bi.icon_button",
      element: this,
      title: BI.i18nText("BI-Basic_Italic"),
      height: o.height,
      width: o.width,
      cls: "text-toolbar-button bi-list-item-active text-italic-font"
    });
    this.italic.on(BI.IconButton.EVENT_CHANGE, function () {
      self.doCommand();
    });
  },
  checkNodes: function checkNodes(e) {
    var self = this;

    try {
      BI.defer(function () {
        if (document.queryCommandState("italic")) {
          self.activate();
        } else {
          self.deactivate();
        }
      });
    } catch (error) {
      BI.RichEditorBoldButton.superclass.checkNodes(e);
    }
  },
  activate: function activate() {
    this.italic.setSelected(true);
  },
  deactivate: function deactivate() {
    this.italic.setSelected(false);
  }
});
BI.shortcut("bi.rich_editor_italic_button", BI.RichEditorItalicButton);

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorParamButton
 * @extends BI.RichEditorParamAction
 */
BI.RichEditorParamButton = BI.inherit(BI.RichEditorParamAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorParamButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 30
    });
  },
  _init: function _init() {
    BI.RichEditorParamButton.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.param = BI.createWidget({
      type: "bi.button",
      element: this,
      level: "ignore",
      minWidth: 0,
      text: BI.i18nText("BI-Formula_Insert"),
      height: o.height,
      width: o.width
    });
    this.param.on(BI.Button.EVENT_CHANGE, function () {
      self.addParam("参数");
    });
  },
  activate: function activate() {},
  deactivate: function deactivate() {}
});
BI.shortcut("bi.rich_editor_param_button", BI.RichEditorParamButton);

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorItalicButton
 * @extends BI.RichEditorAction
 */
BI.RichEditorUnderlineButton = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorUnderlineButton.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "Underline",
      tags: ["U"],
      css: {}
    });
  },
  _init: function _init() {
    BI.RichEditorUnderlineButton.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.underline = BI.createWidget({
      type: "bi.icon_button",
      element: this,
      title: BI.i18nText("BI-Basic_Underline"),
      height: o.height,
      width: o.width,
      cls: "text-toolbar-button bi-list-item-active text-underline-font"
    });
    this.underline.on(BI.IconButton.EVENT_CHANGE, function () {
      self.doCommand();
    });
  },
  checkNodes: function checkNodes(e) {
    var self = this;

    try {
      BI.defer(function () {
        if (document.queryCommandState("underline")) {
          self.activate();
        } else {
          self.deactivate();
        }
      });
    } catch (error) {
      BI.RichEditorBoldButton.superclass.checkNodes(e);
    }
  },
  activate: function activate() {
    this.underline.setSelected(true);
  },
  deactivate: function deactivate() {
    this.underline.setSelected(false);
  }
});
BI.shortcut("bi.rich_editor_underline_button", BI.RichEditorUnderlineButton);

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 颜色选择trigger
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorColorChooserTrigger
 * @extends BI.Widget
 */
BI.RichEditorColorChooserTrigger = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    var conf = BI.RichEditorColorChooserTrigger.superclass._defaultConfig.apply(this, arguments);

    return BI.extend(conf, {
      width: 20,
      height: 20
    });
  },
  _init: function _init() {
    BI.RichEditorColorChooserTrigger.superclass._init.apply(this, arguments);

    this.font = BI.createWidget({
      type: "bi.icon_button",
      title: BI.i18nText("BI-Basic_Font_Color"),
      cls: "text-color-font",
      warningTitle: this.options.warningTitle
    });
    this.underline = BI.createWidget({
      type: "bi.icon_button",
      cls: "text-color-underline-font"
    });
    BI.createWidget({
      type: "bi.absolute_center_adapt",
      element: this,
      items: [{
        el: this.underline
      }, {
        el: this.font
      }]
    });

    if (BI.isNotNull(this.options.value)) {
      this.setValue(this.options.value);
    }
  },
  setValue: function setValue(color) {
    this.underline.element.css("color", color);
  },
  getValue: function getValue() {
    return this.underline.element.css("color");
  }
});
BI.shortcut("bi.rich_editor_color_chooser_trigger", BI.RichEditorColorChooserTrigger);

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 颜色选择
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorBackgroundColorChooser
 * @extends BI.RichEditorAction
 */
BI.RichEditorBackgroundColorChooser = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorBackgroundColorChooser.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20
    });
  },
  _init: function _init() {
    BI.RichEditorBackgroundColorChooser.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.colorchooser = BI.createWidget({
      type: "bi.color_chooser",
      container: null,
      element: this,
      width: o.width,
      height: o.height,
      destroyWhenHide: o.destroyWhenHide,
      recommendColorsGetter: o.recommendColorsGetter,
      el: {
        type: "bi.rich_editor_background_color_chooser_trigger",
        title: BI.i18nText("BI-Widget_Background_Colour"),
        cls: "text-toolbar-button"
      }
    });
    this.colorchooser.on(BI.ColorChooser.EVENT_CHANGE, function () {
      var backgroundColor = this.getValue();
      self.fireEvent("EVENT_CHANGE", backgroundColor);
    });
    this.colorchooser.on(BI.ColorChooser.EVENT_AFTER_POPUPVIEW, function () {
      self.fireEvent("EVENT_AFTER_POPUPVIEW");
    });
  },
  setValue: function setValue(color) {
    this.colorchooser.setValue(color);
  },
  hideIf: function hideIf(e) {
    if (!this.colorchooser.element.find(e.target).length > 0) {
      this.colorchooser.hideView();
    }
  },
  deactivate: function deactivate() {}
});
BI.RichEditorBackgroundColorChooser.EVENT_CHANGE = "EVENT_CHANGE";
BI.RichEditorBackgroundColorChooser.EVENT_AFTER_POPUPVIEW = "EVENT_AFTER_POPUPVIEW";
BI.shortcut("bi.rich_editor_background_color_chooser", BI.RichEditorBackgroundColorChooser);

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 颜色选择
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorColorChooser
 * @extends BI.RichEditorAction
 */
BI.RichEditorColorChooser = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorColorChooser.superclass._defaultConfig.apply(this, arguments), {
      width: 20,
      height: 20,
      command: "foreColor",
      css: {
        color: null
      }
    });
  },
  _init: function _init() {
    BI.RichEditorColorChooser.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.colorchooser = BI.createWidget({
      type: "bi.color_chooser",
      container: null,
      element: this,
      width: o.width,
      height: o.height,
      destroyWhenHide: o.destroyWhenHide,
      recommendColorsGetter: o.recommendColorsGetter,
      el: {
        type: "bi.rich_editor_color_chooser_trigger",
        title: BI.i18nText("BI-Font_Colour"),
        cls: "text-toolbar-button",
        disabled: o.disabled,
        warningTitle: o.warningTitle
      }
    });
    this.colorchooser.on(BI.ColorChooser.EVENT_CHANGE, function () {
      var value = this.getValue(); // 用span代替font

      if (BI.isIE()) {
        self.doCommand(value);
      } else {
        document.execCommand('styleWithCSS', null, true);
        self.doCommand(value || "inherit");
        document.execCommand('styleWithCSS', null, false);
      }
    });
  },
  hideIf: function hideIf(e) {
    if (!this.colorchooser.element.find(e.target).length > 0) {
      this.colorchooser.hideView();
    }
  },
  activate: function activate(rgb) {
    var self = this; // 等下EVENT_CHANGE

    BI.delay(function () {
      var color = BI.DOM.rgb2hex(rgb);
      var rgba = BI.DOM.isRGBColor(rgb) ? BI.DOM.rgba2json(rgb) : {};

      if (rgba.a === 0) {
        color = "transparent";
      }

      self.colorchooser.setValue(color);
    }, 0);
  },
  deactivate: function deactivate() {
    this.colorchooser.setValue("");
  }
});
BI.shortcut("bi.rich_editor_color_chooser", BI.RichEditorColorChooser);

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


BI.RichEditorFontChooser = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorFontChooser.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-rich-editor-font-chooser bi-card",
      command: "FontName",
      width: 100,
      height: 24,
      css: {
        fontFamily: null
      },
      $testId: "bi-rich-editor-font-chooser",
      simple: false
    });
  },
  _init: function _init() {
    BI.RichEditorSizeChooser.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.trigger = BI.createWidget({
      type: "bi.text_trigger",
      height: o.height,
      triggerWidth: 16,
      text: BI.i18nText("BI-Basic_Default")
    });
    this.combo = BI.createWidget({
      type: "bi.combo",
      cls: o.simple ? 'bi-border-bottom' : 'bi-border',
      container: null,
      element: this,
      el: this.trigger,
      adjustLength: 1,
      popup: {
        minWidth: 70,
        el: {
          type: "bi.button_group",
          items: BI.createItems(self._formatArray(BI.isNotEmptyArray(o.fontList) ? o.fontList : BI.Constants.getConstant('bi.constant.materials.rich_editor.font_family')), {
            type: "bi.single_select_item"
          }),
          layouts: [{
            type: "bi.vertical"
          }]
        }
      }
    });
    this.combo.on(BI.Combo.EVENT_CHANGE, function () {
      var val = this.getValue()[0];
      self.activate(val);
      self.doCommand(val);
      this.hideView();
      this.setValue([]);
    });
  },
  _formatArray: function _formatArray(arr) {
    return BI.map(arr, function (i, item) {
      return {
        text: item.text,
        value: BI.isString(item.value) ? item.value.replaceAll("\"", "") : ""
      };
    });
  },
  hideIf: function hideIf(e) {
    if (!this.combo.element.find(e.target).length > 0) {
      this.combo.hideView();
    }
  },
  activate: function activate(fontFamily) {
    var o = this.options; // CHART-19802 后端导出要用真·中文才能匹配，兼容一下老模板的选中效果

    var map = {
      'STHeiti, Hei, SimHei': 'STHeiti, Hei, SimHei, 黑体',
      'STSong, Song, SimSun': 'STSong, Song, SimSun, 宋体',
      'STFangSong, "Fang Song", FangSong': 'STFangSong, "Fang Song", FangSong, 仿宋',
      'STKaiti, Kai, KaiTi': 'STKaiti, Kai, KaiTi, 楷体'
    };
    fontFamily = map[fontFamily] || fontFamily;
    var text = BI.i18nText("BI-Basic_Default");
    BI.any(o.fontList || BI.Constants.getConstant("bi.constant.materials.rich_editor.font_family"), function (idx, item) {
      // 判断时由于浏览器不同传入的时有些会带\"有些不会带，统一去除判断
      if (fontFamily.replaceAll("\"", "") === item.value.replaceAll("\"", "")) {
        text = item.text;
        return true;
      }
    });
    this.fontFamily = fontFamily;
    this.trigger.setText(text);
    this.combo.setValue(fontFamily.replaceAll("\"", ""));
  },
  deactivate: function deactivate() {
    this.trigger.setText(BI.i18nText("BI-Basic_Default"));
    this.combo.setValue();
  },
  getValue: function getValue() {
    return this.fontFamily || BI.FontFamily.DEFAULT;
  }
});
BI.shortcut("bi.rich_editor_font_chooser", BI.RichEditorFontChooser); // 高版本Mac OS已经没有Song（宋体），而是ST Song（华文宋体），仿宋同

BI.FontFamily = {
  DEFAULT: 'Avenir, Segoe UI, PingFangSC-Regular, "Microsoft YaHei"',
  SIM_HEI: "STHeiti, Hei, SimHei, 黑体",
  SIM_SUN: "STSong, Song, SimSun, 宋体",
  FANG_SONG: 'STFangSong, "Fang Song", FangSong, 仿宋',
  KAI_TI: "STKaiti, Kai, KaiTi, 楷体",
  YOU_SHE: "YouShe",
  PANG_MEM: "pangMen",
  ARIAL: "Arial",
  HELVETICA_NEUE: '"Helvetica Neue"',
  VERDANA: "Verdana",
  TIMES_NEW_ROMAN: '"Times New Roman"',
  DIGITAL_NUMBERS: '"Digital Numbers"',
  POPPINS_BOLD: '"Poppins Bold"'
};

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 字体大小选择
 *
 * Created by GUY on 2015/11/26.
 * @class BI.RichEditorSizeChooser
 * @extends BI.RichEditorAction
 */
BI.RichEditorSizeChooser = BI.inherit(BI.RichEditorAction, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditorSizeChooser.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-rich-editor-size-chooser bi-card",
      command: "FontSize",
      width: 50,
      height: 24,
      css: {
        fontSize: null
      },
      $testId: "bi-rich-editor-size-chooser",
      simple: false
    });
  },
  _init: function _init() {
    BI.RichEditorSizeChooser.superclass._init.apply(this, arguments);

    var self = this,
        o = this.options;
    this.trigger = BI.createWidget({
      type: "bi.text_trigger",
      height: o.height,
      triggerWidth: 16,
      text: BI.i18nText("BI-Font_Size"),
      disabled: o.disabled,
      warningTitle: o.warningTitle
    });
    this.combo = BI.createWidget({
      type: "bi.combo",
      cls: o.simple ? "bi-border-bottom" : "bi-border",
      container: null,
      element: this,
      el: this.trigger,
      adjustLength: 1,
      popup: {
        maxWidth: 70,
        minWidth: 70,
        el: {
          type: "bi.button_group",
          items: BI.createItems(BI.Constants.getConstant("bi.constant.materials.rich_editor.font_size"), {
            type: "bi.single_select_item"
          }),
          layouts: [{
            type: "bi.vertical"
          }]
        }
      }
    });
    this.combo.on(BI.Combo.EVENT_CHANGE, function () {
      var val = this.getValue()[0];
      self.doAction(val);
      this.hideView();
      this.setValue([]);
    });
  },
  hideIf: function hideIf(e) {
    if (!this.combo.element.find(e.target).length > 0) {
      this.combo.hideView();
    }
  },
  doAction: function doAction(fontSize) {
    function cleanFontSize(node) {
      BI.$(node).css("font-size", "");
      BI.each(node.childNodes, function (idx, child) {
        cleanFontSize(child);
      });
    }

    this.activate(fontSize);
    var editor = this.options.editor.instance;
    var range = editor.getSavedRng();
    var commonSize = 7;

    if (range && !range.collapsed) {
      this.doCommand(commonSize);
      BI.each(document.getElementsByTagName("font"), function (idx, el) {
        if (BI.contains(BI.$(el).parents(), editor.element[0]) && el["size"] == commonSize) {
          cleanFontSize(el);
          BI.$(el).removeAttr("size").css("font-size", fontSize + "px");
        }
      });
    } else {
      editor.restoreRng();
    }
  },
  activate: function activate(fontSize) {
    fontSize = (fontSize || 12) + "";
    var size = fontSize.replace("px", "");
    this.fontSize = size;
    this.trigger.setText(size);
    this.combo.setValue(BI.parseInt(size));
  },
  deactivate: function deactivate() {
    this.trigger.setText(BI.i18nText("BI-Font_Size"));
    this.combo.setValue();
  },
  getValue: function getValue() {
    return this.fontSize || 12;
  }
});
BI.shortcut("bi.rich_editor_size_chooser", BI.RichEditorSizeChooser);

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author windy
 * @version 10.0
 * Created by windy on 2019/9/10
 */
!function () {
  BI.constant("bi.constant.materials.rich_editor.font_family", [{
    value: BI.FontFamily.DEFAULT,
    text: BI.i18nText("BI-Basic_Default")
  }, {
    value: BI.FontFamily.SIM_HEI,
    text: BI.i18nText("BI-Basic_Sim_Hei")
  }, {
    value: BI.FontFamily.SIM_SUN,
    text: BI.i18nText("BI-Basic_Sim_Sun")
  }, {
    value: BI.FontFamily.FANG_SONG,
    text: BI.i18nText("BI-Basic_Fang_Song")
  }, {
    value: BI.FontFamily.KAI_TI,
    text: BI.i18nText("BI-Basic_Kai_Ti")
  }, {
    value: BI.FontFamily.ARIAL,
    text: "Arial"
  }, {
    value: BI.FontFamily.HELVETICA_NEUE,
    text: "Helvetica Neue"
  }, {
    value: BI.FontFamily.VERDANA,
    text: "Verdana"
  }, {
    value: BI.FontFamily.TIMES_NEW_ROMAN,
    text: "Times New Roman"
  }]);
  BI.constant("bi.constant.materials.rich_editor.font_size", [{
    value: 12,
    text: 12
  }, {
    value: 13,
    text: 13
  }, {
    value: 14,
    text: 14
  }, {
    value: 16,
    text: 16
  }, {
    value: 18,
    text: 18
  }, {
    value: 20,
    text: 20
  }, {
    value: 22,
    text: 22
  }, {
    value: 24,
    text: 24
  }, {
    value: 26,
    text: 26
  }, {
    value: 28,
    text: 28
  }, {
    value: 30,
    text: 30
  }, {
    value: 32,
    text: 32
  }, {
    value: 34,
    text: 34
  }, {
    value: 36,
    text: 36
  }, {
    value: 38,
    text: 38
  }, {
    value: 40,
    text: 40
  }, {
    value: 64,
    text: 64
  }, {
    value: 128,
    text: 128
  }]);
  BI.constant("bi.constant.materials.rich_editor.font_size_range", {
    MAX: 128,
    MIN: 12
  });
}();

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * 富文本编辑器
 *
 * Created by GUY on 2017/9/15.
 * @class BI.RichEditor
 * @extends BI.Widget
 */
BI.RichEditor = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-rich-editor bi-textarea" + (BI.isIE() ? " hack" : ""),
    toolbar: {},
    readOnly: false,
    scrollable: true
  },
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.RichEditor.superclass._defaultConfig.apply(this, arguments), {
      adjustLength: 1,
      adjustXOffset: 0,
      adjustYOffset: 0
    });
  },
  render: function render() {
    var self = this,
        o = this.options;
    var editor = {
      type: "bi.nic_editor",
      width: o.width,
      height: o.height,
      readOnly: o.readOnly,
      scrollable: o.scrollable,
      ref: function ref() {
        self.editor = this;
      },
      listeners: [{
        eventName: BI.NicEditor.EVENT_BLUR,
        action: function action() {
          if (!o.readOnly && self.combo.isViewVisible()) {
            self.combo.hideView();
          }

          self.fireEvent(BI.RichEditor.EVENT_CONFIRM);
        }
      }, {
        eventName: BI.NicEditor.EVENT_FOCUS,
        action: function action() {
          if (!o.readOnly && !self.combo.isViewVisible()) {
            self.combo.showView();
          }

          self.fireEvent(BI.RichEditor.EVENT_FOCUS);
        }
      }]
    };

    if (o.readOnly) {
      return editor;
    }

    this.editor = BI.createWidget(editor);
    return {
      type: "bi.combo",
      container: o.container,
      toggle: false,
      trigger: "click",
      direction: "top,right",
      isNeedAdjustWidth: false,
      isNeedAdjustHeight: false,
      adjustLength: o.adjustLength,
      adjustXOffset: o.adjustXOffset,
      adjustYOffset: o.adjustYOffset,
      ref: function ref() {
        self.combo = this;
      },
      el: this.editor,
      popup: {
        el: BI.extend({
          type: "bi.rich_editor_text_toolbar",
          editor: this.editor
        }, o.toolbar, {
          ref: function ref(_ref) {
            self.editor.bindToolbar(_ref);
            o.toolbar.ref && o.toolbar.ref(_ref);
          }
        }),
        height: 34,
        stopPropagation: false,
        stopEvent: false
      },
      listeners: [{
        eventName: BI.Combo.EVENT_AFTER_HIDEVIEW,
        action: function action() {
          self.fireEvent(BI.RichEditor.EVENT_AFTER_HIDEVIEW);
        }
      }]
    };
  },
  mounted: function mounted() {
    var o = this.options;

    if (BI.isNotNull(o.value)) {
      this.editor.setValue(o.value);
    }
  },
  focus: function focus() {
    this.editor.focus();
  },
  setValue: function setValue(v) {
    this.editor.setValue(v);
  },
  getValue: function getValue(type) {
    return this.editor.getValue(type);
  },
  setVisible: function setVisible(v) {
    if (!v) {
      this.combo.hideView();
    }

    BI.RichEditor.superclass.setVisible.apply(this, arguments);
  },
  getContentHeight: function getContentHeight() {
    return this.editor.getContentHeight();
  },
  getEditor: function getEditor() {
    return this.editor;
  }
});
BI.RichEditor.EVENT_AFTER_HIDEVIEW = "EVENT_AFTER_HIDEVIEW";
BI.RichEditor.EVENT_CONFIRM = "EVENT_CONFIRM";
BI.RichEditor.EVENT_FOCUS = "EVENT_FOCUS";
BI.shortcut("bi.rich_editor", BI.RichEditor);

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
(function (mod) {
  mod(BI.CodeMirror);
})(function (CodeMirror) {
  var tables;
  var defaultTable;
  var keywords;
  var identifierQuote;
  var CONS = {
    QUERY_DIV: ";",
    ALIAS_KEYWORD: "AS"
  };
  var Pos = CodeMirror.Pos,
      cmpPos = CodeMirror.cmpPos;

  function isArray(val) {
    return Object.prototype.toString.call(val) == "[object Array]";
  }

  function getKeywords(editor) {
    var mode = editor.doc.modeOption;
    if (mode === "sql") mode = "text/x-sql";
    return CodeMirror.resolveMode(mode).keywords;
  }

  function getIdentifierQuote(editor) {
    var mode = editor.doc.modeOption;
    if (mode === "sql") mode = "text/x-sql";
    return CodeMirror.resolveMode(mode).identifierQuote || "`";
  }

  function getText(item) {
    return typeof item === "string" ? item : item.text;
  }

  function wrapTable(name, value) {
    if (isArray(value)) value = {
      columns: value
    };
    if (!value.text) value.text = name;
    return value;
  }

  function parseTables(input) {
    var result = {};

    if (isArray(input)) {
      for (var i = input.length - 1; i >= 0; i--) {
        var item = input[i];
        result[getText(item).toUpperCase()] = wrapTable(getText(item), item);
      }
    } else if (input) {
      for (var name in input) {
        result[name.toUpperCase()] = wrapTable(name, input[name]);
      }
    }

    return result;
  }

  function getTable(name) {
    return tables[name.toUpperCase()];
  }

  function shallowClone(object) {
    var result = {};

    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        result[key] = object[key];
      }
    }

    return result;
  }

  function match(string, word) {
    if (BI.isNotEmptyString(string)) {
      var len = string.length;
      var sub = getText(word).substr(0, len);
      return string.toUpperCase() === sub.toUpperCase();
    }
  }

  function addMatches(result, search, wordlist, formatter) {
    if (isArray(wordlist)) {
      for (var i = 0; i < wordlist.length; i++) {
        if (match(search, wordlist[i])) result.push(formatter(wordlist[i], i));
      }
    } else {
      for (var word in wordlist) {
        if (wordlist.hasOwnProperty(word)) {
          var val = wordlist[word];

          if (!val || val === true) {
            val = word;
          } else {
            val = val.displayText ? {
              text: val.text,
              displayText: val.displayText
            } : val.text;
          }

          if (match(search, val)) result.push(formatter(val, -1));
        }
      }
    }
  }

  function cleanName(name) {
    // Get rid name from identifierQuote and preceding dot(.)
    if (name.charAt(0) == ".") {
      name = name.substr(1);
    } // replace doublicated identifierQuotes with single identifierQuotes
    // and remove single identifierQuotes


    var nameParts = name.split(identifierQuote + identifierQuote);

    for (var i = 0; i < nameParts.length; i++) {
      nameParts[i] = nameParts[i].replace(new RegExp(identifierQuote, "g"), "");
    }

    return nameParts.join(identifierQuote);
  }

  function insertIdentifierQuotes(name) {
    var nameParts = getText(name).split(".");

    for (var i = 0; i < nameParts.length; i++) {
      nameParts[i] = identifierQuote + // doublicate identifierQuotes
      nameParts[i].replace(new RegExp(identifierQuote, "g"), identifierQuote + identifierQuote) + identifierQuote;
    }

    var escaped = nameParts.join(".");
    if (typeof name === "string") return escaped;
    name = shallowClone(name);
    name.text = escaped;
    return name;
  }

  function nameCompletion(cur, token, result, editor) {
    // Try to complete table, column names and return start position of completion
    var useIdentifierQuotes = false;
    var nameParts = [];
    var start = token.start;
    var cont = true;

    while (cont) {
      cont = token.string.charAt(0) == ".";
      useIdentifierQuotes = useIdentifierQuotes || token.string.charAt(0) == identifierQuote;
      start = token.start;
      nameParts.unshift(cleanName(token.string));
      token = editor.getTokenAt(Pos(cur.line, token.start));

      if (token.string == ".") {
        cont = true;
        token = editor.getTokenAt(Pos(cur.line, token.start));
      }
    } // Try to complete table names


    var string = nameParts.join(".");
    addMatches(result, string, tables, function (w) {
      return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
    }); // Try to complete columns from defaultTable

    addMatches(result, string, defaultTable, function (w) {
      return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
    }); // Try to complete columns

    string = nameParts.pop();
    var table = nameParts.join(".");
    var alias = false;
    var aliasTable = table; // Check if table is available. If not, find table by Alias

    if (!getTable(table)) {
      var oldTable = table;
      table = findTableByAlias(table, editor);
      if (table !== oldTable) alias = true;
    }

    var columns = getTable(table);

    if (columns && columns.columns) {
      columns = columns.columns;
    }

    if (columns) {
      addMatches(result, string, columns, function (w) {
        var tableInsert = table;
        if (alias == true) tableInsert = aliasTable;

        if (typeof w === "string") {
          w = tableInsert + "." + w;
        } else {
          w = shallowClone(w);
          w.text = tableInsert + "." + w.text;
        }

        return useIdentifierQuotes ? insertIdentifierQuotes(w) : w;
      });
    }

    return start;
  }

  function eachWord(lineText, f) {
    var words = lineText.split(/\s+/);

    for (var i = 0; i < words.length; i++) {
      if (words[i]) f(words[i].replace(/[,;]/g, ""));
    }
  }

  function findTableByAlias(alias, editor) {
    var doc = editor.doc;
    var fullQuery = doc.getValue();
    var aliasUpperCase = alias.toUpperCase();
    var previousWord = "";
    var table = "";
    var separator = [];
    var validRange = {
      start: Pos(0, 0),
      end: Pos(editor.lastLine(), editor.getLineHandle(editor.lastLine()).length)
    }; // add separator

    var indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV);

    while (indexOfSeparator != -1) {
      separator.push(doc.posFromIndex(indexOfSeparator));
      indexOfSeparator = fullQuery.indexOf(CONS.QUERY_DIV, indexOfSeparator + 1);
    }

    separator.unshift(Pos(0, 0));
    separator.push(Pos(editor.lastLine(), editor.getLineHandle(editor.lastLine()).text.length)); // find valid range

    var prevItem = null;
    var current = editor.getCursor();

    for (var i = 0; i < separator.length; i++) {
      if ((prevItem == null || cmpPos(current, prevItem) > 0) && cmpPos(current, separator[i]) <= 0) {
        validRange = {
          start: prevItem,
          end: separator[i]
        };
        break;
      }

      prevItem = separator[i];
    }

    var query = doc.getRange(validRange.start, validRange.end, false);

    for (var i = 0; i < query.length; i++) {
      var lineText = query[i];
      eachWord(lineText, function (word) {
        var wordUpperCase = word.toUpperCase();

        if (wordUpperCase === aliasUpperCase && getTable(previousWord)) {
          table = previousWord;
        }

        if (wordUpperCase !== CONS.ALIAS_KEYWORD) {
          previousWord = word;
        }
      });
      if (table) break;
    }

    return table;
  }

  CodeMirror.registerHelper("hint", "sql", function (editor, options) {
    tables = parseTables(options && options.tables);
    var defaultTableName = options && options.defaultTable;
    var disableKeywords = options && options.disableKeywords;
    defaultTable = defaultTableName && getTable(defaultTableName);
    keywords = getKeywords(editor);
    var keywordsCount = BI.size(keywords);
    var functions = [];
    var cur = editor.getCursor();
    var token = editor.getTokenAt(cur);

    if (options.supportFunction) {
      BI.each(BI.FormulaCollections, function (idx, formula) {
        if (formula.lastIndexOf(token.string, 0) == 0 && !BI.contains(functions, formula)) {
          functions.push(formula);
        }
      });
      var keywords = BI.keys(keywords);
      BI.each(functions, function (idx, func) {
        var lowerCase = func.toLowerCase();
        var upperCase = func.toUpperCase();

        if (!BI.contains(keywords, lowerCase) && !BI.contains(keywords, upperCase)) {
          keywords.push(func);
        }
      });
    }

    identifierQuote = getIdentifierQuote(editor);

    if (defaultTableName && !defaultTable) {
      defaultTable = findTableByAlias(defaultTableName, editor);
    }

    defaultTable = defaultTable || [];

    if (defaultTable.columns) {
      defaultTable = defaultTable.columns;
    }

    var result = [];
    var start, end, search;

    if (token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }

    if (token.string.match(/^[.`"\w@]\w*$/)) {
      search = token.string;
      start = token.start;
      end = token.end;
    } else {
      start = end = cur.ch;
      search = "";
    }

    if (search.charAt(0) == "." || search.charAt(0) == identifierQuote) {
      start = nameCompletion(cur, token, result, editor);
    } else {
      addMatches(result, search, tables, function (w) {
        return w;
      });
      addMatches(result, search, defaultTable, function (w) {
        return w;
      });

      if (!disableKeywords) {
        addMatches(result, search, keywords, function (w, i) {
          var isKeyword = i < keywordsCount;
          return {
            type: isKeyword ? BICst.FORMULA_KEYWORD_TYPE.KEYWORD : BICst.FORMULA_KEYWORD_TYPE.FUNCTION,
            text: w // description: desc[w] || "SQL关键字",
            // className: isKeyword ? "sql-keyword" : "sql-fr-function",
            // render: function (Element, self, data) {
            //   var label = BI.createWidget({
            //     type: "bi.label",
            //     element: Element,
            //     text: data.displayText || getText(data)
            //   });
            //   label.setTitle(data.description, {
            //     container: "body"
            //   });
            // }

          };
        });
      }
    }

    return {
      list: result,
      from: Pos(cur.line, start),
      to: Pos(cur.line, end)
    };
  });
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE
(function (mod) {
  mod(BI.CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("sql", function (config, parserConfig) {
    "use strict";

    var client = parserConfig.client || {},
        atoms = parserConfig.atoms || {
      "false": true,
      "true": true,
      "null": true
    },
        builtin = parserConfig.builtin || {},
        keywords = parserConfig.keywords || {},
        operatorChars = parserConfig.operatorChars || /^[*+\-%<>!=&|~^]/,
        support = parserConfig.support || {},
        hooks = parserConfig.hooks || {},
        dateSQL = parserConfig.dateSQL || {
      date: true,
      time: true,
      timestamp: true
    },
        functions = parserConfig.functions || {};

    function tokenBase(stream, state) {
      var ch = stream.next(); // call hooks from the mime type

      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }

      if (support.hexNumber && (ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/) || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {
        // hex
        // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html
        return "number";
      } else if (support.binaryNumber && ((ch == "b" || ch == "B") && stream.match(/^'[01]+'/) || ch == "0" && stream.match(/^b[01]+/))) {
        // bitstring
        // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html
        return "number";
      } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {
        // numbers
        // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html
        stream.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/);
        support.decimallessFloat && stream.match(/^\.(?!\.)/);
        return "number";
      } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
        // placeholders
        return "variable-3";
      } else if (ch == "'" || ch == "\"" && support.doubleQuote) {
        // strings
        // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
        state.tokenize = tokenLiteral(ch);
        return state.tokenize(stream, state);
      } else if ((support.nCharCast && (ch == "n" || ch == "N") || support.charsetCast && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)) && (stream.peek() == "'" || stream.peek() == "\"")) {
        // charset casting: _utf8'str', N'str', n'str'
        // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
        return "keyword";
      } else if (/^[\(\),\;\[\]]/.test(ch)) {
        // no highlighting
        return null;
      } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {
        // 1-line comment
        stream.skipToEnd();
        return "comment";
      } else if (support.commentHash && ch == "#" || ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" "))) {
        // 1-line comments
        // ref: https://kb.askmonty.org/en/comment-syntax/
        stream.skipToEnd();
        return "comment";
      } else if (ch == "/" && stream.eat("*")) {
        // multi-line comments
        // ref: https://kb.askmonty.org/en/comment-syntax/
        state.tokenize = tokenComment(1);
        return state.tokenize(stream, state);
      } else if (ch == ".") {
        // .1 for 0.1
        if (support.zerolessFloat && stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i)) {
          return "number";
        }

        if (stream.match(/^\.+/)) {
          return null;
        } // .table_name (ODBC)
        // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html


        if (support.ODBCdotTable && stream.match(/^[\w\d_]+/)) {
          return "variable-2";
        }
      } else if (operatorChars.test(ch)) {
        // operators
        stream.eatWhile(operatorChars);
        return null;
      } else if (ch == "{" && (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
        // dates (weird ODBC syntax)
        // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
        return "number";
      } else {
        stream.eatWhile(/^[_\w\d]/);
        var word = stream.current().toLowerCase(); // dates (standard SQL syntax)
        // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html

        if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/))) {
          return "number";
        }

        if (atoms.hasOwnProperty(word)) return "atom";
        if (builtin.hasOwnProperty(word)) return "builtin";
        if (functions.hasOwnProperty(word) && stream.peek() === "(") return "function";
        if (keywords.hasOwnProperty(word)) return "keyword";
        if (client.hasOwnProperty(word)) return "string-2";
        return null;
      }
    } // 'string', with char specified in quote escaped by '\'


    function tokenLiteral(quote) {
      return function (stream, state) {
        var escaped = false,
            ch;

        while ((ch = stream.next()) != null) {
          if (ch == quote && !escaped) {
            state.tokenize = tokenBase;
            break;
          }

          escaped = !escaped && ch == "\\";
        }

        return "string";
      };
    }

    function tokenComment(depth) {
      return function (stream, state) {
        var m = stream.match(/^.*?(\/\*|\*\/)/);
        if (!m) stream.skipToEnd();else if (m[1] == "/*") state.tokenize = tokenComment(depth + 1);else if (depth > 1) state.tokenize = tokenComment(depth - 1);else state.tokenize = tokenBase;
        return "comment";
      };
    }

    function pushContext(stream, state, type) {
      state.context = {
        prev: state.context,
        indent: stream.indentation(),
        col: stream.column(),
        type: type
      };
    }

    function popContext(state) {
      state.indent = state.context.indent;
      state.context = state.context.prev;
    }

    return {
      startState: function startState() {
        return {
          tokenize: tokenBase,
          context: null
        };
      },
      token: function token(stream, state) {
        if (stream.sol()) {
          if (state.context && state.context.align == null) {
            state.context.align = false;
          }
        }

        if (state.tokenize == tokenBase && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (style == "comment") return style;

        if (state.context && state.context.align == null) {
          state.context.align = true;
        }

        var tok = stream.current();

        if (tok == "(") {
          pushContext(stream, state, ")");
        } else if (tok == "[") {
          pushContext(stream, state, "]");
        } else if (state.context && state.context.type == tok) {
          popContext(state);
        }

        return style;
      },
      indent: function indent(state, textAfter) {
        var cx = state.context;
        if (!cx) return CodeMirror.Pass;
        var closing = textAfter.charAt(0) == cx.type;
        if (cx.align) return cx.col + (closing ? 0 : 1);
        return cx.indent + (closing ? 0 : config.indentUnit);
      },
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : "--"
    };
  });

  (function () {
    "use strict"; // `identifier`

    function hookIdentifier(stream) {
      // MySQL/MariaDB identifiers
      // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
      var ch;

      while ((ch = stream.next()) != null) {
        if (ch == "`" && !stream.eat("`")) return "variable-2";
      }

      stream.backUp(stream.current().length - 1);
      return stream.eatWhile(/\w/) ? "variable-2" : null;
    } // "identifier"


    function hookIdentifierDoublequote(stream) {
      // Standard SQL /SQLite identifiers
      // ref: http://web.archive.org/web/20160813185132/http://savage.net.au/SQL/sql-99.bnf.html#delimited%20identifier
      // ref: http://sqlite.org/lang_keywords.html
      var ch;

      while ((ch = stream.next()) != null) {
        if (ch == "\"" && !stream.eat("\"")) return "variable-2";
      }

      stream.backUp(stream.current().length - 1);
      return stream.eatWhile(/\w/) ? "variable-2" : null;
    } // variable token


    function hookVar(stream) {
      // variables
      // @@prefix.varName @varName
      // varName can be quoted with ` or ' or "
      // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html
      if (stream.eat("@")) {
        stream.match(/^session\./);
        stream.match(/^local\./);
        stream.match(/^global\./);
      }

      if (stream.eat("'")) {
        stream.match(/^.*'/);
        return "variable-2";
      } else if (stream.eat("\"")) {
        stream.match(/^.*"/);
        return "variable-2";
      } else if (stream.eat("`")) {
        stream.match(/^.*`/);
        return "variable-2";
      } else if (stream.match(/^[0-9a-zA-Z$\.\_]+/)) {
        return "variable-2";
      }

      return null;
    } // short client keyword token


    function hookClient(stream) {
      // \N means NULL
      // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html
      if (stream.eat("N")) {
        return "atom";
      } // \g, etc
      // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html


      return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
    } // these keywords are used by all SQL dialects (however, a mode can still overwrite it)


    var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit "; // turn a space-separated list into an array

    function set(str) {
      var obj = {},
          words = str.split(" ");

      for (var i = 0; i < words.length; ++i) {
        obj[words[i]] = true;
      }

      return obj;
    } // A generic SQL Mode. It's not a standard, it just try to support what is generally supported


    CodeMirror.defineMIME("text/x-sql", {
      name: "sql",
      keywords: set(sqlKeywords + "begin"),
      builtin: set("bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"),
      atoms: set("false true null unknown"),
      operatorChars: /^[*+\-%<>!=]/,
      dateSQL: set("date time timestamp"),
      support: set("ODBCdotTable doubleQuote binaryNumber hexNumber"),
      functions: BI.makeObject(BI.FormulaCollections, true)
    });
  })();
});
/*
  How Properties of Mime Types are used by SQL Mode
  =================================================

  keywords:
    A list of keywords you want to be highlighted.
  builtin:
    A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").
  operatorChars:
    All characters that must be handled as operators.
  client:
    Commands parsed and executed by the client (not the server).
  support:
    A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.
    * ODBCdotTable: .tableName
    * zerolessFloat: .1
    * doubleQuote
    * nCharCast: N'string'
    * charsetCast: _utf8'string'
    * commentHash: use # char for comments
    * commentSlashSlash: use // for comments
    * commentSpaceRequired: require a space after -- for comments
  atoms:
    Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:
    UNKNOWN, INFINITY, UNDERFLOW, NaN...
  dateSQL:
    Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.
*/

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by Windy on 2017/12/15.
 */
BI.SQLEditor = BI.inherit(BI.Widget, {
  props: function props() {
    return {
      baseCls: "bi-sql-editor",
      value: "",
      lineHeight: 2,
      showHint: true,
      supportFunction: false,
      supportParam: false,
      // 参数显示值构造函数
      paramFormatter: function paramFormatter(v) {
        return v;
      },
      watermark: BI.i18nText("BI-Please_Enter_SQL"),
      lineWrapping: true,
      lineNumbers: false
    };
  },
  render: function render() {
    var o = this.options,
        self = this;
    var conf = {
      mode: "text/x-sql",
      lineWrapping: o.lineWrapping,
      lineNumbers: o.lineNumbers,
      readOnly: o.readOnly
    };
    o.readOnly && (conf.cursorBlinkRate = -1);
    this.editor = BI.CodeMirror(this.element[0], conf);
    o.lineHeight === 1 ? this.element.addClass("codemirror-low-line-height") : this.element.addClass("codemirror-high-line-height");
    this.editor.on("change", function (cm, change) {
      self._checkWaterMark(); // 调用setValue也会触发change, 提示框只需要在编辑的时候触发


      if (o.showHint && self.editor.hasFocus()) {
        BI.CodeMirror.showHint(cm, BI.CodeMirror.sqlHint, {
          completeSingle: false,
          supportFunction: o.supportFunction
        });
      }

      BI.nextTick(function () {
        self.fireEvent(BI.FormulaEditor.EVENT_CHANGE);
      });
    });
    this.editor.on("focus", function () {
      self._checkWaterMark();

      self.fireEvent(BI.FormulaEditor.EVENT_FOCUS);
    });
    this.editor.on("blur", function () {
      self.fireEvent(BI.FormulaEditor.EVENT_BLUR);
    }); // 水印

    this.watermark = BI.createWidget({
      type: "bi.label",
      text: o.watermark,
      cls: "bi-water-mark",
      whiteSpace: "normal",
      textAlign: "left"
    });
    this.watermark.element.bind("mousedown", function (e) {
      self._insertString("");

      self.editor.focus();
      e.stopEvent();
    });
    this.watermark.element.bind("click", function (e) {
      self.editor.focus();
      e.stopEvent();
    });
    BI.createWidget({
      type: "bi.absolute",
      element: this,
      items: [{
        el: this.watermark,
        top: 3,
        left: 6,
        right: 6
      }]
    });

    if (BI.isKey(o.value)) {
      BI.nextTick(function () {
        self.setValue(o.value);
      });
    }
  },
  _setEnable: function _setEnable(b) {
    BI.SQLEditor.superclass._setEnable.apply(this, arguments);

    this.editor.setOption("readOnly", b === true ? false : "nocursor");
  },
  _insertString: function _insertString(str) {
    this.editor.replaceSelection(str);
  },
  _insertParam: function _insertParam(param) {
    var value = param;
    param = this.options.paramFormatter(param);
    var from = this.editor.getCursor(); // 解决插入字段由括号或其他特殊字符包围时分裂的bug,在两端以不可见字符包裹一下

    this.editor.replaceSelection("\u200B" + param + "\u200B");
    var to = this.editor.getCursor();
    var className = "param";

    if (BI.isNotNull(param.match(/^<!.*!>$/))) {
      className = "error-param";
    }

    var options = {
      className: className,
      atomic: true,
      replacedWith: BI.$("<span class='" + className + " start end' />").text(param)[0]
    };
    options.value = value;
    this.editor.markText(from, to, options);
  },
  _checkWaterMark: function _checkWaterMark() {
    var o = this.options;

    if (!this.disabledWaterMark && BI.isEmptyString(this.editor.getValue()) && BI.isKey(o.watermark)) {
      this.watermark && this.watermark.visible();
    } else {
      this.watermark && this.watermark.invisible();
    }
  },
  insertString: function insertString(str) {
    this._insertString(str);

    this.editor.focus();
  },
  insertParam: function insertParam(param) {
    this._insertParam(param);

    this.editor.focus();
  },
  _analyzeContent: function _analyzeContent(v) {
    var regx = /\n|\$[\{][^\}]*[\}]|((?!\$\{).)*((?!\$\{).)|\$[^\{]*[^\$\{]/g;
    return v.match(regx);
  },
  getValue: function getValue() {
    return this.editor.getValue("\n", function (line) {
      var value = line.text,
          num = 0;

      _.forEach(_.sortBy(line.markedSpans, "from"), function (i, ms) {
        switch (i.marker.className) {
          case "param":
          case "error-param":
            var fieldNameLength = i.to - i.from;
            value = value.substr(0, i.from + num) + "$\{" + i.marker.value + "\}" + value.substr(i.to + num, value.length); // 加上${}的偏移

            num += 3; // 加上实际值和显示值的长度差的偏移

            num += i.marker.value.length - fieldNameLength;
            break;
        }
      });

      return value;
    });
  },
  setValue: function setValue(v) {
    var self = this,
        result,
        o = this.options;
    this.refresh();
    self.editor.setValue("");

    if (!o.supportParam) {
      this._insertString(v);

      this._checkWaterMark();

      return;
    }

    result = this._analyzeContent(v || "");
    BI.each(result, function (i, item) {
      var fieldRegx = /\$[\{][^\}]*[\}]/;
      var str = item.match(fieldRegx);

      if (BI.isNotEmptyArray(str)) {
        self._insertParam(str[0].substring(2, item.length - 1));
      } else {
        self._insertString(item);
      }
    });

    this._checkWaterMark();
  },
  refresh: function refresh() {
    var self = this;
    BI.nextTick(function () {
      self.editor.refresh();
    });
  },
  setVisible: function setVisible(visible) {
    BI.SQLEditor.superclass.setVisible.apply(this, arguments);
    visible && this.refresh();
  }
});
BI.shortcut("bi.sql_editor", BI.SQLEditor);

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by Urthur on 2017/11/14.
 */
BI.FormulaFieldPane = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-formula-field-pane bi-card",
    items: [],
    itemsCreator: undefined,
    searcherHeight: 28,
    searcherGap: 8,
    itemHeight: 24,
    leafItemHeight: 24,
    fieldTreeHgap: 0,
    nodeGap: 0
  },
  _store: function _store() {
    return BI.Models.getModel("bi.model.material.formula_field_pane");
  },
  watch: {
    fieldKeyword: function fieldKeyword() {
      this._search();
    }
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.vtape",
      vgap: o.searcherGap,
      hgap: o.searcherGap,
      items: [{
        el: {
          type: "bi.vertical",
          items: [{
            type: "bi.search_editor",
            ref: function ref(_ref2) {
              self.search = _ref2;
            },
            height: o.searcherHeight,
            listeners: [{
              eventName: BI.SearchEditor.EVENT_CHANGE,
              action: BI.debounce(BI.bind(function () {
                self.store.setKeyword(self.search.getValue());
              }), BI.EVENT_RESPONSE_TIME)
            }, {
              eventName: BI.SearchEditor.EVENT_CLEAR,
              action: BI.debounce(BI.bind(function () {
                self.store.setKeyword(self.search.getValue());
              }), BI.EVENT_RESPONSE_TIME)
            }]
          }]
        },
        height: o.searcherHeight
      }, {
        el: {
          type: "bi.vertical",
          items: [{
            type: "bi.formula_fields_tree",
            items: o.items,
            itemsCreator: o.itemsCreator,
            itemHeight: o.itemHeight,
            leafItemHeight: o.leafItemHeight,
            nodeGap: o.nodeGap,
            redmark: function redmark() {
              return true;
            },
            ref: function ref(_ref) {
              self.fieldTree = _ref;
            },
            listeners: [{
              eventName: BI.FormulaFieldsTree.EVENT_CHANGE,
              action: function action() {
                self.fireEvent(BI.FormulaFieldPane.EVENT_CHANGE, this.getValue());
              }
            }]
          }]
        },
        hgap: o.fieldTreeHgap
      }]
    };
  },
  _search: function _search() {
    var self = this,
        o = this.options;
    var items = BI.map(o.items, function (index, item) {
      var res = BI.Func.getSearchResult(item, self.model.fieldKeyword, "text");
      return res.match.concat(res.find);
    });
    this.fieldTree.populate(items, this.model.fieldKeyword);
  },
  getAllLeaves: function getAllLeaves() {
    return this.fieldTree.getAllLeaves();
  },
  populate: function populate(items, keyword) {
    this.options.items = items;
    this.fieldTree.populate(items, keyword);
  }
});
BI.FormulaFieldPane.EVENT_SEARCH = "EVENT_SEARCH";
BI.FormulaFieldPane.EVENT_CHANGE = "EVENT_CHANGE";
BI.shortcut("bi.formula_field_pane", BI.FormulaFieldPane);

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Model = BI.inherit(Fix.Model, {
    context: ["fieldKeyword"],
    state: function state() {
      return {};
    },
    computed: {},
    actions: {
      setKeyword: function setKeyword(v) {
        this.model.fieldKeyword = v;
      }
    }
  });
  BI.model("bi.model.material.formula_field_pane", Model);
}();

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Item = BI.inherit(BI.BasicButton, {
  props: function props() {
    return {
      extraCls: "bi-list-item",
      id: "",
      pId: "",
      height: 24,
      hgap: 0,
      lgap: 0,
      rgap: 0
    };
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.label",
      ref: function ref(_ref) {
        self.text = _ref;
      },
      textAlign: "left",
      whiteSpace: "nowrap",
      textHeight: o.height,
      height: o.height,
      hgap: o.hgap,
      lgap: o.lgap,
      rgap: o.hgap,
      text: o.text,
      value: o.value,
      py: o.py,
      keyword: o.keyword
    };
  },
  doRedMark: function doRedMark() {
    this.text.doRedMark.apply(this.text, arguments);
  },
  unRedMark: function unRedMark() {
    this.text.unRedMark.apply(this.text, arguments);
  },
  doHighLight: function doHighLight() {
    this.text.doHighLight.apply(this.text, arguments);
  },
  unHighLight: function unHighLight() {
    this.text.unHighLight.apply(this.text, arguments);
  },
  getId: function getId() {
    return this.options.id;
  },
  getPId: function getPId() {
    return this.options.pId;
  }
});
BI.shortcut("bi.formula_fields_tree.item", Item);

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


BI.FormulaFieldsTree = BI.inherit(BI.Widget, {
  _const: {
    leafGap: 40
  },
  props: {
    baseCls: "bi-formula-field-tree",
    chooseType: 0,
    items: [],
    itemsCreator: undefined,
    redmark: BI.emptyFn,
    itemHeight: 24,
    leafItemHeight: 24,
    nodeGap: 0
  },
  render: function render() {
    var o = this.options,
        c = this._const,
        self = this;

    var nodes = this._formatItems(BI.deepClone(o.items));

    return {
      type: "bi.level_tree",
      element: this,
      chooseType: o.chooseType,
      expander: {
        isDefaultInit: true,
        showLine: false
      },
      items: nodes,
      el: {
        behaviors: {
          redmark: o.redmark
        }
      },
      ref: function ref(_ref) {
        self.fieldtree = _ref;
      },
      listeners: [{
        eventName: BI.LevelTree.EVENT_CHANGE,
        action: function action() {
          self.fireEvent(BI.FormulaFieldsTree.EVENT_CHANGE);
          self.fieldtree.setValue();
        }
      }]
    };
  },
  _getFieldNum: function _getFieldNum(map, fieldtype) {
    if (BI.isNotNull(map[fieldtype])) {
      return map[fieldtype].length;
    }

    return 0;
  },
  _formatItems: function _formatItems(items, openWhenNotEmpty) {
    var o = this.options,
        c = this._const,
        self = this;

    if (o.itemsCreator) {
      return o.itemsCreator(items, openWhenNotEmpty);
    }

    var map = {};
    BI.each(items, function (i, typeItem) {
      BI.each(BI.Func.getSortedResult(typeItem, "text"), function (i, item) {
        if (item.fieldType === BICst.COLUMN.CALCULATE) {
          item.fieldType = BICst.COLUMN.NUMBER;
        }

        if (!map[item.fieldType]) {
          map[item.fieldType] = [];
        }

        map[item.fieldType].push(item);
      });
    });
    var nodes = [{
      id: BICst.COLUMN.NUMBER,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-field-tree-number-node",
      text: BI.i18nText("BI-Conf_Formula_Numberic_Field") + "(" + self._getFieldNum(map, BICst.COLUMN.NUMBER) + ")",
      value: BICst.COLUMN.NUMBER,
      isParent: true,
      open:  true || (false)
    }];

    if (items.length > 1) {
      nodes.push({
        id: BICst.COLUMN.STRING,
        type: "bi.arrow_group_node",
        $testId: "bi-formula-field-tree-string-node",
        text: BI.i18nText("BI-Conf_Formula_Text_Field") + "(" + self._getFieldNum(map, BICst.COLUMN.STRING) + ")",
        value: BICst.COLUMN.STRING,
        isParent: true,
        open: (openWhenNotEmpty ? self._getFieldNum(map, BICst.COLUMN.STRING) > 0 : false) || false
      });
    }

    if (items.length > 2) {
      nodes.push({
        id: BICst.COLUMN.DATE,
        type: "bi.arrow_group_node",
        $testId: "bi-formula-field-tree-date-node",
        text: BI.i18nText("BI-Conf_Formula_Time_Field") + "(" + self._getFieldNum(map, BICst.COLUMN.DATE) + ")",
        value: BICst.COLUMN.DATE,
        isParent: true,
        open: (openWhenNotEmpty ? self._getFieldNum(map, BICst.COLUMN.DATE) > 0 : false) || false
      });
    }

    if (items.length > 3) {
      nodes.push({
        id: BICst.FORMULA_WIDGET_FIELD_TYPE.DATE,
        $testId: "bi-formula-field-tree-date-widget-node",
        type: "bi.arrow_group_node",
        text: BI.i18nText("BI-Design_Date_Widget_Field") + "(" + items[3].length + ")",
        value: BICst.FORMULA_WIDGET_FIELD_TYPE.DATE,
        isParent: true,
        open: (openWhenNotEmpty ? items[3].length > 0 : false) || false
      });
    }

    if (items.length > 4) {
      nodes.push({
        id: BICst.FORMULA_WIDGET_FIELD_TYPE.STRING,
        $testId: "bi-formula-field-tree-string-widget-node",
        type: "bi.arrow_group_node",
        text: BI.i18nText("BI-Design_String_Widget_Field") + "(" + items[4].length + ")",
        value: BICst.FORMULA_WIDGET_FIELD_TYPE.STRING,
        isParent: true,
        open: (openWhenNotEmpty ? items[4].length > 0 : false) || false
      });
    }

    if (items.length > 5) {
      nodes.push({
        id: BICst.FORMULA_WIDGET_FIELD_TYPE.NUMBER,
        $testId: "bi-formula-field-tree-number-widget-node",
        type: "bi.arrow_group_node",
        text: BI.i18nText("BI-Design_Number_Widget_Field") + "(" + items[5].length + ")",
        value: BICst.FORMULA_WIDGET_FIELD_TYPE.NUMBER,
        isParent: true,
        open: (openWhenNotEmpty ? items[5].length > 0 : false) || false
      });
    }

    BI.each(nodes, function (_idx, node) {
      BI.extend(node, {
        height: o.itemHeight,
        hgap: o.nodeGap,
        iconWrapperWidth: 24,
        expandIcon: 'tree-expander-expand-font',
        collapseIcon: 'tree-expander-collapse-font'
      });
    });
    BI.each(items, function (idx, typeItems) {
      BI.each(typeItems, function (i, item) {
        nodes.push(BI.extend({
          id: BI.UUID(),
          pId: item.fieldType
        }, item, {
          type: "bi.formula_fields_tree.item",
          $testId: "bi-formula-field-tree-field-item-" + item.text,
          cls: "field-item-draggable",
          textAlign: "left",
          lgap: c.leafGap,
          height: o.leafItemHeight
        }));
      });
    });
    return nodes;
  },
  populate: function populate(items, keyword) {
    var nodes = this._formatItems(BI.deepClone(items), BI.isNotNull(keyword) && BI.isNotEmptyString(keyword));

    this.fieldtree.populate(nodes, keyword);
  },
  getValue: function getValue() {
    return this.fieldtree.getValue();
  },
  setValue: function setValue(v) {
    this.fieldtree.setValue(v);
  },
  doBehavior: function doBehavior() {
    this.fieldtree.doBehavior.apply(this.fieldtree, arguments);
  },
  getNodeByValue: function getNodeByValue(v) {
    return this.fieldtree.getNodeByValue(v);
  },
  setTriggerExpand: function setTriggerExpand(v) {
    var node = this.fieldtree.getNodeById(v);

    if (BI.isNotNull(node)) {
      node.showView();
    }
  },
  setTriggerCollapse: function setTriggerCollapse(v) {
    var node = this.fieldtree.getNodeById(v);
    node.hideView();
  },
  expandAll: function expandAll() {
    var self = this;
    BI.each([BICst.COLUMN.NUMBER, BICst.COLUMN.STRING, BICst.COLUMN.DATE], function (i, id) {
      self.setTriggerExpand(id);
    });
  },
  getAllLeaves: function getAllLeaves() {
    return this.fieldtree.getAllLeaves();
  }
});
BI.FormulaFieldsTree.EVENT_CHANGE = "EVENT_CHANGE";
BI.shortcut("bi.formula_fields_tree", BI.FormulaFieldsTree);

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FunctionDescribe = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-formula-function-describe",
    open: false,
    expandable: true,
    defaultHyperLink: null
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.vertical_fill",
      rowSize: [36, o.expandable ? 164 : "fill"],
      cls: "bi-split-top formula-describe-pane",
      items: [{
        el: {
          type: "bi.basic_button",
          ref: function ref(_ref) {
            self.expanderTrigger = _ref;
          },
          selected: true,
          invisible: true,
          render: function render() {
            return {
              type: "bi.left_right_vertical_adapt",
              height: 36,
              items: {
                left: [{
                  type: "bi.label",
                  text: BI.i18nText("BI-Conf_Function_Description"),
                  cls: "more-function-button"
                }],
                right: [{
                  type: "bi.icon_change_button",
                  iconCls: "column-next-page-h-font",
                  width: 25,
                  invisible: !o.expandable,
                  ref: function ref(_ref) {
                    self.describeButton = _ref;
                  }
                }]
              },
              lhgap: 10,
              rhgap: 10
            };
          },
          handler: function handler() {
            if (o.expandable) {
              var selected = this.isSelected();

              if (selected) {
                self.describeButton.setIcon("column-next-page-h-font");
                self.describeGroup.setVisible(true);
              } else {
                self.describeButton.setIcon("column-pre-page-h-font");
                self.describeGroup.setVisible(false);
              }
            }
          }
        }
      }, {
        type: "bi.button_group",
        layouts: [{
          type: "bi.vertical",
          hgap: 20,
          vgap: 5
        }],
        ref: function ref(_ref) {
          self.describeGroup = _ref;
        },
        items: [{
          type: "bi.vertical",
          vgap: 10,
          items: [{
            type: "bi.text",
            whiteSpace: "normal",
            textAlign: "left",
            text: BI.i18nText("BI-Formula_Function_Tip1")
          }, {
            type: "bi.html_label",
            cls: "cm-s-default",
            whiteSpace: "normal",
            textAlign: "left",
            text: BI.i18nText("BI-Formula_Function_Tip2")
          }, o.defaultHyperLink ? {
            type: "bi.a",
            cls: "hyperlink-button",
            whiteSpace: "normal",
            textAlign: "left",
            text: BI.i18nText("BI-Formula_Help_Document"),
            href: o.defaultHyperLink
          } : null]
        }]
      }]
    };
  },
  populate: function populate(func) {
    this.expanderTrigger.setVisible(true);
    this.describeGroup.populate([BI.isFunction(func.description) ? func.description() : {
      type: "bi.vertical",
      bgap: 5,
      items: [{
        type: "bi.label",
        cls: "cm-strong",
        textAlign: "left",
        text: func.text + ":"
      }, {
        type: "bi.label",
        whiteSpace: "normal",
        textAlign: "left",
        text: func.description
      }, func.hyperlink ? {
        type: "bi.a",
        text: BI.i18nText("BI-Formula_Function_More_Example"),
        href: func.hyperlink
      } : null]
    }]);
  }
});
BI.shortcut("bi.formula_function_describe", FunctionDescribe);

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Item = BI.inherit(BI.BasicButton, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.TreeTextLeafItem.superclass._defaultConfig.apply(this, arguments), {
      extraCls: "bi-list-item-active2",
      id: "",
      pId: "",
      height: 24,
      hgap: 0,
      lgap: 0,
      rgap: 0,
      description: ""
    });
  },
  mounted: function mounted() {
    var _this = this;

    this.element.hover(function () {
      _this.fireEvent("EVENT_HOVER", _this.getValue());
    });
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.label",
      ref: function ref(_ref) {
        self.text = _ref;
      },
      cls: "draggable-handle",
      textAlign: "left",
      whiteSpace: "nowrap",
      height: o.height,
      hgap: o.hgap,
      lgap: o.lgap,
      rgap: o.hgap,
      text: o.text,
      value: o.value,
      py: o.py,
      keyword: o.keyword
    };
  },
  doRedMark: function doRedMark() {
    this.text.doRedMark.apply(this.text, arguments);
  },
  unRedMark: function unRedMark() {
    this.text.unRedMark.apply(this.text, arguments);
  },
  doHighLight: function doHighLight() {
    this.text.doHighLight.apply(this.text, arguments);
  },
  unHighLight: function unHighLight() {
    this.text.unHighLight.apply(this.text, arguments);
  },
  getId: function getId() {
    return this.options.id;
  },
  getPId: function getPId() {
    return this.options.pId;
  }
});
BI.shortcut("bi.formula_functions_tree.item", Item);

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by roy on 15/9/14.
 */
BI.FormulaFunctionsTree = BI.inherit(BI.Widget, {
  _const: {
    leafGap: 40
  },
  props: {
    baseCls: "bi-formula-function-tree bi-card",
    chooseType: 0,
    items: [],
    redmark: BI.emptyFn,
    itemHeight: 24,
    leafItemHeight: 24,
    nodeGap: 0
  },
  _store: function _store() {
    return BI.Models.getModel("bi.model.material.formula_functions_tree");
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.level_tree",
      expander: {
        isDefaultInit: true,
        showLine: false
      },
      items: this._getFormatNodes(o.items),
      el: {
        behaviors: {
          redmark: o.redmark
        }
      },
      ref: function ref() {
        self.fieldtree = this;
      },
      listeners: [{
        eventName: BI.LevelTree.EVENT_CHANGE,
        action: function action() {
          self.fireEvent(BI.FormulaFunctionsTree.EVENT_CHANGE, self._getSelectItem(self.getValue(), o.items));
          self.fieldtree.setValue(self.getValue());
        }
      }]
    };
  },
  _getFieldNum: function _getFieldNum(map, fieldtype) {
    if (BI.isNotNull(map[fieldtype])) {
      return map[fieldtype].length;
    }

    return 0;
  },
  _getFormatNodes: function _getFormatNodes(items, keyword) {
    var o = this.options,
        c = this._const,
        self = this;
    var map = {};
    BI.each(items, function (i, item) {
      if (!map[item.fieldType]) {
        map[item.fieldType] = [];
      }

      map[item.fieldType].push(item);
    });
    var isOpen = BI.isNotNull(keyword) && BI.isNotEmptyString(keyword);
    var templateNodes = [{
      id: BICst.FUNCTION.MATH,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-math-node",
      text: BI.i18nText("BI-Conf_Formula_Numberic_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.MATH) + ")",
      value: BICst.FUNCTION.MATH,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.TEXT,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-text-node",
      text: BI.i18nText("BI-Conf_Formula_Text_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.TEXT) + ")",
      value: BICst.FUNCTION.TEXT,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.DATE,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-date-node",
      text: BI.i18nText("BI-Conf_Formula_Time_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.DATE) + ")",
      value: BICst.FUNCTION.DATE,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.ARRAY,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-array-node",
      text: BI.i18nText("BI-Conf_Formula_Array_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.ARRAY) + ")",
      value: BICst.FUNCTION.ARRAY,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.LOGIC,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-logic-node",
      text: BI.i18nText("BI-Conf_Formula_Logic_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.LOGIC) + ")",
      value: BICst.FUNCTION.LOGIC,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.ANALYSIS,
      type: "bi.arrow_group_node",
      text: BI.i18nText("BI-Conf_Formula_Analysis") + "(" + self._getFieldNum(map, BICst.FUNCTION.ANALYSIS) + ")",
      value: BICst.FUNCTION.ANALYSIS,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.OTHER,
      $testId: "bi-formula-function-tree-other-node",
      type: "bi.arrow_group_node",
      text: BI.i18nText("BI-Conf_Formula_Other_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.OTHER) + ")",
      value: BICst.FUNCTION.OTHER,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.AGG,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-agg-node",
      text: BI.i18nText("BI-Design_Function_AGG") + "(" + self._getFieldNum(map, BICst.FUNCTION.AGG) + ")",
      value: BICst.FUNCTION.AGG,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.TABLE_CAL,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-table-cal-node",
      text: BI.i18nText("BI-Design_Rapid_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.TABLE_CAL) + ")",
      value: BICst.FUNCTION.TABLE_CAL,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.COMMON,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-common-node",
      text: BI.i18nText("BI-Basic_Common_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.COMMON) + ")",
      value: BICst.FUNCTION.COMMON,
      isParent: true,
      open: isOpen
    }, {
      id: BICst.FUNCTION.FIXED_CAL,
      type: "bi.arrow_group_node",
      $testId: "bi-formula-function-tree-fixed-cal-node",
      text: BI.i18nText("BI-Design_Fixed_Function") + "(" + self._getFieldNum(map, BICst.FUNCTION.FIXED_CAL) + ")",
      value: BICst.FUNCTION.FIXED_CAL,
      isParent: true,
      open: isOpen
    }];
    var nodes = BI.filter(templateNodes, function (index, node) {
      BI.extend(node, {
        height: o.itemHeight,
        hgap: o.nodeGap,
        iconWrapperWidth: 24,
        expandIcon: 'tree-expander-expand-font',
        collapseIcon: 'tree-expander-collapse-font'
      });
      return BI.contains(self.model.availableFunctionValues, node.value);
    });
    nodes.sort(function (a, b) {
      var indexA = BI.indexOf(self.model.availableFunctionValues, a.value);
      var indexB = BI.indexOf(self.model.availableFunctionValues, b.value);
      return indexA - indexB;
    });
    BI.first(nodes).open = true;
    BI.each(items, function (i, item) {
      nodes.push(BI.extend({
        id: BI.UUID(),
        pId: item.fieldType
      }, item, {
        type: "bi.formula_functions_tree.item",
        $testId: "bi-formula-function-tree-item-" + BI.toLowerCase(item.text),
        cls: "function-item-draggable",
        textAlign: "left",
        lgap: c.leafGap,
        height: o.leafItemHeight,
        listeners: [{
          eventName: "EVENT_HOVER",
          action: function action() {
            self.fieldtree.setValue(item.value);
            self.fireEvent(BI.FormulaFunctionsTree.EVENT_HOVER, self._getSelectItem([item.value], o.items));
          }
        }]
      }));
    });
    return nodes;
  },
  populate: function populate(items, keyword) {
    var o = this.options;
    o.items = items;
    this.fieldtree.populate(this._getFormatNodes(items, keyword), keyword);
  },
  getValue: function getValue() {
    return this.fieldtree.getValue();
  },
  setValue: function setValue(v) {
    this.fieldtree.setValue(v);
  },
  doBehavior: function doBehavior() {
    this.fieldtree.doBehavior.apply(this.fieldtree, arguments);
  },
  getNodeByValue: function getNodeByValue(v) {
    return this.fieldtree.getNodeByValue(v);
  },
  setTriggerExpand: function setTriggerExpand(v) {
    var node = this.fieldtree.getNodeById(v);

    if (BI.isNotNull(node)) {
      node.showView();
    }
  },
  setTriggerCollapse: function setTriggerCollapse(v) {
    var node = this.fieldtree.getNodeById(v);
    node.hideView();
  },
  expandAll: function expandAll() {
    var self = this;
    BI.each([BICst.FUNCTION.MATH, BICst.FUNCTION.ARRAY, BICst.FUNCTION.DATE, BICst.FUNCTION.LOGIC, BICst.FUNCTION.ANALYSIS, BICst.FUNCTION.OTHER, BICst.FUNCTION.TEXT, BICst.FUNCTION.COMMON, BICst.FUNCTION.AGG, BICst.FUNCTION.FIXED_CAL], function (i, id) {
      self.setTriggerExpand(id);
    });
  },
  _getSelectItem: function _getSelectItem(v, items) {
    return BI.find(items, function (i, item) {
      return item.value === v[0];
    });
  },
  getAllLeaves: function getAllLeaves() {
    return this.fieldtree.getAllLeaves();
  }
});
BI.FormulaFunctionsTree.EVENT_CHANGE = "EVENT_CHANGE";
BI.FormulaFunctionsTree.EVENT_HOVER = "EVENT_HOVER";
BI.shortcut("bi.formula_functions_tree", BI.FormulaFunctionsTree);

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Model = BI.inherit(Fix.Model, {
    context: ["functionTypes"],
    computed: {
      availableFunctionValues: function availableFunctionValues() {
        var service = BI.Services.getService("bi.service.material.formula_insert");
        return BI.map(this.model.functionTypes, function (index, type) {
          return service.getFunctionValueByType(type);
        });
      }
    }
  });
  BI.model("bi.model.material.formula_functions_tree", Model);
}();

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by roy on 15/9/14.
 */
BI.FormulaFunctionPane = BI.inherit(BI.Widget, {
  props: {
    baseCls: "bi-formula-function-pane bi-card",
    items: [],
    searcherHeight: 24,
    searcherGap: 10,
    functionTreeHgap: 0,
    itemHeight: 24,
    leafItemHeight: 24,
    nodeGap: 0
  },
  _store: function _store() {
    return BI.Models.getModel("bi.model.material.formula_function_pane");
  },
  watch: {
    functionKeyword: function functionKeyword(_functionKeyword) {
      var o = this.options;

      var keyword = _functionKeyword.toLowerCase();

      var resultArray = [];
      BI.each(o.items, function (i, item) {
        if (item.value.toLowerCase().indexOf(keyword) > -1 || BI.isEmptyString(keyword)) {
          resultArray.push(item);
        }
      });
      this.functionTree.populate(resultArray, keyword);
      this.fireEvent(BI.FormulaFunctionPane.EVENT_SEARCH);
    }
  },
  render: function render() {
    var self = this,
        o = this.options;
    return {
      type: "bi.htape",
      items: [{
        el: {
          type: "bi.vtape",
          cls: "bi-split-left",
          vgap: o.searcherGap,
          hgap: o.searcherGap,
          items: [{
            el: {
              type: "bi.vertical",
              items: [{
                type: "bi.search_editor",
                height: o.searcherHeight,
                listeners: [{
                  eventName: BI.SearchEditor.EVENT_CHANGE,
                  action: function action() {
                    self.store.setKeyword(this.getValue());
                  }
                }, {
                  eventName: BI.SearchEditor.EVENT_CLEAR,
                  action: function action() {
                    self.store.setKeyword(this.getValue());
                  }
                }]
              }]
            },
            height: o.searcherHeight
          }, {
            el: {
              type: "bi.vertical",
              items: [{
                type: "bi.formula_functions_tree",
                cls: "style-top",
                items: o.items,
                itemHeight: o.itemHeight,
                leafItemHeight: o.leafItemHeight,
                nodeGap: o.nodeGap,
                ref: function ref(_ref) {
                  self.functionTree = _ref;
                },
                redmark: function redmark() {
                  return true;
                },
                listeners: [{
                  eventName: BI.FormulaFunctionsTree.EVENT_CHANGE,
                  action: function action(v) {
                    self.fireEvent(BI.FormulaFunctionPane.EVENT_INSET, v);
                  }
                }, {
                  eventName: BI.FormulaFunctionsTree.EVENT_HOVER,
                  action: function action(v) {
                    self.fireEvent(BI.FormulaFunctionPane.EVENT_HOVER, v);
                  }
                }]
              }]
            },
            hgap: o.functionTreeHgap
          }]
        }
      }]
    };
  },
  getAllLeaves: function getAllLeaves() {
    return this.functionTree.getAllLeaves();
  },
  setValue: function setValue(v) {
    this.functionTree.setValue(v);
  }
});
BI.FormulaFunctionPane.EVENT_INSET = "EVENT_INSET";
BI.FormulaFunctionPane.EVENT_HOVER = "EVENT_HOVER";
BI.FormulaFunctionPane.EVENT_CLOSE = "EVENT_CLOSE";
BI.FormulaFunctionPane.EVENT_SEARCH = "EVENT_SEARCH";
BI.shortcut("bi.formula_function_pane", BI.FormulaFunctionPane);

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Model = BI.inherit(Fix.Model, {
    context: ["functionKeyword"],
    state: function state() {
      return {};
    },
    computed: {},
    actions: {
      setKeyword: function setKeyword(v) {
        this.model.functionKeyword = v;
      }
    }
  });
  BI.model("bi.model.material.formula_function_pane", Model);
}();

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Created by roy on 15/9/29.
 */
!function () {
  var SymbolGroup = BI.inherit(BI.Widget, {
    constants: {
      hgap: 7.5,
      textWidth: 14,
      textHeight: 17,
      enableSwitcher: false
    },
    _defaultConfig: function _defaultConfig() {
      return BI.extend(SymbolGroup.superclass._defaultConfig.apply(this, arguments), {
        baseCls: "bi-formula-symbol-group",
        fieldType: BICst.FORMULA_GENERATE_TYPE.AUTO,
        itemHeight: 24
      });
    },
    render: function render() {
      var self = this,
          c = this.constants,
          o = this.options;
      var items = [{
        cls: "operator-plus-font",
        $testId: "bi-formula-symbol-group-plus",
        value: "+"
      }, {
        cls: "operator-minus-font",
        $testId: "bi-formula-symbol-group-minus",
        value: "-"
      }, {
        cls: "operator-multi-font",
        $testId: "bi-formula-symbol-group-mul",
        value: "*"
      }, {
        cls: "operator-divide-font",
        $testId: "bi-formula-symbol-group-div",
        value: "/"
      }, {
        cls: "operator-left-brackets-font",
        $testId: "bi-formula-symbol-group-left-brackets",
        value: "("
      }, {
        cls: "operator-right-brackets-font",
        $testId: "bi-formula-symbol-group-right-brackets",
        value: ")"
      }];
      var layoutItems = {
        left: [{
          type: "bi.button_group",
          chooseType: -1,
          items: BI.createItems(items, {
            type: "bi.icon_button",
            forceNotSelected: true,
            once: false,
            textWidth: c.textWidth,
            textHeight: c.textHeight,
            cls: "symbol-button bi-list-item"
          }),
          layouts: [{
            type: "bi.vertical_adapt",
            lgap: 15
          }],
          listeners: [{
            eventName: BI.ButtonGroup.EVENT_CHANGE,
            action: function action(v) {
              self.fireEvent("EVENT_CHANGE", v);
            }
          }],
          ref: function ref(_ref) {
            self.symbolgroup = _ref;
          }
        }]
      };

      if (this.options.enableSwitcher === true) {
        layoutItems.right = [{
          el: {
            type: "bi.label",
            text: BI.i18nText("BI-Basic_Field_Type")
          },
          rgap: 10
        }, {
          el: {
            type: "bi.icon_combo",
            cls: "bi-list-item",
            items: [{
              iconCls: "formula-auto-font",
              text: BI.i18nText("BI-Basic_Auto"),
              $testId: "bi-formula-symbol-group-auto",
              value: BICst.FORMULA_GENERATE_TYPE.AUTO,
              height: o.itemHeight
            }, {
              iconCls: "string-field-font",
              $testId: "bi-formula-symbol-group-string",
              text: BI.i18nText("BI-Basic_Text"),
              value: BICst.FORMULA_GENERATE_TYPE.STRING,
              height: o.itemHeight
            }, {
              iconCls: "number-field-font",
              $testId: "bi-formula-symbol-group-number",
              text: BI.i18nText("BI-Basic_Number"),
              value: BICst.FORMULA_GENERATE_TYPE.NUMBER,
              height: o.itemHeight
            }, {
              iconCls: "date-field-font",
              $testId: "bi-formula-symbol-group-date",
              text: BI.i18nText("BI-Basic_Time"),
              value: BICst.FORMULA_GENERATE_TYPE.DATE,
              height: o.itemHeight
            }],
            value: this.options.fieldType,
            ref: function ref(_ref) {
              self.iconCombo = _ref;
            },
            listeners: [{
              eventName: BI.IconCombo.EVENT_CHANGE,
              action: function action() {
                self.fireEvent("EVENT_TYPE_CHANGE");
              }
            }]
          },
          rgap: 5
        }];
      }

      return {
        type: "bi.left_right_vertical_adapt",
        llgap: 5,
        items: layoutItems
      };
    },
    getValue: function getValue() {
      if (BI.isNotNull(this.iconCombo)) {
        return this.iconCombo.getValue();
      }
    },
    setValue: function setValue(v) {
      if (BI.isNotNull(this.iconCombo)) {
        this.iconCombo.setValue(v || BICst.FORMULA_GENERATE_TYPE.AUTO);
      }
    }
  });
  BI.shortcut("bi.symbol_group", SymbolGroup);
}();

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


BI.FormulaInsert = BI.inherit(BI.Widget, {
  constants: {
    height: 30,
    width: 160,
    right: 10,
    button_bottom: 7,
    pane_bottom: -1,
    MORE_FUNCTION: 0,
    RETRACT: 1,
    retract_width: 30,
    more_width: 200,
    function_pane_width: 180,
    field_pane_width: 220,
    describe_height: 200,
    describe_retract_height: 36,
    enableSwitcher: false,
    abandonFunctions: [],
    functionRegex: /\w+/
  },
  props: function props() {
    return {
      baseCls: "bi-formula-insert",
      fieldItems: [],
      fieldItemsCreator: undefined,
      errorFieldItems: [],
      functionTypes: ["COMMON", "MATH", "DATETIME", "ARRAY", "TEXT", "LOGIC", "OTHER"],
      validationChecker: function validationChecker() {
        return BICst.FORMULA_STATE.VALID;
      },
      keywordsGetter: function keywordsGetter() {
        return BI.FormulaCollections;
      },
      formulaJSONGetter: function formulaJSONGetter() {
        return BI.FormulaJSONs;
      },
      checkFormulaValidation: BI.Func.checkFormulaValidation,
      searcherHeight: 24,
      searcherGap: 10,
      functionTreeHgap: 0,
      fieldTreeHgap: 0,
      itemHeight: 24,
      nodeGap: 0,
      functionPaneOpened: false,
      autoCheck: true,
      direction: "horizontal",
      watermark: BI.i18nText("BI-Conf_Formula_Water_Mark")
    };
  },
  _store: function _store() {
    return BI.Models.getModel("bi.model.material.formula_insert", {
      fieldItems: this.options.fieldItems,
      functionTypes: this.options.functionTypes,
      formulaJSONGetter: this.options.formulaJSONGetter
    });
  },
  render: function render() {
    var self = this,
        o = this.options,
        c = this.constants;
    self.validation = BICst.FORMULA_STATE.VALID;
    BI.FormulaCollections = BI.filter(BI.FormulaOriginCollections, function (index, name) {
      return BI.contains(self.model.availableFunctions, name.toUpperCase());
    });
    this.fieldPane = BI.createWidget({
      type: "bi.formula_field_pane",
      cls: "bi-formula-field-pane",
      items: o.fieldItems,
      itemsCreator: o.fieldItemsCreator,
      searcherGap: o.searcherGap,
      searcherHeight: o.searcherHeight,
      fieldTreeHgap: o.fieldTreeHgap,
      itemHeight: o.itemHeight,
      leafItemHeight: o.leafItemHeight || o.itemHeight,
      nodeGap: o.nodeGap,
      width: c.field_pane_width,
      listeners: [{
        eventName: BI.FormulaFieldPane.EVENT_CHANGE,
        action: function action(v) {
          self.store.insertField(v[0]);
          self.formulaedit.insertField(v[0], true);
        }
      }, {
        eventName: BI.FormulaFieldPane.EVENT_SEARCH,
        action: function action() {
          self._bindFieldDragEvent();
        }
      }]
    });
    this.symbolgroup = BI.createWidget({
      type: "bi.symbol_group",
      height: c.height,
      enableSwitcher: o.enableSwitcher,
      fieldType: o.fieldType,
      itemHeight: o.itemHeight,
      cls: "symbol-group-column",
      listeners: [{
        eventName: "EVENT_CHANGE",
        action: function action(v) {
          self.store.insertOperator(v);
          self.formulaedit.insertOperator(v);
        }
      }, {
        eventName: "EVENT_TYPE_CHANGE",
        action: function action() {
          self.fireEvent(BI.FormulaInsert.EVENT_TYPE_CHANGE);
        }
      }]
    });
    this.formulaedit = BI.createWidget({
      type: "bi.formula_editor",
      $testId: "bi-formula-editor",
      cls: "bi-split-top",
      tipType: "warning",
      paramFormatter: BI.bind(this._paramFormatter, this),
      valueGetter: BI.bind(this._valueGetter, this),
      formulaChecker: o.formulaChecker,
      paramTypeGetter: function paramTypeGetter(id) {
        var info = self.fieldsDetailMap[id] || {};

        switch (info.type) {
          case BICst.COLUMN.DATE:
            return 'date';

          case BICst.COLUMN.NUMBER:
            return 'number';

          case BICst.COLUMN.STRING:
            return "string";

          default:
            return info.type;
        }
      },
      keywordsGetter: function keywordsGetter() {
        var keywords = o.keywordsGetter();
        return keywords.concat(BI.map(BI.flatten(self._getSortedResult(o.fieldItems)), function (idx, field) {
          return {
            iconCls: self._getIconCls(field),
            text: field.text,
            value: field.value,
            type: BICst.FORMULA_KEYWORD_TYPE.PARAM
          };
        }));
      },
      watermark: o.watermark,
      listeners: [{
        eventName: BI.FormulaEditor.EVENT_CHANGE,
        action: function action() {
          self._checkValidation();
        }
      }, {
        eventName: BI.FormulaEditor.EVENT_BLUR,
        action: function action() {
          self.hideTip();

          if (!self.checkValidation()) {
            self.formulaedit.setTitle(self.formulaedit.getTip() || self.getErrorText() || BI.i18nText("BI-Basic_Formula_Invalid"), {
              belowMouse: true
            });
            self.showTip();
          }
        }
      }, {
        eventName: BI.FormulaEditor.EVENT_FOCUS,
        action: function action() {
          self.formulaedit.setTitle("");

          if (!self.checkValidation()) {
            self.showTip();
          }
        }
      }, {
        eventName: BI.FormulaEditor.EVENT_KEY_UP,
        action: function action(key) {
          self.store.inputOperator(key);
        }
      }, {
        eventName: BI.FormulaEditor.EVENT_CURSOR_ACTIVITY,
        action: function action(cm) {
          //  点击公式中函数名显示函数释义,识别光标位置为函数名与函数左括号
          var cur = cm.getCursor();
          var token = cm.getTokenAt(cur);
          var str = "";

          if (token.type === "keyword") {
            str = token.string;
          } else if (token.type === "bracket" && token.string === "(") {
            var tokens = cm.getLineTokens(cur.line);
            BI.some(tokens, function (i, t) {
              if (t.end === cur.ch - 1) {
                str = t.string;
              }
            });
          }

          var v = self._getFunction(str);

          if (BI.isNotNull(v)) {
            self.describePane.setVisible(true);
            self.describePane.populate(v);
            self.functionpane.setValue(v.value);
          }
        }
      }, {
        eventName: "EVENT_SELECT_HINT",
        action: function action(comp) {// nothing
        }
      }, {
        eventName: "EVENT_PICK_HINT",
        action: function action(comp) {
          var v = self._getFunction(comp.value);

          if (BI.isNotNull(v)) {
            self.describePane.setVisible(true);
            self.describePane.populate(v);
            self.functionpane.setValue(v.value);
          }
        }
      }]
    });
    this.describePane = BI.createWidget({
      type: "bi.formula_function_describe",
      cls: "bi-split-top formula-describe-pane",
      expandable: o.direction === "horizontal",
      invisible: o.direction === "horizontal",
      defaultHyperLink: o.defaultHyperLink
    });
    this.functionbutton = BI.createWidget({
      type: "bi.node_button",
      open: o.functionPaneOpened,
      render: function render() {
        return {
          type: "bi.vertical",
          width: c.retract_width,
          cls: "bi-background",
          items: [{
            type: "bi.icon_change_button",
            ref: function ref(_ref) {
              self.functionTriggerBtn = _ref;
            },
            iconCls: o.functionPaneOpened ? "formula-collapse" : "formula-expand",
            cls: "more-function-button",
            height: 30
          }, {
            type: "bi.label",
            textWidth: 13,
            textHeight: 18,
            whiteSpace: "normal",
            text: BI.i18nText("BI-Basic_Function")
          }]
        };
      },
      handler: function handler() {
        this.isOpened() ? self._closeFunctionPane() : self._openFunctionPane();
      }
    });
    this.functionpane = BI.createWidget({
      type: "bi.formula_function_pane",
      items: self.model.functionItems,
      searcherHeight: o.searcherHeight,
      searcherGap: o.searcherGap,
      functionTreeHgap: o.functionTreeHgap,
      itemHeight: o.itemHeight,
      leafItemHeight: o.leafItemHeight || o.itemHeight,
      nodeGap: o.nodeGap,
      width: c.function_pane_width,
      invisible: o.direction === "horizontal" ? !o.functionPaneOpened : false,
      listeners: [{
        eventName: BI.FormulaFunctionPane.EVENT_INSET,
        action: function action(v) {
          var functionName = v.text;

          if (BI.isNotEmptyString(functionName)) {
            self.store.insertFunction(functionName);
            self.formulaedit.insertFunction(functionName);
          }
        }
      }, {
        eventName: BI.FormulaFunctionPane.EVENT_SEARCH,
        action: function action() {
          self._bindFunctionDragEvent();
        }
      }, {
        eventName: BI.FormulaFunctionPane.EVENT_HOVER,
        action: function action(v) {
          var functionName = v.text;

          if (BI.isNotEmptyString(functionName)) {
            self.describePane.setVisible(true);
            self.describePane.populate(v);
          }
        }
      }]
    });
    this.formulaedit.element.droppable({
      accept: ".field-item-draggable,.function-item-draggable",
      drop: function drop(event, ui) {
        var fieldId = ui.helper.attr("fieldId"),
            func = ui.helper.attr("func");

        if (BI.isNotNull(fieldId)) {
          self.store.insertDragField(fieldId, true);
          self.formulaedit.insertField(fieldId, true);
        }

        if (BI.isNotNull(func)) {
          self.store.insertDragFunction(func);
          self.formulaedit.insertFunction(func);
        }
      }
    });

    this._bindFunctionDragEvent();

    this.populate(o.fieldItems);

    if (o.direction === "vertical") {
      return {
        type: "bi.vertical_fill",
        rowSize: [0.5, "fill"],
        items: [{
          el: {
            type: "bi.vertical_fill",
            rowSize: ["", "fill"],
            horizontalAlign: "stretch",
            items: [{
              el: this.symbolgroup
            }, {
              el: this.formulaedit
            }]
          }
        }, {
          el: {
            type: "bi.horizontal_fill",
            columnSize: [0.5, 0.5],
            items: [{
              type: "bi.horizontal_fill",
              columnSize: [0.6, 0.4],
              cls: "bi-split-top bi-split-right",
              items: [{
                el: this.fieldPane
              }, {
                el: this.functionpane
              }]
            }, {
              el: this.describePane
            }]
          }
        }],
        ref: function ref(_ref) {
          self.formulaPane = _ref;
        }
      };
    }

    return {
      type: "bi.horizontal_fill",
      columnSize: ["", "fill"],
      items: [{
        el: {
          type: "bi.horizontal_fill",
          cls: "bi-split-right",
          items: [{
            el: this.functionbutton
          }, {
            el: this.functionpane
          }]
        }
      }, {
        el: {
          type: "bi.horizontal_fill",
          columnSize: ["", "fill"],
          items: [{
            el: this.fieldPane
          }, {
            type: "bi.vertical_fill",
            rowSize: ["", "fill", ""],
            cls: "bi-split-left",
            items: [{
              el: this.symbolgroup
            }, {
              el: this.formulaedit
            }, {
              el: this.describePane
            }]
          }]
        }
      }],
      ref: function ref(_ref) {
        self.formulaPane = _ref;
      }
    };
  },
  mounted: function mounted() {
    var o = this.options;

    if (BI.isNotNull(o.value)) {
      this.setValue(o.value);
    }
  },
  _getSortedResult: function _getSortedResult(fieldItems) {
    return BI.map(fieldItems, function (i, itemArray) {
      return BI.Func.getSortedResult(itemArray, "text");
    });
  },
  _getIconCls: function _getIconCls(field) {
    if (field.iconCls) {
      return field.iconCls;
    }

    var iconCls;

    switch (field.fieldType) {
      case BICst.COLUMN.STRING:
        iconCls = 'string-field-font';
        break;

      case BICst.COLUMN.NUMBER:
        iconCls = 'number-field-font';
        break;

      case BICst.COLUMN.DATE:
        iconCls = 'date-field-font';
        break;

      default:
        break;
    }

    return iconCls;
  },
  _paramFormatter: function _paramFormatter(fieldId) {
    if (BI.has(this.fieldErrorValueTextMap, fieldId)) {
      return "<!" + this.fieldErrorValueTextMap[fieldId] + "!>";
    }

    return this.fieldValueTextMap[fieldId];
  },
  _valueGetter: function _valueGetter(text) {
    return this.fieldErrorTextValueMap[text] || this.fieldTextValueMap[text];
  },
  _getFunctionItems: function _getFunctionItems(v) {
    var self = this,
        c = this.constants,
        result = this._analyzeContent(v.replaceAll(/[\'\"](.+?)[\'\"]/g, "") || "") || [];
    this.functionArray = [];
    BI.each(result.reverse(), function (i, str) {
      var func = self._getFunction(str);

      if (BI.isNotEmptyObject(func) && !BI.some(self.functionArray, function (j, item) {
        var text = item.text.toLowerCase();
        var lowerString = str.toLowerCase();
        return text === lowerString;
      })) {
        self.functionArray.push(func);
      }
    });
    var items = [];
    BI.each(this.functionArray, function (index, valueObj) {
      var item = BI.createWidget({
        type: "bi.vertical",
        items: [{
          type: "bi.label",
          cls: "cm-strong",
          textAlign: "left",
          text: valueObj.text + ":"
        }, {
          type: "bi.label",
          whiteSpace: "normal",
          textAlign: "left",
          text: valueObj.description
        }]
      });
      items.push(item);
    });
    this.describePane.populate(items.slice(0, 1));

    if (BI.isEmptyArray(items)) {
      this.describePane.setVisible(false);
    } else {
      if (!this.describePane.isVisible()) {
        this.describePane.setVisible(true);
      }
    }
  },
  _reHsize: function _reHsize(size) {
    this.formulaPane.options.items[0].width = size;
    this.formulaPane.resize();
  },
  _getFunction: function _getFunction(str) {
    return BI.find(this.model.functionItems, function (i, item) {
      // BI-93848 如果带匹配列表中有直接相同的，匹配上
      if (item.text === str) {
        return true;
      }

      var text = item.text.toLowerCase();
      var lowerString = str.toLowerCase(); //BI-51959 非直接相等的函数名不允许function字符串大小写混写

      var upperString = str.toUpperCase();
      var notMixedString = upperString === str || lowerString === str;
      return text === lowerString && notMixedString;
    });
  },
  _checkValidation: function _checkValidation() {
    var self = this,
        o = this.options;
    var str = self.formulaedit.getCheckString();
    var formula = self.getValue();
    var usedFields = self.getUsedFields();
    var allInvalidIds = BI.map(o.errorFieldItems, "value");
    var isAllFieldNotInErrorFields = !BI.some(usedFields, function (index, fId) {
      return BI.contains(allInvalidIds, fId);
    });
    var isAllFieldValid = isAllFieldNotInErrorFields;

    if (isAllFieldNotInErrorFields) {
      var allValidIds = BI.map(BI.flatten(o.fieldItems), "value");
      isAllFieldValid = !BI.some(usedFields, function (index, fId) {
        return !BI.contains(allValidIds, fId);
      });
    }

    if (!isAllFieldValid) {
      self.validation = BICst.FORMULA_STATE.FIELD_MISS;
      self.showTip();
      self.fireEvent(BI.FormulaInsert.EVENT_ERROR);
    } else {
      var checkId = BI.UUID();
      self.store.setLastCheckId(checkId);
      var checkResult = this.formulaedit.check(formula);

      if (o.autoCheck && BI.isNotNull(checkResult)) {
        var errorInfo = JSON.parse(checkResult.message);

        this._dealCheckResult(checkId, formula, false, {
          errorCode: [],
          errorMessage: [errorInfo.errorText]
        }, {
          usedFields: usedFields
        });
      } else if (o.checkFormulaValidation) {
        o.checkFormulaValidation({
          str: str,
          origin: formula,
          fieldsMap: this.fieldsDetailMap
        }, function (valid, response) {
          self._dealCheckResult(checkId, formula, valid, response, {
            usedFields: usedFields
          });
        });
      } else {
        self._dealCheckResult(checkId, formula, true, {}, {
          usedFields: usedFields
        });
      }
    }
  },
  _dealCheckResult: function _dealCheckResult(checkId, formula, valid, response, opt) {
    opt = opt || {};
    response = response || {};
    this.errorMessage = [];
    if (checkId !== this.model.lastCheckId) return;
    var validState,
        errorCode = response.errorCode,
        errorMessage = response.errorMessage;

    if (valid) {
      validState = this.options.validationChecker(opt.usedFields, formula, response);
    } else {
      this.errorMessage = errorMessage;

      if (BI.contains(errorCode, BICst.ErrorCode.FORMULA_ERROR.DIS_AGGRESSIVE_FUNCTION_HAS_FIELD_WITH_DETAIL_FILTER)) {
        validState = BICst.FORMULA_STATE.DETAIL_FILTER_NOT_SUPPORT;
      }
    }

    if (BI.isNull(validState)) {
      validState = valid ? BICst.FORMULA_STATE.VALID : BICst.FORMULA_STATE.INVALID;
    }

    var validation = validState === BICst.FORMULA_STATE.VALID;

    if (validation) {
      this.validation = BICst.FORMULA_STATE.VALID;
      this.hideTip();
      this.fireEvent(BI.FormulaInsert.EVENT_CHANGE);
      this.fireEvent(BI.FormulaInsert.EVENT_VALID);
    } else {
      this.validation = validState;
      this.showTip();
      this.fireEvent(BI.FormulaInsert.EVENT_ERROR);
    }
  },
  _analyzeContent: function _analyzeContent(v) {
    // \w*\w 这是干啥呢, 至少匹配一次\w ? 那可以用\w+
    var regx = /\$[\{][^\}]*[\}]|\w+(\.\w+)*|\$\{[^\$\(\)\+\-\*\/)\$,]*\w\}|\$\{[^\$\(\)\+\-\*\/]*\w\}|\$\{[^\$\(\)\+\-\*\/]*[\u4e00-\u9fa5]\}|\w|(.)|\n/g;
    return v.match(regx);
  },
  _createFieldTextValueMap: function _createFieldTextValueMap(fieldItems) {
    var fieldMap = {};
    BI.each(fieldItems, function (idx, typeItems) {
      BI.each(typeItems, function (i, fieldItem) {
        fieldMap[fieldItem.text] = fieldItem.value;
      });
    });
    return fieldMap;
  },
  _createErrorTextValueMap: function _createErrorTextValueMap() {
    var fieldMap = {};
    BI.each(this.options.errorFieldItems, function (idx, fieldItem) {
      fieldMap[fieldItem.text] = fieldItem.value;
    });
    return fieldMap;
  },
  _createErrorValueTextMap: function _createErrorValueTextMap() {
    var fieldMap = {};
    BI.each(this.options.errorFieldItems, function (idx, fieldItem) {
      fieldMap[fieldItem.value] = fieldItem.text;
    });
    return fieldMap;
  },
  _createFieldValueTextMap: function _createFieldValueTextMap(fieldItems) {
    var fieldMap = {};
    BI.each(fieldItems, function (idx, typeItems) {
      BI.each(typeItems, function (i, fieldItem) {
        fieldMap[fieldItem.value] = fieldItem.text;
      });
    });
    return fieldMap;
  },
  _createFieldDetailMap: function _createFieldDetailMap(fieldItems) {
    var fieldMap = {};
    BI.each(fieldItems, function (idx, typeItems) {
      BI.each(typeItems, function (i, fieldItem) {
        var fType = fieldItem.fieldType;

        switch (fType) {
          case BICst.FORMULA_WIDGET_FIELD_TYPE.DATE:
            fType = BICst.COLUMN.DATE;
            break;

          case BICst.FORMULA_WIDGET_FIELD_TYPE.STRING:
            fType = BICst.COLUMN.STRING;
            break;

          case BICst.FORMULA_WIDGET_FIELD_TYPE.NUMBER:
          case BICst.COLUMN.CALCULATE:
            fType = BICst.COLUMN.NUMBER;
            break;

          default:
        }

        fieldMap[fieldItem.value] = {
          type: fType,
          isAgg: fieldItem.isAgg || false,
          hasDetailFilter: fieldItem.hasDetailFilter || false,
          freeAggregate: fieldItem.freeAggregate || false
        };
      });
    });
    return fieldMap;
  },
  _bindFieldDragEvent: function _bindFieldDragEvent() {
    var self = this;
    BI.each(self.fieldPane.getAllLeaves(), function (i, node) {
      node.element.draggable({
        cursorAt: {
          top: 5,
          left: 5
        },
        helper: function helper() {
          var hint = BI.createWidget({
            type: "bi.helper",
            value: node.getValue(),
            text: self.fieldValueTextMap[node.getValue()]
          });
          BI.createWidget({
            element: self,
            type: "bi.default",
            items: [hint]
          });
          hint.element.attr({
            fieldId: node.getValue(),
            field: self.fieldValueTextMap[node.getValue()]
          });
          return hint.element;
        }
      });
    });
  },
  _bindFunctionDragEvent: function _bindFunctionDragEvent() {
    var self = this;
    BI.each(self.functionpane.getAllLeaves(), function (i, node) {
      node.element.draggable({
        cursorAt: {
          top: 5,
          left: 5
        },
        handle: ".draggable-handle",
        helper: function helper() {
          var hint = BI.createWidget({
            type: "bi.helper",
            value: node.getValue(),
            text: node.getValue()
          });
          BI.createWidget({
            element: self,
            type: "bi.default",
            items: [hint]
          });
          hint.element.attr({
            func: node.getValue()
          });
          return hint.element;
        }
      });
    });
  },
  _openFunctionPane: function _openFunctionPane() {
    this.functionTriggerBtn.setIcon("formula-collapse");
    this.functionpane.setVisible(true);
  },
  _closeFunctionPane: function _closeFunctionPane() {
    this.functionTriggerBtn.setIcon("formula-expand");
    this.functionpane.setVisible(false);
  },
  checkValidation: function checkValidation() {
    return this.validation === BICst.FORMULA_STATE.VALID;
  },
  getErrorText: function getErrorText() {
    if (BI.isEmptyString(this.getValue())) {
      return BI.i18nText("BI-Basic_Please_Add_Formula");
    }

    if (BI.isNotEmptyArray(this.errorMessage)) {
      return this.errorMessage.join("\n");
    }

    var errorText = "";

    switch (this.validation) {
      case BICst.FORMULA_STATE.DETAIL_FILTER_NOT_SUPPORT:
        errorText = BI.i18nText("BI-Design_Formula_Not_Support_Detail_Filter");
        break;

      case BICst.FORMULA_STATE.AGG_INVALID:
        errorText = BI.i18nText("BI-Design_Detail_Table_Not_Support_AGG");
        break;

      case BICst.FORMULA_STATE.FIXED_INVALID:
        errorText = BI.i18nText("BI-Design_Detail_Table_Not_Support_Fixed");
        break;

      case BICst.FORMULA_STATE.FIELD_MISS:
        errorText = BI.i18nText("BI-Basic_Field_Cannot_Find");
        break;

      case BICst.FORMULA_STATE.NOT_SUPPORT_STRING_OR_DATE:
        errorText = BI.i18nText("BI-Design_Not_Support_Date_Or_String");
        break;

      case BICst.FORMULA_STATE.RAPID_INVALID:
        errorText = BI.i18nText("BI-Design_Detail_Table_Not_Support_Rapid");
        break;

      default:
        errorText = BI.i18nText("BI-Basic_Formula_Invalid");
    }

    return errorText;
  },
  showTip: function showTip() {
    // if (BI.isNull(this.errorTip)) return;
    // this.errorText.setValue(errorText);
    // this.errorTip.setVisible(true);
    // this.normalTip.setVisible(false);
    this.formulaedit.showTip(this.getErrorText());
  },
  hideTip: function hideTip() {
    // if (BI.isNull(this.errorTip)) return;
    // this.normalTip.setVisible(this.checkValidation());
    // this.errorTip.setVisible(false);
    this.formulaedit.hideTip();
  },
  refresh: function refresh() {
    this.formulaedit.refresh();
  },
  setValue: function setValue(v) {
    this.formulaedit.refresh();
    this.formulaedit.setValue(v);

    this._checkValidation();
  },
  getFormulaString: function getFormulaString() {
    return this.formulaedit.getFormulaString();
  },
  getUsedFields: function getUsedFields() {
    return this.formulaedit.getUsedFields();
  },
  setFormulaFieldType: function setFormulaFieldType(v) {
    return this.symbolgroup.setValue(v);
  },
  getFormulaFieldType: function getFormulaFieldType() {
    return this.symbolgroup.getValue();
  },
  getValue: function getValue() {
    return this.formulaedit.getValue();
  },
  populate: function populate(fieldItems) {
    this.options.fieldItems = fieldItems;
    this.fieldTextValueMap = this._createFieldTextValueMap(fieldItems);
    this.fieldValueTextMap = this._createFieldValueTextMap(fieldItems);
    this.fieldErrorTextValueMap = this._createErrorTextValueMap();
    this.fieldErrorValueTextMap = this._createErrorValueTextMap();
    this.fieldsDetailMap = this._createFieldDetailMap(fieldItems);
    this.fieldPane.populate(fieldItems);

    this._bindFieldDragEvent();
  }
});
BI.FormulaInsert.EVENT_VALID = "EVENT_VALID";
BI.FormulaInsert.EVENT_ERROR = "EVENT_ERROR";
BI.FormulaInsert.EVENT_CHANGE = "EVENT_CHANGE";
BI.FormulaInsert.EVENT_TYPE_CHANGE = "EVENT_TYPE_CHANGE";
BI.shortcut("bi.formula_insert", BI.FormulaInsert);

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Model = BI.inherit(Fix.Model, {
    childContext: ["fieldKeyword", "functionKeyword", "functionTypes"],
    state: function state() {
      var o = this.options;
      return {
        fieldItems: o.fieldItems,
        fieldKeyword: "",
        functionKeyword: "",
        functionTypes: o.functionTypes,
        lastCheckId: null
      };
    },
    computed: {
      allFieldItems: function allFieldItems() {
        return BI.flatten(this.options.fieldItems);
      },
      numberFieldItems: function numberFieldItems() {
        return BI.filter(this.model.allFieldItems, function (index, fieldItem) {
          return fieldItem.fieldType === BICst.COLUMN.NUMBER;
        });
      },
      numberFieldIds: function numberFieldIds() {
        return BI.map(this.model.numberFieldItems, "value");
      },
      stringFieldItems: function stringFieldItems() {
        return BI.filter(this.model.allFieldItems, function (index, fieldItem) {
          return fieldItem.fieldType === BICst.COLUMN.STRING;
        });
      },
      stringFieldIds: function stringFieldIds() {
        return BI.map(this.model.stringFieldItems, "value");
      },
      dateFieldItems: function dateFieldItems() {
        return BI.filter(this.model.allFieldItems, function (index, fieldItem) {
          return fieldItem.fieldType === BICst.COLUMN.DATE;
        });
      },
      dateFieldIds: function dateFieldIds() {
        return BI.map(this.model.dateFieldItems, "value");
      },
      functionItems: function functionItems() {
        var self = this;
        var functionObjs = this.options.formulaJSONGetter();
        var functionItems = [];
        var service = BI.Services.getService("bi.service.material.formula_insert");
        BI.each(functionObjs, function (i, functionObj) {
          if (self.model.functionTypes.includes(functionObj.type)) {
            functionItems.push({
              text: functionObj.name,
              value: functionObj.name,
              fieldType: service.getFunctionValueByType(functionObj.type),
              description: functionObj.def
            });
          }
        });
        return functionItems;
      },
      availableFunctions: function availableFunctions() {
        return BI.map(this.model.functionItems, "value");
      }
    },
    actions: {
      insertOperator: function insertOperator(v) {},
      inputOperator: function inputOperator(v) {},
      insertField: function insertField(v) {},
      insertFunction: function insertFunction(func) {},
      insertDragFunction: function insertDragFunction(id) {},
      insertDragField: function insertDragField(fieldId) {},
      addFunctionType: function addFunctionType(type) {
        this.model.functionTypes.push(type);
      },
      setLastCheckId: function setLastCheckId(value) {
        this.model.lastCheckId = value;
      }
    }
  });
  BI.model("bi.model.material.formula_insert", Model);
}();

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


!function () {
  var Service = BI.inherit(BI.OB, {
    getFunctionValueByType: function getFunctionValueByType(functionType) {
      switch (functionType) {
        case "MATH":
          return BICst.FUNCTION.MATH;

        case "TEXT":
          return BICst.FUNCTION.TEXT;

        case "DATETIME":
          return BICst.FUNCTION.DATE;

        case "ARRAY":
          return BICst.FUNCTION.ARRAY;

        case "LOGIC":
          return BICst.FUNCTION.LOGIC;

        case "AGG":
          return BICst.FUNCTION.AGG;

        case "COMMON":
          return BICst.FUNCTION.COMMON;

        case "TABLE_CAL":
          return BICst.FUNCTION.TABLE_CAL;

        case "ANALYSIS":
          return BICst.FUNCTION.ANALYSIS;

        case "OTHER":
          return BICst.FUNCTION.OTHER;

        case "FIXED_CAL":
          return BICst.FUNCTION.FIXED_CAL;

        default:
          return;
      }
    }
  });
  BI.service("bi.service.material.formula_insert", Service);
}();

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @author: Teller
 * @createdAt: 2018/7/6 下午1:59
 * @Description
*/
!function () {
  var Button = BI.inherit(BI.BasicButton, {
    props: {
      baseCls: "bi-components-formula-text-func-button cursor-pointer",
      $testId: "bi-components-formula-text-func-button"
    },
    render: function render() {
      return {
        type: "bi.horizontal_adapt",
        items: [{
          type: "bi.text_button",
          textWidth: 13,
          textHeight: 18,
          whiteSpace: "normal",
          text: BI.i18nText("BI-Basic_Function")
        }]
      };
    }
  });
  BI.shortcut("bi.components.formula.text_func_button", Button);
}();

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(207)(__webpack_require__(542));

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * svg绘图
 *
 * Created by GUY on 2015/12/3.
 * @class BI.Svg
 * @extends BI.Widget
 */
BI.Svg = BI.inherit(BI.Widget, {
  _defaultConfig: function _defaultConfig() {
    return BI.extend(BI.Svg.superclass._defaultConfig.apply(this, arguments), {
      baseCls: "bi-svg"
    });
  },
  _init: function _init() {
    BI.Svg.superclass._init.apply(this, arguments);

    this.paper = Raphael(this.element[0]);
    this.element.css("overflow", "hidden");
    BI.$(this.paper.canvas).width("100%").height("100%").css({
      left: "0",
      top: "0"
    }).appendTo(this.element);
    this.top = this.paper.top;
    this.bottom = this.paper.bottom;
    this.customAttributes = this.paper.customAttributes;
    this.ca = this.paper.ca;
    this.raphael = this.paper.raphael;
  },
  add: function add() {
    return this.paper.add.apply(this.paper, arguments);
  },
  path: function path() {
    return this.paper.path.apply(this.paper, arguments);
  },
  image: function image() {
    return this.paper.image.apply(this.paper, arguments);
  },
  rect: function rect() {
    return this.paper.rect.apply(this.paper, arguments);
  },
  circle: function circle() {
    return this.paper.circle.apply(this.paper, arguments);
  },
  ellipse: function ellipse() {
    return this.paper.ellipse.apply(this.paper, arguments);
  },
  text: function text() {
    return this.paper.text.apply(this.paper, arguments);
  },
  print: function print() {
    return this.paper.print.apply(this.paper, arguments);
  },
  setStart: function setStart() {
    return this.paper.setStart.apply(this.paper, arguments);
  },
  setFinish: function setFinish() {
    return this.paper.setFinish.apply(this.paper, arguments);
  },
  setSize: function setSize() {
    return this.paper.setSize.apply(this.paper, arguments);
  },
  setViewBox: function setViewBox() {
    return this.paper.setViewBox.apply(this.paper, arguments);
  },
  getById: function getById() {
    return this.paper.getById.apply(this.paper, arguments);
  },
  getElementByPoint: function getElementByPoint() {
    return this.paper.getElementByPoint.apply(this.paper, arguments);
  },
  getElementsByPoint: function getElementsByPoint() {
    return this.paper.getElementsByPoint.apply(this.paper, arguments);
  },
  getFont: function getFont() {
    return this.paper.getFont.apply(this.paper, arguments);
  },
  set: function set() {
    return this.paper.set.apply(this.paper, arguments);
  },
  remove: function remove() {
    return this.paper.remove.apply(this.paper, arguments);
  },
  clear: function clear() {
    return this.paper.clear.apply(this.paper, arguments);
  }
});
BI.shortcut("bi.svg", BI.Svg);

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(window, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && _typeof(value) === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) {
          __webpack_require__.d(ns, key, function (key) {
            return value[key];
          }.bind(null, key));
        }
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 66);
      /******/
    }
    /************************************************************************/

    /******/
    ([
    /* 0 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _AbstractEvent = __webpack_require__(64);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _AbstractEvent2["default"];
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _AbstractPlugin = __webpack_require__(60);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _AbstractPlugin2["default"];
      /***/
    },
    /* 2 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _closest = __webpack_require__(51);

      Object.defineProperty(exports, 'closest', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_closest)["default"];
        }
      });

      var _requestNextAnimationFrame = __webpack_require__(49);

      Object.defineProperty(exports, 'requestNextAnimationFrame', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_requestNextAnimationFrame)["default"];
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /***/

    },
    /* 3 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SensorEvent = __webpack_require__(44);

      Object.keys(_SensorEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SensorEvent[key];
          }
        });
      });
      /***/
    },
    /* 4 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Sensor = __webpack_require__(47);

      var _Sensor2 = _interopRequireDefault(_Sensor);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Sensor2["default"];
      /***/
    },
    /* 5 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DragEvent = __webpack_require__(14);

      Object.keys(_DragEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DragEvent[key];
          }
        });
      });

      var _DraggableEvent = __webpack_require__(13);

      Object.keys(_DraggableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DraggableEvent[key];
          }
        });
      });

      var _Plugins = __webpack_require__(12);

      Object.keys(_Plugins).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _Plugins[key];
          }
        });
      });

      var _Sensors = __webpack_require__(6);

      Object.keys(_Sensors).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _Sensors[key];
          }
        });
      });

      var _Draggable = __webpack_require__(37);

      var _Draggable2 = _interopRequireDefault(_Draggable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Draggable2["default"];
      /***/
    },
    /* 6 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Sensor = __webpack_require__(4);

      Object.defineProperty(exports, 'Sensor', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Sensor)["default"];
        }
      });

      var _MouseSensor = __webpack_require__(46);

      Object.defineProperty(exports, 'MouseSensor', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_MouseSensor)["default"];
        }
      });

      var _TouchSensor = __webpack_require__(43);

      Object.defineProperty(exports, 'TouchSensor', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_TouchSensor)["default"];
        }
      });

      var _DragSensor = __webpack_require__(41);

      Object.defineProperty(exports, 'DragSensor', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_DragSensor)["default"];
        }
      });

      var _ForceTouchSensor = __webpack_require__(39);

      Object.defineProperty(exports, 'ForceTouchSensor', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ForceTouchSensor)["default"];
        }
      });

      var _SensorEvent = __webpack_require__(3);

      Object.keys(_SensorEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SensorEvent[key];
          }
        });
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /***/

    },
    /* 7 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SnappableEvent = __webpack_require__(18);

      Object.keys(_SnappableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SnappableEvent[key];
          }
        });
      });
      /***/
    },
    /* 8 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _CollidableEvent = __webpack_require__(23);

      Object.keys(_CollidableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _CollidableEvent[key];
          }
        });
      });
      /***/
    },
    /* 9 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SortableEvent = __webpack_require__(27);

      Object.keys(_SortableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SortableEvent[key];
          }
        });
      });
      /***/
    },
    /* 10 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SwappableEvent = __webpack_require__(30);

      Object.keys(_SwappableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SwappableEvent[key];
          }
        });
      });
      /***/
    },
    /* 11 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DroppableEvent = __webpack_require__(33);

      Object.keys(_DroppableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DroppableEvent[key];
          }
        });
      });
      /***/
    },
    /* 12 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Announcement = __webpack_require__(62);

      Object.defineProperty(exports, 'Announcement', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Announcement)["default"];
        }
      });
      Object.defineProperty(exports, 'defaultAnnouncementOptions', {
        enumerable: true,
        get: function get() {
          return _Announcement.defaultOptions;
        }
      });

      var _Focusable = __webpack_require__(59);

      Object.defineProperty(exports, 'Focusable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Focusable)["default"];
        }
      });

      var _Mirror = __webpack_require__(57);

      Object.defineProperty(exports, 'Mirror', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Mirror)["default"];
        }
      });
      Object.defineProperty(exports, 'defaultMirrorOptions', {
        enumerable: true,
        get: function get() {
          return _Mirror.defaultOptions;
        }
      });

      var _Scrollable = __webpack_require__(53);

      Object.defineProperty(exports, 'Scrollable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Scrollable)["default"];
        }
      });
      Object.defineProperty(exports, 'defaultScrollableOptions', {
        enumerable: true,
        get: function get() {
          return _Scrollable.defaultOptions;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /***/

    },
    /* 13 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DraggableEvent = __webpack_require__(63);

      Object.keys(_DraggableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DraggableEvent[key];
          }
        });
      });
      /***/
    },
    /* 14 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DragEvent = __webpack_require__(65);

      Object.keys(_DragEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DragEvent[key];
          }
        });
      });
      /***/
    },
    /* 15 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onSortableSorted = Symbol('onSortableSorted');
      /**
       * SwapAnimation default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.duration
       * @property {String} defaultOptions.easingFunction
       * @property {Boolean} defaultOptions.horizontal
       * @type {Object}
       */

      var defaultOptions = exports.defaultOptions = {
        duration: 150,
        easingFunction: 'ease-in-out',
        horizontal: false
      };
      /**
       * SwapAnimation plugin adds swap animations for sortable
       * @class SwapAnimation
       * @module SwapAnimation
       * @extends AbstractPlugin
       */

      var SwapAnimation = /*#__PURE__*/function (_AbstractPlugin2$defa) {
        _inheritsLoose(SwapAnimation, _AbstractPlugin2$defa);

        /**
         * SwapAnimation constructor.
         * @constructs SwapAnimation
         * @param {Draggable} draggable - Draggable instance
         */
        function SwapAnimation(draggable) {
          var _this;

          _this = _AbstractPlugin2$defa.call(this, draggable) || this;
          /**
           * SwapAnimation options
           * @property {Object} options
           * @property {Number} defaultOptions.duration
           * @property {String} defaultOptions.easingFunction
           * @type {Object}
           */

          _this.options = _extends({}, defaultOptions, _this.getOptions());
          /**
           * Last animation frame
           * @property {Number} lastAnimationFrame
           * @type {Number}
           */

          _this.lastAnimationFrame = null;
          _this[onSortableSorted] = _this[onSortableSorted].bind(_assertThisInitialized(_this));
          return _this;
        }
        /**
         * Attaches plugins event listeners
         */


        var _proto = SwapAnimation.prototype;

        _proto.attach = function attach() {
          this.draggable.on('sortable:sorted', this[onSortableSorted]);
        }
        /**
         * Detaches plugins event listeners
         */
        ;

        _proto.detach = function detach() {
          this.draggable.off('sortable:sorted', this[onSortableSorted]);
        }
        /**
         * Returns options passed through draggable
         * @return {Object}
         */
        ;

        _proto.getOptions = function getOptions() {
          return this.draggable.options.swapAnimation || {};
        }
        /**
         * Sortable sorted handler
         * @param {SortableSortedEvent} sortableEvent
         * @private
         */
        ;

        _proto[onSortableSorted] = function (_ref8) {
          var _this2 = this;

          var oldIndex = _ref8.oldIndex,
              newIndex = _ref8.newIndex,
              dragEvent = _ref8.dragEvent;
          var source = dragEvent.source,
              over = dragEvent.over;
          cancelAnimationFrame(this.lastAnimationFrame); // Can be done in a separate frame

          this.lastAnimationFrame = requestAnimationFrame(function () {
            if (oldIndex >= newIndex) {
              animate(source, over, _this2.options);
            } else {
              animate(over, source, _this2.options);
            }
          });
        };

        return SwapAnimation;
      }(_AbstractPlugin2["default"]);

      exports["default"] = SwapAnimation;
      /**
       * Animates two elements
       * @param {HTMLElement} from
       * @param {HTMLElement} to
       * @param {Object} options
       * @param {Number} options.duration
       * @param {String} options.easingFunction
       * @param {String} options.horizontal
       * @private
       */

      function animate(from, to, _ref9) {
        var duration = _ref9.duration,
            easingFunction = _ref9.easingFunction,
            horizontal = _ref9.horizontal;

        for (var _i = 0, _arr = [from, to]; _i < _arr.length; _i++) {
          var element = _arr[_i];
          element.style.pointerEvents = 'none';
        }

        if (horizontal) {
          var width = from.offsetWidth;
          from.style.transform = "translate3d(".concat(width, "px, 0, 0)");
          to.style.transform = "translate3d(-".concat(width, "px, 0, 0)");
        } else {
          var height = from.offsetHeight;
          from.style.transform = "translate3d(0, ".concat(height, "px, 0)");
          to.style.transform = "translate3d(0, -".concat(height, "px, 0)");
        }

        requestAnimationFrame(function () {
          for (var _i2 = 0, _arr2 = [from, to]; _i2 < _arr2.length; _i2++) {
            var _element = _arr2[_i2];

            _element.addEventListener('transitionend', resetElementOnTransitionEnd);

            _element.style.transition = "transform ".concat(duration, "ms ").concat(easingFunction);
            _element.style.transform = '';
          }
        });
      }
      /**
       * Resets animation style properties after animation has completed
       * @param {Event} event
       * @private
       */


      function resetElementOnTransitionEnd(event) {
        event.target.style.transition = '';
        event.target.style.pointerEvents = '';
        event.target.removeEventListener('transitionend', resetElementOnTransitionEnd);
      }
      /***/

    },
    /* 16 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _SwapAnimation = __webpack_require__(15);

      var _SwapAnimation2 = _interopRequireDefault(_SwapAnimation);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _SwapAnimation2["default"];
      exports.defaultOptions = _SwapAnimation.defaultOptions;
      /***/
    },
    /* 17 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      var _SnappableEvent = __webpack_require__(7);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragStart = Symbol('onDragStart');
      var onDragStop = Symbol('onDragStop');
      var onDragOver = Symbol('onDragOver');
      var onDragOut = Symbol('onDragOut');
      var onMirrorCreated = Symbol('onMirrorCreated');
      var onMirrorDestroy = Symbol('onMirrorDestroy');
      /**
       * Snappable plugin which snaps draggable elements into place
       * @class Snappable
       * @module Snappable
       * @extends AbstractPlugin
       */

      var Snappable = /*#__PURE__*/function (_AbstractPlugin2$defa2) {
        _inheritsLoose(Snappable, _AbstractPlugin2$defa2);

        /**
         * Snappable constructor.
         * @constructs Snappable
         * @param {Draggable} draggable - Draggable instance
         */
        function Snappable(draggable) {
          var _this3;

          _this3 = _AbstractPlugin2$defa2.call(this, draggable) || this;
          /**
           * Keeps track of the first source element
           * @property {HTMLElement|null} firstSource
           */

          _this3.firstSource = null;
          /**
           * Keeps track of the mirror element
           * @property {HTMLElement} mirror
           */

          _this3.mirror = null;
          _this3[onDragStart] = _this3[onDragStart].bind(_assertThisInitialized(_this3));
          _this3[onDragStop] = _this3[onDragStop].bind(_assertThisInitialized(_this3));
          _this3[onDragOver] = _this3[onDragOver].bind(_assertThisInitialized(_this3));
          _this3[onDragOut] = _this3[onDragOut].bind(_assertThisInitialized(_this3));
          _this3[onMirrorCreated] = _this3[onMirrorCreated].bind(_assertThisInitialized(_this3));
          _this3[onMirrorDestroy] = _this3[onMirrorDestroy].bind(_assertThisInitialized(_this3));
          return _this3;
        }
        /**
         * Attaches plugins event listeners
         */


        var _proto2 = Snappable.prototype;

        _proto2.attach = function attach() {
          this.draggable.on('drag:start', this[onDragStart]).on('drag:stop', this[onDragStop]).on('drag:over', this[onDragOver]).on('drag:out', this[onDragOut]).on('droppable:over', this[onDragOver]).on('droppable:out', this[onDragOut]).on('mirror:created', this[onMirrorCreated]).on('mirror:destroy', this[onMirrorDestroy]);
        }
        /**
         * Detaches plugins event listeners
         */
        ;

        _proto2.detach = function detach() {
          this.draggable.off('drag:start', this[onDragStart]).off('drag:stop', this[onDragStop]).off('drag:over', this[onDragOver]).off('drag:out', this[onDragOut]).off('droppable:over', this[onDragOver]).off('droppable:out', this[onDragOut]).off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]);
        }
        /**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */
        ;

        _proto2[onDragStart] = function (event) {
          if (event.canceled()) {
            return;
          }

          this.firstSource = event.source;
        }
        /**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */
        ;

        _proto2[onDragStop] = function () {
          this.firstSource = null;
        }
        /**
         * Drag over handler
         * @private
         * @param {DragOverEvent|DroppableOverEvent} event - Drag over event
         */
        ;

        _proto2[onDragOver] = function (event) {
          var _this4 = this;

          if (event.canceled()) {
            return;
          }

          var source = event.source || event.dragEvent.source;

          if (source === this.firstSource) {
            this.firstSource = null;
            return;
          }

          var snapInEvent = new _SnappableEvent.SnapInEvent({
            dragEvent: event,
            snappable: event.over || event.droppable
          });
          this.draggable.trigger(snapInEvent);

          if (snapInEvent.canceled()) {
            return;
          }

          if (this.mirror) {
            this.mirror.style.display = 'none';
          }

          source.classList.remove(this.draggable.getClassNameFor('source:dragging'));
          source.classList.add(this.draggable.getClassNameFor('source:placed')); // Need to cancel this in drag out

          setTimeout(function () {
            source.classList.remove(_this4.draggable.getClassNameFor('source:placed'));
          }, this.draggable.options.placedTimeout);
        }
        /**
         * Drag out handler
         * @private
         * @param {DragOutEvent|DroppableOutEvent} event - Drag out event
         */
        ;

        _proto2[onDragOut] = function (event) {
          if (event.canceled()) {
            return;
          }

          var source = event.source || event.dragEvent.source;
          var snapOutEvent = new _SnappableEvent.SnapOutEvent({
            dragEvent: event,
            snappable: event.over || event.droppable
          });
          this.draggable.trigger(snapOutEvent);

          if (snapOutEvent.canceled()) {
            return;
          }

          if (this.mirror) {
            this.mirror.style.display = '';
          }

          source.classList.add(this.draggable.getClassNameFor('source:dragging'));
        }
        /**
         * Mirror created handler
         * @param {MirrorCreatedEvent} mirrorEvent
         * @private
         */
        ;

        _proto2[onMirrorCreated] = function (_ref10) {
          var mirror = _ref10.mirror;
          this.mirror = mirror;
        }
        /**
         * Mirror destroy handler
         * @param {MirrorDestroyEvent} mirrorEvent
         * @private
         */
        ;

        _proto2[onMirrorDestroy] = function () {
          this.mirror = null;
        };

        return Snappable;
      }(_AbstractPlugin2["default"]);

      exports["default"] = Snappable;
      /***/
    },
    /* 18 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SnapOutEvent = exports.SnapInEvent = exports.SnapEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base snap event
       * @class SnapEvent
       * @module SnapEvent
       * @extends AbstractEvent
       */


      var SnapEvent = /*#__PURE__*/function (_AbstractEvent2$defau) {
        _inheritsLoose(SnapEvent, _AbstractEvent2$defau);

        function SnapEvent() {
          return _AbstractEvent2$defau.apply(this, arguments) || this;
        }

        _createClass(SnapEvent, [{
          key: "dragEvent",

          /**
           * Drag event that triggered this snap event
           * @property dragEvent
           * @type {DragEvent}
           * @readonly
           */
          get: function get() {
            return this.data.dragEvent;
          }
          /**
           * Snappable element
           * @property snappable
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "snappable",
          get: function get() {
            return this.data.snappable;
          }
        }]);

        return SnapEvent;
      }(_AbstractEvent2["default"]);

      exports.SnapEvent = SnapEvent;
      /**
       * Snap in event
       * @class SnapInEvent
       * @module SnapInEvent
       * @extends SnapEvent
       */

      SnapEvent.type = 'snap';

      var SnapInEvent = /*#__PURE__*/function (_SnapEvent) {
        _inheritsLoose(SnapInEvent, _SnapEvent);

        function SnapInEvent() {
          return _SnapEvent.apply(this, arguments) || this;
        }

        return SnapInEvent;
      }(SnapEvent);

      exports.SnapInEvent = SnapInEvent;
      /**
       * Snap out event
       * @class SnapOutEvent
       * @module SnapOutEvent
       * @extends SnapEvent
       */

      SnapInEvent.type = 'snap:in';
      SnapInEvent.cancelable = true;

      var SnapOutEvent = /*#__PURE__*/function (_SnapEvent2) {
        _inheritsLoose(SnapOutEvent, _SnapEvent2);

        function SnapOutEvent() {
          return _SnapEvent2.apply(this, arguments) || this;
        }

        return SnapOutEvent;
      }(SnapEvent);

      exports.SnapOutEvent = SnapOutEvent;
      SnapOutEvent.type = 'snap:out';
      SnapOutEvent.cancelable = true;
      /***/
    },
    /* 19 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SnappableEvent = __webpack_require__(7);

      Object.keys(_SnappableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SnappableEvent[key];
          }
        });
      });

      var _Snappable = __webpack_require__(17);

      var _Snappable2 = _interopRequireDefault(_Snappable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Snappable2["default"];
      /***/
    },
    /* 20 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      var _utils = __webpack_require__(2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onMirrorCreated = Symbol('onMirrorCreated');
      var onMirrorDestroy = Symbol('onMirrorDestroy');
      var onDragOver = Symbol('onDragOver');
      var resize = Symbol('resize');
      /**
       * ResizeMirror default options
       * @property {Object} defaultOptions
       * @type {Object}
       */

      var defaultOptions = exports.defaultOptions = {};
      /**
       * The ResizeMirror plugin resizes the mirror element to the dimensions of the draggable element that the mirror is hovering over
       * @class ResizeMirror
       * @module ResizeMirror
       * @extends AbstractPlugin
       */

      var ResizeMirror = /*#__PURE__*/function (_AbstractPlugin2$defa3) {
        _inheritsLoose(ResizeMirror, _AbstractPlugin2$defa3);

        /**
         * ResizeMirror constructor.
         * @constructs ResizeMirror
         * @param {Draggable} draggable - Draggable instance
         */
        function ResizeMirror(draggable) {
          var _this5;

          _this5 = _AbstractPlugin2$defa3.call(this, draggable) || this;
          /**
           * ResizeMirror options
           * @property {Object} options
           * @type {Object}
           */

          _this5.options = _extends({}, defaultOptions, _this5.getOptions());
          /**
           * ResizeMirror remembers the last width when resizing the mirror
           * to avoid additional writes to the DOM
           * @property {number} lastWidth
           */

          _this5.lastWidth = 0;
          /**
           * ResizeMirror remembers the last height when resizing the mirror
           * to avoid additional writes to the DOM
           * @property {number} lastHeight
           */

          _this5.lastHeight = 0;
          /**
           * Keeps track of the mirror element
           * @property {HTMLElement} mirror
           */

          _this5.mirror = null;
          _this5[onMirrorCreated] = _this5[onMirrorCreated].bind(_assertThisInitialized(_this5));
          _this5[onMirrorDestroy] = _this5[onMirrorDestroy].bind(_assertThisInitialized(_this5));
          _this5[onDragOver] = _this5[onDragOver].bind(_assertThisInitialized(_this5));
          return _this5;
        }
        /**
         * Attaches plugins event listeners
         */


        var _proto3 = ResizeMirror.prototype;

        _proto3.attach = function attach() {
          this.draggable.on('mirror:created', this[onMirrorCreated]).on('drag:over', this[onDragOver]).on('drag:over:container', this[onDragOver]);
        }
        /**
         * Detaches plugins event listeners
         */
        ;

        _proto3.detach = function detach() {
          this.draggable.off('mirror:created', this[onMirrorCreated]).off('mirror:destroy', this[onMirrorDestroy]).off('drag:over', this[onDragOver]).off('drag:over:container', this[onDragOver]);
        }
        /**
         * Returns options passed through draggable
         * @return {Object}
         */
        ;

        _proto3.getOptions = function getOptions() {
          return this.draggable.options.resizeMirror || {};
        }
        /**
         * Mirror created handler
         * @param {MirrorCreatedEvent} mirrorEvent
         * @private
         */
        ;

        _proto3[onMirrorCreated] = function (_ref11) {
          var mirror = _ref11.mirror;
          this.mirror = mirror;
        }
        /**
         * Mirror destroy handler
         * @param {MirrorDestroyEvent} mirrorEvent
         * @private
         */
        ;

        _proto3[onMirrorDestroy] = function () {
          this.mirror = null;
        }
        /**
         * Drag over handler
         * @param {DragOverEvent | DragOverContainer} dragEvent
         * @private
         */
        ;

        _proto3[onDragOver] = function (dragEvent) {
          this[resize](dragEvent);
        }
        /**
         * Resize function for
         * @param {DragOverEvent | DragOverContainer} dragEvent
         * @private
         */
        ;

        _proto3[resize] = function (_ref12) {
          var _this6 = this;

          var overContainer = _ref12.overContainer,
              over = _ref12.over;
          requestAnimationFrame(function () {
            if (_this6.mirror.parentNode !== overContainer) {
              overContainer.appendChild(_this6.mirror);
            }

            var overElement = over || _this6.draggable.getDraggableElementsForContainer(overContainer)[0];

            if (!overElement) {
              return;
            }

            (0, _utils.requestNextAnimationFrame)(function () {
              var overRect = overElement.getBoundingClientRect();

              if (_this6.lastHeight === overRect.height && _this6.lastWidth === overRect.width) {
                return;
              }

              _this6.mirror.style.width = "".concat(overRect.width, "px");
              _this6.mirror.style.height = "".concat(overRect.height, "px");
              _this6.lastWidth = overRect.width;
              _this6.lastHeight = overRect.height;
            });
          });
        };

        return ResizeMirror;
      }(_AbstractPlugin2["default"]);

      exports["default"] = ResizeMirror;
      /***/
    },
    /* 21 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _ResizeMirror = __webpack_require__(20);

      var _ResizeMirror2 = _interopRequireDefault(_ResizeMirror);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _ResizeMirror2["default"];
      exports.defaultOptions = _ResizeMirror.defaultOptions;
      /***/
    },
    /* 22 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      var _utils = __webpack_require__(2);

      var _CollidableEvent = __webpack_require__(8);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragMove = Symbol('onDragMove');
      var onDragStop = Symbol('onDragStop');
      var onRequestAnimationFrame = Symbol('onRequestAnimationFrame');
      /**
       * Collidable plugin which detects colliding elements while dragging
       * @class Collidable
       * @module Collidable
       * @extends AbstractPlugin
       */

      var Collidable = /*#__PURE__*/function (_AbstractPlugin2$defa4) {
        _inheritsLoose(Collidable, _AbstractPlugin2$defa4);

        /**
         * Collidable constructor.
         * @constructs Collidable
         * @param {Draggable} draggable - Draggable instance
         */
        function Collidable(draggable) {
          var _this7;

          _this7 = _AbstractPlugin2$defa4.call(this, draggable) || this;
          /**
           * Keeps track of currently colliding elements
           * @property {HTMLElement|null} currentlyCollidingElement
           * @type {HTMLElement|null}
           */

          _this7.currentlyCollidingElement = null;
          /**
           * Keeps track of currently colliding elements
           * @property {HTMLElement|null} lastCollidingElement
           * @type {HTMLElement|null}
           */

          _this7.lastCollidingElement = null;
          /**
           * Animation frame for finding colliding elements
           * @property {Number|null} currentAnimationFrame
           * @type {Number|null}
           */

          _this7.currentAnimationFrame = null;
          _this7[onDragMove] = _this7[onDragMove].bind(_assertThisInitialized(_this7));
          _this7[onDragStop] = _this7[onDragStop].bind(_assertThisInitialized(_this7));
          _this7[onRequestAnimationFrame] = _this7[onRequestAnimationFrame].bind(_assertThisInitialized(_this7));
          return _this7;
        }
        /**
         * Attaches plugins event listeners
         */


        var _proto4 = Collidable.prototype;

        _proto4.attach = function attach() {
          this.draggable.on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);
        }
        /**
         * Detaches plugins event listeners
         */
        ;

        _proto4.detach = function detach() {
          this.draggable.off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);
        }
        /**
         * Returns current collidables based on `collidables` option
         * @return {HTMLElement[]}
         */
        ;

        _proto4.getCollidables = function getCollidables() {
          var collidables = this.draggable.options.collidables;

          if (typeof collidables === 'string') {
            return Array.prototype.slice.call(document.querySelectorAll(collidables));
          } else if (collidables instanceof NodeList || collidables instanceof Array) {
            return Array.prototype.slice.call(collidables);
          } else if (collidables instanceof HTMLElement) {
            return [collidables];
          } else if (typeof collidables === 'function') {
            return collidables();
          } else {
            return [];
          }
        }
        /**
         * Drag move handler
         * @private
         * @param {DragMoveEvent} event - Drag move event
         */
        ;

        _proto4[onDragMove] = function (event) {
          var target = event.sensorEvent.target;
          this.currentAnimationFrame = requestAnimationFrame(this[onRequestAnimationFrame](target));

          if (this.currentlyCollidingElement) {
            event.cancel();
          }

          var collidableInEvent = new _CollidableEvent.CollidableInEvent({
            dragEvent: event,
            collidingElement: this.currentlyCollidingElement
          });
          var collidableOutEvent = new _CollidableEvent.CollidableOutEvent({
            dragEvent: event,
            collidingElement: this.lastCollidingElement
          });
          var enteringCollidable = Boolean(this.currentlyCollidingElement && this.lastCollidingElement !== this.currentlyCollidingElement);
          var leavingCollidable = Boolean(!this.currentlyCollidingElement && this.lastCollidingElement);

          if (enteringCollidable) {
            if (this.lastCollidingElement) {
              this.draggable.trigger(collidableOutEvent);
            }

            this.draggable.trigger(collidableInEvent);
          } else if (leavingCollidable) {
            this.draggable.trigger(collidableOutEvent);
          }

          this.lastCollidingElement = this.currentlyCollidingElement;
        }
        /**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */
        ;

        _proto4[onDragStop] = function (event) {
          var lastCollidingElement = this.currentlyCollidingElement || this.lastCollidingElement;
          var collidableOutEvent = new _CollidableEvent.CollidableOutEvent({
            dragEvent: event,
            collidingElement: lastCollidingElement
          });

          if (lastCollidingElement) {
            this.draggable.trigger(collidableOutEvent);
          }

          this.lastCollidingElement = null;
          this.currentlyCollidingElement = null;
        }
        /**
         * Animation frame function
         * @private
         * @param {HTMLElement} target - Current move target
         * @return {Function}
         */
        ;

        _proto4[onRequestAnimationFrame] = function (target) {
          var _this8 = this;

          return function () {
            var collidables = _this8.getCollidables();

            _this8.currentlyCollidingElement = (0, _utils.closest)(target, function (element) {
              return collidables.includes(element);
            });
          };
        };

        return Collidable;
      }(_AbstractPlugin2["default"]);

      exports["default"] = Collidable;
      /***/
    },
    /* 23 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.CollidableOutEvent = exports.CollidableInEvent = exports.CollidableEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base collidable event
       * @class CollidableEvent
       * @module CollidableEvent
       * @extends AbstractEvent
       */


      var CollidableEvent = /*#__PURE__*/function (_AbstractEvent2$defau2) {
        _inheritsLoose(CollidableEvent, _AbstractEvent2$defau2);

        function CollidableEvent() {
          return _AbstractEvent2$defau2.apply(this, arguments) || this;
        }

        _createClass(CollidableEvent, [{
          key: "dragEvent",

          /**
           * Drag event that triggered this colliable event
           * @property dragEvent
           * @type {DragEvent}
           * @readonly
           */
          get: function get() {
            return this.data.dragEvent;
          }
        }]);

        return CollidableEvent;
      }(_AbstractEvent2["default"]);

      exports.CollidableEvent = CollidableEvent;
      /**
       * Collidable in event
       * @class CollidableInEvent
       * @module CollidableInEvent
       * @extends CollidableEvent
       */

      CollidableEvent.type = 'collidable';

      var CollidableInEvent = /*#__PURE__*/function (_CollidableEvent2) {
        _inheritsLoose(CollidableInEvent, _CollidableEvent2);

        function CollidableInEvent() {
          return _CollidableEvent2.apply(this, arguments) || this;
        }

        _createClass(CollidableInEvent, [{
          key: "collidingElement",

          /**
           * Element you are currently colliding with
           * @property collidingElement
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.collidingElement;
          }
        }]);

        return CollidableInEvent;
      }(CollidableEvent);

      exports.CollidableInEvent = CollidableInEvent;
      /**
       * Collidable out event
       * @class CollidableOutEvent
       * @module CollidableOutEvent
       * @extends CollidableEvent
       */

      CollidableInEvent.type = 'collidable:in';

      var CollidableOutEvent = /*#__PURE__*/function (_CollidableEvent3) {
        _inheritsLoose(CollidableOutEvent, _CollidableEvent3);

        function CollidableOutEvent() {
          return _CollidableEvent3.apply(this, arguments) || this;
        }

        _createClass(CollidableOutEvent, [{
          key: "collidingElement",

          /**
           * Element you were previously colliding with
           * @property collidingElement
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.collidingElement;
          }
        }]);

        return CollidableOutEvent;
      }(CollidableEvent);

      exports.CollidableOutEvent = CollidableOutEvent;
      CollidableOutEvent.type = 'collidable:out';
      /***/
    },
    /* 24 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _CollidableEvent = __webpack_require__(8);

      Object.keys(_CollidableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _CollidableEvent[key];
          }
        });
      });

      var _Collidable = __webpack_require__(22);

      var _Collidable2 = _interopRequireDefault(_Collidable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Collidable2["default"];
      /***/
    },
    /* 25 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Collidable = __webpack_require__(24);

      Object.defineProperty(exports, 'Collidable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Collidable)["default"];
        }
      });

      var _ResizeMirror = __webpack_require__(21);

      Object.defineProperty(exports, 'ResizeMirror', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_ResizeMirror)["default"];
        }
      });
      Object.defineProperty(exports, 'defaultResizeMirrorOptions', {
        enumerable: true,
        get: function get() {
          return _ResizeMirror.defaultOptions;
        }
      });

      var _Snappable = __webpack_require__(19);

      Object.defineProperty(exports, 'Snappable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Snappable)["default"];
        }
      });

      var _SwapAnimation = __webpack_require__(16);

      Object.defineProperty(exports, 'SwapAnimation', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_SwapAnimation)["default"];
        }
      });
      Object.defineProperty(exports, 'defaultSwapAnimationOptions', {
        enumerable: true,
        get: function get() {
          return _SwapAnimation.defaultOptions;
        }
      });

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /***/

    },
    /* 26 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _Draggable = __webpack_require__(5);

      var _Draggable2 = _interopRequireDefault(_Draggable);

      var _SortableEvent = __webpack_require__(9);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragStart = Symbol('onDragStart');
      var onDragOverContainer = Symbol('onDragOverContainer');
      var onDragOver = Symbol('onDragOver');
      var onDragStop = Symbol('onDragStop');
      /**
       * Returns announcement message when a Draggable element has been sorted with another Draggable element
       * or moved into a new container
       * @param {SortableSortedEvent} sortableEvent
       * @return {String}
       */

      function onSortableSortedDefaultAnnouncement(_ref13) {
        var dragEvent = _ref13.dragEvent;
        var sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'sortable element';

        if (dragEvent.over) {
          var overText = dragEvent.over.textContent.trim() || dragEvent.over.id || 'sortable element';
          var isFollowing = dragEvent.source.compareDocumentPosition(dragEvent.over) & Node.DOCUMENT_POSITION_FOLLOWING;

          if (isFollowing) {
            return "Placed ".concat(sourceText, " after ").concat(overText);
          } else {
            return "Placed ".concat(sourceText, " before ").concat(overText);
          }
        } else {
          // need to figure out how to compute container name
          return "Placed ".concat(sourceText, " into a different container");
        }
      }
      /**
       * @const {Object} defaultAnnouncements
       * @const {Function} defaultAnnouncements['sortable:sorted']
       */


      var defaultAnnouncements = {
        'sortable:sorted': onSortableSortedDefaultAnnouncement
      };
      /**
       * Sortable is built on top of Draggable and allows sorting of draggable elements. Sortable will keep
       * track of the original index and emits the new index as you drag over draggable elements.
       * @class Sortable
       * @module Sortable
       * @extends Draggable
       */

      var Sortable = /*#__PURE__*/function (_Draggable2$default) {
        _inheritsLoose(Sortable, _Draggable2$default);

        /**
         * Sortable constructor.
         * @constructs Sortable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Sortable containers
         * @param {Object} options - Options for Sortable
         */
        function Sortable() {
          var _this9;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this9 = _Draggable2$default.call(this, containers, _extends({}, options, {
            announcements: _extends({}, defaultAnnouncements, options.announcements || {})
          })) || this;
          /**
           * start index of source on drag start
           * @property startIndex
           * @type {Number}
           */

          _this9.startIndex = null;
          /**
           * start container on drag start
           * @property startContainer
           * @type {HTMLElement}
           * @default null
           */

          _this9.startContainer = null;
          _this9[onDragStart] = _this9[onDragStart].bind(_assertThisInitialized(_this9));
          _this9[onDragOverContainer] = _this9[onDragOverContainer].bind(_assertThisInitialized(_this9));
          _this9[onDragOver] = _this9[onDragOver].bind(_assertThisInitialized(_this9));
          _this9[onDragStop] = _this9[onDragStop].bind(_assertThisInitialized(_this9));

          _this9.on('drag:start', _this9[onDragStart]).on('drag:over:container', _this9[onDragOverContainer]).on('drag:over', _this9[onDragOver]).on('drag:stop', _this9[onDragStop]);

          return _this9;
        }
        /**
         * Destroys Sortable instance.
         */


        var _proto5 = Sortable.prototype;

        _proto5.destroy = function destroy() {
          _Draggable2$default.prototype.destroy.call(this);

          this.off('drag:start', this[onDragStart]).off('drag:over:container', this[onDragOverContainer]).off('drag:over', this[onDragOver]).off('drag:stop', this[onDragStop]);
        }
        /**
         * Returns true index of element within its container during drag operation, i.e. excluding mirror and original source
         * @param {HTMLElement} element - An element
         * @return {Number}
         */
        ;

        _proto5.index = function index(element) {
          return this.getDraggableElementsForContainer(element.parentNode).indexOf(element);
        }
        /**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */
        ;

        _proto5[onDragStart] = function (event) {
          this.startContainer = event.source.parentNode;
          this.startIndex = this.index(event.source);
          var sortableStartEvent = new _SortableEvent.SortableStartEvent({
            dragEvent: event,
            startIndex: this.startIndex,
            startContainer: this.startContainer
          });
          this.trigger(sortableStartEvent);

          if (sortableStartEvent.canceled()) {
            event.cancel();
          }
        }
        /**
         * Drag over container handler
         * @private
         * @param {DragOverContainerEvent} event - Drag over container event
         */
        ;

        _proto5[onDragOverContainer] = function (event) {
          if (event.canceled()) {
            return;
          }

          var source = event.source,
              over = event.over,
              overContainer = event.overContainer;
          var oldIndex = this.index(source);
          var sortableSortEvent = new _SortableEvent.SortableSortEvent({
            dragEvent: event,
            currentIndex: oldIndex,
            source: source,
            over: over
          });
          this.trigger(sortableSortEvent);

          if (sortableSortEvent.canceled()) {
            return;
          }

          var children = this.getDraggableElementsForContainer(overContainer);
          var moves = move({
            source: source,
            over: over,
            overContainer: overContainer,
            children: children
          });

          if (!moves) {
            return;
          }

          var oldContainer = moves.oldContainer,
              newContainer = moves.newContainer;
          var newIndex = this.index(event.source);
          var sortableSortedEvent = new _SortableEvent.SortableSortedEvent({
            dragEvent: event,
            oldIndex: oldIndex,
            newIndex: newIndex,
            oldContainer: oldContainer,
            newContainer: newContainer
          });
          this.trigger(sortableSortedEvent);
        }
        /**
         * Drag over handler
         * @private
         * @param {DragOverEvent} event - Drag over event
         */
        ;

        _proto5[onDragOver] = function (event) {
          if (event.over === event.originalSource || event.over === event.source) {
            return;
          }

          var source = event.source,
              over = event.over,
              overContainer = event.overContainer;
          var oldIndex = this.index(source);
          var sortableSortEvent = new _SortableEvent.SortableSortEvent({
            dragEvent: event,
            currentIndex: oldIndex,
            source: source,
            over: over
          });
          this.trigger(sortableSortEvent);

          if (sortableSortEvent.canceled()) {
            return;
          }

          var children = this.getDraggableElementsForContainer(overContainer);
          var moves = move({
            source: source,
            over: over,
            overContainer: overContainer,
            children: children
          });

          if (!moves) {
            return;
          }

          var oldContainer = moves.oldContainer,
              newContainer = moves.newContainer;
          var newIndex = this.index(source);
          var sortableSortedEvent = new _SortableEvent.SortableSortedEvent({
            dragEvent: event,
            oldIndex: oldIndex,
            newIndex: newIndex,
            oldContainer: oldContainer,
            newContainer: newContainer
          });
          this.trigger(sortableSortedEvent);
        }
        /**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */
        ;

        _proto5[onDragStop] = function (event) {
          var sortableStopEvent = new _SortableEvent.SortableStopEvent({
            dragEvent: event,
            oldIndex: this.startIndex,
            newIndex: this.index(event.source),
            oldContainer: this.startContainer,
            newContainer: event.source.parentNode
          });
          this.trigger(sortableStopEvent);
          this.startIndex = null;
          this.startContainer = null;
        };

        return Sortable;
      }(_Draggable2["default"]);

      exports["default"] = Sortable;

      function index(element) {
        return Array.prototype.indexOf.call(element.parentNode.children, element);
      }

      function move(_ref14) {
        var source = _ref14.source,
            over = _ref14.over,
            overContainer = _ref14.overContainer,
            children = _ref14.children;
        var emptyOverContainer = !children.length;
        var differentContainer = source.parentNode !== overContainer;
        var sameContainer = over && !differentContainer;

        if (emptyOverContainer) {
          return moveInsideEmptyContainer(source, overContainer);
        } else if (sameContainer) {
          return moveWithinContainer(source, over);
        } else if (differentContainer) {
          return moveOutsideContainer(source, over, overContainer);
        } else {
          return null;
        }
      }

      function moveInsideEmptyContainer(source, overContainer) {
        var oldContainer = source.parentNode;
        overContainer.appendChild(source);
        return {
          oldContainer: oldContainer,
          newContainer: overContainer
        };
      }

      function moveWithinContainer(source, over) {
        var oldIndex = index(source);
        var newIndex = index(over);

        if (oldIndex < newIndex) {
          source.parentNode.insertBefore(source, over.nextElementSibling);
        } else {
          source.parentNode.insertBefore(source, over);
        }

        return {
          oldContainer: source.parentNode,
          newContainer: source.parentNode
        };
      }

      function moveOutsideContainer(source, over, overContainer) {
        var oldContainer = source.parentNode;

        if (over) {
          over.parentNode.insertBefore(source, over);
        } else {
          // need to figure out proper position
          overContainer.appendChild(source);
        }

        return {
          oldContainer: oldContainer,
          newContainer: source.parentNode
        };
      }
      /***/

    },
    /* 27 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SortableStopEvent = exports.SortableSortedEvent = exports.SortableSortEvent = exports.SortableStartEvent = exports.SortableEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base sortable event
       * @class SortableEvent
       * @module SortableEvent
       * @extends AbstractEvent
       */


      var SortableEvent = /*#__PURE__*/function (_AbstractEvent2$defau3) {
        _inheritsLoose(SortableEvent, _AbstractEvent2$defau3);

        function SortableEvent() {
          return _AbstractEvent2$defau3.apply(this, arguments) || this;
        }

        _createClass(SortableEvent, [{
          key: "dragEvent",

          /**
           * Original drag event that triggered this sortable event
           * @property dragEvent
           * @type {DragEvent}
           * @readonly
           */
          get: function get() {
            return this.data.dragEvent;
          }
        }]);

        return SortableEvent;
      }(_AbstractEvent2["default"]);

      exports.SortableEvent = SortableEvent;
      /**
       * Sortable start event
       * @class SortableStartEvent
       * @module SortableStartEvent
       * @extends SortableEvent
       */

      SortableEvent.type = 'sortable';

      var SortableStartEvent = /*#__PURE__*/function (_SortableEvent2) {
        _inheritsLoose(SortableStartEvent, _SortableEvent2);

        function SortableStartEvent() {
          return _SortableEvent2.apply(this, arguments) || this;
        }

        _createClass(SortableStartEvent, [{
          key: "startIndex",

          /**
           * Start index of source on sortable start
           * @property startIndex
           * @type {Number}
           * @readonly
           */
          get: function get() {
            return this.data.startIndex;
          }
          /**
           * Start container on sortable start
           * @property startContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "startContainer",
          get: function get() {
            return this.data.startContainer;
          }
        }]);

        return SortableStartEvent;
      }(SortableEvent);

      exports.SortableStartEvent = SortableStartEvent;
      /**
       * Sortable sort event
       * @class SortableSortEvent
       * @module SortableSortEvent
       * @extends SortableEvent
       */

      SortableStartEvent.type = 'sortable:start';
      SortableStartEvent.cancelable = true;

      var SortableSortEvent = /*#__PURE__*/function (_SortableEvent3) {
        _inheritsLoose(SortableSortEvent, _SortableEvent3);

        function SortableSortEvent() {
          return _SortableEvent3.apply(this, arguments) || this;
        }

        _createClass(SortableSortEvent, [{
          key: "currentIndex",

          /**
           * Index of current draggable element
           * @property currentIndex
           * @type {Number}
           * @readonly
           */
          get: function get() {
            return this.data.currentIndex;
          }
          /**
           * Draggable element you are hovering over
           * @property over
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "over",
          get: function get() {
            return this.data.oldIndex;
          }
          /**
           * Draggable container element you are hovering over
           * @property overContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "overContainer",
          get: function get() {
            return this.data.newIndex;
          }
        }]);

        return SortableSortEvent;
      }(SortableEvent);

      exports.SortableSortEvent = SortableSortEvent;
      /**
       * Sortable sorted event
       * @class SortableSortedEvent
       * @module SortableSortedEvent
       * @extends SortableEvent
       */

      SortableSortEvent.type = 'sortable:sort';
      SortableSortEvent.cancelable = true;

      var SortableSortedEvent = /*#__PURE__*/function (_SortableEvent4) {
        _inheritsLoose(SortableSortedEvent, _SortableEvent4);

        function SortableSortedEvent() {
          return _SortableEvent4.apply(this, arguments) || this;
        }

        _createClass(SortableSortedEvent, [{
          key: "oldIndex",

          /**
           * Index of last sorted event
           * @property oldIndex
           * @type {Number}
           * @readonly
           */
          get: function get() {
            return this.data.oldIndex;
          }
          /**
           * New index of this sorted event
           * @property newIndex
           * @type {Number}
           * @readonly
           */

        }, {
          key: "newIndex",
          get: function get() {
            return this.data.newIndex;
          }
          /**
           * Old container of draggable element
           * @property oldContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "oldContainer",
          get: function get() {
            return this.data.oldContainer;
          }
          /**
           * New container of draggable element
           * @property newContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "newContainer",
          get: function get() {
            return this.data.newContainer;
          }
        }]);

        return SortableSortedEvent;
      }(SortableEvent);

      exports.SortableSortedEvent = SortableSortedEvent;
      /**
       * Sortable stop event
       * @class SortableStopEvent
       * @module SortableStopEvent
       * @extends SortableEvent
       */

      SortableSortedEvent.type = 'sortable:sorted';

      var SortableStopEvent = /*#__PURE__*/function (_SortableEvent5) {
        _inheritsLoose(SortableStopEvent, _SortableEvent5);

        function SortableStopEvent() {
          return _SortableEvent5.apply(this, arguments) || this;
        }

        _createClass(SortableStopEvent, [{
          key: "oldIndex",

          /**
           * Original index on sortable start
           * @property oldIndex
           * @type {Number}
           * @readonly
           */
          get: function get() {
            return this.data.oldIndex;
          }
          /**
           * New index of draggable element
           * @property newIndex
           * @type {Number}
           * @readonly
           */

        }, {
          key: "newIndex",
          get: function get() {
            return this.data.newIndex;
          }
          /**
           * Original container of draggable element
           * @property oldContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "oldContainer",
          get: function get() {
            return this.data.oldContainer;
          }
          /**
           * New container of draggable element
           * @property newContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "newContainer",
          get: function get() {
            return this.data.newContainer;
          }
        }]);

        return SortableStopEvent;
      }(SortableEvent);

      exports.SortableStopEvent = SortableStopEvent;
      SortableStopEvent.type = 'sortable:stop';
      /***/
    },
    /* 28 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SortableEvent = __webpack_require__(9);

      Object.keys(_SortableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SortableEvent[key];
          }
        });
      });

      var _Sortable = __webpack_require__(26);

      var _Sortable2 = _interopRequireDefault(_Sortable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Sortable2["default"];
      /***/
    },
    /* 29 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _Draggable = __webpack_require__(5);

      var _Draggable2 = _interopRequireDefault(_Draggable);

      var _SwappableEvent = __webpack_require__(10);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragStart = Symbol('onDragStart');
      var onDragOver = Symbol('onDragOver');
      var onDragStop = Symbol('onDragStop');
      /**
       * Returns an announcement message when the Draggable element is swapped with another draggable element
       * @param {SwappableSwappedEvent} swappableEvent
       * @return {String}
       */

      function onSwappableSwappedDefaultAnnouncement(_ref15) {
        var dragEvent = _ref15.dragEvent,
            swappedElement = _ref15.swappedElement;
        var sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'swappable element';
        var overText = swappedElement.textContent.trim() || swappedElement.id || 'swappable element';
        return "Swapped ".concat(sourceText, " with ").concat(overText);
      }
      /**
       * @const {Object} defaultAnnouncements
       * @const {Function} defaultAnnouncements['swappabled:swapped']
       */


      var defaultAnnouncements = {
        'swappabled:swapped': onSwappableSwappedDefaultAnnouncement
      };
      /**
       * Swappable is built on top of Draggable and allows swapping of draggable elements.
       * Order is irrelevant to Swappable.
       * @class Swappable
       * @module Swappable
       * @extends Draggable
       */

      var Swappable = /*#__PURE__*/function (_Draggable2$default2) {
        _inheritsLoose(Swappable, _Draggable2$default2);

        /**
         * Swappable constructor.
         * @constructs Swappable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Swappable containers
         * @param {Object} options - Options for Swappable
         */
        function Swappable() {
          var _this10;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this10 = _Draggable2$default2.call(this, containers, _extends({}, options, {
            announcements: _extends({}, defaultAnnouncements, options.announcements || {})
          })) || this;
          /**
           * Last draggable element that was dragged over
           * @property lastOver
           * @type {HTMLElement}
           */

          _this10.lastOver = null;
          _this10[onDragStart] = _this10[onDragStart].bind(_assertThisInitialized(_this10));
          _this10[onDragOver] = _this10[onDragOver].bind(_assertThisInitialized(_this10));
          _this10[onDragStop] = _this10[onDragStop].bind(_assertThisInitialized(_this10));

          _this10.on('drag:start', _this10[onDragStart]).on('drag:over', _this10[onDragOver]).on('drag:stop', _this10[onDragStop]);

          return _this10;
        }
        /**
         * Destroys Swappable instance.
         */


        var _proto6 = Swappable.prototype;

        _proto6.destroy = function destroy() {
          _Draggable2$default2.prototype.destroy.call(this);

          this.off('drag:start', this._onDragStart).off('drag:over', this._onDragOver).off('drag:stop', this._onDragStop);
        }
        /**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */
        ;

        _proto6[onDragStart] = function (event) {
          var swappableStartEvent = new _SwappableEvent.SwappableStartEvent({
            dragEvent: event
          });
          this.trigger(swappableStartEvent);

          if (swappableStartEvent.canceled()) {
            event.cancel();
          }
        }
        /**
         * Drag over handler
         * @private
         * @param {DragOverEvent} event - Drag over event
         */
        ;

        _proto6[onDragOver] = function (event) {
          if (event.over === event.originalSource || event.over === event.source || event.canceled()) {
            return;
          }

          var swappableSwapEvent = new _SwappableEvent.SwappableSwapEvent({
            dragEvent: event,
            over: event.over,
            overContainer: event.overContainer
          });
          this.trigger(swappableSwapEvent);

          if (swappableSwapEvent.canceled()) {
            return;
          } // swap originally swapped element back


          if (this.lastOver && this.lastOver !== event.over) {
            swap(this.lastOver, event.source);
          }

          if (this.lastOver === event.over) {
            this.lastOver = null;
          } else {
            this.lastOver = event.over;
          }

          swap(event.source, event.over);
          var swappableSwappedEvent = new _SwappableEvent.SwappableSwappedEvent({
            dragEvent: event,
            swappedElement: event.over
          });
          this.trigger(swappableSwappedEvent);
        }
        /**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */
        ;

        _proto6[onDragStop] = function (event) {
          var swappableStopEvent = new _SwappableEvent.SwappableStopEvent({
            dragEvent: event
          });
          this.trigger(swappableStopEvent);
          this.lastOver = null;
        };

        return Swappable;
      }(_Draggable2["default"]);

      exports["default"] = Swappable;

      function withTempElement(callback) {
        var tmpElement = document.createElement('div');
        callback(tmpElement);
        tmpElement.parentNode.removeChild(tmpElement);
      }

      function swap(source, over) {
        var overParent = over.parentNode;
        var sourceParent = source.parentNode;
        withTempElement(function (tmpElement) {
          sourceParent.insertBefore(tmpElement, source);
          overParent.insertBefore(source, over);
          sourceParent.insertBefore(over, tmpElement);
        });
      }
      /***/

    },
    /* 30 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.SwappableStopEvent = exports.SwappableSwappedEvent = exports.SwappableSwapEvent = exports.SwappableStartEvent = exports.SwappableEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base swappable event
       * @class SwappableEvent
       * @module SwappableEvent
       * @extends AbstractEvent
       */


      var SwappableEvent = /*#__PURE__*/function (_AbstractEvent2$defau4) {
        _inheritsLoose(SwappableEvent, _AbstractEvent2$defau4);

        function SwappableEvent() {
          return _AbstractEvent2$defau4.apply(this, arguments) || this;
        }

        _createClass(SwappableEvent, [{
          key: "dragEvent",

          /**
           * Original drag event that triggered this swappable event
           * @property dragEvent
           * @type {DragEvent}
           * @readonly
           */
          get: function get() {
            return this.data.dragEvent;
          }
        }]);

        return SwappableEvent;
      }(_AbstractEvent2["default"]);

      exports.SwappableEvent = SwappableEvent;
      /**
       * Swappable start event
       * @class SwappableStartEvent
       * @module SwappableStartEvent
       * @extends SwappableEvent
       */

      SwappableEvent.type = 'swappable';

      var SwappableStartEvent = /*#__PURE__*/function (_SwappableEvent2) {
        _inheritsLoose(SwappableStartEvent, _SwappableEvent2);

        function SwappableStartEvent() {
          return _SwappableEvent2.apply(this, arguments) || this;
        }

        return SwappableStartEvent;
      }(SwappableEvent);

      exports.SwappableStartEvent = SwappableStartEvent;
      /**
       * Swappable swap event
       * @class SwappableSwapEvent
       * @module SwappableSwapEvent
       * @extends SwappableEvent
       */

      SwappableStartEvent.type = 'swappable:start';
      SwappableStartEvent.cancelable = true;

      var SwappableSwapEvent = /*#__PURE__*/function (_SwappableEvent3) {
        _inheritsLoose(SwappableSwapEvent, _SwappableEvent3);

        function SwappableSwapEvent() {
          return _SwappableEvent3.apply(this, arguments) || this;
        }

        _createClass(SwappableSwapEvent, [{
          key: "over",

          /**
           * Draggable element you are over
           * @property over
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.over;
          }
          /**
           * Draggable container you are over
           * @property overContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "overContainer",
          get: function get() {
            return this.data.overContainer;
          }
        }]);

        return SwappableSwapEvent;
      }(SwappableEvent);

      exports.SwappableSwapEvent = SwappableSwapEvent;
      /**
       * Swappable swapped event
       * @class SwappableSwappedEvent
       * @module SwappableSwappedEvent
       * @extends SwappableEvent
       */

      SwappableSwapEvent.type = 'swappable:swap';
      SwappableSwapEvent.cancelable = true;

      var SwappableSwappedEvent = /*#__PURE__*/function (_SwappableEvent4) {
        _inheritsLoose(SwappableSwappedEvent, _SwappableEvent4);

        function SwappableSwappedEvent() {
          return _SwappableEvent4.apply(this, arguments) || this;
        }

        _createClass(SwappableSwappedEvent, [{
          key: "swappedElement",

          /**
           * The draggable element that you swapped with
           * @property swappedElement
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.swappedElement;
          }
        }]);

        return SwappableSwappedEvent;
      }(SwappableEvent);

      exports.SwappableSwappedEvent = SwappableSwappedEvent;
      /**
       * Swappable stop event
       * @class SwappableStopEvent
       * @module SwappableStopEvent
       * @extends SwappableEvent
       */

      SwappableSwappedEvent.type = 'swappable:swapped';

      var SwappableStopEvent = /*#__PURE__*/function (_SwappableEvent5) {
        _inheritsLoose(SwappableStopEvent, _SwappableEvent5);

        function SwappableStopEvent() {
          return _SwappableEvent5.apply(this, arguments) || this;
        }

        return SwappableStopEvent;
      }(SwappableEvent);

      exports.SwappableStopEvent = SwappableStopEvent;
      SwappableStopEvent.type = 'swappable:stop';
      /***/
    },
    /* 31 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _SwappableEvent = __webpack_require__(10);

      Object.keys(_SwappableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _SwappableEvent[key];
          }
        });
      });

      var _Swappable = __webpack_require__(29);

      var _Swappable2 = _interopRequireDefault(_Swappable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Swappable2["default"];
      /***/
    },
    /* 32 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _utils = __webpack_require__(2);

      var _Draggable = __webpack_require__(5);

      var _Draggable2 = _interopRequireDefault(_Draggable);

      var _DroppableEvent = __webpack_require__(11);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragStart = Symbol('onDragStart');
      var onDragMove = Symbol('onDragMove');
      var onDragStop = Symbol('onDragStop');
      var dropInDropzone = Symbol('dropInDropZone');
      var returnToOriginalDropzone = Symbol('returnToOriginalDropzone');
      var closestDropzone = Symbol('closestDropzone');
      var getDropzones = Symbol('getDropzones');
      /**
       * Returns an announcement message when the Draggable element is dropped into a dropzone element
       * @param {DroppableDroppedEvent} droppableEvent
       * @return {String}
       */

      function onDroppableDroppedDefaultAnnouncement(_ref16) {
        var dragEvent = _ref16.dragEvent,
            dropzone = _ref16.dropzone;
        var sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';
        var dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';
        return "Dropped ".concat(sourceText, " into ").concat(dropzoneText);
      }
      /**
       * Returns an announcement message when the Draggable element has returned to its original dropzone element
       * @param {DroppableReturnedEvent} droppableEvent
       * @return {String}
       */


      function onDroppableReturnedDefaultAnnouncement(_ref17) {
        var dragEvent = _ref17.dragEvent,
            dropzone = _ref17.dropzone;
        var sourceText = dragEvent.source.textContent.trim() || dragEvent.source.id || 'draggable element';
        var dropzoneText = dropzone.textContent.trim() || dropzone.id || 'droppable element';
        return "Returned ".concat(sourceText, " from ").concat(dropzoneText);
      }
      /**
       * @const {Object} defaultAnnouncements
       * @const {Function} defaultAnnouncements['droppable:dropped']
       * @const {Function} defaultAnnouncements['droppable:returned']
       */


      var defaultAnnouncements = {
        'droppable:dropped': onDroppableDroppedDefaultAnnouncement,
        'droppable:returned': onDroppableReturnedDefaultAnnouncement
      };
      var defaultClasses = {
        'droppable:active': 'draggable-dropzone--active',
        'droppable:occupied': 'draggable-dropzone--occupied'
      };
      var defaultOptions = {
        dropzone: '.draggable-droppable'
      };
      /**
       * Droppable is built on top of Draggable and allows dropping draggable elements
       * into dropzone element
       * @class Droppable
       * @module Droppable
       * @extends Draggable
       */

      var Droppable = /*#__PURE__*/function (_Draggable2$default3) {
        _inheritsLoose(Droppable, _Draggable2$default3);

        /**
         * Droppable constructor.
         * @constructs Droppable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Droppable containers
         * @param {Object} options - Options for Droppable
         */
        function Droppable() {
          var _this11;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this11 = _Draggable2$default3.call(this, containers, _extends({}, defaultOptions, options, {
            classes: _extends({}, defaultClasses, options.classes || {}),
            announcements: _extends({}, defaultAnnouncements, options.announcements || {})
          })) || this;
          /**
           * All dropzone elements on drag start
           * @property dropzones
           * @type {HTMLElement[]}
           */

          _this11.dropzones = null;
          /**
           * Last dropzone element that the source was dropped into
           * @property lastDropzone
           * @type {HTMLElement}
           */

          _this11.lastDropzone = null;
          /**
           * Initial dropzone element that the source was drag from
           * @property initialDropzone
           * @type {HTMLElement}
           */

          _this11.initialDropzone = null;
          _this11[onDragStart] = _this11[onDragStart].bind(_assertThisInitialized(_this11));
          _this11[onDragMove] = _this11[onDragMove].bind(_assertThisInitialized(_this11));
          _this11[onDragStop] = _this11[onDragStop].bind(_assertThisInitialized(_this11));

          _this11.on('drag:start', _this11[onDragStart]).on('drag:move', _this11[onDragMove]).on('drag:stop', _this11[onDragStop]);

          return _this11;
        }
        /**
         * Destroys Droppable instance.
         */


        var _proto7 = Droppable.prototype;

        _proto7.destroy = function destroy() {
          _Draggable2$default3.prototype.destroy.call(this);

          this.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);
        }
        /**
         * Drag start handler
         * @private
         * @param {DragStartEvent} event - Drag start event
         */
        ;

        _proto7[onDragStart] = function (event) {
          if (event.canceled()) {
            return;
          }

          this.dropzones = _toConsumableArray(this[getDropzones]());
          var dropzone = (0, _utils.closest)(event.sensorEvent.target, this.options.dropzone);

          if (!dropzone) {
            event.cancel();
            return;
          }

          var droppableStartEvent = new _DroppableEvent.DroppableStartEvent({
            dragEvent: event,
            dropzone: dropzone
          });
          this.trigger(droppableStartEvent);

          if (droppableStartEvent.canceled()) {
            event.cancel();
            return;
          }

          this.initialDropzone = dropzone;

          var _iterator = _createForOfIteratorHelper(this.dropzones),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var dropzoneElement = _step.value;

              if (dropzoneElement.classList.contains(this.getClassNameFor('droppable:occupied'))) {
                continue;
              }

              dropzoneElement.classList.add(this.getClassNameFor('droppable:active'));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        /**
         * Drag move handler
         * @private
         * @param {DragMoveEvent} event - Drag move event
         */
        ;

        _proto7[onDragMove] = function (event) {
          if (event.canceled()) {
            return;
          }

          var dropzone = this[closestDropzone](event.sensorEvent.target);
          var overEmptyDropzone = dropzone && !dropzone.classList.contains(this.getClassNameFor('droppable:occupied'));

          if (overEmptyDropzone && this[dropInDropzone](event, dropzone)) {
            this.lastDropzone = dropzone;
          } else if ((!dropzone || dropzone === this.initialDropzone) && this.lastDropzone) {
            this[returnToOriginalDropzone](event);
            this.lastDropzone = null;
          }
        }
        /**
         * Drag stop handler
         * @private
         * @param {DragStopEvent} event - Drag stop event
         */
        ;

        _proto7[onDragStop] = function (event) {
          var droppableStopEvent = new _DroppableEvent.DroppableStopEvent({
            dragEvent: event,
            dropzone: this.lastDropzone || this.initialDropzone
          });
          this.trigger(droppableStopEvent);
          var occupiedClass = this.getClassNameFor('droppable:occupied');

          var _iterator2 = _createForOfIteratorHelper(this.dropzones),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var dropzone = _step2.value;
              dropzone.classList.remove(this.getClassNameFor('droppable:active'));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          if (this.lastDropzone && this.lastDropzone !== this.initialDropzone) {
            this.initialDropzone.classList.remove(occupiedClass);
          }

          this.dropzones = null;
          this.lastDropzone = null;
          this.initialDropzone = null;
        }
        /**
         * Drops a draggable element into a dropzone element
         * @private
         * @param {DragMoveEvent} event - Drag move event
         * @param {HTMLElement} dropzone - Dropzone element to drop draggable into
         */
        ;

        _proto7[dropInDropzone] = function (event, dropzone) {
          var droppableDroppedEvent = new _DroppableEvent.DroppableDroppedEvent({
            dragEvent: event,
            dropzone: dropzone
          });
          this.trigger(droppableDroppedEvent);

          if (droppableDroppedEvent.canceled()) {
            return false;
          }

          var occupiedClass = this.getClassNameFor('droppable:occupied');

          if (this.lastDropzone) {
            this.lastDropzone.classList.remove(occupiedClass);
          }

          dropzone.appendChild(event.source);
          dropzone.classList.add(occupiedClass);
          return true;
        }
        /**
         * Moves the previously dropped element back into its original dropzone
         * @private
         * @param {DragMoveEvent} event - Drag move event
         */
        ;

        _proto7[returnToOriginalDropzone] = function (event) {
          var droppableReturnedEvent = new _DroppableEvent.DroppableReturnedEvent({
            dragEvent: event,
            dropzone: this.lastDropzone
          });
          this.trigger(droppableReturnedEvent);

          if (droppableReturnedEvent.canceled()) {
            return;
          }

          this.initialDropzone.appendChild(event.source);
          this.lastDropzone.classList.remove(this.getClassNameFor('droppable:occupied'));
        }
        /**
         * Returns closest dropzone element for even target
         * @private
         * @param {HTMLElement} target - Event target
         * @return {HTMLElement|null}
         */
        ;

        _proto7[closestDropzone] = function (target) {
          if (!this.dropzones) {
            return null;
          }

          return (0, _utils.closest)(target, this.dropzones);
        }
        /**
         * Returns all current dropzone elements for this draggable instance
         * @private
         * @return {NodeList|HTMLElement[]|Array}
         */
        ;

        _proto7[getDropzones] = function () {
          var dropzone = this.options.dropzone;

          if (typeof dropzone === 'string') {
            return document.querySelectorAll(dropzone);
          } else if (dropzone instanceof NodeList || dropzone instanceof Array) {
            return dropzone;
          } else if (typeof dropzone === 'function') {
            return dropzone();
          } else {
            return [];
          }
        };

        return Droppable;
      }(_Draggable2["default"]);

      exports["default"] = Droppable;
      /***/
    },
    /* 33 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DroppableStopEvent = exports.DroppableReturnedEvent = exports.DroppableDroppedEvent = exports.DroppableStartEvent = exports.DroppableEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base droppable event
       * @class DroppableEvent
       * @module DroppableEvent
       * @extends AbstractEvent
       */


      var DroppableEvent = /*#__PURE__*/function (_AbstractEvent2$defau5) {
        _inheritsLoose(DroppableEvent, _AbstractEvent2$defau5);

        function DroppableEvent() {
          return _AbstractEvent2$defau5.apply(this, arguments) || this;
        }

        _createClass(DroppableEvent, [{
          key: "dragEvent",

          /**
           * Original drag event that triggered this droppable event
           * @property dragEvent
           * @type {DragEvent}
           * @readonly
           */
          get: function get() {
            return this.data.dragEvent;
          }
        }]);

        return DroppableEvent;
      }(_AbstractEvent2["default"]);

      exports.DroppableEvent = DroppableEvent;
      /**
       * Droppable start event
       * @class DroppableStartEvent
       * @module DroppableStartEvent
       * @extends DroppableEvent
       */

      DroppableEvent.type = 'droppable';

      var DroppableStartEvent = /*#__PURE__*/function (_DroppableEvent2) {
        _inheritsLoose(DroppableStartEvent, _DroppableEvent2);

        function DroppableStartEvent() {
          return _DroppableEvent2.apply(this, arguments) || this;
        }

        _createClass(DroppableStartEvent, [{
          key: "dropzone",

          /**
           * The initial dropzone element of the currently dragging draggable element
           * @property dropzone
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.dropzone;
          }
        }]);

        return DroppableStartEvent;
      }(DroppableEvent);

      exports.DroppableStartEvent = DroppableStartEvent;
      /**
       * Droppable dropped event
       * @class DroppableDroppedEvent
       * @module DroppableDroppedEvent
       * @extends DroppableEvent
       */

      DroppableStartEvent.type = 'droppable:start';
      DroppableStartEvent.cancelable = true;

      var DroppableDroppedEvent = /*#__PURE__*/function (_DroppableEvent3) {
        _inheritsLoose(DroppableDroppedEvent, _DroppableEvent3);

        function DroppableDroppedEvent() {
          return _DroppableEvent3.apply(this, arguments) || this;
        }

        _createClass(DroppableDroppedEvent, [{
          key: "dropzone",

          /**
           * The dropzone element you dropped the draggable element into
           * @property dropzone
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.dropzone;
          }
        }]);

        return DroppableDroppedEvent;
      }(DroppableEvent);

      exports.DroppableDroppedEvent = DroppableDroppedEvent;
      /**
       * Droppable returned event
       * @class DroppableReturnedEvent
       * @module DroppableReturnedEvent
       * @extends DroppableEvent
       */

      DroppableDroppedEvent.type = 'droppable:dropped';
      DroppableDroppedEvent.cancelable = true;

      var DroppableReturnedEvent = /*#__PURE__*/function (_DroppableEvent4) {
        _inheritsLoose(DroppableReturnedEvent, _DroppableEvent4);

        function DroppableReturnedEvent() {
          return _DroppableEvent4.apply(this, arguments) || this;
        }

        _createClass(DroppableReturnedEvent, [{
          key: "dropzone",

          /**
           * The dropzone element you dragged away from
           * @property dropzone
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.dropzone;
          }
        }]);

        return DroppableReturnedEvent;
      }(DroppableEvent);

      exports.DroppableReturnedEvent = DroppableReturnedEvent;
      /**
       * Droppable stop event
       * @class DroppableStopEvent
       * @module DroppableStopEvent
       * @extends DroppableEvent
       */

      DroppableReturnedEvent.type = 'droppable:returned';
      DroppableReturnedEvent.cancelable = true;

      var DroppableStopEvent = /*#__PURE__*/function (_DroppableEvent5) {
        _inheritsLoose(DroppableStopEvent, _DroppableEvent5);

        function DroppableStopEvent() {
          return _DroppableEvent5.apply(this, arguments) || this;
        }

        _createClass(DroppableStopEvent, [{
          key: "dropzone",

          /**
           * The final dropzone element of the draggable element
           * @property dropzone
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.dropzone;
          }
        }]);

        return DroppableStopEvent;
      }(DroppableEvent);

      exports.DroppableStopEvent = DroppableStopEvent;
      DroppableStopEvent.type = 'droppable:stop';
      DroppableStopEvent.cancelable = true;
      /***/
    },
    /* 34 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DroppableEvent = __webpack_require__(11);

      Object.keys(_DroppableEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _DroppableEvent[key];
          }
        });
      });

      var _Droppable = __webpack_require__(32);

      var _Droppable2 = _interopRequireDefault(_Droppable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Droppable2["default"];
      /***/
    },
    /* 35 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      /**
       * The Emitter is a simple emitter class that provides you with `on()`, `off()` and `trigger()` methods
       * @class Emitter
       * @module Emitter
       */

      var Emitter = /*#__PURE__*/function () {
        function Emitter() {
          this.callbacks = {};
        }
        /**
         * Registers callbacks by event name
         * @param {String} type
         * @param {...Function} callbacks
         */


        var _proto8 = Emitter.prototype;

        _proto8.on = function on(type) {
          var _this$callbacks$type;

          if (!this.callbacks[type]) {
            this.callbacks[type] = [];
          }

          for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            callbacks[_key - 1] = arguments[_key];
          }

          (_this$callbacks$type = this.callbacks[type]).push.apply(_this$callbacks$type, callbacks);

          return this;
        }
        /**
         * Unregisters callbacks by event name
         * @param {String} type
         * @param {Function} callback
         */
        ;

        _proto8.off = function off(type, callback) {
          if (!this.callbacks[type]) {
            return null;
          }

          var copy = this.callbacks[type].slice(0);

          for (var i = 0; i < copy.length; i++) {
            if (callback === copy[i]) {
              this.callbacks[type].splice(i, 1);
            }
          }

          return this;
        }
        /**
         * Triggers event callbacks by event object
         * @param {AbstractEvent} event
         */
        ;

        _proto8.trigger = function trigger(event) {
          if (!this.callbacks[event.type]) {
            return null;
          }

          var callbacks = _toConsumableArray(this.callbacks[event.type]);

          var caughtErrors = [];

          for (var i = callbacks.length - 1; i >= 0; i--) {
            var callback = callbacks[i];

            try {
              callback(event);
            } catch (error) {
              caughtErrors.push(error);
            }
          }

          if (caughtErrors.length) {
            /* eslint-disable no-console */
            console.error("Draggable caught errors while triggering '".concat(event.type, "'"), caughtErrors);
            /* eslint-disable no-console */
          }

          return this;
        };

        return Emitter;
      }();

      exports["default"] = Emitter;
      /***/
    },
    /* 36 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Emitter = __webpack_require__(35);

      var _Emitter2 = _interopRequireDefault(_Emitter);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Emitter2["default"];
      /***/
    },
    /* 37 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _utils = __webpack_require__(2);

      var _Plugins = __webpack_require__(12);

      var _Emitter = __webpack_require__(36);

      var _Emitter2 = _interopRequireDefault(_Emitter);

      var _Sensors = __webpack_require__(6);

      var _DraggableEvent = __webpack_require__(13);

      var _DragEvent = __webpack_require__(14);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragStart = Symbol('onDragStart');
      var onDragMove = Symbol('onDragMove');
      var onDragStop = Symbol('onDragStop');
      var onDragPressure = Symbol('onDragPressure');
      /**
       * @const {Object} defaultAnnouncements
       * @const {Function} defaultAnnouncements['drag:start']
       * @const {Function} defaultAnnouncements['drag:stop']
       */

      var defaultAnnouncements = {
        'drag:start': function dragStart(event) {
          return "Picked up ".concat(event.source.textContent.trim() || event.source.id || 'draggable element');
        },
        'drag:stop': function dragStop(event) {
          return "Released ".concat(event.source.textContent.trim() || event.source.id || 'draggable element');
        }
      };
      var defaultClasses = {
        'container:dragging': 'draggable-container--is-dragging',
        'source:dragging': 'draggable-source--is-dragging',
        'source:placed': 'draggable-source--placed',
        'container:placed': 'draggable-container--placed',
        'body:dragging': 'draggable--is-dragging',
        'draggable:over': 'draggable--over',
        'container:over': 'draggable-container--over',
        'source:original': 'draggable--original',
        mirror: 'draggable-mirror'
      };
      var defaultOptions = exports.defaultOptions = {
        draggable: '.draggable-source',
        handle: null,
        delay: 100,
        placedTimeout: 800,
        plugins: [],
        sensors: []
      };
      /**
       * This is the core draggable library that does the heavy lifting
       * @class Draggable
       * @module Draggable
       */

      var Draggable = /*#__PURE__*/function () {
        /**
         * Draggable constructor.
         * @constructs Draggable
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Draggable containers
         * @param {Object} options - Options for draggable
         */
        function Draggable() {
          var _this12 = this;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [document.body];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          /**
           * Draggable containers
           * @property containers
           * @type {HTMLElement[]}
           */
          if (containers instanceof NodeList || containers instanceof Array) {
            this.containers = _toConsumableArray(containers);
          } else if (containers instanceof HTMLElement) {
            this.containers = [containers];
          } else {
            throw new Error('Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`');
          }

          this.options = _extends({}, defaultOptions, options, {
            classes: _extends({}, defaultClasses, options.classes || {}),
            announcements: _extends({}, defaultAnnouncements, options.announcements || {})
          });
          /**
           * Draggables event emitter
           * @property emitter
           * @type {Emitter}
           */

          this.emitter = new _Emitter2["default"]();
          /**
           * Current drag state
           * @property dragging
           * @type {Boolean}
           */

          this.dragging = false;
          /**
           * Active plugins
           * @property plugins
           * @type {Plugin[]}
           */

          this.plugins = [];
          /**
           * Active sensors
           * @property sensors
           * @type {Sensor[]}
           */

          this.sensors = [];
          this[onDragStart] = this[onDragStart].bind(this);
          this[onDragMove] = this[onDragMove].bind(this);
          this[onDragStop] = this[onDragStop].bind(this);
          this[onDragPressure] = this[onDragPressure].bind(this);
          document.addEventListener('drag:start', this[onDragStart], true);
          document.addEventListener('drag:move', this[onDragMove], true);
          document.addEventListener('drag:stop', this[onDragStop], true);
          document.addEventListener('drag:pressure', this[onDragPressure], true);
          var defaultPlugins = Object.values(Draggable.Plugins).map(function (Plugin) {
            return Plugin;
          });
          var defaultSensors = [_Sensors.MouseSensor, _Sensors.TouchSensor];
          this.addPlugin.apply(this, [].concat(_toConsumableArray(defaultPlugins), _toConsumableArray(this.options.plugins)));
          this.addSensor.apply(this, [].concat(defaultSensors, _toConsumableArray(this.options.sensors)));
          var draggableInitializedEvent = new _DraggableEvent.DraggableInitializedEvent({
            draggable: this
          });
          this.on('mirror:created', function (_ref18) {
            var mirror = _ref18.mirror;
            return _this12.mirror = mirror;
          });
          this.on('mirror:destroy', function () {
            return _this12.mirror = null;
          });
          this.trigger(draggableInitializedEvent);
        }
        /**
         * Destroys Draggable instance. This removes all internal event listeners and
         * deactivates sensors and plugins
         */

        /**
         * Default plugins draggable uses
         * @static
         * @property {Object} Plugins
         * @property {Announcement} Plugins.Announcement
         * @property {Focusable} Plugins.Focusable
         * @property {Mirror} Plugins.Mirror
         * @property {Scrollable} Plugins.Scrollable
         * @type {Object}
         */


        var _proto9 = Draggable.prototype;

        _proto9.destroy = function destroy() {
          document.removeEventListener('drag:start', this[onDragStart], true);
          document.removeEventListener('drag:move', this[onDragMove], true);
          document.removeEventListener('drag:stop', this[onDragStop], true);
          document.removeEventListener('drag:pressure', this[onDragPressure], true);
          var draggableDestroyEvent = new _DraggableEvent.DraggableDestroyEvent({
            draggable: this
          });
          this.trigger(draggableDestroyEvent);
          this.removePlugin.apply(this, _toConsumableArray(this.plugins.map(function (plugin) {
            return plugin.constructor;
          })));
          this.removeSensor.apply(this, _toConsumableArray(this.sensors.map(function (sensor) {
            return sensor.constructor;
          })));
        }
        /**
         * Adds plugin to this draggable instance. This will end up calling the attach method of the plugin
         * @param {...typeof Plugin} plugins - Plugins that you want attached to draggable
         * @return {Draggable}
         * @example draggable.addPlugin(CustomA11yPlugin, CustomMirrorPlugin)
         */
        ;

        _proto9.addPlugin = function addPlugin() {
          var _this13 = this;

          for (var _len2 = arguments.length, plugins = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            plugins[_key2] = arguments[_key2];
          }

          var activePlugins = plugins.map(function (Plugin) {
            return new Plugin(_this13);
          });
          activePlugins.forEach(function (plugin) {
            return plugin.attach();
          });
          this.plugins = [].concat(_toConsumableArray(this.plugins), _toConsumableArray(activePlugins));
          return this;
        }
        /**
         * Removes plugins that are already attached to this draggable instance. This will end up calling
         * the detach method of the plugin
         * @param {...typeof Plugin} plugins - Plugins that you want detached from draggable
         * @return {Draggable}
         * @example draggable.removePlugin(MirrorPlugin, CustomMirrorPlugin)
         */
        ;

        _proto9.removePlugin = function removePlugin() {
          for (var _len3 = arguments.length, plugins = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            plugins[_key3] = arguments[_key3];
          }

          var removedPlugins = this.plugins.filter(function (plugin) {
            return plugins.includes(plugin.constructor);
          });
          removedPlugins.forEach(function (plugin) {
            return plugin.detach();
          });
          this.plugins = this.plugins.filter(function (plugin) {
            return !plugins.includes(plugin.constructor);
          });
          return this;
        }
        /**
         * Adds sensors to this draggable instance. This will end up calling the attach method of the sensor
         * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable
         * @return {Draggable}
         * @example draggable.addSensor(ForceTouchSensor, CustomSensor)
         */
        ;

        _proto9.addSensor = function addSensor() {
          var _this14 = this;

          for (var _len4 = arguments.length, sensors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            sensors[_key4] = arguments[_key4];
          }

          var activeSensors = sensors.map(function (Sensor) {
            return new Sensor(_this14.containers, _this14.options);
          });
          activeSensors.forEach(function (sensor) {
            return sensor.attach();
          });
          this.sensors = [].concat(_toConsumableArray(this.sensors), _toConsumableArray(activeSensors));
          return this;
        }
        /**
         * Removes sensors that are already attached to this draggable instance. This will end up calling
         * the detach method of the sensor
         * @param {...typeof Sensor} sensors - Sensors that you want attached to draggable
         * @return {Draggable}
         * @example draggable.removeSensor(TouchSensor, DragSensor)
         */
        ;

        _proto9.removeSensor = function removeSensor() {
          for (var _len5 = arguments.length, sensors = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            sensors[_key5] = arguments[_key5];
          }

          var removedSensors = this.sensors.filter(function (sensor) {
            return sensors.includes(sensor.constructor);
          });
          removedSensors.forEach(function (sensor) {
            return sensor.detach();
          });
          this.sensors = this.sensors.filter(function (sensor) {
            return !sensors.includes(sensor.constructor);
          });
          return this;
        }
        /**
         * Adds container to this draggable instance
         * @param {...HTMLElement} containers - Containers you want to add to draggable
         * @return {Draggable}
         * @example draggable.addContainer(document.body)
         */
        ;

        _proto9.addContainer = function addContainer() {
          for (var _len6 = arguments.length, containers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            containers[_key6] = arguments[_key6];
          }

          this.containers = [].concat(_toConsumableArray(this.containers), containers);
          this.sensors.forEach(function (sensor) {
            return sensor.addContainer.apply(sensor, containers);
          });
          return this;
        }
        /**
         * Removes container from this draggable instance
         * @param {...HTMLElement} containers - Containers you want to remove from draggable
         * @return {Draggable}
         * @example draggable.removeContainer(document.body)
         */
        ;

        _proto9.removeContainer = function removeContainer() {
          for (var _len7 = arguments.length, containers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            containers[_key7] = arguments[_key7];
          }

          this.containers = this.containers.filter(function (container) {
            return !containers.includes(container);
          });
          this.sensors.forEach(function (sensor) {
            return sensor.removeContainer.apply(sensor, containers);
          });
          return this;
        }
        /**
         * Adds listener for draggable events
         * @param {String} type - Event name
         * @param {...Function} callbacks - Event callbacks
         * @return {Draggable}
         * @example draggable.on('drag:start', (dragEvent) => dragEvent.cancel());
         */
        ;

        _proto9.on = function on(type) {
          var _this$emitter;

          for (var _len8 = arguments.length, callbacks = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
            callbacks[_key8 - 1] = arguments[_key8];
          }

          (_this$emitter = this.emitter).on.apply(_this$emitter, [type].concat(callbacks));

          return this;
        }
        /**
         * Removes listener from draggable
         * @param {String} type - Event name
         * @param {Function} callback - Event callback
         * @return {Draggable}
         * @example draggable.off('drag:start', handlerFunction);
         */
        ;

        _proto9.off = function off(type, callback) {
          this.emitter.off(type, callback);
          return this;
        }
        /**
         * Triggers draggable event
         * @param {AbstractEvent} event - Event instance
         * @return {Draggable}
         * @example draggable.trigger(event);
         */
        ;

        _proto9.trigger = function trigger(event) {
          this.emitter.trigger(event);
          return this;
        }
        /**
         * Returns class name for class identifier
         * @param {String} name - Name of class identifier
         * @return {String|null}
         */
        ;

        _proto9.getClassNameFor = function getClassNameFor(name) {
          return this.options.classes[name];
        }
        /**
         * Returns true if this draggable instance is currently dragging
         * @return {Boolean}
         */
        ;

        _proto9.isDragging = function isDragging() {
          return Boolean(this.dragging);
        }
        /**
         * Returns all draggable elements
         * @return {HTMLElement[]}
         */
        ;

        _proto9.getDraggableElements = function getDraggableElements() {
          var _this15 = this;

          return this.containers.reduce(function (current, container) {
            return [].concat(_toConsumableArray(current), _toConsumableArray(_this15.getDraggableElementsForContainer(container)));
          }, []);
        }
        /**
         * Returns draggable elements for a given container, excluding the mirror and
         * original source element if present
         * @param {HTMLElement} container
         * @return {HTMLElement[]}
         */
        ;

        _proto9.getDraggableElementsForContainer = function getDraggableElementsForContainer(container) {
          var _this16 = this;

          var allDraggableElements = container.querySelectorAll(this.options.draggable);
          return _toConsumableArray(allDraggableElements).filter(function (childElement) {
            return childElement !== _this16.originalSource && childElement !== _this16.mirror;
          });
        }
        /**
         * Drag start handler
         * @private
         * @param {Event} event - DOM Drag event
         */
        ;

        _proto9[onDragStart] = function (event) {
          var _this17 = this;

          var sensorEvent = getSensorEvent(event);
          var target = sensorEvent.target,
              container = sensorEvent.container;

          if (!this.containers.includes(container)) {
            return;
          }

          if (this.options.handle && target && !(0, _utils.closest)(target, this.options.handle)) {
            sensorEvent.cancel();
            return;
          } // Find draggable source element


          this.originalSource = (0, _utils.closest)(target, this.options.draggable);
          this.sourceContainer = container;

          if (!this.originalSource) {
            sensorEvent.cancel();
            return;
          }

          if (this.lastPlacedSource && this.lastPlacedContainer) {
            clearTimeout(this.placedTimeoutID);
            this.lastPlacedSource.classList.remove(this.getClassNameFor('source:placed'));
            this.lastPlacedContainer.classList.remove(this.getClassNameFor('container:placed'));
          }

          this.source = this.originalSource.cloneNode(true);
          this.originalSource.parentNode.insertBefore(this.source, this.originalSource);
          this.originalSource.style.display = 'none';
          var dragEvent = new _DragEvent.DragStartEvent({
            source: this.source,
            originalSource: this.originalSource,
            sourceContainer: container,
            sensorEvent: sensorEvent
          });
          this.trigger(dragEvent);
          this.dragging = !dragEvent.canceled();

          if (dragEvent.canceled()) {
            this.source.parentNode.removeChild(this.source);
            this.originalSource.style.display = null;
            return;
          }

          this.originalSource.classList.add(this.getClassNameFor('source:original'));
          this.source.classList.add(this.getClassNameFor('source:dragging'));
          this.sourceContainer.classList.add(this.getClassNameFor('container:dragging'));
          document.body.classList.add(this.getClassNameFor('body:dragging'));
          applyUserSelect(document.body, 'none');
          requestAnimationFrame(function () {
            var oldSensorEvent = getSensorEvent(event);
            var newSensorEvent = oldSensorEvent.clone({
              target: _this17.source
            });

            _this17[onDragMove](_extends({}, event, {
              detail: newSensorEvent
            }));
          });
        }
        /**
         * Drag move handler
         * @private
         * @param {Event} event - DOM Drag event
         */
        ;

        _proto9[onDragMove] = function (event) {
          if (!this.dragging) {
            return;
          }

          var sensorEvent = getSensorEvent(event);
          var container = sensorEvent.container;
          var target = sensorEvent.target;
          var dragMoveEvent = new _DragEvent.DragMoveEvent({
            source: this.source,
            originalSource: this.originalSource,
            sourceContainer: container,
            sensorEvent: sensorEvent
          });
          this.trigger(dragMoveEvent);

          if (dragMoveEvent.canceled()) {
            sensorEvent.cancel();
          }

          target = (0, _utils.closest)(target, this.options.draggable);
          var withinCorrectContainer = (0, _utils.closest)(sensorEvent.target, this.containers);
          var overContainer = sensorEvent.overContainer || withinCorrectContainer;
          var isLeavingContainer = this.currentOverContainer && overContainer !== this.currentOverContainer;
          var isLeavingDraggable = this.currentOver && target !== this.currentOver;
          var isOverContainer = overContainer && this.currentOverContainer !== overContainer;
          var isOverDraggable = withinCorrectContainer && target && this.currentOver !== target;

          if (isLeavingDraggable) {
            var dragOutEvent = new _DragEvent.DragOutEvent({
              source: this.source,
              originalSource: this.originalSource,
              sourceContainer: container,
              sensorEvent: sensorEvent,
              over: this.currentOver
            });
            this.currentOver.classList.remove(this.getClassNameFor('draggable:over'));
            this.currentOver = null;
            this.trigger(dragOutEvent);
          }

          if (isLeavingContainer) {
            var dragOutContainerEvent = new _DragEvent.DragOutContainerEvent({
              source: this.source,
              originalSource: this.originalSource,
              sourceContainer: container,
              sensorEvent: sensorEvent,
              overContainer: this.currentOverContainer
            });
            this.currentOverContainer.classList.remove(this.getClassNameFor('container:over'));
            this.currentOverContainer = null;
            this.trigger(dragOutContainerEvent);
          }

          if (isOverContainer) {
            overContainer.classList.add(this.getClassNameFor('container:over'));
            var dragOverContainerEvent = new _DragEvent.DragOverContainerEvent({
              source: this.source,
              originalSource: this.originalSource,
              sourceContainer: container,
              sensorEvent: sensorEvent,
              overContainer: overContainer
            });
            this.currentOverContainer = overContainer;
            this.trigger(dragOverContainerEvent);
          }

          if (isOverDraggable) {
            target.classList.add(this.getClassNameFor('draggable:over'));
            var dragOverEvent = new _DragEvent.DragOverEvent({
              source: this.source,
              originalSource: this.originalSource,
              sourceContainer: container,
              sensorEvent: sensorEvent,
              overContainer: overContainer,
              over: target
            });
            this.currentOver = target;
            this.trigger(dragOverEvent);
          }
        }
        /**
         * Drag stop handler
         * @private
         * @param {Event} event - DOM Drag event
         */
        ;

        _proto9[onDragStop] = function (event) {
          var _this18 = this;

          if (!this.dragging) {
            return;
          }

          this.dragging = false;
          var dragStopEvent = new _DragEvent.DragStopEvent({
            source: this.source,
            originalSource: this.originalSource,
            sensorEvent: event.sensorEvent,
            sourceContainer: this.sourceContainer
          });
          this.trigger(dragStopEvent);
          this.source.parentNode.insertBefore(this.originalSource, this.source);
          this.source.parentNode.removeChild(this.source);
          this.originalSource.style.display = '';
          this.source.classList.remove(this.getClassNameFor('source:dragging'));
          this.originalSource.classList.remove(this.getClassNameFor('source:original'));
          this.originalSource.classList.add(this.getClassNameFor('source:placed'));
          this.sourceContainer.classList.add(this.getClassNameFor('container:placed'));
          this.sourceContainer.classList.remove(this.getClassNameFor('container:dragging'));
          document.body.classList.remove(this.getClassNameFor('body:dragging'));
          applyUserSelect(document.body, '');

          if (this.currentOver) {
            this.currentOver.classList.remove(this.getClassNameFor('draggable:over'));
          }

          if (this.currentOverContainer) {
            this.currentOverContainer.classList.remove(this.getClassNameFor('container:over'));
          }

          this.lastPlacedSource = this.originalSource;
          this.lastPlacedContainer = this.sourceContainer;
          this.placedTimeoutID = setTimeout(function () {
            if (_this18.lastPlacedSource) {
              _this18.lastPlacedSource.classList.remove(_this18.getClassNameFor('source:placed'));
            }

            if (_this18.lastPlacedContainer) {
              _this18.lastPlacedContainer.classList.remove(_this18.getClassNameFor('container:placed'));
            }

            _this18.lastPlacedSource = null;
            _this18.lastPlacedContainer = null;
          }, this.options.placedTimeout);
          this.source = null;
          this.originalSource = null;
          this.currentOverContainer = null;
          this.currentOver = null;
          this.sourceContainer = null;
        }
        /**
         * Drag pressure handler
         * @private
         * @param {Event} event - DOM Drag event
         */
        ;

        _proto9[onDragPressure] = function (event) {
          if (!this.dragging) {
            return;
          }

          var sensorEvent = getSensorEvent(event);
          var source = this.source || (0, _utils.closest)(sensorEvent.originalEvent.target, this.options.draggable);
          var dragPressureEvent = new _DragEvent.DragPressureEvent({
            sensorEvent: sensorEvent,
            source: source,
            pressure: sensorEvent.pressure
          });
          this.trigger(dragPressureEvent);
        };

        return Draggable;
      }();

      exports["default"] = Draggable;
      Draggable.Plugins = {
        Announcement: _Plugins.Announcement,
        Focusable: _Plugins.Focusable,
        Mirror: _Plugins.Mirror,
        Scrollable: _Plugins.Scrollable
      };

      function getSensorEvent(event) {
        return event.detail;
      }

      function applyUserSelect(element, value) {
        element.style.webkitUserSelect = value;
        element.style.mozUserSelect = value;
        element.style.msUserSelect = value;
        element.style.oUserSelect = value;
        element.style.userSelect = value;
      }
      /***/

    },
    /* 38 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Sensor = __webpack_require__(4);

      var _Sensor2 = _interopRequireDefault(_Sensor);

      var _SensorEvent = __webpack_require__(3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onMouseForceWillBegin = Symbol('onMouseForceWillBegin');
      var onMouseForceDown = Symbol('onMouseForceDown');
      var onMouseDown = Symbol('onMouseDown');
      var onMouseForceChange = Symbol('onMouseForceChange');
      var onMouseMove = Symbol('onMouseMove');
      var onMouseUp = Symbol('onMouseUp');
      var onMouseForceGlobalChange = Symbol('onMouseForceGlobalChange');
      /**
       * This sensor picks up native force touch events and dictates drag operations
       * @class ForceTouchSensor
       * @module ForceTouchSensor
       * @extends Sensor
       */

      var ForceTouchSensor = /*#__PURE__*/function (_Sensor2$default) {
        _inheritsLoose(ForceTouchSensor, _Sensor2$default);

        /**
         * ForceTouchSensor constructor.
         * @constructs ForceTouchSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
        function ForceTouchSensor() {
          var _this19;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this19 = _Sensor2$default.call(this, containers, options) || this;
          /**
           * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed
           * @property mightDrag
           * @type {Boolean}
           */

          _this19.mightDrag = false;
          _this19[onMouseForceWillBegin] = _this19[onMouseForceWillBegin].bind(_assertThisInitialized(_this19));
          _this19[onMouseForceDown] = _this19[onMouseForceDown].bind(_assertThisInitialized(_this19));
          _this19[onMouseDown] = _this19[onMouseDown].bind(_assertThisInitialized(_this19));
          _this19[onMouseForceChange] = _this19[onMouseForceChange].bind(_assertThisInitialized(_this19));
          _this19[onMouseMove] = _this19[onMouseMove].bind(_assertThisInitialized(_this19));
          _this19[onMouseUp] = _this19[onMouseUp].bind(_assertThisInitialized(_this19));
          return _this19;
        }
        /**
         * Attaches sensors event listeners to the DOM
         */


        var _proto10 = ForceTouchSensor.prototype;

        _proto10.attach = function attach() {
          var _iterator3 = _createForOfIteratorHelper(this.containers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var container = _step3.value;
              container.addEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);
              container.addEventListener('webkitmouseforcedown', this[onMouseForceDown], false);
              container.addEventListener('mousedown', this[onMouseDown], true);
              container.addEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          document.addEventListener('mousemove', this[onMouseMove]);
          document.addEventListener('mouseup', this[onMouseUp]);
        }
        /**
         * Detaches sensors event listeners to the DOM
         */
        ;

        _proto10.detach = function detach() {
          var _iterator4 = _createForOfIteratorHelper(this.containers),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var container = _step4.value;
              container.removeEventListener('webkitmouseforcewillbegin', this[onMouseForceWillBegin], false);
              container.removeEventListener('webkitmouseforcedown', this[onMouseForceDown], false);
              container.removeEventListener('mousedown', this[onMouseDown], true);
              container.removeEventListener('webkitmouseforcechanged', this[onMouseForceChange], false);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          document.removeEventListener('mousemove', this[onMouseMove]);
          document.removeEventListener('mouseup', this[onMouseUp]);
        }
        /**
         * Mouse force will begin handler
         * @private
         * @param {Event} event - Mouse force will begin event
         */
        ;

        _proto10[onMouseForceWillBegin] = function (event) {
          event.preventDefault();
          this.mightDrag = true;
        }
        /**
         * Mouse force down handler
         * @private
         * @param {Event} event - Mouse force down event
         */
        ;

        _proto10[onMouseForceDown] = function (event) {
          if (this.dragging) {
            return;
          }

          var target = document.elementFromPoint(event.clientX, event.clientY);
          var container = event.currentTarget;
          var dragStartEvent = new _SensorEvent.DragStartSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: container,
            originalEvent: event
          });
          this.trigger(container, dragStartEvent);
          this.currentContainer = container;
          this.dragging = !dragStartEvent.canceled();
          this.mightDrag = false;
        }
        /**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */
        ;

        _proto10[onMouseUp] = function (event) {
          if (!this.dragging) {
            return;
          }

          var dragStopEvent = new _SensorEvent.DragStopSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: null,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragStopEvent);
          this.currentContainer = null;
          this.dragging = false;
          this.mightDrag = false;
        }
        /**
         * Mouse down handler
         * @private
         * @param {Event} event - Mouse down event
         */
        ;

        _proto10[onMouseDown] = function (event) {
          if (!this.mightDrag) {
            return;
          } // Need workaround for real click
          // Cancel potential drag events


          event.stopPropagation();
          event.stopImmediatePropagation();
          event.preventDefault();
        }
        /**
         * Mouse move handler
         * @private
         * @param {Event} event - Mouse force will begin event
         */
        ;

        _proto10[onMouseMove] = function (event) {
          if (!this.dragging) {
            return;
          }

          var target = document.elementFromPoint(event.clientX, event.clientY);
          var dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragMoveEvent);
        }
        /**
         * Mouse force change handler
         * @private
         * @param {Event} event - Mouse force change event
         */
        ;

        _proto10[onMouseForceChange] = function (event) {
          if (this.dragging) {
            return;
          }

          var target = event.target;
          var container = event.currentTarget;
          var dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({
            pressure: event.webkitForce,
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: container,
            originalEvent: event
          });
          this.trigger(container, dragPressureEvent);
        }
        /**
         * Mouse force global change handler
         * @private
         * @param {Event} event - Mouse force global change event
         */
        ;

        _proto10[onMouseForceGlobalChange] = function (event) {
          if (!this.dragging) {
            return;
          }

          var target = event.target;
          var dragPressureEvent = new _SensorEvent.DragPressureSensorEvent({
            pressure: event.webkitForce,
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragPressureEvent);
        };

        return ForceTouchSensor;
      }(_Sensor2["default"]);

      exports["default"] = ForceTouchSensor;
      /***/
    },
    /* 39 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _ForceTouchSensor = __webpack_require__(38);

      var _ForceTouchSensor2 = _interopRequireDefault(_ForceTouchSensor);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _ForceTouchSensor2["default"];
      /***/
    },
    /* 40 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _utils = __webpack_require__(2);

      var _Sensor = __webpack_require__(4);

      var _Sensor2 = _interopRequireDefault(_Sensor);

      var _SensorEvent = __webpack_require__(3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onMouseDown = Symbol('onMouseDown');
      var onMouseUp = Symbol('onMouseUp');
      var onDragStart = Symbol('onDragStart');
      var onDragOver = Symbol('onDragOver');
      var onDragEnd = Symbol('onDragEnd');
      var onDrop = Symbol('onDrop');
      var reset = Symbol('reset');
      /**
       * This sensor picks up native browser drag events and dictates drag operations
       * @class DragSensor
       * @module DragSensor
       * @extends Sensor
       */

      var DragSensor = /*#__PURE__*/function (_Sensor2$default2) {
        _inheritsLoose(DragSensor, _Sensor2$default2);

        /**
         * DragSensor constructor.
         * @constructs DragSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
        function DragSensor() {
          var _this20;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this20 = _Sensor2$default2.call(this, containers, options) || this;
          /**
           * Mouse down timer which will end up setting the draggable attribute, unless canceled
           * @property mouseDownTimeout
           * @type {Number}
           */

          _this20.mouseDownTimeout = null;
          /**
           * Draggable element needs to be remembered to unset the draggable attribute after drag operation has completed
           * @property draggableElement
           * @type {HTMLElement}
           */

          _this20.draggableElement = null;
          /**
           * Native draggable element could be links or images, their draggable state will be disabled during drag operation
           * @property nativeDraggableElement
           * @type {HTMLElement}
           */

          _this20.nativeDraggableElement = null;
          _this20[onMouseDown] = _this20[onMouseDown].bind(_assertThisInitialized(_this20));
          _this20[onMouseUp] = _this20[onMouseUp].bind(_assertThisInitialized(_this20));
          _this20[onDragStart] = _this20[onDragStart].bind(_assertThisInitialized(_this20));
          _this20[onDragOver] = _this20[onDragOver].bind(_assertThisInitialized(_this20));
          _this20[onDragEnd] = _this20[onDragEnd].bind(_assertThisInitialized(_this20));
          _this20[onDrop] = _this20[onDrop].bind(_assertThisInitialized(_this20));
          return _this20;
        }
        /**
         * Attaches sensors event listeners to the DOM
         */


        var _proto11 = DragSensor.prototype;

        _proto11.attach = function attach() {
          document.addEventListener('mousedown', this[onMouseDown], true);
        }
        /**
         * Detaches sensors event listeners to the DOM
         */
        ;

        _proto11.detach = function detach() {
          document.removeEventListener('mousedown', this[onMouseDown], true);
        }
        /**
         * Drag start handler
         * @private
         * @param {Event} event - Drag start event
         */
        ;

        _proto11[onDragStart] = function (event) {
          var _this21 = this;

          // Need for firefox. "text" key is needed for IE
          event.dataTransfer.setData('text', '');
          event.dataTransfer.effectAllowed = this.options.type;
          var target = document.elementFromPoint(event.clientX, event.clientY);
          this.currentContainer = (0, _utils.closest)(event.target, this.containers);

          if (!this.currentContainer) {
            return;
          }

          var dragStartEvent = new _SensorEvent.DragStartSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          }); // Workaround

          setTimeout(function () {
            _this21.trigger(_this21.currentContainer, dragStartEvent);

            if (dragStartEvent.canceled()) {
              _this21.dragging = false;
            } else {
              _this21.dragging = true;
            }
          }, 0);
        }
        /**
         * Drag over handler
         * @private
         * @param {Event} event - Drag over event
         */
        ;

        _proto11[onDragOver] = function (event) {
          if (!this.dragging) {
            return;
          }

          var target = document.elementFromPoint(event.clientX, event.clientY);
          var container = this.currentContainer;
          var dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: container,
            originalEvent: event
          });
          this.trigger(container, dragMoveEvent);

          if (!dragMoveEvent.canceled()) {
            event.preventDefault();
            event.dataTransfer.dropEffect = this.options.type;
          }
        }
        /**
         * Drag end handler
         * @private
         * @param {Event} event - Drag end event
         */
        ;

        _proto11[onDragEnd] = function (event) {
          if (!this.dragging) {
            return;
          }

          document.removeEventListener('mouseup', this[onMouseUp], true);
          var target = document.elementFromPoint(event.clientX, event.clientY);
          var container = this.currentContainer;
          var dragStopEvent = new _SensorEvent.DragStopSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: container,
            originalEvent: event
          });
          this.trigger(container, dragStopEvent);
          this.dragging = false;
          this[reset]();
        }
        /**
         * Drop handler
         * @private
         * @param {Event} event - Drop event
         */
        ;

        _proto11[onDrop] = function (event) {
          // eslint-disable-line class-methods-use-this
          event.preventDefault();
        }
        /**
         * Mouse down handler
         * @private
         * @param {Event} event - Mouse down event
         */
        ;

        _proto11[onMouseDown] = function (event) {
          var _this22 = this;

          // Firefox bug for inputs within draggables https://bugzilla.mozilla.org/show_bug.cgi?id=739071
          if (event.target && (event.target.form || event.target.contenteditable)) {
            return;
          }

          var nativeDraggableElement = (0, _utils.closest)(event.target, function (element) {
            return element.draggable;
          });

          if (nativeDraggableElement) {
            nativeDraggableElement.draggable = false;
            this.nativeDraggableElement = nativeDraggableElement;
          }

          document.addEventListener('mouseup', this[onMouseUp], true);
          document.addEventListener('dragstart', this[onDragStart], false);
          document.addEventListener('dragover', this[onDragOver], false);
          document.addEventListener('dragend', this[onDragEnd], false);
          document.addEventListener('drop', this[onDrop], false);
          var target = (0, _utils.closest)(event.target, this.options.draggable);

          if (!target) {
            return;
          }

          this.mouseDownTimeout = setTimeout(function () {
            target.draggable = true;
            _this22.draggableElement = target;
          }, this.options.delay);
        }
        /**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */
        ;

        _proto11[onMouseUp] = function () {
          this[reset]();
        }
        /**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */
        ;

        _proto11[reset] = function () {
          clearTimeout(this.mouseDownTimeout);
          document.removeEventListener('mouseup', this[onMouseUp], true);
          document.removeEventListener('dragstart', this[onDragStart], false);
          document.removeEventListener('dragover', this[onDragOver], false);
          document.removeEventListener('dragend', this[onDragEnd], false);
          document.removeEventListener('drop', this[onDrop], false);

          if (this.nativeDraggableElement) {
            this.nativeDraggableElement.draggable = true;
            this.nativeDraggableElement = null;
          }

          if (this.draggableElement) {
            this.draggableElement.draggable = false;
            this.draggableElement = null;
          }
        };

        return DragSensor;
      }(_Sensor2["default"]);

      exports["default"] = DragSensor;
      /***/
    },
    /* 41 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _DragSensor = __webpack_require__(40);

      var _DragSensor2 = _interopRequireDefault(_DragSensor);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _DragSensor2["default"];
      /***/
    },
    /* 42 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _utils = __webpack_require__(2);

      var _Sensor = __webpack_require__(4);

      var _Sensor2 = _interopRequireDefault(_Sensor);

      var _SensorEvent = __webpack_require__(3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onTouchStart = Symbol('onTouchStart');
      var onTouchHold = Symbol('onTouchHold');
      var onTouchEnd = Symbol('onTouchEnd');
      var onTouchMove = Symbol('onTouchMove');
      /**
       * Prevents scrolling when set to true
       * @var {Boolean} preventScrolling
       */

      var preventScrolling = false; // WebKit requires cancelable `touchmove` events to be added as early as possible

      window.addEventListener('touchmove', function (event) {
        if (!preventScrolling) {
          return;
        } // Prevent scrolling


        event.preventDefault();
      }, {
        passive: false
      });
      /**
       * This sensor picks up native browser touch events and dictates drag operations
       * @class TouchSensor
       * @module TouchSensor
       * @extends Sensor
       */

      var TouchSensor = /*#__PURE__*/function (_Sensor2$default3) {
        _inheritsLoose(TouchSensor, _Sensor2$default3);

        /**
         * TouchSensor constructor.
         * @constructs TouchSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
        function TouchSensor() {
          var _this23;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this23 = _Sensor2$default3.call(this, containers, options) || this;
          /**
           * Closest scrollable container so accidental scroll can cancel long touch
           * @property currentScrollableParent
           * @type {HTMLElement}
           */

          _this23.currentScrollableParent = null;
          /**
           * TimeoutID for long touch
           * @property tapTimeout
           * @type {Number}
           */

          _this23.tapTimeout = null;
          /**
           * touchMoved indicates if touch has moved during tapTimeout
           * @property touchMoved
           * @type {Boolean}
           */

          _this23.touchMoved = false;
          _this23[onTouchStart] = _this23[onTouchStart].bind(_assertThisInitialized(_this23));
          _this23[onTouchHold] = _this23[onTouchHold].bind(_assertThisInitialized(_this23));
          _this23[onTouchEnd] = _this23[onTouchEnd].bind(_assertThisInitialized(_this23));
          _this23[onTouchMove] = _this23[onTouchMove].bind(_assertThisInitialized(_this23));
          return _this23;
        }
        /**
         * Attaches sensors event listeners to the DOM
         */


        var _proto12 = TouchSensor.prototype;

        _proto12.attach = function attach() {
          document.addEventListener('touchstart', this[onTouchStart]);
        }
        /**
         * Detaches sensors event listeners to the DOM
         */
        ;

        _proto12.detach = function detach() {
          document.removeEventListener('touchstart', this[onTouchStart]);
        }
        /**
         * Touch start handler
         * @private
         * @param {Event} event - Touch start event
         */
        ;

        _proto12[onTouchStart] = function (event) {
          var container = (0, _utils.closest)(event.target, this.containers);

          if (!container) {
            return;
          }

          document.addEventListener('touchmove', this[onTouchMove]);
          document.addEventListener('touchend', this[onTouchEnd]);
          document.addEventListener('touchcancel', this[onTouchEnd]);
          container.addEventListener('contextmenu', onContextMenu);
          this.currentContainer = container;
          this.tapTimeout = setTimeout(this[onTouchHold](event, container), this.options.delay);
        }
        /**
         * Touch hold handler
         * @private
         * @param {Event} event - Touch start event
         * @param {HTMLElement} container - Container element
         */
        ;

        _proto12[onTouchHold] = function (event, container) {
          var _this24 = this;

          return function () {
            if (_this24.touchMoved) {
              return;
            }

            var touch = event.touches[0] || event.changedTouches[0];
            var target = event.target;
            var dragStartEvent = new _SensorEvent.DragStartSensorEvent({
              clientX: touch.pageX,
              clientY: touch.pageY,
              target: target,
              container: container,
              originalEvent: event
            });

            _this24.trigger(container, dragStartEvent);

            _this24.dragging = !dragStartEvent.canceled();
            preventScrolling = _this24.dragging;
          };
        }
        /**
         * Touch move handler
         * @private
         * @param {Event} event - Touch move event
         */
        ;

        _proto12[onTouchMove] = function (event) {
          this.touchMoved = true;

          if (!this.dragging) {
            return;
          }

          var touch = event.touches[0] || event.changedTouches[0];
          var target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);
          var dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
            clientX: touch.pageX,
            clientY: touch.pageY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragMoveEvent);
        }
        /**
         * Touch end handler
         * @private
         * @param {Event} event - Touch end event
         */
        ;

        _proto12[onTouchEnd] = function (event) {
          this.touchMoved = false;
          preventScrolling = false;
          document.removeEventListener('touchend', this[onTouchEnd]);
          document.removeEventListener('touchcancel', this[onTouchEnd]);
          document.removeEventListener('touchmove', this[onTouchMove]);

          if (this.currentContainer) {
            this.currentContainer.removeEventListener('contextmenu', onContextMenu);
          }

          clearTimeout(this.tapTimeout);

          if (!this.dragging) {
            return;
          }

          var touch = event.touches[0] || event.changedTouches[0];
          var target = document.elementFromPoint(touch.pageX - window.scrollX, touch.pageY - window.scrollY);
          event.preventDefault();
          var dragStopEvent = new _SensorEvent.DragStopSensorEvent({
            clientX: touch.pageX,
            clientY: touch.pageY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragStopEvent);
          this.currentContainer = null;
          this.dragging = false;
        };

        return TouchSensor;
      }(_Sensor2["default"]);

      exports["default"] = TouchSensor;

      function onContextMenu(event) {
        event.preventDefault();
        event.stopPropagation();
      }
      /***/

    },
    /* 43 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _TouchSensor = __webpack_require__(42);

      var _TouchSensor2 = _interopRequireDefault(_TouchSensor);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _TouchSensor2["default"];
      /***/
    },
    /* 44 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DragPressureSensorEvent = exports.DragStopSensorEvent = exports.DragMoveSensorEvent = exports.DragStartSensorEvent = exports.SensorEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base sensor event
       * @class SensorEvent
       * @module SensorEvent
       * @extends AbstractEvent
       */


      var SensorEvent = /*#__PURE__*/function (_AbstractEvent2$defau6) {
        _inheritsLoose(SensorEvent, _AbstractEvent2$defau6);

        function SensorEvent() {
          return _AbstractEvent2$defau6.apply(this, arguments) || this;
        }

        _createClass(SensorEvent, [{
          key: "originalEvent",

          /**
           * Original browser event that triggered a sensor
           * @property originalEvent
           * @type {Event}
           * @readonly
           */
          get: function get() {
            return this.data.originalEvent;
          }
          /**
           * Normalized clientX for both touch and mouse events
           * @property clientX
           * @type {Number}
           * @readonly
           */

        }, {
          key: "clientX",
          get: function get() {
            return this.data.clientX;
          }
          /**
           * Normalized clientY for both touch and mouse events
           * @property clientY
           * @type {Number}
           * @readonly
           */

        }, {
          key: "clientY",
          get: function get() {
            return this.data.clientY;
          }
          /**
           * Normalized target for both touch and mouse events
           * Returns the element that is behind cursor or touch pointer
           * @property target
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "target",
          get: function get() {
            return this.data.target;
          }
          /**
           * Container that initiated the sensor
           * @property container
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "container",
          get: function get() {
            return this.data.container;
          }
          /**
           * Trackpad pressure
           * @property pressure
           * @type {Number}
           * @readonly
           */

        }, {
          key: "pressure",
          get: function get() {
            return this.data.pressure;
          }
        }]);

        return SensorEvent;
      }(_AbstractEvent2["default"]);

      exports.SensorEvent = SensorEvent;
      /**
       * Drag start sensor event
       * @class DragStartSensorEvent
       * @module DragStartSensorEvent
       * @extends SensorEvent
       */

      var DragStartSensorEvent = /*#__PURE__*/function (_SensorEvent2) {
        _inheritsLoose(DragStartSensorEvent, _SensorEvent2);

        function DragStartSensorEvent() {
          return _SensorEvent2.apply(this, arguments) || this;
        }

        return DragStartSensorEvent;
      }(SensorEvent);

      exports.DragStartSensorEvent = DragStartSensorEvent;
      /**
       * Drag move sensor event
       * @class DragMoveSensorEvent
       * @module DragMoveSensorEvent
       * @extends SensorEvent
       */

      DragStartSensorEvent.type = 'drag:start';

      var DragMoveSensorEvent = /*#__PURE__*/function (_SensorEvent3) {
        _inheritsLoose(DragMoveSensorEvent, _SensorEvent3);

        function DragMoveSensorEvent() {
          return _SensorEvent3.apply(this, arguments) || this;
        }

        return DragMoveSensorEvent;
      }(SensorEvent);

      exports.DragMoveSensorEvent = DragMoveSensorEvent;
      /**
       * Drag stop sensor event
       * @class DragStopSensorEvent
       * @module DragStopSensorEvent
       * @extends SensorEvent
       */

      DragMoveSensorEvent.type = 'drag:move';

      var DragStopSensorEvent = /*#__PURE__*/function (_SensorEvent4) {
        _inheritsLoose(DragStopSensorEvent, _SensorEvent4);

        function DragStopSensorEvent() {
          return _SensorEvent4.apply(this, arguments) || this;
        }

        return DragStopSensorEvent;
      }(SensorEvent);

      exports.DragStopSensorEvent = DragStopSensorEvent;
      /**
       * Drag pressure sensor event
       * @class DragPressureSensorEvent
       * @module DragPressureSensorEvent
       * @extends SensorEvent
       */

      DragStopSensorEvent.type = 'drag:stop';

      var DragPressureSensorEvent = /*#__PURE__*/function (_SensorEvent5) {
        _inheritsLoose(DragPressureSensorEvent, _SensorEvent5);

        function DragPressureSensorEvent() {
          return _SensorEvent5.apply(this, arguments) || this;
        }

        return DragPressureSensorEvent;
      }(SensorEvent);

      exports.DragPressureSensorEvent = DragPressureSensorEvent;
      DragPressureSensorEvent.type = 'drag:pressure';
      /***/
    },
    /* 45 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _utils = __webpack_require__(2);

      var _Sensor = __webpack_require__(4);

      var _Sensor2 = _interopRequireDefault(_Sensor);

      var _SensorEvent = __webpack_require__(3);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onContextMenuWhileDragging = Symbol('onContextMenuWhileDragging');
      var onMouseDown = Symbol('onMouseDown');
      var onMouseMove = Symbol('onMouseMove');
      var onMouseUp = Symbol('onMouseUp');
      /**
       * This sensor picks up native browser mouse events and dictates drag operations
       * @class MouseSensor
       * @module MouseSensor
       * @extends Sensor
       */

      var MouseSensor = /*#__PURE__*/function (_Sensor2$default4) {
        _inheritsLoose(MouseSensor, _Sensor2$default4);

        /**
         * MouseSensor constructor.
         * @constructs MouseSensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
        function MouseSensor() {
          var _this25;

          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          _this25 = _Sensor2$default4.call(this, containers, options) || this;
          /**
           * Indicates if mouse button is still down
           * @property mouseDown
           * @type {Boolean}
           */

          _this25.mouseDown = false;
          /**
           * Mouse down timer which will end up triggering the drag start operation
           * @property mouseDownTimeout
           * @type {Number}
           */

          _this25.mouseDownTimeout = null;
          /**
           * Indicates if context menu has been opened during drag operation
           * @property openedContextMenu
           * @type {Boolean}
           */

          _this25.openedContextMenu = false;
          _this25[onContextMenuWhileDragging] = _this25[onContextMenuWhileDragging].bind(_assertThisInitialized(_this25));
          _this25[onMouseDown] = _this25[onMouseDown].bind(_assertThisInitialized(_this25));
          _this25[onMouseMove] = _this25[onMouseMove].bind(_assertThisInitialized(_this25));
          _this25[onMouseUp] = _this25[onMouseUp].bind(_assertThisInitialized(_this25));
          return _this25;
        }
        /**
         * Attaches sensors event listeners to the DOM
         */


        var _proto13 = MouseSensor.prototype;

        _proto13.attach = function attach() {
          document.addEventListener('mousedown', this[onMouseDown], true);
        }
        /**
         * Detaches sensors event listeners to the DOM
         */
        ;

        _proto13.detach = function detach() {
          document.removeEventListener('mousedown', this[onMouseDown], true);
        }
        /**
         * Mouse down handler
         * @private
         * @param {Event} event - Mouse down event
         */
        ;

        _proto13[onMouseDown] = function (event) {
          var _this26 = this;

          if (event.button !== 0 || event.ctrlKey || event.metaKey) {
            return;
          }

          document.addEventListener('mouseup', this[onMouseUp]);
          var target = document.elementFromPoint(event.clientX, event.clientY);
          var container = (0, _utils.closest)(target, this.containers);

          if (!container) {
            return;
          }

          document.addEventListener('dragstart', preventNativeDragStart);
          this.mouseDown = true;
          clearTimeout(this.mouseDownTimeout);
          this.mouseDownTimeout = setTimeout(function () {
            if (!_this26.mouseDown) {
              return;
            }

            var dragStartEvent = new _SensorEvent.DragStartSensorEvent({
              clientX: event.clientX,
              clientY: event.clientY,
              target: target,
              container: container,
              originalEvent: event
            });

            _this26.trigger(container, dragStartEvent);

            _this26.currentContainer = container;
            _this26.dragging = !dragStartEvent.canceled();

            if (_this26.dragging) {
              document.addEventListener('contextmenu', _this26[onContextMenuWhileDragging]);
              document.addEventListener('mousemove', _this26[onMouseMove]);
            }
          }, this.options.delay);
        }
        /**
         * Mouse move handler
         * @private
         * @param {Event} event - Mouse move event
         */
        ;

        _proto13[onMouseMove] = function (event) {
          if (!this.dragging) {
            return;
          }

          var target = document.elementFromPoint(event.clientX, event.clientY);
          var dragMoveEvent = new _SensorEvent.DragMoveSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragMoveEvent);
        }
        /**
         * Mouse up handler
         * @private
         * @param {Event} event - Mouse up event
         */
        ;

        _proto13[onMouseUp] = function (event) {
          this.mouseDown = Boolean(this.openedContextMenu);

          if (this.openedContextMenu) {
            this.openedContextMenu = false;
            return;
          }

          document.removeEventListener('mouseup', this[onMouseUp]);
          document.removeEventListener('dragstart', preventNativeDragStart);

          if (!this.dragging) {
            return;
          }

          var target = document.elementFromPoint(event.clientX, event.clientY);
          var dragStopEvent = new _SensorEvent.DragStopSensorEvent({
            clientX: event.clientX,
            clientY: event.clientY,
            target: target,
            container: this.currentContainer,
            originalEvent: event
          });
          this.trigger(this.currentContainer, dragStopEvent);
          document.removeEventListener('contextmenu', this[onContextMenuWhileDragging]);
          document.removeEventListener('mousemove', this[onMouseMove]);
          this.currentContainer = null;
          this.dragging = false;
        }
        /**
         * Context menu handler
         * @private
         * @param {Event} event - Context menu event
         */
        ;

        _proto13[onContextMenuWhileDragging] = function (event) {
          event.preventDefault();
          this.openedContextMenu = true;
        };

        return MouseSensor;
      }(_Sensor2["default"]);

      exports["default"] = MouseSensor;

      function preventNativeDragStart(event) {
        event.preventDefault();
      }
      /***/

    },
    /* 46 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _MouseSensor = __webpack_require__(45);

      var _MouseSensor2 = _interopRequireDefault(_MouseSensor);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _MouseSensor2["default"];
      /***/
    },
    /* 47 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };
      /**
       * Base sensor class. Extend from this class to create a new or custom sensor
       * @class Sensor
       * @module Sensor
       */


      var Sensor = /*#__PURE__*/function () {
        /**
         * Sensor constructor.
         * @constructs Sensor
         * @param {HTMLElement[]|NodeList|HTMLElement} containers - Containers
         * @param {Object} options - Options
         */
        function Sensor() {
          var containers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          /**
           * Current containers
           * @property containers
           * @type {HTMLElement[]}
           */
          this.containers = _toConsumableArray(containers);
          /**
           * Current options
           * @property options
           * @type {Object}
           */

          this.options = _extends({}, options);
          /**
           * Current drag state
           * @property dragging
           * @type {Boolean}
           */

          this.dragging = false;
          /**
           * Current container
           * @property currentContainer
           * @type {HTMLElement}
           */

          this.currentContainer = null;
        }
        /**
         * Attaches sensors event listeners to the DOM
         * @return {Sensor}
         */


        var _proto14 = Sensor.prototype;

        _proto14.attach = function attach() {
          return this;
        }
        /**
         * Detaches sensors event listeners to the DOM
         * @return {Sensor}
         */
        ;

        _proto14.detach = function detach() {
          return this;
        }
        /**
         * Adds container to this sensor instance
         * @param {...HTMLElement} containers - Containers you want to add to this sensor
         * @example draggable.addContainer(document.body)
         */
        ;

        _proto14.addContainer = function addContainer() {
          for (var _len9 = arguments.length, containers = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
            containers[_key9] = arguments[_key9];
          }

          this.containers = [].concat(_toConsumableArray(this.containers), containers);
        }
        /**
         * Removes container from this sensor instance
         * @param {...HTMLElement} containers - Containers you want to remove from this sensor
         * @example draggable.removeContainer(document.body)
         */
        ;

        _proto14.removeContainer = function removeContainer() {
          for (var _len10 = arguments.length, containers = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
            containers[_key10] = arguments[_key10];
          }

          this.containers = this.containers.filter(function (container) {
            return !containers.includes(container);
          });
        }
        /**
         * Triggers event on target element
         * @param {HTMLElement} element - Element to trigger event on
         * @param {SensorEvent} sensorEvent - Sensor event to trigger
         */
        ;

        _proto14.trigger = function trigger(element, sensorEvent) {
          var event = document.createEvent('Event');
          event.detail = sensorEvent;
          event.initEvent(sensorEvent.type, true, true);
          element.dispatchEvent(event);
          this.lastEvent = sensorEvent;
          return sensorEvent;
        };

        return Sensor;
      }();

      exports["default"] = Sensor;
      /***/
    },
    /* 48 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = requestNextAnimationFrame;

      function requestNextAnimationFrame(callback) {
        return requestAnimationFrame(function () {
          requestAnimationFrame(callback);
        });
      }
      /***/

    },
    /* 49 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _requestNextAnimationFrame = __webpack_require__(48);

      var _requestNextAnimationFrame2 = _interopRequireDefault(_requestNextAnimationFrame);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _requestNextAnimationFrame2["default"];
      /***/
    },
    /* 50 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports["default"] = closest;
      var matchFunction = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector;
      /**
       * Get the closest parent element of a given element that matches the given
       * selector string or matching function
       *
       * @param {Element} element The child element to find a parent of
       * @param {String|Function} selector The string or function to use to match
       *     the parent element
       * @return {Element|null}
       */

      function closest(element, value) {
        if (!element) {
          return null;
        }

        var selector = value;
        var callback = value;
        var nodeList = value;
        var singleElement = value;
        var isSelector = Boolean(typeof value === 'string');
        var isFunction = Boolean(typeof value === 'function');
        var isNodeList = Boolean(value instanceof NodeList || value instanceof Array);
        var isElement = Boolean(value instanceof HTMLElement);

        function conditionFn(currentElement) {
          if (!currentElement) {
            return currentElement;
          } else if (isSelector) {
            return matchFunction.call(currentElement, selector);
          } else if (isNodeList) {
            return _toConsumableArray(nodeList).includes(currentElement);
          } else if (isElement) {
            return singleElement === currentElement;
          } else if (isFunction) {
            return callback(currentElement);
          } else {
            return null;
          }
        }

        var current = element;

        do {
          current = current.correspondingUseElement || current.correspondingElement || current;

          if (conditionFn(current)) {
            return current;
          }

          current = current.parentNode;
        } while (current && current !== document.body && current !== document);

        return null;
      }
      /***/

    },
    /* 51 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _closest = __webpack_require__(50);

      var _closest2 = _interopRequireDefault(_closest);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _closest2["default"];
      /***/
    },
    /* 52 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = exports.scroll = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      var _utils = __webpack_require__(2);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onDragStart = exports.onDragStart = Symbol('onDragStart');
      var onDragMove = exports.onDragMove = Symbol('onDragMove');
      var onDragStop = exports.onDragStop = Symbol('onDragStop');
      var scroll = exports.scroll = Symbol('scroll');
      /**
       * Scrollable default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.speed
       * @property {Number} defaultOptions.sensitivity
       * @property {HTMLElement[]} defaultOptions.scrollableElements
       * @type {Object}
       */

      var defaultOptions = exports.defaultOptions = {
        speed: 6,
        sensitivity: 50,
        scrollableElements: []
      };
      /**
       * Scrollable plugin which scrolls the closest scrollable parent
       * @class Scrollable
       * @module Scrollable
       * @extends AbstractPlugin
       */

      var Scrollable = /*#__PURE__*/function (_AbstractPlugin2$defa5) {
        _inheritsLoose(Scrollable, _AbstractPlugin2$defa5);

        /**
         * Scrollable constructor.
         * @constructs Scrollable
         * @param {Draggable} draggable - Draggable instance
         */
        function Scrollable(draggable) {
          var _this27;

          _this27 = _AbstractPlugin2$defa5.call(this, draggable) || this;
          /**
           * Scrollable options
           * @property {Object} options
           * @property {Number} options.speed
           * @property {Number} options.sensitivity
           * @property {HTMLElement[]} options.scrollableElements
           * @type {Object}
           */

          _this27.options = _extends({}, defaultOptions, _this27.getOptions());
          /**
           * Keeps current mouse position
           * @property {Object} currentMousePosition
           * @property {Number} currentMousePosition.clientX
           * @property {Number} currentMousePosition.clientY
           * @type {Object|null}
           */

          _this27.currentMousePosition = null;
          /**
           * Scroll animation frame
           * @property scrollAnimationFrame
           * @type {Number|null}
           */

          _this27.scrollAnimationFrame = null;
          /**
           * Closest scrollable element
           * @property scrollableElement
           * @type {HTMLElement|null}
           */

          _this27.scrollableElement = null;
          /**
           * Animation frame looking for the closest scrollable element
           * @property findScrollableElementFrame
           * @type {Number|null}
           */

          _this27.findScrollableElementFrame = null;
          _this27[onDragStart] = _this27[onDragStart].bind(_assertThisInitialized(_this27));
          _this27[onDragMove] = _this27[onDragMove].bind(_assertThisInitialized(_this27));
          _this27[onDragStop] = _this27[onDragStop].bind(_assertThisInitialized(_this27));
          _this27[scroll] = _this27[scroll].bind(_assertThisInitialized(_this27));
          return _this27;
        }
        /**
         * Attaches plugins event listeners
         */


        var _proto15 = Scrollable.prototype;

        _proto15.attach = function attach() {
          this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]);
        }
        /**
         * Detaches plugins event listeners
         */
        ;

        _proto15.detach = function detach() {
          this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]);
        }
        /**
         * Returns options passed through draggable
         * @return {Object}
         */
        ;

        _proto15.getOptions = function getOptions() {
          return this.draggable.options.scrollable || {};
        }
        /**
         * Returns closest scrollable elements by element
         * @param {HTMLElement} target
         * @return {HTMLElement}
         */
        ;

        _proto15.getScrollableElement = function getScrollableElement(target) {
          if (this.hasDefinedScrollableElements()) {
            return (0, _utils.closest)(target, this.options.scrollableElements) || document.documentElement;
          } else {
            return closestScrollableElement(target);
          }
        }
        /**
         * Returns true if at least one scrollable element have been defined via options
         * @param {HTMLElement} target
         * @return {Boolean}
         */
        ;

        _proto15.hasDefinedScrollableElements = function hasDefinedScrollableElements() {
          return Boolean(this.options.scrollableElements.length !== 0);
        }
        /**
         * Drag start handler. Finds closest scrollable parent in separate frame
         * @param {DragStartEvent} dragEvent
         * @private
         */
        ;

        _proto15[onDragStart] = function (dragEvent) {
          var _this28 = this;

          this.findScrollableElementFrame = requestAnimationFrame(function () {
            _this28.scrollableElement = _this28.getScrollableElement(dragEvent.source);
          });
        }
        /**
         * Drag move handler. Remembers mouse position and initiates scrolling
         * @param {DragMoveEvent} dragEvent
         * @private
         */
        ;

        _proto15[onDragMove] = function (dragEvent) {
          var _this29 = this;

          this.findScrollableElementFrame = requestAnimationFrame(function () {
            _this29.scrollableElement = _this29.getScrollableElement(dragEvent.sensorEvent.target);
          });

          if (!this.scrollableElement) {
            return;
          }

          var sensorEvent = dragEvent.sensorEvent;
          var scrollOffset = {
            x: 0,
            y: 0
          };

          if ('ontouchstart' in window) {
            scrollOffset.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
            scrollOffset.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
          }

          this.currentMousePosition = {
            clientX: sensorEvent.clientX - scrollOffset.x,
            clientY: sensorEvent.clientY - scrollOffset.y
          };
          this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
        }
        /**
         * Drag stop handler. Cancels scroll animations and resets state
         * @private
         */
        ;

        _proto15[onDragStop] = function () {
          cancelAnimationFrame(this.scrollAnimationFrame);
          cancelAnimationFrame(this.findScrollableElementFrame);
          this.scrollableElement = null;
          this.scrollAnimationFrame = null;
          this.findScrollableElementFrame = null;
          this.currentMousePosition = null;
        }
        /**
         * Scroll function that does the heavylifting
         * @private
         */
        ;

        _proto15[scroll] = function () {
          if (!this.scrollableElement || !this.currentMousePosition) {
            return;
          }

          cancelAnimationFrame(this.scrollAnimationFrame);
          var _this$options = this.options,
              speed = _this$options.speed,
              sensitivity = _this$options.sensitivity;
          var rect = this.scrollableElement.getBoundingClientRect();
          var bottomCutOff = rect.bottom > window.innerHeight;
          var topCutOff = rect.top < 0;
          var cutOff = topCutOff || bottomCutOff;
          var documentScrollingElement = getDocumentScrollingElement();
          var scrollableElement = this.scrollableElement;
          var clientX = this.currentMousePosition.clientX;
          var clientY = this.currentMousePosition.clientY;

          if (scrollableElement !== document.body && scrollableElement !== document.documentElement && !cutOff) {
            var offsetHeight = scrollableElement.offsetHeight,
                offsetWidth = scrollableElement.offsetWidth;

            if (rect.top + offsetHeight - clientY < sensitivity) {
              scrollableElement.scrollTop += speed;
            } else if (clientY - rect.top < sensitivity) {
              scrollableElement.scrollTop -= speed;
            }

            if (rect.left + offsetWidth - clientX < sensitivity) {
              scrollableElement.scrollLeft += speed;
            } else if (clientX - rect.left < sensitivity) {
              scrollableElement.scrollLeft -= speed;
            }
          } else {
            var _window = window,
                innerHeight = _window.innerHeight,
                innerWidth = _window.innerWidth;

            if (clientY < sensitivity) {
              documentScrollingElement.scrollTop -= speed;
            } else if (innerHeight - clientY < sensitivity) {
              documentScrollingElement.scrollTop += speed;
            }

            if (clientX < sensitivity) {
              documentScrollingElement.scrollLeft -= speed;
            } else if (innerWidth - clientX < sensitivity) {
              documentScrollingElement.scrollLeft += speed;
            }
          }

          this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
        };

        return Scrollable;
      }(_AbstractPlugin2["default"]);

      exports["default"] = Scrollable;
      /**
       * Returns true if the passed element has overflow
       * @param {HTMLElement} element
       * @return {Boolean}
       * @private
       */

      function hasOverflow(element) {
        var overflowRegex = /(auto|scroll)/;
        var computedStyles = getComputedStyle(element, null);
        var overflow = computedStyles.getPropertyValue('overflow') + computedStyles.getPropertyValue('overflow-y') + computedStyles.getPropertyValue('overflow-x');
        return overflowRegex.test(overflow);
      }
      /**
       * Returns true if the passed element is statically positioned
       * @param {HTMLElement} element
       * @return {Boolean}
       * @private
       */


      function isStaticallyPositioned(element) {
        var position = getComputedStyle(element).getPropertyValue('position');
        return position === 'static';
      }
      /**
       * Finds closest scrollable element
       * @param {HTMLElement} element
       * @return {HTMLElement}
       * @private
       */


      function closestScrollableElement(element) {
        if (!element) {
          return getDocumentScrollingElement();
        }

        var position = getComputedStyle(element).getPropertyValue('position');
        var excludeStaticParents = position === 'absolute';
        var scrollableElement = (0, _utils.closest)(element, function (parent) {
          if (excludeStaticParents && isStaticallyPositioned(parent)) {
            return false;
          }

          return hasOverflow(parent);
        });

        if (position === 'fixed' || !scrollableElement) {
          return getDocumentScrollingElement();
        } else {
          return scrollableElement;
        }
      }
      /**
       * Returns element that scrolls document
       * @return {HTMLElement}
       * @private
       */


      function getDocumentScrollingElement() {
        return document.scrollingElement || document.documentElement;
      }
      /***/

    },
    /* 53 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _Scrollable = __webpack_require__(52);

      var _Scrollable2 = _interopRequireDefault(_Scrollable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Scrollable2["default"];
      exports.defaultOptions = _Scrollable.defaultOptions;
      /***/
    },
    /* 54 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.MirrorDestroyEvent = exports.MirrorMoveEvent = exports.MirrorAttachedEvent = exports.MirrorCreatedEvent = exports.MirrorCreateEvent = exports.MirrorEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base mirror event
       * @class MirrorEvent
       * @module MirrorEvent
       * @extends AbstractEvent
       */


      var MirrorEvent = /*#__PURE__*/function (_AbstractEvent2$defau7) {
        _inheritsLoose(MirrorEvent, _AbstractEvent2$defau7);

        function MirrorEvent() {
          return _AbstractEvent2$defau7.apply(this, arguments) || this;
        }

        _createClass(MirrorEvent, [{
          key: "source",

          /**
           * Draggables source element
           * @property source
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.source;
          }
          /**
           * Draggables original source element
           * @property originalSource
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "originalSource",
          get: function get() {
            return this.data.originalSource;
          }
          /**
           * Draggables source container element
           * @property sourceContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "sourceContainer",
          get: function get() {
            return this.data.sourceContainer;
          }
          /**
           * Sensor event
           * @property sensorEvent
           * @type {SensorEvent}
           * @readonly
           */

        }, {
          key: "sensorEvent",
          get: function get() {
            return this.data.sensorEvent;
          }
          /**
           * Drag event
           * @property dragEvent
           * @type {DragEvent}
           * @readonly
           */

        }, {
          key: "dragEvent",
          get: function get() {
            return this.data.dragEvent;
          }
          /**
           * Original event that triggered sensor event
           * @property originalEvent
           * @type {Event}
           * @readonly
           */

        }, {
          key: "originalEvent",
          get: function get() {
            if (this.sensorEvent) {
              return this.sensorEvent.originalEvent;
            }

            return null;
          }
        }]);

        return MirrorEvent;
      }(_AbstractEvent2["default"]);

      exports.MirrorEvent = MirrorEvent;
      /**
       * Mirror create event
       * @class MirrorCreateEvent
       * @module MirrorCreateEvent
       * @extends MirrorEvent
       */

      var MirrorCreateEvent = /*#__PURE__*/function (_MirrorEvent2) {
        _inheritsLoose(MirrorCreateEvent, _MirrorEvent2);

        function MirrorCreateEvent() {
          return _MirrorEvent2.apply(this, arguments) || this;
        }

        return MirrorCreateEvent;
      }(MirrorEvent);

      exports.MirrorCreateEvent = MirrorCreateEvent;
      /**
       * Mirror created event
       * @class MirrorCreatedEvent
       * @module MirrorCreatedEvent
       * @extends MirrorEvent
       */

      MirrorCreateEvent.type = 'mirror:create';

      var MirrorCreatedEvent = /*#__PURE__*/function (_MirrorEvent3) {
        _inheritsLoose(MirrorCreatedEvent, _MirrorEvent3);

        function MirrorCreatedEvent() {
          return _MirrorEvent3.apply(this, arguments) || this;
        }

        _createClass(MirrorCreatedEvent, [{
          key: "mirror",

          /**
           * Draggables mirror element
           * @property mirror
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.mirror;
          }
        }]);

        return MirrorCreatedEvent;
      }(MirrorEvent);

      exports.MirrorCreatedEvent = MirrorCreatedEvent;
      /**
       * Mirror attached event
       * @class MirrorAttachedEvent
       * @module MirrorAttachedEvent
       * @extends MirrorEvent
       */

      MirrorCreatedEvent.type = 'mirror:created';

      var MirrorAttachedEvent = /*#__PURE__*/function (_MirrorEvent4) {
        _inheritsLoose(MirrorAttachedEvent, _MirrorEvent4);

        function MirrorAttachedEvent() {
          return _MirrorEvent4.apply(this, arguments) || this;
        }

        _createClass(MirrorAttachedEvent, [{
          key: "mirror",

          /**
           * Draggables mirror element
           * @property mirror
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.mirror;
          }
        }]);

        return MirrorAttachedEvent;
      }(MirrorEvent);

      exports.MirrorAttachedEvent = MirrorAttachedEvent;
      /**
       * Mirror move event
       * @class MirrorMoveEvent
       * @module MirrorMoveEvent
       * @extends MirrorEvent
       */

      MirrorAttachedEvent.type = 'mirror:attached';

      var MirrorMoveEvent = /*#__PURE__*/function (_MirrorEvent5) {
        _inheritsLoose(MirrorMoveEvent, _MirrorEvent5);

        function MirrorMoveEvent() {
          return _MirrorEvent5.apply(this, arguments) || this;
        }

        _createClass(MirrorMoveEvent, [{
          key: "mirror",

          /**
           * Draggables mirror element
           * @property mirror
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.mirror;
          }
        }]);

        return MirrorMoveEvent;
      }(MirrorEvent);

      exports.MirrorMoveEvent = MirrorMoveEvent;
      /**
       * Mirror destroy event
       * @class MirrorDestroyEvent
       * @module MirrorDestroyEvent
       * @extends MirrorEvent
       */

      MirrorMoveEvent.type = 'mirror:move';
      MirrorMoveEvent.cancelable = true;

      var MirrorDestroyEvent = /*#__PURE__*/function (_MirrorEvent6) {
        _inheritsLoose(MirrorDestroyEvent, _MirrorEvent6);

        function MirrorDestroyEvent() {
          return _MirrorEvent6.apply(this, arguments) || this;
        }

        _createClass(MirrorDestroyEvent, [{
          key: "mirror",

          /**
           * Draggables mirror element
           * @property mirror
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.mirror;
          }
        }]);

        return MirrorDestroyEvent;
      }(MirrorEvent);

      exports.MirrorDestroyEvent = MirrorDestroyEvent;
      MirrorDestroyEvent.type = 'mirror:destroy';
      MirrorDestroyEvent.cancelable = true;
      /***/
    },
    /* 55 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _MirrorEvent = __webpack_require__(54);

      Object.keys(_MirrorEvent).forEach(function (key) {
        if (key === "default" || key === "__esModule") return;
        Object.defineProperty(exports, key, {
          enumerable: true,
          get: function get() {
            return _MirrorEvent[key];
          }
        });
      });
      /***/
    },
    /* 56 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = exports.getAppendableContainer = exports.onScroll = exports.onMirrorMove = exports.onMirrorCreated = exports.onDragStop = exports.onDragMove = exports.onDragStart = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      var _MirrorEvent = __webpack_require__(55);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      function _objectWithoutProperties(obj, keys) {
        var target = {};

        for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;
          if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
          target[i] = obj[i];
        }

        return target;
      }

      var onDragStart = exports.onDragStart = Symbol('onDragStart');
      var onDragMove = exports.onDragMove = Symbol('onDragMove');
      var onDragStop = exports.onDragStop = Symbol('onDragStop');
      var onMirrorCreated = exports.onMirrorCreated = Symbol('onMirrorCreated');
      var onMirrorMove = exports.onMirrorMove = Symbol('onMirrorMove');
      var onScroll = exports.onScroll = Symbol('onScroll');
      var getAppendableContainer = exports.getAppendableContainer = Symbol('getAppendableContainer');
      /**
       * Mirror default options
       * @property {Object} defaultOptions
       * @property {Boolean} defaultOptions.constrainDimensions
       * @property {Boolean} defaultOptions.xAxis
       * @property {Boolean} defaultOptions.yAxis
       * @property {null} defaultOptions.cursorOffsetX
       * @property {null} defaultOptions.cursorOffsetY
       * @type {Object}
       */

      var defaultOptions = exports.defaultOptions = {
        constrainDimensions: false,
        xAxis: true,
        yAxis: true,
        cursorOffsetX: null,
        cursorOffsetY: null
      };
      /**
       * Mirror plugin which controls the mirror positioning while dragging
       * @class Mirror
       * @module Mirror
       * @extends AbstractPlugin
       */

      var Mirror = /*#__PURE__*/function (_AbstractPlugin2$defa6) {
        _inheritsLoose(Mirror, _AbstractPlugin2$defa6);

        /**
         * Mirror constructor.
         * @constructs Mirror
         * @param {Draggable} draggable - Draggable instance
         */
        function Mirror(draggable) {
          var _this30;

          _this30 = _AbstractPlugin2$defa6.call(this, draggable) || this;
          /**
           * Mirror options
           * @property {Object} options
           * @property {Boolean} options.constrainDimensions
           * @property {Boolean} options.xAxis
           * @property {Boolean} options.yAxis
           * @property {Number|null} options.cursorOffsetX
           * @property {Number|null} options.cursorOffsetY
           * @property {String|HTMLElement|Function} options.appendTo
           * @type {Object}
           */

          _this30.options = _extends({}, defaultOptions, _this30.getOptions());
          /**
           * Scroll offset for touch devices because the mirror is positioned fixed
           * @property {Object} scrollOffset
           * @property {Number} scrollOffset.x
           * @property {Number} scrollOffset.y
           */

          _this30.scrollOffset = {
            x: 0,
            y: 0
          };
          /**
           * Initial scroll offset for touch devices because the mirror is positioned fixed
           * @property {Object} scrollOffset
           * @property {Number} scrollOffset.x
           * @property {Number} scrollOffset.y
           */

          _this30.initialScrollOffset = {
            x: window.scrollX,
            y: window.scrollY
          };
          _this30[onDragStart] = _this30[onDragStart].bind(_assertThisInitialized(_this30));
          _this30[onDragMove] = _this30[onDragMove].bind(_assertThisInitialized(_this30));
          _this30[onDragStop] = _this30[onDragStop].bind(_assertThisInitialized(_this30));
          _this30[onMirrorCreated] = _this30[onMirrorCreated].bind(_assertThisInitialized(_this30));
          _this30[onMirrorMove] = _this30[onMirrorMove].bind(_assertThisInitialized(_this30));
          _this30[onScroll] = _this30[onScroll].bind(_assertThisInitialized(_this30));
          return _this30;
        }
        /**
         * Attaches plugins event listeners
         */


        var _proto16 = Mirror.prototype;

        _proto16.attach = function attach() {
          this.draggable.on('drag:start', this[onDragStart]).on('drag:move', this[onDragMove]).on('drag:stop', this[onDragStop]).on('mirror:created', this[onMirrorCreated]).on('mirror:move', this[onMirrorMove]);
        }
        /**
         * Detaches plugins event listeners
         */
        ;

        _proto16.detach = function detach() {
          this.draggable.off('drag:start', this[onDragStart]).off('drag:move', this[onDragMove]).off('drag:stop', this[onDragStop]).off('mirror:created', this[onMirrorCreated]).off('mirror:move', this[onMirrorMove]);
        }
        /**
         * Returns options passed through draggable
         * @return {Object}
         */
        ;

        _proto16.getOptions = function getOptions() {
          return this.draggable.options.mirror || {};
        };

        _proto16[onDragStart] = function (dragEvent) {
          if (dragEvent.canceled()) {
            return;
          }

          if ('ontouchstart' in window) {
            document.addEventListener('scroll', this[onScroll], true);
          }

          this.initialScrollOffset = {
            x: window.scrollX,
            y: window.scrollY
          };
          var source = dragEvent.source,
              originalSource = dragEvent.originalSource,
              sourceContainer = dragEvent.sourceContainer,
              sensorEvent = dragEvent.sensorEvent;
          var mirrorCreateEvent = new _MirrorEvent.MirrorCreateEvent({
            source: source,
            originalSource: originalSource,
            sourceContainer: sourceContainer,
            sensorEvent: sensorEvent,
            dragEvent: dragEvent
          });
          this.draggable.trigger(mirrorCreateEvent);

          if (isNativeDragEvent(sensorEvent) || mirrorCreateEvent.canceled()) {
            return;
          }

          var appendableContainer = this[getAppendableContainer](source) || sourceContainer;
          this.mirror = source.cloneNode(true);
          var mirrorCreatedEvent = new _MirrorEvent.MirrorCreatedEvent({
            source: source,
            originalSource: originalSource,
            sourceContainer: sourceContainer,
            sensorEvent: sensorEvent,
            dragEvent: dragEvent,
            mirror: this.mirror
          });
          var mirrorAttachedEvent = new _MirrorEvent.MirrorAttachedEvent({
            source: source,
            originalSource: originalSource,
            sourceContainer: sourceContainer,
            sensorEvent: sensorEvent,
            dragEvent: dragEvent,
            mirror: this.mirror
          });
          this.draggable.trigger(mirrorCreatedEvent);
          appendableContainer.appendChild(this.mirror);
          this.draggable.trigger(mirrorAttachedEvent);
        };

        _proto16[onDragMove] = function (dragEvent) {
          if (!this.mirror || dragEvent.canceled()) {
            return;
          }

          var source = dragEvent.source,
              originalSource = dragEvent.originalSource,
              sourceContainer = dragEvent.sourceContainer,
              sensorEvent = dragEvent.sensorEvent;
          var mirrorMoveEvent = new _MirrorEvent.MirrorMoveEvent({
            source: source,
            originalSource: originalSource,
            sourceContainer: sourceContainer,
            sensorEvent: sensorEvent,
            dragEvent: dragEvent,
            mirror: this.mirror
          });
          this.draggable.trigger(mirrorMoveEvent);
        };

        _proto16[onDragStop] = function (dragEvent) {
          if ('ontouchstart' in window) {
            document.removeEventListener('scroll', this[onScroll], true);
          }

          this.initialScrollOffset = {
            x: 0,
            y: 0
          };
          this.scrollOffset = {
            x: 0,
            y: 0
          };

          if (!this.mirror) {
            return;
          }

          var source = dragEvent.source,
              sourceContainer = dragEvent.sourceContainer,
              sensorEvent = dragEvent.sensorEvent;
          var mirrorDestroyEvent = new _MirrorEvent.MirrorDestroyEvent({
            source: source,
            mirror: this.mirror,
            sourceContainer: sourceContainer,
            sensorEvent: sensorEvent,
            dragEvent: dragEvent
          });
          this.draggable.trigger(mirrorDestroyEvent);

          if (!mirrorDestroyEvent.canceled()) {
            this.mirror.parentNode.removeChild(this.mirror);
          }
        };

        _proto16[onScroll] = function () {
          this.scrollOffset = {
            x: window.scrollX - this.initialScrollOffset.x,
            y: window.scrollY - this.initialScrollOffset.y
          };
        }
        /**
         * Mirror created handler
         * @param {MirrorCreatedEvent} mirrorEvent
         * @return {Promise}
         * @private
         */
        ;

        _proto16[onMirrorCreated] = function (_ref19) {
          var _this31 = this;

          var mirror = _ref19.mirror,
              source = _ref19.source,
              sensorEvent = _ref19.sensorEvent;
          var mirrorClass = this.draggable.getClassNameFor('mirror');

          var setState = function setState(_ref) {
            var mirrorOffset = _ref.mirrorOffset,
                initialX = _ref.initialX,
                initialY = _ref.initialY,
                args = _objectWithoutProperties(_ref, ['mirrorOffset', 'initialX', 'initialY']);

            _this31.mirrorOffset = mirrorOffset;
            _this31.initialX = initialX;
            _this31.initialY = initialY;
            return _extends({
              mirrorOffset: mirrorOffset,
              initialX: initialX,
              initialY: initialY
            }, args);
          };

          var initialState = {
            mirror: mirror,
            source: source,
            sensorEvent: sensorEvent,
            mirrorClass: mirrorClass,
            scrollOffset: this.scrollOffset,
            options: this.options
          };
          return Promise.resolve(initialState) // Fix reflow here
          .then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({
            initial: true
          })).then(removeMirrorID).then(setState);
        }
        /**
         * Mirror move handler
         * @param {MirrorMoveEvent} mirrorEvent
         * @return {Promise|null}
         * @private
         */
        ;

        _proto16[onMirrorMove] = function (mirrorEvent) {
          if (mirrorEvent.canceled()) {
            return null;
          }

          var initialState = {
            mirror: mirrorEvent.mirror,
            sensorEvent: mirrorEvent.sensorEvent,
            mirrorOffset: this.mirrorOffset,
            options: this.options,
            initialX: this.initialX,
            initialY: this.initialY,
            scrollOffset: this.scrollOffset
          };
          return Promise.resolve(initialState).then(positionMirror({
            raf: true
          }));
        }
        /**
         * Returns appendable container for mirror based on the appendTo option
         * @private
         * @param {Object} options
         * @param {HTMLElement} options.source - Current source
         * @return {HTMLElement}
         */
        ;

        _proto16[getAppendableContainer] = function (source) {
          var appendTo = this.options.appendTo;

          if (typeof appendTo === 'string') {
            return document.querySelector(appendTo);
          } else if (appendTo instanceof HTMLElement) {
            return appendTo;
          } else if (typeof appendTo === 'function') {
            return appendTo(source);
          } else {
            return source.parentNode;
          }
        };

        return Mirror;
      }(_AbstractPlugin2["default"]);

      exports["default"] = Mirror;
      /**
       * Computes mirror dimensions based on the source element
       * Adds sourceRect to state
       * @param {Object} state
       * @param {HTMLElement} state.source
       * @return {Promise}
       * @private
       */

      function computeMirrorDimensions(_ref2) {
        var source = _ref2.source,
            args = _objectWithoutProperties(_ref2, ['source']);

        return withPromise(function (resolve) {
          var sourceRect = source.getBoundingClientRect();
          resolve(_extends({
            source: source,
            sourceRect: sourceRect
          }, args));
        });
      }
      /**
       * Calculates mirror offset
       * Adds mirrorOffset to state
       * @param {Object} state
       * @param {SensorEvent} state.sensorEvent
       * @param {DOMRect} state.sourceRect
       * @return {Promise}
       * @private
       */


      function calculateMirrorOffset(_ref3) {
        var sensorEvent = _ref3.sensorEvent,
            sourceRect = _ref3.sourceRect,
            options = _ref3.options,
            args = _objectWithoutProperties(_ref3, ['sensorEvent', 'sourceRect', 'options']);

        return withPromise(function (resolve) {
          var top = options.cursorOffsetY === null ? sensorEvent.clientY - sourceRect.top : options.cursorOffsetY;
          var left = options.cursorOffsetX === null ? sensorEvent.clientX - sourceRect.left : options.cursorOffsetX;
          var mirrorOffset = {
            top: top,
            left: left
          };
          resolve(_extends({
            sensorEvent: sensorEvent,
            sourceRect: sourceRect,
            mirrorOffset: mirrorOffset,
            options: options
          }, args));
        });
      }
      /**
       * Applys mirror styles
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @param {HTMLElement} state.source
       * @param {Object} state.options
       * @return {Promise}
       * @private
       */


      function resetMirror(_ref4) {
        var mirror = _ref4.mirror,
            source = _ref4.source,
            options = _ref4.options,
            args = _objectWithoutProperties(_ref4, ['mirror', 'source', 'options']);

        return withPromise(function (resolve) {
          var offsetHeight;
          var offsetWidth;

          if (options.constrainDimensions) {
            var computedSourceStyles = getComputedStyle(source);
            offsetHeight = computedSourceStyles.getPropertyValue('height');
            offsetWidth = computedSourceStyles.getPropertyValue('width');
          }

          mirror.style.position = 'fixed';
          mirror.style.pointerEvents = 'none';
          mirror.style.top = 0;
          mirror.style.left = 0;
          mirror.style.margin = 0;

          if (options.constrainDimensions) {
            mirror.style.height = offsetHeight;
            mirror.style.width = offsetWidth;
          }

          resolve(_extends({
            mirror: mirror,
            source: source,
            options: options
          }, args));
        });
      }
      /**
       * Applys mirror class on mirror element
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @param {String} state.mirrorClass
       * @return {Promise}
       * @private
       */


      function addMirrorClasses(_ref5) {
        var mirror = _ref5.mirror,
            mirrorClass = _ref5.mirrorClass,
            args = _objectWithoutProperties(_ref5, ['mirror', 'mirrorClass']);

        return withPromise(function (resolve) {
          mirror.classList.add(mirrorClass);
          resolve(_extends({
            mirror: mirror,
            mirrorClass: mirrorClass
          }, args));
        });
      }
      /**
       * Removes source ID from cloned mirror element
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @return {Promise}
       * @private
       */


      function removeMirrorID(_ref6) {
        var mirror = _ref6.mirror,
            args = _objectWithoutProperties(_ref6, ['mirror']);

        return withPromise(function (resolve) {
          mirror.removeAttribute('id');
          delete mirror.id;
          resolve(_extends({
            mirror: mirror
          }, args));
        });
      }
      /**
       * Positions mirror with translate3d
       * @param {Object} state
       * @param {HTMLElement} state.mirror
       * @param {SensorEvent} state.sensorEvent
       * @param {Object} state.mirrorOffset
       * @param {Number} state.initialY
       * @param {Number} state.initialX
       * @param {Object} state.options
       * @return {Promise}
       * @private
       */


      function positionMirror() {
        var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref20$withFrame = _ref20.withFrame,
            withFrame = _ref20$withFrame === void 0 ? false : _ref20$withFrame,
            _ref20$initial = _ref20.initial,
            initial = _ref20$initial === void 0 ? false : _ref20$initial;

        return function (_ref7) {
          var mirror = _ref7.mirror,
              sensorEvent = _ref7.sensorEvent,
              mirrorOffset = _ref7.mirrorOffset,
              initialY = _ref7.initialY,
              initialX = _ref7.initialX,
              scrollOffset = _ref7.scrollOffset,
              options = _ref7.options,
              args = _objectWithoutProperties(_ref7, ['mirror', 'sensorEvent', 'mirrorOffset', 'initialY', 'initialX', 'scrollOffset', 'options']);

          return withPromise(function (resolve) {
            var result = _extends({
              mirror: mirror,
              sensorEvent: sensorEvent,
              mirrorOffset: mirrorOffset,
              options: options
            }, args);

            if (mirrorOffset) {
              var x = sensorEvent.clientX - mirrorOffset.left - scrollOffset.x;
              var y = sensorEvent.clientY - mirrorOffset.top - scrollOffset.y;

              if (options.xAxis && options.yAxis || initial) {
                mirror.style.transform = "translate3d(".concat(x, "px, ").concat(y, "px, 0)");
              } else if (options.xAxis && !options.yAxis) {
                mirror.style.transform = "translate3d(".concat(x, "px, ").concat(initialY, "px, 0)");
              } else if (options.yAxis && !options.xAxis) {
                mirror.style.transform = "translate3d(".concat(initialX, "px, ").concat(y, "px, 0)");
              }

              if (initial) {
                result.initialX = x;
                result.initialY = y;
              }
            }

            resolve(result);
          }, {
            frame: withFrame
          });
        };
      }
      /**
       * Wraps functions in promise with potential animation frame option
       * @param {Function} callback
       * @param {Object} options
       * @param {Boolean} options.raf
       * @return {Promise}
       * @private
       */


      function withPromise(callback) {
        var _ref21 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref21$raf = _ref21.raf,
            raf = _ref21$raf === void 0 ? false : _ref21$raf;

        return new Promise(function (resolve, reject) {
          if (raf) {
            requestAnimationFrame(function () {
              callback(resolve, reject);
            });
          } else {
            callback(resolve, reject);
          }
        });
      }
      /**
       * Returns true if the sensor event was triggered by a native browser drag event
       * @param {SensorEvent} sensorEvent
       */


      function isNativeDragEvent(sensorEvent) {
        return /^drag/.test(sensorEvent.originalEvent.type);
      }
      /***/

    },
    /* 57 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _Mirror = __webpack_require__(56);

      var _Mirror2 = _interopRequireDefault(_Mirror);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Mirror2["default"];
      exports.defaultOptions = _Mirror.defaultOptions;
      /***/
    },
    /* 58 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onInitialize = Symbol('onInitialize');
      var onDestroy = Symbol('onDestroy');
      /**
       * Focusable default options
       * @property {Object} defaultOptions
       * @type {Object}
       */

      var defaultOptions = {};
      /**
       * Focusable plugin
       * @class Focusable
       * @module Focusable
       * @extends AbstractPlugin
       */

      var Focusable = /*#__PURE__*/function (_AbstractPlugin2$defa7) {
        _inheritsLoose(Focusable, _AbstractPlugin2$defa7);

        /**
         * Focusable constructor.
         * @constructs Focusable
         * @param {Draggable} draggable - Draggable instance
         */
        function Focusable(draggable) {
          var _this32;

          _this32 = _AbstractPlugin2$defa7.call(this, draggable) || this;
          /**
           * Focusable options
           * @property {Object} options
           * @type {Object}
           */

          _this32.options = _extends({}, defaultOptions, _this32.getOptions());
          _this32[onInitialize] = _this32[onInitialize].bind(_assertThisInitialized(_this32));
          _this32[onDestroy] = _this32[onDestroy].bind(_assertThisInitialized(_this32));
          return _this32;
        }
        /**
         * Attaches listeners to draggable
         */


        var _proto17 = Focusable.prototype;

        _proto17.attach = function attach() {
          this.draggable.on('draggable:initialize', this[onInitialize]).on('draggable:destroy', this[onDestroy]);
        }
        /**
         * Detaches listeners from draggable
         */
        ;

        _proto17.detach = function detach() {
          this.draggable.off('draggable:initialize', this[onInitialize]).off('draggable:destroy', this[onDestroy]);
        }
        /**
         * Returns options passed through draggable
         * @return {Object}
         */
        ;

        _proto17.getOptions = function getOptions() {
          return this.draggable.options.focusable || {};
        }
        /**
         * Returns draggable containers and elements
         * @return {HTMLElement[]}
         */
        ;

        _proto17.getElements = function getElements() {
          return [].concat(_toConsumableArray(this.draggable.containers), _toConsumableArray(this.draggable.getDraggableElements()));
        }
        /**
         * Intialize handler
         * @private
         */
        ;

        _proto17[onInitialize] = function () {
          var _this33 = this;

          // Can wait until the next best frame is available
          requestAnimationFrame(function () {
            _this33.getElements().forEach(function (element) {
              return decorateElement(element);
            });
          });
        }
        /**
         * Destroy handler
         * @private
         */
        ;

        _proto17[onDestroy] = function () {
          var _this34 = this;

          // Can wait until the next best frame is available
          requestAnimationFrame(function () {
            _this34.getElements().forEach(function (element) {
              return stripElement(element);
            });
          });
        };

        return Focusable;
      }(_AbstractPlugin2["default"]);

      exports["default"] = Focusable;
      /**
       * Keeps track of all the elements that are missing tabindex attributes
       * so they can be reset when draggable gets destroyed
       * @const {HTMLElement[]} elementsWithMissingTabIndex
       */

      var elementsWithMissingTabIndex = [];
      /**
       * Decorates element with tabindex attributes
       * @param {HTMLElement} element
       * @return {Object}
       * @private
       */

      function decorateElement(element) {
        var hasMissingTabIndex = Boolean(!element.getAttribute('tabindex') && element.tabIndex === -1);

        if (hasMissingTabIndex) {
          elementsWithMissingTabIndex.push(element);
          element.tabIndex = 0;
        }
      }
      /**
       * Removes elements tabindex attributes
       * @param {HTMLElement} element
       * @private
       */


      function stripElement(element) {
        var tabIndexElementPosition = elementsWithMissingTabIndex.indexOf(element);

        if (tabIndexElementPosition !== -1) {
          element.tabIndex = -1;
          elementsWithMissingTabIndex.splice(tabIndexElementPosition, 1);
        }
      }
      /***/

    },
    /* 59 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _Focusable = __webpack_require__(58);

      var _Focusable2 = _interopRequireDefault(_Focusable);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Focusable2["default"];
      /***/
    },
    /* 60 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      /**
       * All draggable plugins inherit from this class.
       * @abstract
       * @class AbstractPlugin
       * @module AbstractPlugin
       */

      var AbstractPlugin = /*#__PURE__*/function () {
        /**
         * AbstractPlugin constructor.
         * @constructs AbstractPlugin
         * @param {Draggable} draggable - Draggable instance
         */
        function AbstractPlugin(draggable) {
          /**
           * Draggable instance
           * @property draggable
           * @type {Draggable}
           */
          this.draggable = draggable;
        }
        /**
         * Override to add listeners
         * @abstract
         */


        var _proto18 = AbstractPlugin.prototype;

        _proto18.attach = function attach() {
          throw new Error('Not Implemented');
        }
        /**
         * Override to remove listeners
         * @abstract
         */
        ;

        _proto18.detach = function detach() {
          throw new Error('Not Implemented');
        };

        return AbstractPlugin;
      }();

      exports["default"] = AbstractPlugin;
      /***/
    },
    /* 61 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      var onInitialize = Symbol('onInitialize');
      var onDestroy = Symbol('onDestroy');
      var announceEvent = Symbol('announceEvent');
      var announceMessage = Symbol('announceMessage');
      var ARIA_RELEVANT = 'aria-relevant';
      var ARIA_ATOMIC = 'aria-atomic';
      var ARIA_LIVE = 'aria-live';
      var ROLE = 'role';
      /**
       * Announcement default options
       * @property {Object} defaultOptions
       * @property {Number} defaultOptions.expire
       * @type {Object}
       */

      var defaultOptions = exports.defaultOptions = {
        expire: 7000
      };
      /**
       * Announcement plugin
       * @class Announcement
       * @module Announcement
       * @extends AbstractPlugin
       */

      var Announcement = /*#__PURE__*/function (_AbstractPlugin2$defa8) {
        _inheritsLoose(Announcement, _AbstractPlugin2$defa8);

        /**
         * Announcement constructor.
         * @constructs Announcement
         * @param {Draggable} draggable - Draggable instance
         */
        function Announcement(draggable) {
          var _this35;

          _this35 = _AbstractPlugin2$defa8.call(this, draggable) || this;
          /**
           * Plugin options
           * @property options
           * @type {Object}
           */

          _this35.options = _extends({}, defaultOptions, _this35.getOptions());
          /**
           * Original draggable trigger method. Hack until we have onAll or on('all')
           * @property originalTriggerMethod
           * @type {Function}
           */

          _this35.originalTriggerMethod = _this35.draggable.trigger;
          _this35[onInitialize] = _this35[onInitialize].bind(_assertThisInitialized(_this35));
          _this35[onDestroy] = _this35[onDestroy].bind(_assertThisInitialized(_this35));
          return _this35;
        }
        /**
         * Attaches listeners to draggable
         */


        var _proto19 = Announcement.prototype;

        _proto19.attach = function attach() {
          this.draggable.on('draggable:initialize', this[onInitialize]);
        }
        /**
         * Detaches listeners from draggable
         */
        ;

        _proto19.detach = function detach() {
          this.draggable.off('draggable:destroy', this[onDestroy]);
        }
        /**
         * Returns passed in options
         */
        ;

        _proto19.getOptions = function getOptions() {
          return this.draggable.options.announcements || {};
        }
        /**
         * Announces event
         * @private
         * @param {AbstractEvent} event
         */
        ;

        _proto19[announceEvent] = function (event) {
          var message = this.options[event.type];

          if (message && typeof message === 'string') {
            this[announceMessage](message);
          }

          if (message && typeof message === 'function') {
            this[announceMessage](message(event));
          }
        }
        /**
         * Announces message to screen reader
         * @private
         * @param {String} message
         */
        ;

        _proto19[announceMessage] = function (message) {
          announce(message, {
            expire: this.options.expire
          });
        }
        /**
         * Initialize hander
         * @private
         */
        ;

        _proto19[onInitialize] = function () {
          var _this36 = this;

          // Hack until there is an api for listening for all events
          this.draggable.trigger = function (event) {
            try {
              _this36[announceEvent](event);
            } finally {
              // Ensure that original trigger is called
              _this36.originalTriggerMethod.call(_this36.draggable, event);
            }
          };
        }
        /**
         * Destroy hander
         * @private
         */
        ;

        _proto19[onDestroy] = function () {
          this.draggable.trigger = this.originalTriggerMethod;
        };

        return Announcement;
      }(_AbstractPlugin2["default"]);

      exports["default"] = Announcement;
      /**
       * @const {HTMLElement} liveRegion
       */

      var liveRegion = createRegion();
      /**
       * Announces message via live region
       * @param {String} message
       * @param {Object} options
       * @param {Number} options.expire
       */

      function announce(message, _ref22) {
        var expire = _ref22.expire;
        var element = document.createElement('div');
        element.textContent = message;
        liveRegion.appendChild(element);
        return setTimeout(function () {
          liveRegion.removeChild(element);
        }, expire);
      }
      /**
       * Creates region element
       * @return {HTMLElement}
       */


      function createRegion() {
        var element = document.createElement('div');
        element.setAttribute('id', 'draggable-live-region');
        element.setAttribute(ARIA_RELEVANT, 'additions');
        element.setAttribute(ARIA_ATOMIC, 'true');
        element.setAttribute(ARIA_LIVE, 'assertive');
        element.setAttribute(ROLE, 'log');
        element.style.position = 'fixed';
        element.style.width = '1px';
        element.style.height = '1px';
        element.style.top = '-1px';
        element.style.overflow = 'hidden';
        return element;
      } // Append live region element as early as possible


      document.addEventListener('DOMContentLoaded', function () {
        document.body.appendChild(liveRegion);
      });
      /***/
    },
    /* 62 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.defaultOptions = undefined;

      var _Announcement = __webpack_require__(61);

      var _Announcement2 = _interopRequireDefault(_Announcement);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports["default"] = _Announcement2["default"];
      exports.defaultOptions = _Announcement.defaultOptions;
      /***/
    },
    /* 63 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DraggableDestroyEvent = exports.DraggableInitializedEvent = exports.DraggableEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base draggable event
       * @class DraggableEvent
       * @module DraggableEvent
       * @extends AbstractEvent
       */


      var DraggableEvent = /*#__PURE__*/function (_AbstractEvent2$defau8) {
        _inheritsLoose(DraggableEvent, _AbstractEvent2$defau8);

        function DraggableEvent() {
          return _AbstractEvent2$defau8.apply(this, arguments) || this;
        }

        _createClass(DraggableEvent, [{
          key: "draggable",

          /**
           * Draggable instance
           * @property draggable
           * @type {Draggable}
           * @readonly
           */
          get: function get() {
            return this.data.draggable;
          }
        }]);

        return DraggableEvent;
      }(_AbstractEvent2["default"]);

      exports.DraggableEvent = DraggableEvent;
      /**
       * Draggable initialized event
       * @class DraggableInitializedEvent
       * @module DraggableInitializedEvent
       * @extends DraggableEvent
       */

      DraggableEvent.type = 'draggable';

      var DraggableInitializedEvent = /*#__PURE__*/function (_DraggableEvent2) {
        _inheritsLoose(DraggableInitializedEvent, _DraggableEvent2);

        function DraggableInitializedEvent() {
          return _DraggableEvent2.apply(this, arguments) || this;
        }

        return DraggableInitializedEvent;
      }(DraggableEvent);

      exports.DraggableInitializedEvent = DraggableInitializedEvent;
      /**
       * Draggable destory event
       * @class DraggableInitializedEvent
       * @module DraggableDestroyEvent
       * @extends DraggableDestroyEvent
       */

      DraggableInitializedEvent.type = 'draggable:initialize';

      var DraggableDestroyEvent = /*#__PURE__*/function (_DraggableEvent3) {
        _inheritsLoose(DraggableDestroyEvent, _DraggableEvent3);

        function DraggableDestroyEvent() {
          return _DraggableEvent3.apply(this, arguments) || this;
        }

        return DraggableDestroyEvent;
      }(DraggableEvent);

      exports.DraggableDestroyEvent = DraggableDestroyEvent;
      DraggableDestroyEvent.type = 'draggable:destroy';
      /***/
    },
    /* 64 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      var _canceled = Symbol('canceled');
      /**
       * All events fired by draggable inherit this class. You can call `cancel()` to
       * cancel a specific event or you can check if an event has been canceled by
       * calling `canceled()`.
       * @abstract
       * @class AbstractEvent
       * @module AbstractEvent
       */


      var AbstractEvent = /*#__PURE__*/function () {
        /**
         * AbstractEvent constructor.
         * @constructs AbstractEvent
         * @param {object} data - Event data
         */

        /**
         * Event type
         * @static
         * @abstract
         * @property type
         * @type {String}
         */
        function AbstractEvent(data) {
          this[_canceled] = false;
          this.data = data;
        }
        /**
         * Read-only type
         * @abstract
         * @return {String}
         */

        /**
         * Event cancelable
         * @static
         * @abstract
         * @property cancelable
         * @type {Boolean}
         */


        var _proto20 = AbstractEvent.prototype;

        /**
         * Cancels the event instance
         * @abstract
         */
        _proto20.cancel = function cancel() {
          this[_canceled] = true;
        }
        /**
         * Check if event has been canceled
         * @abstract
         * @return {Boolean}
         */
        ;

        _proto20.canceled = function canceled() {
          return Boolean(this[_canceled]);
        }
        /**
         * Returns new event instance with existing event data.
         * This method allows for overriding of event data.
         * @param {Object} data
         * @return {AbstractEvent}
         */
        ;

        _proto20.clone = function clone(data) {
          return new this.constructor(_extends({}, this.data, data));
        };

        _createClass(AbstractEvent, [{
          key: "type",
          get: function get() {
            return this.constructor.type;
          }
          /**
           * Read-only cancelable
           * @abstract
           * @return {Boolean}
           */

        }, {
          key: "cancelable",
          get: function get() {
            return this.constructor.cancelable;
          }
        }]);

        return AbstractEvent;
      }();

      exports["default"] = AbstractEvent;
      AbstractEvent.type = 'event';
      AbstractEvent.cancelable = false;
      /***/
    },
    /* 65 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DragStopEvent = exports.DragPressureEvent = exports.DragOutContainerEvent = exports.DragOverContainerEvent = exports.DragOutEvent = exports.DragOverEvent = exports.DragMoveEvent = exports.DragStartEvent = exports.DragEvent = undefined;

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      /**
       * Base drag event
       * @class DragEvent
       * @module DragEvent
       * @extends AbstractEvent
       */


      var DragEvent = /*#__PURE__*/function (_AbstractEvent2$defau9) {
        _inheritsLoose(DragEvent, _AbstractEvent2$defau9);

        function DragEvent() {
          return _AbstractEvent2$defau9.apply(this, arguments) || this;
        }

        _createClass(DragEvent, [{
          key: "source",

          /**
           * Draggables source element
           * @property source
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.source;
          }
          /**
           * Draggables original source element
           * @property originalSource
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "originalSource",
          get: function get() {
            return this.data.originalSource;
          }
          /**
           * Draggables mirror element
           * @property mirror
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "mirror",
          get: function get() {
            return this.data.mirror;
          }
          /**
           * Draggables source container element
           * @property sourceContainer
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "sourceContainer",
          get: function get() {
            return this.data.sourceContainer;
          }
          /**
           * Sensor event
           * @property sensorEvent
           * @type {SensorEvent}
           * @readonly
           */

        }, {
          key: "sensorEvent",
          get: function get() {
            return this.data.sensorEvent;
          }
          /**
           * Original event that triggered sensor event
           * @property originalEvent
           * @type {Event}
           * @readonly
           */

        }, {
          key: "originalEvent",
          get: function get() {
            if (this.sensorEvent) {
              return this.sensorEvent.originalEvent;
            }

            return null;
          }
        }]);

        return DragEvent;
      }(_AbstractEvent2["default"]);

      exports.DragEvent = DragEvent;
      /**
       * Drag start event
       * @class DragStartEvent
       * @module DragStartEvent
       * @extends DragEvent
       */

      DragEvent.type = 'drag';

      var DragStartEvent = /*#__PURE__*/function (_DragEvent2) {
        _inheritsLoose(DragStartEvent, _DragEvent2);

        function DragStartEvent() {
          return _DragEvent2.apply(this, arguments) || this;
        }

        return DragStartEvent;
      }(DragEvent);

      exports.DragStartEvent = DragStartEvent;
      /**
       * Drag move event
       * @class DragMoveEvent
       * @module DragMoveEvent
       * @extends DragEvent
       */

      DragStartEvent.type = 'drag:start';
      DragStartEvent.cancelable = true;

      var DragMoveEvent = /*#__PURE__*/function (_DragEvent3) {
        _inheritsLoose(DragMoveEvent, _DragEvent3);

        function DragMoveEvent() {
          return _DragEvent3.apply(this, arguments) || this;
        }

        return DragMoveEvent;
      }(DragEvent);

      exports.DragMoveEvent = DragMoveEvent;
      /**
       * Drag over event
       * @class DragOverEvent
       * @module DragOverEvent
       * @extends DragEvent
       */

      DragMoveEvent.type = 'drag:move';

      var DragOverEvent = /*#__PURE__*/function (_DragEvent4) {
        _inheritsLoose(DragOverEvent, _DragEvent4);

        function DragOverEvent() {
          return _DragEvent4.apply(this, arguments) || this;
        }

        _createClass(DragOverEvent, [{
          key: "overContainer",

          /**
           * Draggable container you are over
           * @property overContainer
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.overContainer;
          }
          /**
           * Draggable element you are over
           * @property over
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "over",
          get: function get() {
            return this.data.over;
          }
        }]);

        return DragOverEvent;
      }(DragEvent);

      exports.DragOverEvent = DragOverEvent;
      /**
       * Drag out event
       * @class DragOutEvent
       * @module DragOutEvent
       * @extends DragEvent
       */

      DragOverEvent.type = 'drag:over';
      DragOverEvent.cancelable = true;

      var DragOutEvent = /*#__PURE__*/function (_DragEvent5) {
        _inheritsLoose(DragOutEvent, _DragEvent5);

        function DragOutEvent() {
          return _DragEvent5.apply(this, arguments) || this;
        }

        _createClass(DragOutEvent, [{
          key: "overContainer",

          /**
           * Draggable container you are over
           * @property overContainer
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.overContainer;
          }
          /**
           * Draggable element you left
           * @property over
           * @type {HTMLElement}
           * @readonly
           */

        }, {
          key: "over",
          get: function get() {
            return this.data.over;
          }
        }]);

        return DragOutEvent;
      }(DragEvent);

      exports.DragOutEvent = DragOutEvent;
      /**
       * Drag over container event
       * @class DragOverContainerEvent
       * @module DragOverContainerEvent
       * @extends DragEvent
       */

      DragOutEvent.type = 'drag:out';

      var DragOverContainerEvent = /*#__PURE__*/function (_DragEvent6) {
        _inheritsLoose(DragOverContainerEvent, _DragEvent6);

        function DragOverContainerEvent() {
          return _DragEvent6.apply(this, arguments) || this;
        }

        _createClass(DragOverContainerEvent, [{
          key: "overContainer",

          /**
           * Draggable container you are over
           * @property overContainer
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.overContainer;
          }
        }]);

        return DragOverContainerEvent;
      }(DragEvent);

      exports.DragOverContainerEvent = DragOverContainerEvent;
      /**
       * Drag out container event
       * @class DragOutContainerEvent
       * @module DragOutContainerEvent
       * @extends DragEvent
       */

      DragOverContainerEvent.type = 'drag:over:container';

      var DragOutContainerEvent = /*#__PURE__*/function (_DragEvent7) {
        _inheritsLoose(DragOutContainerEvent, _DragEvent7);

        function DragOutContainerEvent() {
          return _DragEvent7.apply(this, arguments) || this;
        }

        _createClass(DragOutContainerEvent, [{
          key: "overContainer",

          /**
           * Draggable container you left
           * @property overContainer
           * @type {HTMLElement}
           * @readonly
           */
          get: function get() {
            return this.data.overContainer;
          }
        }]);

        return DragOutContainerEvent;
      }(DragEvent);

      exports.DragOutContainerEvent = DragOutContainerEvent;
      /**
       * Drag pressure event
       * @class DragPressureEvent
       * @module DragPressureEvent
       * @extends DragEvent
       */

      DragOutContainerEvent.type = 'drag:out:container';

      var DragPressureEvent = /*#__PURE__*/function (_DragEvent8) {
        _inheritsLoose(DragPressureEvent, _DragEvent8);

        function DragPressureEvent() {
          return _DragEvent8.apply(this, arguments) || this;
        }

        _createClass(DragPressureEvent, [{
          key: "pressure",

          /**
           * Pressure applied on draggable element
           * @property pressure
           * @type {Number}
           * @readonly
           */
          get: function get() {
            return this.data.pressure;
          }
        }]);

        return DragPressureEvent;
      }(DragEvent);

      exports.DragPressureEvent = DragPressureEvent;
      /**
       * Drag stop event
       * @class DragStopEvent
       * @module DragStopEvent
       * @extends DragEvent
       */

      DragPressureEvent.type = 'drag:pressure';

      var DragStopEvent = /*#__PURE__*/function (_DragEvent9) {
        _inheritsLoose(DragStopEvent, _DragEvent9);

        function DragStopEvent() {
          return _DragEvent9.apply(this, arguments) || this;
        }

        return DragStopEvent;
      }(DragEvent);

      exports.DragStopEvent = DragStopEvent;
      DragStopEvent.type = 'drag:stop';
      /***/
    },
    /* 66 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Plugins = exports.Sensors = exports.Sortable = exports.Swappable = exports.Droppable = exports.Draggable = exports.BasePlugin = exports.BaseEvent = undefined;

      var _Draggable = __webpack_require__(5);

      Object.defineProperty(exports, 'Draggable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Draggable)["default"];
        }
      });

      var _Droppable = __webpack_require__(34);

      Object.defineProperty(exports, 'Droppable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Droppable)["default"];
        }
      });

      var _Swappable = __webpack_require__(31);

      Object.defineProperty(exports, 'Swappable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Swappable)["default"];
        }
      });

      var _Sortable = __webpack_require__(28);

      Object.defineProperty(exports, 'Sortable', {
        enumerable: true,
        get: function get() {
          return _interopRequireDefault(_Sortable)["default"];
        }
      });

      var _AbstractEvent = __webpack_require__(0);

      var _AbstractEvent2 = _interopRequireDefault(_AbstractEvent);

      var _AbstractPlugin = __webpack_require__(1);

      var _AbstractPlugin2 = _interopRequireDefault(_AbstractPlugin);

      var _Sensors = __webpack_require__(6);

      var Sensors = _interopRequireWildcard(_Sensors);

      var _Plugins = __webpack_require__(25);

      var Plugins = _interopRequireWildcard(_Plugins);

      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};

          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }

          newObj["default"] = obj;
          return newObj;
        }
      }

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }

      exports.BaseEvent = _AbstractEvent2["default"];
      exports.BasePlugin = _AbstractPlugin2["default"];
      exports.Sensors = Sensors;
      exports.Plugins = Plugins;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(44)(module)))

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _inserter = __webpack_require__(28);

var _inserter2 = __webpack_require__(305);

var _inserter3 = __webpack_require__(306);

var _formula = __webpack_require__(307);

var _parameter = __webpack_require__(309);

var _socket = __webpack_require__(322);

BI.extend(BI, {
  FormulaInserter: _inserter.FormulaInserter,
  ComplexFormulaInserter: _inserter2.ComplexFormulaInserter,
  RegularFormulaInserter: _inserter3.RegularFormulaInserter,
  FormulaOpeartingPanel: _formula.FormulaOpeartingPanel,
  ParameterEditor: _parameter.ParameterEditor,
  initSocket: _socket.initSocket
});

/***/ }),
/* 302 */
/***/ (function(module, exports) {

module.exports = BI.CodeMirror;

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormulaFunctionItem = void 0;

var _decorator = __webpack_require__(1);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FormulaFunctionItem = (_dec = (0, _decorator.shortcut)(), _dec(_class = (_class2 = /*#__PURE__*/function (_BI$BasicButton) {
  _inheritsLoose(FormulaFunctionItem, _BI$BasicButton);

  function FormulaFunctionItem() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$BasicButton.call.apply(_BI$BasicButton, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      baseCls: "bi-list-item-select",
      text: "",
      title: "",
      value: ""
    });

    return _this;
  }

  var _proto = FormulaFunctionItem.prototype;

  _proto.render = function render() {
    var _this2 = this;

    return {
      type: BI.TextButton.xtype,
      text: this.options.text,
      value: this.options.value,
      trigger: "dblclick",
      textAlign: "left",
      hgap: 5,
      handler: function handler() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this2.fireEvent.apply(_this2, [BI.Controller.EVENT_CHANGE, BI.Events.CLICK].concat(args));
      }
    };
  };

  return FormulaFunctionItem;
}(BI.BasicButton), _defineProperty(_class2, "xtype", "bi.formula.function_item"), _class2)) || _class);
exports.FormulaFunctionItem = FormulaFunctionItem;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormulaVarItem = void 0;

var _decorator = __webpack_require__(1);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FormulaVarItem = (_dec = (0, _decorator.shortcut)(), _dec(_class = (_class2 = /*#__PURE__*/function (_BI$BasicButton) {
  _inheritsLoose(FormulaVarItem, _BI$BasicButton);

  function FormulaVarItem() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$BasicButton.call.apply(_BI$BasicButton, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "leaf", void 0);

    _defineProperty(_assertThisInitialized(_this), "props", {
      text: "",
      title: "",
      value: "",
      layoutType: BI.MidTreeLeafItem.xtype
    });

    return _this;
  }

  var _proto = FormulaVarItem.prototype;

  _proto.render = function render() {
    var _this2 = this;

    return {
      type: BI.HTapeLayout.xtype,
      items: [{
        type: BI.Label.xtype,
        width: 16
      }, {
        type: this.options.layoutType,
        cls: "bi-list-item-select",
        ref: function ref(_ref) {
          _this2.leaf = _ref;
        },
        text: this.options.text,
        value: this.options.value,
        trigger: "dblclick",
        textAlign: "left",
        handler: function handler() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this2.fireEvent.apply(_this2, [BI.Controller.EVENT_CHANGE, BI.Events.CLICK].concat(args));
        }
      }]
    };
  };

  _proto.setSelected = function setSelected(flag) {
    _BI$BasicButton.prototype.setSelected.call(this, flag);

    this.leaf.setSelected(flag);
  };

  return FormulaVarItem;
}(BI.BasicButton), _defineProperty(_class2, "xtype", "bi.formula.var_item"), _class2)) || _class);
exports.FormulaVarItem = FormulaVarItem;

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComplexFormulaInserter = void 0;

var _inserter = __webpack_require__(28);

var _decorator = __webpack_require__(1);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ComplexFormulaInserter = (_dec = (0, _decorator.shortcut)(), _dec(_class = (_class2 = /*#__PURE__*/function (_FormulaInserter) {
  _inheritsLoose(ComplexFormulaInserter, _FormulaInserter);

  function ComplexFormulaInserter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _FormulaInserter.call.apply(_FormulaInserter, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: {
        formula: "",
        keepFormulaWhenExportOrEdit: false,
        keepFormulaWhenReportOrAnalyze: true
      }
    });

    _defineProperty(_assertThisInitialized(_this), "exportOrEditCheckbox", void 0);

    _defineProperty(_assertThisInitialized(_this), "reportOrAnalyzeCheckbox", void 0);

    return _this;
  }

  var _proto = ComplexFormulaInserter.prototype;

  _proto.getToolbarLayout = function getToolbarLayout() {
    var _this2 = this;

    return {
      type: BI.VerticalAdaptLayout.xtype,
      items: [{
        type: BI.MultiSelectItem.xtype,
        ref: function ref(_ref) {
          _this2.exportOrEditCheckbox = _ref;
        },
        width: 180,
        lgap: 10,
        text: BI.i18nText("BI-Basic_Export_Or_Edit_Keep_Formula"),
        selected: this.options.value.keepFormulaWhenExportOrEdit,
        listeners: [{
          eventName: BI.MultiSelectItem.EVENT_CHANGE,
          action: function action() {
            var isSelected = _this2.exportOrEditCheckbox.isSelected();

            if (isSelected) {
              _this2.reportOrAnalyzeCheckbox.setEnable(false);

              _this2.reportOrAnalyzeCheckbox.setSelected(true);
            } else {
              _this2.reportOrAnalyzeCheckbox.setEnable(true);
            }
          }
        }]
      }, {
        type: BI.MultiSelectItem.xtype,
        ref: function ref(_ref) {
          _this2.reportOrAnalyzeCheckbox = _ref;
        },
        width: 220,
        lgap: 10,
        text: BI.i18nText("BI-Basic_Report_Or_Analyze_Keep_Formula"),
        disabled: this.options.value.keepFormulaWhenExportOrEdit,
        selected: this.options.value.keepFormulaWhenReportOrAnalyze
      }, {
        type: BI.Button.xtype,
        text: BI.i18nText("BI-Basic_Check_Validation"),
        handler: function handler() {
          _this2.validate();
        }
      }]
    };
  };

  _proto.getValue = function getValue() {
    return {
      formula: this.formulaEditor.getValue(),
      keepFormulaWhenExportOrEdit: this.exportOrEditCheckbox.isSelected(),
      keepFormulaWhenReportOrAnalyze: this.reportOrAnalyzeCheckbox.isSelected()
    };
  };

  return ComplexFormulaInserter;
}(_inserter.FormulaInserter), _defineProperty(_class2, "xtype", "bi.formula_operating_panel.complex.inserter"), _class2)) || _class);
exports.ComplexFormulaInserter = ComplexFormulaInserter;

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RegularFormulaInserter = void 0;

var _inserter = __webpack_require__(28);

var _decorator = __webpack_require__(1);

var _dec, _class, _class2;

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var RegularFormulaInserter = (_dec = (0, _decorator.shortcut)(), _dec(_class = (_class2 = /*#__PURE__*/function (_FormulaInserter) {
  _inheritsLoose(RegularFormulaInserter, _FormulaInserter);

  function RegularFormulaInserter() {
    return _FormulaInserter.apply(this, arguments) || this;
  }

  var _proto = RegularFormulaInserter.prototype;

  _proto.getToolbarLayout = function getToolbarLayout() {
    var _this = this;

    return {
      type: BI.AbsoluteLayout.xtype,
      items: [{
        el: {
          type: BI.Button.xtype,
          text: BI.i18nText("BI-Basic_Check_Validation"),
          handler: function handler() {
            _this.validate();
          }
        },
        right: 93,
        top: 12
      }]
    };
  };

  return RegularFormulaInserter;
}(_inserter.FormulaInserter), _defineProperty(_class2, "xtype", "bi.formula_operating_panel.regular.inserter"), _class2)) || _class);
exports.RegularFormulaInserter = RegularFormulaInserter;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormulaOpeartingPanel = void 0;

var _decorator = __webpack_require__(1);

var _formula = __webpack_require__(45);

var _formula2 = __webpack_require__(308);

var _inserter = __webpack_require__(28);

var _formula3 = __webpack_require__(46);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var searchPaneWidth = 253;
var searchButtonWidth = 54;
var LabelTitleHeight = 24;
var FormulaOpeartingPanel = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _decorator.store)(_formula2.FormulaModel), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Pane) {
  _inheritsLoose(FormulaOpeartingPanel, _BI$Pane);

  function FormulaOpeartingPanel() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Pane.call.apply(_BI$Pane, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "functionTypeGroup", void 0);

    _defineProperty(_assertThisInitialized(_this), "functionNameGroup", void 0);

    _defineProperty(_assertThisInitialized(_this), "model", void 0);

    _defineProperty(_assertThisInitialized(_this), "store", void 0);

    _defineProperty(_assertThisInitialized(_this), "descriptionLabel", void 0);

    _defineProperty(_assertThisInitialized(_this), "searchEditor", void 0);

    _defineProperty(_assertThisInitialized(_this), "relatedFunctionNameGroup", void 0);

    _defineProperty(_assertThisInitialized(_this), "formulaEditor", void 0);

    _defineProperty(_assertThisInitialized(_this), "varTree", void 0);

    _defineProperty(_assertThisInitialized(_this), "props", {
      inserterType: _inserter.FormulaInserter.xtype,
      value: {
        formula: ""
      },
      configLoader: function configLoader() {
        return new Promise(function (resolve) {
          resolve({
            vars: [],
            JSONs: []
          });
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "watch", {
      functionNames: function functionNames() {
        _this.functionNameGroup.populate(_this.model.functionNames);

        _this.scrollFunctionName2View();
      },
      selectedFunctionNameOrVarName: function selectedFunctionNameOrVarName() {
        if ((0, _formula.isBelong2FormulaFunction)(_this.model.selectedFunctionNameOrVarName)) {
          _this.functionNameGroup.setValue(_this.model.selectedFunctionNameOrVarName);

          _this.scrollFunctionName2View();
        }
      },
      selectedFunctionType: function selectedFunctionType() {
        _this.functionTypeGroup.setValue(_this.model.selectedFunctionType);

        _this.functionNameGroup.setValue(_this.model.selectedFunctionNameOrVarName);
      },
      functionDescription: function functionDescription() {
        _this.descriptionLabel.setText(_this.model.functionDescription);
      },
      relatedFunctionNames: function relatedFunctionNames() {
        var relatedFunctionNames = _this.model.relatedFunctionNames;

        _this.relatedFunctionNameGroup.populate(relatedFunctionNames);

        var relatedFunctionName = BI.isEmptyArray(relatedFunctionNames) ? null : BI.first(relatedFunctionNames).value;

        _this.relatedFunctionNameGroup.setValue(relatedFunctionName);

        relatedFunctionName && _this.store.setSelectedFunctionName(relatedFunctionName);
      },
      isCached: function isCached() {
        _this.functionTypeGroup.populate((0, _formula.transformFormulaJSONs2FunctionTypes)());

        _this.functionTypeGroup.setValue(_this.model.selectedFunctionType);

        _this.functionNameGroup.setValue(_this.model.selectedFunctionNameOrVarName);

        _this.varTree.populate((0, _formula.transformFormulaVarItems)());
      }
    });

    return _this;
  }

  var _proto = FormulaOpeartingPanel.prototype;

  _proto.render = function render() {
    var _this2 = this;

    return {
      type: BI.VTapeLayout.xtype,
      items: [{
        el: {
          type: BI.LeftRightVerticalAdaptLayout.xtype,
          items: {
            left: [{
              type: BI.Label.xtype,
              text: BI.i18nText("BI-Basic_Please_Input_Formula")
            }],
            right: [{
              type: BI.SearchEditor.xtype,
              ref: function ref(_ref) {
                _this2.searchEditor = _ref;
              },
              width: searchPaneWidth - searchButtonWidth - 5,
              listeners: [{
                eventName: BI.SearchEditor.EVENT_ENTER,
                action: function action() {
                  _this2.store.setKeyword(_this2.searchEditor.getValue());
                }
              }, {
                eventName: BI.SearchEditor.EVENT_EMPTY,
                action: function action() {
                  _this2.store.setKeyword("");
                }
              }]
            }, {
              lgap: 5,
              el: {
                type: BI.Button.xtype,
                text: BI.i18nText("BI-Basic_Search"),
                minWidth: 0,
                width: searchButtonWidth,
                handler: function handler() {
                  _this2.store.setKeyword(_this2.searchEditor.getValue());
                }
              }
            }]
          }
        },
        height: LabelTitleHeight
      }, {
        el: {
          type: BI.HTapeLayout.xtype,
          items: [{
            type: this.options.inserterType,
            ref: function ref(_ref) {
              _this2.formulaEditor = _ref;
            },
            value: this.options.value,
            rgap: 10,
            listeners: [{
              eventName: "EVENT_SHOW_HINT",
              action: function action(hint) {
                _this2.store.setSelectedFunctionName(hint);

                _this2.scrollFunctionName2View();
              }
            }, {
              eventName: "EVENT_SELECT_HINT",
              action: function action(hint) {
                _this2.store.setSelectedFunctionName(hint);

                _this2.scrollFunctionName2View();
              }
            }]
          }, {
            el: {
              type: BI.ButtonGroup.xtype,
              ref: function ref(_ref) {
                _this2.relatedFunctionNameGroup = _ref;
              },
              cls: "bi-border",
              items: this.model.relatedFunctionNames,
              layouts: [{
                type: BI.VerticalLayout.xtype
              }],
              listeners: [{
                eventName: BI.ButtonGroup.EVENT_CHANGE,
                action: function action(val) {
                  _this2.store.setSelectedFunctionName(val);
                }
              }]
            },
            width: searchPaneWidth
          }]
        },
        height: 200,
        tgap: 10
      }, {
        type: BI.HTapeLayout.xtype,
        items: [{
          el: {
            type: BI.VTapeLayout.xtype,
            items: [{
              el: {
                type: BI.Label.xtype,
                text: BI.i18nText("BI-Basic_Function_Type"),
                textAlign: "left"
              },
              height: LabelTitleHeight
            }, {
              type: BI.ButtonGroup.xtype,
              ref: function ref(_ref) {
                _this2.functionTypeGroup = _ref;
              },
              value: this.model.selectedFunctionType,
              cls: "bi-border",
              items: (0, _formula.transformFormulaJSONs2FunctionTypes)(),
              layouts: [{
                type: BI.VerticalLayout.xtype
              }],
              listeners: [{
                eventName: BI.ButtonGroup.EVENT_CHANGE,
                action: function action(val) {
                  _this2.store.setSelectedFunctionType(val);
                }
              }]
            }]
          },
          width: 135
        }, {
          el: {
            type: BI.VTapeLayout.xtype,
            items: [{
              el: {
                type: BI.Label.xtype,
                text: BI.i18nText("BI-Basic_Function_Name"),
                textAlign: "left"
              },
              height: LabelTitleHeight
            }, {
              type: BI.ButtonGroup.xtype,
              ref: function ref(_ref) {
                _this2.functionNameGroup = _ref;
              },
              value: this.model.selectedFunctionNameOrVarName,
              cls: "bi-border",
              items: this.model.functionNames,
              layouts: [{
                type: BI.VerticalLayout.xtype
              }],
              listeners: [{
                eventName: BI.Controller.EVENT_CHANGE,
                action: function action(_type, val, _widget, e) {
                  _this2.store.setSelectedFunctionName(val, false);

                  if (e.type === "dblclick") {
                    _this2.formulaEditor.insertFunction(val);
                  }
                }
              }]
            }]
          },
          lgap: 5,
          width: 135
        }, {
          el: {
            type: BI.VTapeLayout.xtype,
            items: [{
              el: {
                type: BI.Label.xtype,
                text: BI.i18nText("BI-Basic_Vars"),
                textAlign: "left"
              },
              height: LabelTitleHeight
            }, {
              type: BI.CustomTree.xtype,
              cls: "bi-border",
              chooseType: BI.Selection.Single,
              ref: function ref(_ref) {
                _this2.varTree = _ref;
              },
              el: {
                type: BI.ButtonTree.xtype,
                layouts: [{
                  type: BI.VerticalLayout.xtype
                }]
              },
              items: (0, _formula.transformFormulaVarItems)(),
              listeners: [{
                eventName: BI.Controller.EVENT_CHANGE,
                action: function action(type, val, _widget, e) {
                  if (type !== BI.Events.CLICK) {
                    return;
                  }

                  _this2.store.setSelectedVarName(val);

                  if (e && e.type === "dblclick") {
                    _this2.formulaEditor.insertField(val);
                  }
                }
              }]
            }]
          },
          lgap: 5,
          width: 300
        }, {
          el: {
            type: BI.VTapeLayout.xtype,
            items: [{
              el: {
                type: BI.Label.xtype,
                text: BI.i18nText("BI-Basic_Function_Description"),
                textAlign: "left"
              },
              height: LabelTitleHeight
            }, {
              type: BI.VerticalLayout.xtype,
              cls: "bi-border",
              items: [{
                el: {
                  type: BI.Text.xtype,
                  ref: function ref(_ref) {
                    _this2.descriptionLabel = _ref;
                  },
                  text: this.model.functionDescription,
                  whiteSpace: "normal",
                  hgap: 5
                }
              }]
            }]
          },
          lgap: 5
        }]
      }]
    };
  };

  _proto.beforeRender = function beforeRender(callback) {
    var _this3 = this;

    if ((0, _formula.isFormulaConfigCached)()) {
      callback();
      return;
    }

    this.loading();
    this.options.configLoader().then(function (data) {
      _this3.loaded();

      (0, _formula.setFormulaConfigCache)(data);

      _this3.store.setSelectedFunctionName(_formula3.DEFAULT_FUNCTION_NAME);

      callback();
    });
  }
  /**
   * functionName滚动到可见区域
   */
  ;

  _proto.scrollFunctionName2View = function scrollFunctionName2View() {
    var _this4 = this;

    if (!this.model.needScrollToView) {
      return;
    }

    var functionNameWidget = this.functionNameGroup.getAllButtons().find(function (functionNameWidget) {
      return functionNameWidget.getValue() === _this4.model.selectedFunctionNameOrVarName;
    });

    if (BI.isNull(functionNameWidget)) {
      return;
    }

    functionNameWidget.element[0].scrollIntoView();
  };

  _proto.getValue = function getValue() {
    return this.formulaEditor.getValue();
  }
  /**
   * 对外加载数据的接口
   * @param data 数据
   */
  ;

  _proto.loadConfigData = function loadConfigData(data) {
    if ((0, _formula.isFormulaConfigCached)()) {
      return;
    }

    (0, _formula.setFormulaConfigCache)(data);
    this.store.setSelectedFunctionName(_formula3.DEFAULT_FUNCTION_NAME);
  };

  return FormulaOpeartingPanel;
}(BI.Pane), _defineProperty(_class2, "xtype", "bi.formula_operating_panel"), _class2)) || _class) || _class);
exports.FormulaOpeartingPanel = FormulaOpeartingPanel;

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FormulaModel = void 0;

var _decorator = __webpack_require__(1);

var _formula = __webpack_require__(45);

var _formula2 = __webpack_require__(46);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FormulaModel = (_dec = (0, _decorator.model)(), _dec(_class = (_class2 = /*#__PURE__*/function (_Model) {
  _inheritsLoose(FormulaModel, _Model);

  function FormulaModel() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Model.call.apply(_Model, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "computed", {
      functionNames: function functionNames() {
        return (0, _formula.transformFormulaJSONs2FunctionNames)(_this.model.selectedFunctionType);
      },
      functionDescription: function functionDescription() {
        return (0, _formula.getFunctionDescriptionByFunctionName)(_this.model.selectedFunctionNameOrVarName) || (0, _formula.getVarDescriptionByVarName)(_this.model.selectedFunctionNameOrVarName);
      },
      relatedFunctionNames: function relatedFunctionNames() {
        return (0, _formula.getSearchedFunctionNames)(_this.model.keyword);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "actions", {
      setSelectedFunctionType: function setSelectedFunctionType(val) {
        _this.model.selectedFunctionType = val;
        _this.model.selectedFunctionNameOrVarName = (BI.first((0, _formula.transformFormulaJSONs2FunctionNames)(_this.model.selectedFunctionType)) || {}).value;
      },
      setSelectedFunctionName: function setSelectedFunctionName(_functionName) {
        var needScrollToView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var functionName = _functionName.toUpperCase();

        var speculatedFunctionType = (0, _formula.getFunctionTypeByFunctionName)(functionName);

        if (BI.isNull(speculatedFunctionType)) {
          return;
        }

        _this.model.selectedFunctionType = speculatedFunctionType;
        _this.model.selectedFunctionNameOrVarName = functionName;
        _this.model.needScrollToView = needScrollToView;
      },
      setKeyword: function setKeyword(val) {
        _this.model.keyword = val;
      },
      setSelectedVarName: function setSelectedVarName(val) {
        _this.model.selectedFunctionNameOrVarName = val;
      }
    });

    return _this;
  }

  var _proto = FormulaModel.prototype;

  _proto.state = function state() {
    return {
      selectedFunctionType: (0, _formula.getFunctionTypeByFunctionName)(_formula2.DEFAULT_FUNCTION_NAME) || _formula2.DEFAULT_FUNCTION_TYPE,
      selectedFunctionNameOrVarName: _formula2.DEFAULT_FUNCTION_NAME,
      keyword: "",
      needScrollToView: true
    };
  };

  return FormulaModel;
}(_decorator.Model), _defineProperty(_class2, "xtype", "bi.model.formula_operating_panel"), _class2)) || _class);
exports.FormulaModel = FormulaModel;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParameterEditor = void 0;

var _decorator = __webpack_require__(1);

var _parameter = __webpack_require__(310);

var _parameter_input = __webpack_require__(311);

var _parameter_header = __webpack_require__(321);

var _parameter_header2 = __webpack_require__(110);

var _dec, _dec2, _class, _class2;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ParameterEditor = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _decorator.store)(_parameter.ParameterModel), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(ParameterEditor, _BI$Widget);

  function ParameterEditor() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      height: 200,
      title: "",
      headers: _parameter_header2.defaultHeaderItems,
      value: []
    });

    _defineProperty(_assertThisInitialized(_this), "parameterInputs", void 0);

    _defineProperty(_assertThisInitialized(_this), "model", void 0);

    _defineProperty(_assertThisInitialized(_this), "store", void 0);

    _defineProperty(_assertThisInitialized(_this), "watch", {
      parameters: function parameters() {
        _this.parameterInputs.populate(_this.renderParameterInputs());
      },
      selectedId: function selectedId(id) {
        _this.parameterInputs.setValue(id);
      }
    });

    return _this;
  }

  var _proto = ParameterEditor.prototype;

  _proto.render = function render() {
    var _this2 = this;

    this.setDefaultValue();
    return {
      type: BI.VTapeLayout.xtype,
      items: [{
        el: this.renderHeader(),
        height: 25
      }, {
        el: {
          type: BI.CenterLayout.xtype,
          cls: "bi-border",
          items: [{
            type: BI.Label.xtype,
            text: BI.i18nText("BI-Basic_Parameter_Name")
          }, {
            type: BI.Label.xtype,
            cls: "bi-border-left",
            text: BI.i18nText("BI-Basic_Parameter_Value")
          }]
        },
        height: 25
      }, {
        type: BI.ButtonGroup.xtype,
        cls: "bi-border",
        layouts: [{
          type: BI.VerticalLayout.xtype
        }],
        items: this.renderParameterInputs(),
        ref: function ref(_ref) {
          _this2.parameterInputs = _ref;
        }
      }]
    };
  };

  _proto.renderHeader = function renderHeader() {
    var _this3 = this;

    var _this$options = this.options,
        title = _this$options.title,
        headers = _this$options.headers;
    return {
      type: _parameter_header.ParameterHeader.xtype,
      title: title,
      headers: headers,
      listeners: [{
        eventName: "EVENT_INSERT",
        action: function action() {
          _this3.addItem({
            name: "",
            value: "",
            id: BI.UUID(),
            type: "String"
          });
        }
      }, {
        eventName: "EVENT_DELETE",
        action: function action() {
          _this3.removeSelectedItem();
        }
      }, {
        eventName: "EVENT_MOVE_UP",
        action: function action() {
          _this3.moveUp();
        }
      }, {
        eventName: "EVENT_MOVE_DOWN",
        action: function action() {
          _this3.moveDown();
        }
      }, {
        eventName: "EVENT_REFRESH",
        action: function action() {
          _this3.refresh();

          _this3.fireEvent("EVENT_REFRESH");
        }
      }]
    };
  };

  _proto.getValue = function getValue() {
    return this.model.parameters.map(function (item) {
      return {
        name: item.name,
        value: item.value,
        type: item.type
      };
    });
  };

  _proto.setValue = function setValue(value) {
    this.store.setParameters(value.map(function (item) {
      return _objectSpread(_objectSpread({}, item), {}, {
        id: BI.UUID()
      });
    }));
  };

  _proto.addItem = function addItem(item) {
    var _item$name = item.name,
        name = _item$name === void 0 ? "" : _item$name,
        _item$value = item.value,
        value = _item$value === void 0 ? "" : _item$value,
        _item$type = item.type,
        type = _item$type === void 0 ? "String" : _item$type;
    this.store.setParameters([].concat(_toConsumableArray(this.model.parameters), [{
      name: name,
      value: value,
      type: type,
      id: BI.UUID()
    }]));
  };

  _proto.removeSelectedItem = function removeSelectedItem() {
    var _this4 = this;

    if (this.model.selectedId) {
      BI.Msg.confirm(BI.i18nText("BI-Basic_Prompt"), BI.i18nText("BI-Basic_Parameter_Delete_Confirm"), function (re) {
        if (re) {
          _this4.store.removeSelectedParameter();
        }
      });
    } else {
      BI.Msg.alert(BI.i18nText("BI-Basic_Prompt"), BI.i18nText("BI-Basic_Parameter_Delete_Alert"));
    }
  };

  _proto.moveUp = function moveUp() {
    this.store.move("up");
  };

  _proto.moveDown = function moveDown() {
    this.store.move("down");
  };

  _proto.refresh = function refresh() {
    this.setDefaultValue();
  };

  _proto.setDefaultValue = function setDefaultValue() {
    var _this$options$value = this.options.value,
        value = _this$options$value === void 0 ? [] : _this$options$value;
    this.setValue(value);
  };

  _proto.renderParameterInputs = function renderParameterInputs() {
    var _this5 = this;

    return this.model.parameters.map(function (item) {
      return {
        type: _parameter_input.ParameterInput.xtype,
        inputName: item.name,
        inputValue: item.value,
        inputType: item.type,
        id: item.id,
        value: item.id,
        selected: item.id === _this5.model.selectedId,
        listeners: [{
          eventName: 'EVENT_CHANGE',
          action: function action() {
            _this5.fireEvent('EVENT_CHANGE');
          }
        }]
      };
    });
  };

  return ParameterEditor;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor"), _class2)) || _class) || _class);
exports.ParameterEditor = ParameterEditor;

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParameterModel = void 0;

var _decorator = __webpack_require__(1);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ParameterModel = (_dec = (0, _decorator.model)(), _dec(_class = (_class2 = /*#__PURE__*/function (_Model) {
  _inheritsLoose(ParameterModel, _Model);

  function ParameterModel() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Model.call.apply(_Model, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "childContext", ["selectedId", "parameters"]);

    _defineProperty(_assertThisInitialized(_this), "actions", {
      setParameters: function setParameters(parameters) {
        _this.model.parameters = parameters;
      },
      removeSelectedParameter: function removeSelectedParameter() {
        _this.setParameters(_this.model.parameters.filter(function (item) {
          return item.id !== _this.model.selectedId;
        }));
      },
      move: function move(type) {
        if (_this.model.selectedId) {
          var index = _this.model.parameters.findIndex(function (item) {
            return item.id === _this.model.selectedId;
          });

          if (type === "up" && index > 0) {
            var oldItem = _this.model.parameters.splice(index, 1)[0];

            _this.model.parameters.splice(index - 1, 0, oldItem);
          }

          if (type === "down" && index < _this.model.parameters.length - 1) {
            var _oldItem = _this.model.parameters.splice(index, 1)[0];

            _this.model.parameters.splice(index + 1, 0, _oldItem);
          }
        }
      }
    });

    return _this;
  }

  var _proto = ParameterModel.prototype;

  _proto.state = function state() {
    return {
      parameters: [],
      selectedId: ""
    };
  };

  return ParameterModel;
}(_decorator.Model), _defineProperty(_class2, "xtype", "bi.model.parameter_editor"), _class2)) || _class);
exports.ParameterModel = ParameterModel;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParameterInput = void 0;

var _decorator = __webpack_require__(1);

__webpack_require__(312);

var _input2 = __webpack_require__(14);

__webpack_require__(319);

var _parameter_input2 = __webpack_require__(320);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var tipType = "tip";
var ParameterInput = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _decorator.store)(_parameter_input2.ParameterInputModel), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$BasicButton) {
  _inheritsLoose(ParameterInput, _BI$BasicButton);

  function ParameterInput() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$BasicButton.call.apply(_BI$BasicButton, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      inputName: "",
      inputValue: "",
      inputType: "String",
      height: 22,
      id: "",
      baseCls: "parameter-editor-input",
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "store", void 0);

    _defineProperty(_assertThisInitialized(_this), "model", void 0);

    _defineProperty(_assertThisInitialized(_this), "tab", void 0);

    _defineProperty(_assertThisInitialized(_this), "parameterName", void 0);

    _defineProperty(_assertThisInitialized(_this), "parameterValue", void 0);

    _defineProperty(_assertThisInitialized(_this), "iconCombo", void 0);

    return _this;
  }

  var _proto = ParameterInput.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var _this$options = this.options,
        inputName = _this$options.inputName,
        inputValue = _this$options.inputValue;
    var inputType = this.options.inputType;
    var id = this.options.id;
    return {
      type: BI.CenterLayout.xtype,
      cls: "bi-border",
      items: [{
        type: BI.Editor.xtype,
        height: 22,
        allowBlank: true,
        value: inputName,
        ref: function ref(_ref) {
          _this2.parameterName = _ref;
        },
        listeners: [{
          eventName: BI.TextEditor.EVENT_CHANGE,
          action: function action() {
            inputName = _this2.parameterName.getValue();

            _this2.tab.setSelect(inputName ? inputType : tipType);

            inputValue = inputName ? inputValue : "";

            _this2.store.setParameterName(id, inputName);

            _this2.fireEvent(BI.TextEditor.EVENT_CHANGE);
          }
        }, {
          eventName: BI.TextEditor.EVENT_FOCUS,
          action: function action() {
            _this2.store.setSelectedId(id);
          }
        }]
      }, {
        type: BI.HTapeLayout.xtype,
        items: [{
          type: BI.Tab.xtype,
          single: true,
          showIndex: inputName ? inputType : tipType,
          ref: function ref(_ref) {
            _this2.tab = _ref;
          },
          cardCreator: function cardCreator(index) {
            return _this2.renderInputs(index);
          }
        }]
      }]
    };
  };

  _proto.renderInputs = function renderInputs(type) {
    var _this3 = this;

    var _this$options2 = this.options,
        inputValue = _this$options2.inputValue,
        id = _this$options2.id;

    if (type === "tip") {
      return {
        type: BI.TextButton.xtype,
        cls: "bi-error bi-border-left",
        text: BI.i18nText("BI-Basic_Parameter_Please_Set_Parameter_Name"),
        handler: function handler() {
          _this3.parameterName.focus();
        }
      };
    }

    var xtype = (0, _input2.getInput)(type);
    return {
      type: BI.HTapeLayout.xtype,
      items: [{
        el: {
          type: BI.IconCombo.xtype,
          cls: "bi-border-left bi-border-right",
          height: 22,
          width: 25,
          value: type,
          items: this.renderDownList(),
          ref: function ref(_ref) {
            _this3.iconCombo = _ref;
          },
          listeners: [{
            eventName: "EVENT_CHANGE",
            action: function action() {
              _this3.tab.setSelect(tipType);

              var typeValue = _this3.iconCombo.getValue()[0];

              if (typeValue) {
                _this3.tab.setSelect(typeValue);
              }

              _this3.store.setParameterValue(id, "", typeValue);

              _this3.fireEvent('EVENT_CHANGE');
            }
          }]
        },
        width: 25
      }, {
        type: xtype,
        value: inputValue,
        listeners: [{
          eventName: "EVENT_CHANGE",
          action: function action(value) {
            var type = _this3.iconCombo.getValue()[0];

            _this3.store.setParameterValue(id, value, type);

            _this3.fireEvent("EVENT_CHANGE");
          }
        }, {
          eventName: "EVENT_FOCUS",
          action: function action() {
            _this3.store.setSelectedId(id);
          }
        }]
      }]
    };
  };

  _proto.renderDownList = function renderDownList() {
    return [{
      text: BI.i18nText("BI-Basic_Parameter_Type_String"),
      value: "String",
      iconCls: "parameter-string-font"
    }, {
      text: BI.i18nText("BI-Basic_Parameter_Type_Int"),
      value: "Integer",
      iconCls: "parameter-int-font"
    }, {
      text: BI.i18nText("BI-Basic_Parameter_Type_Number"),
      value: "Double",
      iconCls: "parameter-double-font"
    }, {
      text: BI.i18nText("BI-Basic_Parameter_Type_Date"),
      value: "Date",
      iconCls: "parameter-date-font"
    }, {
      text: BI.i18nText("BI-Basic_Parameter_Type_Boolean"),
      value: "Boolean",
      iconCls: "parameter-boolean-font"
    }, {
      text: BI.i18nText("BI-Basic_Parameter_Type_Formula"),
      value: "Formula",
      iconCls: "parameter-formula-font"
    }];
  };

  return ParameterInput;
}(BI.BasicButton), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input"), _class2)) || _class) || _class);
exports.ParameterInput = ParameterInput;

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(313);

__webpack_require__(314);

__webpack_require__(315);

__webpack_require__(316);

__webpack_require__(317);

__webpack_require__(318);

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputBoolean = void 0;

var _decorator = __webpack_require__(1);

var _input = __webpack_require__(14);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputBoolean = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _input.input)("Boolean"), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$BasicButton) {
  _inheritsLoose(InputBoolean, _BI$BasicButton);

  function InputBoolean() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$BasicButton.call.apply(_BI$BasicButton, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "input", void 0);

    _defineProperty(_assertThisInitialized(_this), "hasSelected", void 0);

    return _this;
  }

  var _proto = InputBoolean.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var value = this.options.value;
    this.hasSelected = value === "true";
    return {
      type: BI.MultiSelectItem.xtype,
      width: 80,
      selected: this.hasSelected,
      text: "true",
      ref: function ref(_ref) {
        _this2.input = _ref;
      },
      listeners: [{
        eventName: BI.MultiSelectItem.EVENT_CHANGE,
        action: function action() {
          _this2.hasSelected = !_this2.hasSelected;

          _this2.fireEvent("EVENT_CHANGE", _this2.hasSelected);
        }
      }]
    };
  };

  _proto.doClick = function doClick() {
    this.fireEvent("EVENT_FOCUS");
  };

  return InputBoolean;
}(BI.BasicButton), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input.boolean"), _class2)) || _class) || _class);
exports.InputBoolean = InputBoolean;

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputDate = void 0;

var _decorator = __webpack_require__(1);

var _input = __webpack_require__(14);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputDate = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _input.input)("Date"), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(InputDate, _BI$Widget);

  function InputDate() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "input", void 0);

    return _this;
  }

  var _proto = InputDate.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var value = this.options.value;
    var dates = value.split("-");
    return {
      type: BI.DynamicDateCombo.xtype,
      height: 22,
      allowBlank: true,
      value: dates.length === 3 ? {
        year: dates[0],
        month: dates[1],
        day: dates[2]
      } : "",
      ref: function ref(_ref) {
        _this2.input = _ref;
      },
      listeners: [{
        eventName: BI.DynamicDateCombo.EVENT_CONFIRM,
        action: function action() {
          var _ref2 = _this2.input.getValue().value,
              day = _ref2.day,
              month = _ref2.month,
              year = _ref2.year;

          _this2.fireEvent("EVENT_CHANGE", "".concat(year, "-").concat(month, "-").concat(day));
        }
      }, {
        eventName: BI.DynamicDateCombo.EVENT_FOCUS,
        action: function action() {
          _this2.fireEvent("EVENT_FOCUS");
        }
      }]
    };
  };

  return InputDate;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input.date"), _class2)) || _class) || _class);
exports.InputDate = InputDate;

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputInt = void 0;

var _decorator = __webpack_require__(1);

var _input = __webpack_require__(14);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputInt = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _input.input)("Integer"), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(InputInt, _BI$Widget);

  function InputInt() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "input", void 0);

    return _this;
  }

  var _proto = InputInt.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var value = this.options.value;
    return {
      type: BI.Editor.xtype,
      height: 22,
      allowBlank: true,
      value: value,
      ref: function ref(_ref) {
        _this2.input = _ref;
      },
      validationChecker: function validationChecker(v) {
        return BI.isInteger(v);
      },
      listeners: [{
        eventName: BI.Editor.EVENT_CHANGE,
        action: function action() {
          var value = _this2.input.getValue();

          _this2.fireEvent("EVENT_CHANGE", value);
        }
      }, {
        eventName: BI.Editor.EVENT_FOCUS,
        action: function action() {
          _this2.fireEvent("EVENT_FOCUS");
        }
      }]
    };
  };

  return InputInt;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input.int"), _class2)) || _class) || _class);
exports.InputInt = InputInt;

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputDouble = void 0;

var _decorator = __webpack_require__(1);

var _input = __webpack_require__(14);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputDouble = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _input.input)("Double"), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(InputDouble, _BI$Widget);

  function InputDouble() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "input", void 0);

    return _this;
  }

  var _proto = InputDouble.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var value = this.options.value;
    return {
      type: BI.Editor.xtype,
      height: 22,
      allowBlank: true,
      value: value,
      ref: function ref(_ref) {
        _this2.input = _ref;
      },
      validationChecker: function validationChecker(v) {
        return BI.isNumeric(v);
      },
      listeners: [{
        eventName: BI.Editor.EVENT_CHANGE,
        action: function action() {
          var value = _this2.input.getValue();

          _this2.fireEvent("EVENT_CHANGE", value);
        }
      }, {
        eventName: BI.Editor.EVENT_FOCUS,
        action: function action() {
          _this2.fireEvent("EVENT_FOCUS");
        }
      }]
    };
  };

  return InputDouble;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input.double"), _class2)) || _class) || _class);
exports.InputDouble = InputDouble;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputString = void 0;

var _decorator = __webpack_require__(1);

var _input = __webpack_require__(14);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputString = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _input.input)("String"), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(InputString, _BI$Widget);

  function InputString() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "input", void 0);

    return _this;
  }

  var _proto = InputString.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var value = this.options.value;
    return {
      type: BI.Editor.xtype,
      height: 22,
      allowBlank: true,
      value: value,
      ref: function ref(_ref) {
        _this2.input = _ref;
      },
      listeners: [{
        eventName: BI.Editor.EVENT_CHANGE,
        action: function action() {
          var value = _this2.input.getValue();

          _this2.fireEvent("EVENT_CHANGE", value);
        }
      }, {
        eventName: BI.Editor.EVENT_FOCUS,
        action: function action() {
          _this2.fireEvent("EVENT_FOCUS");
        }
      }]
    };
  };

  return InputString;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input.string"), _class2)) || _class) || _class);
exports.InputString = InputString;

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputFormula = void 0;

var _decorator = __webpack_require__(1);

var _input = __webpack_require__(14);

var _dec, _dec2, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var InputFormula = (_dec = (0, _decorator.shortcut)(), _dec2 = (0, _input.input)("Formula"), _dec(_class = _dec2(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(InputFormula, _BI$Widget);

  function InputFormula() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      value: ""
    });

    _defineProperty(_assertThisInitialized(_this), "input", void 0);

    return _this;
  }

  var _proto = InputFormula.prototype;

  _proto.mounted = function mounted() {// TODO: 打开公式编辑器
  };

  _proto.render = function render() {
    var _this2 = this;

    var value = this.options.value;
    return {
      type: BI.Editor.xtype,
      height: 22,
      allowBlank: true,
      value: value,
      ref: function ref(_ref) {
        _this2.input = _ref;
      },
      listeners: [{
        eventName: BI.Editor.EVENT_CHANGE,
        action: function action() {
          var value = _this2.input.getValue();

          _this2.fireEvent("EVENT_CHANGE", value);
        }
      }, {
        eventName: BI.Editor.EVENT_FOCUS,
        action: function action() {
          _this2.fireEvent("EVENT_FOCUS");
        }
      }]
    };
  };

  return InputFormula;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor.parameter_input.formula"), _class2)) || _class) || _class);
exports.InputFormula = InputFormula;

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParameterInputModel = void 0;

var _decorator = __webpack_require__(1);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ParameterInputModel = (_dec = (0, _decorator.model)(), _dec(_class = (_class2 = /*#__PURE__*/function (_Model) {
  _inheritsLoose(ParameterInputModel, _Model);

  function ParameterInputModel() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Model.call.apply(_Model, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "context", ["selectedId", "parameters"]);

    _defineProperty(_assertThisInitialized(_this), "actions", {
      setSelectedId: function setSelectedId(id) {
        _this.model.selectedId = id;
      },
      setParameterName: function setParameterName(id, name) {
        var thisParameter = _this.getParameter(id);

        if (thisParameter) {
          thisParameter.name = name;
        }
      },
      setParameterValue: function setParameterValue(id, value, type) {
        var thisParameter = _this.getParameter(id);

        if (thisParameter) {
          thisParameter.value = value;
          thisParameter.type = type;
        }
      }
    });

    return _this;
  }

  var _proto = ParameterInputModel.prototype;

  _proto.getParameter = function getParameter(id) {
    return this.model.parameters.find(function (item) {
      return item.id === id;
    });
  };

  return ParameterInputModel;
}(_decorator.Model), _defineProperty(_class2, "xtype", "bi.model.parameter_editor.parameter_input"), _class2)) || _class);
exports.ParameterInputModel = ParameterInputModel;

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParameterHeader = void 0;

var _decorator = __webpack_require__(1);

var _parameter_header = __webpack_require__(110);

var _dec, _class, _class2;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { _defaults(o, p); return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ParameterHeader = (_dec = (0, _decorator.shortcut)(), _dec(_class = (_class2 = /*#__PURE__*/function (_BI$Widget) {
  _inheritsLoose(ParameterHeader, _BI$Widget);

  function ParameterHeader() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BI$Widget.call.apply(_BI$Widget, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "props", {
      title: "",
      headers: _parameter_header.defaultHeaderItems
    });

    return _this;
  }

  var _proto = ParameterHeader.prototype;

  _proto.render = function render() {
    var title = this.options.title;
    return {
      type: BI.LeftRightVerticalAdaptLayout.xtype,
      items: {
        left: [{
          type: BI.Label.xtype,
          lgap: 2,
          text: title,
          textAlign: "left"
        }],
        right: this.renderItem()
      }
    };
  };

  _proto.renderItem = function renderItem() {
    var _this2 = this;

    var headers = this.options.headers;
    return headers.map(function (item) {
      if (BI.isString(item)) {
        var head = _parameter_header.headerItemsData.find(function (data) {
          return data.type === item;
        });

        if (head) {
          return {
            type: BI.IconButton.xtype,
            cls: head.cls,
            width: 25,
            title: BI.i18nText(head.title),
            handler: function handler() {
              _this2.fireEvent(head.event);
            }
          };
        }

        return {
          type: "bi.default"
        };
      }

      return item;
    });
  };

  return ParameterHeader;
}(BI.Widget), _defineProperty(_class2, "xtype", "bi.parameter_editor.header"), _class2)) || _class);
exports.ParameterHeader = ParameterHeader;

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initSocket = initSocket;

/**
 * 初始化socket连接
 * @param {*} options 连接socket的参数
 * @param {*} cb 返回连接结果
 */
function initSocket(options, cb) {
  var callback = BI.isFunction(cb) ? cb : BI.emptyFn;
  var useJavaxWebSocket = options.useJavaxWebSocket || false;

  if (useJavaxWebSocket) {
    return initJavaxWebSocket(options, callback);
  }

  return initFallbackWebSocket(null, options, callback);
}
/**
 * 新的websocket连接方案,无需额外的端口
 * @param options
 * @param callback
 * @returns {*}
 */


function initJavaxWebSocket(options, callback) {
  var socket;
  var requestUrl = options.requestUrl,
      contextPath = options.contextPath,
      webSocketNameSpace = options.webSocketNameSpace,
      query = options.query,
      extraOptions = options.options;
  var contextName = "".concat(contextPath === "/" ? "" : contextPath, "/websocket");

  try {
    socket = io("".concat(requestUrl).concat(location.port ? ":".concat(location.port) : "").concat(webSocketNameSpace), BI.extend({
      query: query,
      path: contextName,
      transports: ["websocket", "polling"],
      timeout: 15000
    }, extraOptions));
    var fallback = true; // 监听到失败或者超时时改用旧方案,仅初次建立连接时候失败会走降级方案,连接成功后再遇到断开连接将在当前方案基础上执行重连逻辑

    socket.on("connect_error", function () {
      socket.off("connect_error");
      socket.off("connect");
      fallback && initFallbackWebSocket(socket, options, callback);
    });
    socket.on("connect", function () {
      fallback = false;
      callback("success");
    });
    return socket;
  } catch (e) {
    throw new Error(e);
  }
}
/**
 * 旧的方案websocket连接方案,需要额外的端口
 * @param socket
 * @param options
 * @param callback
 * @returns {*}
 */


function initFallbackWebSocket(socket, options, callback) {
  var ports = options.webSocketPort,
      requestUrl = options.requestUrl,
      webSocketNameSpace = options.webSocketNameSpace,
      query = options.query,
      webSocketContextName = options.webSocketContextName,
      extraOptions = options.options;

  function reconnect(manager) {
    if (BI.isEmptyArray(ports)) {
      callback("fail");
      return;
    }

    manager.uri = "".concat(requestUrl, ":").concat(ports.shift()).concat(webSocketNameSpace);
    manager.connect(function () {});
  }

  try {
    if (BI.isNull(socket)) {
      socket = io("".concat(requestUrl, ":").concat(ports.shift()).concat(webSocketNameSpace), BI.extend({
        query: query,
        path: webSocketContextName,
        transports: ["polling", "websocket"],
        timeout: 5000
      }, extraOptions));
    } else {
      socket.io.opts.path = webSocketContextName;
      socket.io.opts.query = query;
      socket.io.opts.transports = ["polling", "websocket"];
      socket.io.uri = "".concat(requestUrl, ":").concat(ports.shift()).concat(webSocketNameSpace);
      socket.io.connect(function () {});
    } // 监听到失败或者超时时使用下一个端口


    socket.on("connect_error", function () {
      reconnect(socket.io);
    });
    socket.on("connect", function () {
      callback("success");
    });
    return socket;
  } catch (e) {
    throw new Error(e);
  }
}

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(207)(__webpack_require__(388));

/***/ }),
/* 388 */
/***/ (function(module, exports) {

module.exports = "// version 5.42.2\r\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: https://codemirror.net/LICENSE\r\n\r\n// This is CodeMirror (https://codemirror.net), a code editor\r\n// implemented in JavaScript on top of the browser's DOM.\r\n//\r\n// You can find some technical background for some of the code below\r\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\r\n\r\n(function (global, factory) {\r\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n        typeof define === 'function' && define.amd ? define(factory) :\r\n            (BI.CodeMirror = BI.CodeMirror || factory());\r\n}(this, (function () { 'use strict';\r\n\r\n    // Kludges for bugs and behavior differences that can't be feature\r\n    // detected are enabled based on userAgent etc sniffing.\r\n    var userAgent = navigator.userAgent;\r\n    var platform = navigator.platform;\r\n\r\n    var gecko = /gecko\\/\\d/i.test(userAgent);\r\n    var ie_upto10 = /MSIE \\d/.test(userAgent);\r\n    var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\r\n    var edge = /Edge\\/(\\d+)/.exec(userAgent);\r\n    var ie = ie_upto10 || ie_11up || edge;\r\n    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\r\n    var webkit = !edge && /WebKit\\//.test(userAgent);\r\n    var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\r\n    var chrome = !edge && /Chrome\\//.test(userAgent);\r\n    var presto = /Opera\\//.test(userAgent);\r\n    var safari = /Apple Computer/.test(navigator.vendor);\r\n    var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\r\n    var phantom = /PhantomJS/.test(userAgent);\r\n\r\n    var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\r\n    var android = /Android/.test(userAgent);\r\n    // This is woefully incomplete. Suggestions for alternative methods welcome.\r\n    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\r\n    var mac = ios || /Mac/.test(platform);\r\n    var chromeOS = /\\bCrOS\\b/.test(userAgent);\r\n    var windows = /win/i.test(platform);\r\n\r\n    var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\r\n    if (presto_version) { presto_version = Number(presto_version[1]); }\r\n    if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\r\n    // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\r\n    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\r\n    var captureRightClick = gecko || (ie && ie_version >= 9);\r\n\r\n    function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\r\n\r\n    var rmClass = function(node, cls) {\r\n        var current = node.className;\r\n        var match = classTest(cls).exec(current);\r\n        if (match) {\r\n            var after = current.slice(match.index + match[0].length);\r\n            node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\r\n        }\r\n    };\r\n\r\n    function removeChildren(e) {\r\n        for (var count = e.childNodes.length; count > 0; --count)\r\n        { e.removeChild(e.firstChild); }\r\n        return e\r\n    }\r\n\r\n    function removeChildrenAndAdd(parent, e) {\r\n        return removeChildren(parent).appendChild(e)\r\n    }\r\n\r\n    function elt(tag, content, className, style) {\r\n        var e = document.createElement(tag);\r\n        if (className) { e.className = className; }\r\n        if (style) { e.style.cssText = style; }\r\n        if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\r\n        else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\r\n        return e\r\n    }\r\n    // wrapper for elt, which removes the elt from the accessibility tree\r\n    function eltP(tag, content, className, style) {\r\n        var e = elt(tag, content, className, style);\r\n        e.setAttribute(\"role\", \"presentation\");\r\n        return e\r\n    }\r\n\r\n    var range;\r\n    if (document.createRange) { range = function(node, start, end, endNode) {\r\n        var r = document.createRange();\r\n        r.setEnd(endNode || node, end);\r\n        r.setStart(node, start);\r\n        return r\r\n    }; }\r\n    else { range = function(node, start, end) {\r\n        var r = document.body.createTextRange();\r\n        try { r.moveToElementText(node.parentNode); }\r\n        catch(e) { return r }\r\n        r.collapse(true);\r\n        r.moveEnd(\"character\", end);\r\n        r.moveStart(\"character\", start);\r\n        return r\r\n    }; }\r\n\r\n    function contains(parent, child) {\r\n        if (child.nodeType == 3) // Android browser always returns false when child is a textnode\r\n        { child = child.parentNode; }\r\n        if (parent.contains)\r\n        { return parent.contains(child) }\r\n        do {\r\n            if (child.nodeType == 11) { child = child.host; }\r\n            if (child == parent) { return true }\r\n        } while (child = child.parentNode)\r\n    }\r\n\r\n    function activeElt() {\r\n        // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\r\n        // IE < 10 will throw when accessed while the page is loading or in an iframe.\r\n        // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\r\n        var activeElement;\r\n        try {\r\n            activeElement = document.activeElement;\r\n        } catch(e) {\r\n            activeElement = document.body || null;\r\n        }\r\n        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\r\n        { activeElement = activeElement.shadowRoot.activeElement; }\r\n        return activeElement\r\n    }\r\n\r\n    function addClass(node, cls) {\r\n        var current = node.className;\r\n        if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\r\n    }\r\n    function joinClasses(a, b) {\r\n        var as = a.split(\" \");\r\n        for (var i = 0; i < as.length; i++)\r\n        { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\r\n        return b\r\n    }\r\n\r\n    var selectInput = function(node) { node.select(); };\r\n    if (ios) // Mobile Safari apparently has a bug where select() is broken.\r\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\r\n    else if (ie) // Suppress mysterious IE10 errors\r\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\r\n\r\n    function bind(f) {\r\n        var args = Array.prototype.slice.call(arguments, 1);\r\n        return function(){return f.apply(null, args)}\r\n    }\r\n\r\n    function copyObj(obj, target, overwrite) {\r\n        if (!target) { target = {}; }\r\n        for (var prop in obj)\r\n        { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\r\n        { target[prop] = obj[prop]; } }\r\n        return target\r\n    }\r\n\r\n    // Counts the column offset in a string, taking tabs into account.\r\n    // Used mostly to find indentation.\r\n    function countColumn(string, end, tabSize, startIndex, startValue) {\r\n        if (end == null) {\r\n            end = string.search(/[^\\s\\u00a0]/);\r\n            if (end == -1) { end = string.length; }\r\n        }\r\n        for (var i = startIndex || 0, n = startValue || 0;;) {\r\n            var nextTab = string.indexOf(\"\\t\", i);\r\n            if (nextTab < 0 || nextTab >= end)\r\n            { return n + (end - i) }\r\n            n += nextTab - i;\r\n            n += tabSize - (n % tabSize);\r\n            i = nextTab + 1;\r\n        }\r\n    }\r\n\r\n    var Delayed = function() {this.id = null;};\r\n    Delayed.prototype.set = function (ms, f) {\r\n        clearTimeout(this.id);\r\n        this.id = setTimeout(f, ms);\r\n    };\r\n\r\n    function indexOf(array, elt) {\r\n        for (var i = 0; i < array.length; ++i)\r\n        { if (array[i] == elt) { return i } }\r\n        return -1\r\n    }\r\n\r\n    // Number of pixels added to scroller and sizer to hide scrollbar\r\n    var scrollerGap = 30;\r\n\r\n    // Returned or thrown by various protocols to signal 'I'm not\r\n    // handling this'.\r\n    var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\r\n\r\n    // Reused option objects for setSelection & friends\r\n    var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\r\n\r\n    // The inverse of countColumn -- find the offset that corresponds to\r\n    // a particular column.\r\n    function findColumn(string, goal, tabSize) {\r\n        for (var pos = 0, col = 0;;) {\r\n            var nextTab = string.indexOf(\"\\t\", pos);\r\n            if (nextTab == -1) { nextTab = string.length; }\r\n            var skipped = nextTab - pos;\r\n            if (nextTab == string.length || col + skipped >= goal)\r\n            { return pos + Math.min(skipped, goal - col) }\r\n            col += nextTab - pos;\r\n            col += tabSize - (col % tabSize);\r\n            pos = nextTab + 1;\r\n            if (col >= goal) { return pos }\r\n        }\r\n    }\r\n\r\n    var spaceStrs = [\"\"];\r\n    function spaceStr(n) {\r\n        while (spaceStrs.length <= n)\r\n        { spaceStrs.push(lst(spaceStrs) + \" \"); }\r\n        return spaceStrs[n]\r\n    }\r\n\r\n    function lst(arr) { return arr[arr.length-1] }\r\n\r\n    function map(array, f) {\r\n        var out = [];\r\n        for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\r\n        return out\r\n    }\r\n\r\n    function insertSorted(array, value, score) {\r\n        var pos = 0, priority = score(value);\r\n        while (pos < array.length && score(array[pos]) <= priority) { pos++; }\r\n        array.splice(pos, 0, value);\r\n    }\r\n\r\n    function nothing() {}\r\n\r\n    function createObj(base, props) {\r\n        var inst;\r\n        if (Object.create) {\r\n            inst = Object.create(base);\r\n        } else {\r\n            nothing.prototype = base;\r\n            inst = new nothing();\r\n        }\r\n        if (props) { copyObj(props, inst); }\r\n        return inst\r\n    }\r\n\r\n    var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\r\n    function isWordCharBasic(ch) {\r\n        return /\\w/.test(ch) || ch > \"\\x80\" &&\r\n            (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\r\n    }\r\n    function isWordChar(ch, helper) {\r\n        if (!helper) { return isWordCharBasic(ch) }\r\n        if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\r\n        return helper.test(ch)\r\n    }\r\n\r\n    function isEmpty(obj) {\r\n        for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\r\n        return true\r\n    }\r\n\r\n    // Extending unicode characters. A series of a non-extending char +\r\n    // any number of extending chars is treated as a single unit as far\r\n    // as editing and measuring is concerned. This is not fully correct,\r\n    // since some scripts/fonts/browsers also treat other configurations\r\n    // of code points as a group.\r\n    var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\r\n    function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\r\n\r\n    // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\r\n    function skipExtendingChars(str, pos, dir) {\r\n        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\r\n        return pos\r\n    }\r\n\r\n    // Returns the value from the range [`from`; `to`] that satisfies\r\n    // `pred` and is closest to `from`. Assumes that at least `to`\r\n    // satisfies `pred`. Supports `from` being greater than `to`.\r\n    function findFirst(pred, from, to) {\r\n        // At any point we are certain `to` satisfies `pred`, don't know\r\n        // whether `from` does.\r\n        var dir = from > to ? -1 : 1;\r\n        for (;;) {\r\n            if (from == to) { return from }\r\n            var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\r\n            if (mid == from) { return pred(mid) ? from : to }\r\n            if (pred(mid)) { to = mid; }\r\n            else { from = mid + dir; }\r\n        }\r\n    }\r\n\r\n    // The display handles the DOM integration, both for input reading\r\n    // and content drawing. It holds references to DOM nodes and\r\n    // display-related state.\r\n\r\n    function Display(place, doc, input) {\r\n        var d = this;\r\n        this.input = input;\r\n\r\n        // Covers bottom-right square when both scrollbars are present.\r\n        d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\r\n        d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\r\n        // Covers bottom of gutter when coverGutterNextToScrollbar is on\r\n        // and h scrollbar is present.\r\n        d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\r\n        d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\r\n        // Will contain the actual code, positioned to cover the viewport.\r\n        d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\r\n        // Elements are added to these to represent selection and cursors.\r\n        d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\r\n        d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\r\n        // A visibility: hidden element used to find the size of things.\r\n        d.measure = elt(\"div\", null, \"CodeMirror-measure\");\r\n        // When lines outside of the viewport are measured, they are drawn in this.\r\n        d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\r\n        // Wraps everything that needs to exist inside the vertically-padded coordinate system\r\n        d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\r\n            null, \"position: relative; outline: none\");\r\n        var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\r\n        // Moved around its parent to cover visible view.\r\n        d.mover = elt(\"div\", [lines], null, \"position: relative\");\r\n        // Set to the height of the document, allowing scrolling.\r\n        d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\r\n        d.sizerWidth = null;\r\n        // Behavior of elts with overflow: auto and padding is\r\n        // inconsistent across browsers. This is used to ensure the\r\n        // scrollable area is big enough.\r\n        d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\r\n        // Will contain the gutters, if any.\r\n        d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\r\n        d.lineGutter = null;\r\n        // Actual scrollable element.\r\n        d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\r\n        d.scroller.setAttribute(\"tabIndex\", \"-1\");\r\n        // The element in which the editor lives.\r\n        d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\r\n\r\n        // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\r\n        if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\r\n        if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\r\n\r\n        if (place) {\r\n            if (place.appendChild) { place.appendChild(d.wrapper); }\r\n            else { place(d.wrapper); }\r\n        }\r\n\r\n        // Current rendered range (may be bigger than the view window).\r\n        d.viewFrom = d.viewTo = doc.first;\r\n        d.reportedViewFrom = d.reportedViewTo = doc.first;\r\n        // Information about the rendered lines.\r\n        d.view = [];\r\n        d.renderedView = null;\r\n        // Holds info about a single rendered line when it was rendered\r\n        // for measurement, while not in view.\r\n        d.externalMeasured = null;\r\n        // Empty space (in pixels) above the view\r\n        d.viewOffset = 0;\r\n        d.lastWrapHeight = d.lastWrapWidth = 0;\r\n        d.updateLineNumbers = null;\r\n\r\n        d.nativeBarWidth = d.barHeight = d.barWidth = 0;\r\n        d.scrollbarsClipped = false;\r\n\r\n        // Used to only resize the line number gutter when necessary (when\r\n        // the amount of lines crosses a boundary that makes its width change)\r\n        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\r\n        // Set to true when a non-horizontal-scrolling line widget is\r\n        // added. As an optimization, line widget aligning is skipped when\r\n        // this is false.\r\n        d.alignWidgets = false;\r\n\r\n        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n\r\n        // Tracks the maximum line length so that the horizontal scrollbar\r\n        // can be kept static when scrolling.\r\n        d.maxLine = null;\r\n        d.maxLineLength = 0;\r\n        d.maxLineChanged = false;\r\n\r\n        // Used for measuring wheel scrolling granularity\r\n        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\r\n\r\n        // True when shift is held down.\r\n        d.shift = false;\r\n\r\n        // Used to track whether anything happened since the context menu\r\n        // was opened.\r\n        d.selForContextMenu = null;\r\n\r\n        d.activeTouch = null;\r\n\r\n        input.init(d);\r\n    }\r\n\r\n    // Find the line object corresponding to the given line number.\r\n    function getLine(doc, n) {\r\n        n -= doc.first;\r\n        if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\r\n        var chunk = doc;\r\n        while (!chunk.lines) {\r\n            for (var i = 0;; ++i) {\r\n                var child = chunk.children[i], sz = child.chunkSize();\r\n                if (n < sz) { chunk = child; break }\r\n                n -= sz;\r\n            }\r\n        }\r\n        return chunk.lines[n]\r\n    }\r\n\r\n    // Get the part of a document between two positions, as an array of\r\n    // strings.\r\n    function getBetween(doc, start, end) {\r\n        var out = [], n = start.line;\r\n        doc.iter(start.line, end.line + 1, function (line) {\r\n            var text = line.text;\r\n            if (n == end.line) { text = text.slice(0, end.ch); }\r\n            if (n == start.line) { text = text.slice(start.ch); }\r\n            out.push(text);\r\n            ++n;\r\n        });\r\n        return out\r\n    }\r\n\r\n    function getLines(doc, from, to, lineFilter) {\r\n        var out = [];\r\n        doc.iter(from, to, function (line) {\r\n            var text = line.text;\r\n            if (lineFilter) {\r\n                text = lineFilter(line);\r\n            }\r\n            out.push(text);\r\n        });\r\n        return out;\r\n    }\r\n\r\n    // Update the height of a line, propagating the height change\r\n    // upwards to parent nodes.\r\n    function updateLineHeight(line, height) {\r\n        var diff = height - line.height;\r\n        if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\r\n    }\r\n\r\n    // Given a line object, find its line number by walking up through\r\n    // its parent links.\r\n    function lineNo(line) {\r\n        if (line.parent == null) { return null }\r\n        var cur = line.parent, no = indexOf(cur.lines, line);\r\n        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n            for (var i = 0;; ++i) {\r\n                if (chunk.children[i] == cur) { break }\r\n                no += chunk.children[i].chunkSize();\r\n            }\r\n        }\r\n        return no + cur.first\r\n    }\r\n\r\n    // Find the line at the given vertical position, using the height\r\n    // information in the document tree.\r\n    function lineAtHeight(chunk, h) {\r\n        var n = chunk.first;\r\n        outer: do {\r\n            for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\r\n                var child = chunk.children[i$1], ch = child.height;\r\n                if (h < ch) { chunk = child; continue outer }\r\n                h -= ch;\r\n                n += child.chunkSize();\r\n            }\r\n            return n\r\n        } while (!chunk.lines)\r\n        var i = 0;\r\n        for (; i < chunk.lines.length; ++i) {\r\n            var line = chunk.lines[i], lh = line.height;\r\n            if (h < lh) { break }\r\n            h -= lh;\r\n        }\r\n        return n + i\r\n    }\r\n\r\n    function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\r\n\r\n    function lineNumberFor(options, i) {\r\n        return String(options.lineNumberFormatter(i + options.firstLineNumber))\r\n    }\r\n\r\n    // A Pos instance represents a position within the text.\r\n    function Pos(line, ch, sticky) {\r\n        if ( sticky === void 0 ) sticky = null;\r\n\r\n        if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\r\n        this.line = line;\r\n        this.ch = ch;\r\n        this.sticky = sticky;\r\n    }\r\n\r\n    // Compare two positions, return 0 if they are the same, a negative\r\n    // number when a is less, and a positive number otherwise.\r\n    function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\r\n\r\n    function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\r\n\r\n    function copyPos(x) {return Pos(x.line, x.ch)}\r\n    function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\r\n    function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\r\n\r\n    // Most of the external API clips given positions to make sure they\r\n    // actually exist within the document.\r\n    function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\r\n    function clipPos(doc, pos) {\r\n        if (pos.line < doc.first) { return Pos(doc.first, 0) }\r\n        var last = doc.first + doc.size - 1;\r\n        if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\r\n        return clipToLen(pos, getLine(doc, pos.line).text.length)\r\n    }\r\n    function clipToLen(pos, linelen) {\r\n        var ch = pos.ch;\r\n        if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\r\n        else if (ch < 0) { return Pos(pos.line, 0) }\r\n        else { return pos }\r\n    }\r\n    function clipPosArray(doc, array) {\r\n        var out = [];\r\n        for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\r\n        return out\r\n    }\r\n\r\n    // Optimize some code when these features are not used.\r\n    var sawReadOnlySpans = false, sawCollapsedSpans = false;\r\n\r\n    function seeReadOnlySpans() {\r\n        sawReadOnlySpans = true;\r\n    }\r\n\r\n    function seeCollapsedSpans() {\r\n        sawCollapsedSpans = true;\r\n    }\r\n\r\n    // TEXTMARKER SPANS\r\n\r\n    function MarkedSpan(marker, from, to) {\r\n        this.marker = marker;\r\n        this.from = from; this.to = to;\r\n    }\r\n\r\n    // Search an array of spans for a span matching the given marker.\r\n    function getMarkedSpanFor(spans, marker) {\r\n        if (spans) { for (var i = 0; i < spans.length; ++i) {\r\n            var span = spans[i];\r\n            if (span.marker == marker) { return span }\r\n        } }\r\n    }\r\n    // Remove a span from an array, returning undefined if no spans are\r\n    // left (we don't store arrays for lines without spans).\r\n    function removeMarkedSpan(spans, span) {\r\n        var r;\r\n        for (var i = 0; i < spans.length; ++i)\r\n        { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\r\n        return r\r\n    }\r\n    // Add a span to a line.\r\n    function addMarkedSpan(line, span) {\r\n        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\r\n        span.marker.attachLine(line);\r\n    }\r\n\r\n    // Used for the algorithm that adjusts markers for a change in the\r\n    // document. These functions cut an array of spans at a given\r\n    // character position, returning an array of remaining chunks (or\r\n    // undefined if nothing remains).\r\n    function markedSpansBefore(old, startCh, isInsert) {\r\n        var nw;\r\n        if (old) { for (var i = 0; i < old.length; ++i) {\r\n            var span = old[i], marker = span.marker;\r\n            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\r\n            if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\r\n                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\r\n                ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\r\n            }\r\n        } }\r\n        return nw\r\n    }\r\n    function markedSpansAfter(old, endCh, isInsert) {\r\n        var nw;\r\n        if (old) { for (var i = 0; i < old.length; ++i) {\r\n            var span = old[i], marker = span.marker;\r\n            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\r\n            if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\r\n                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\r\n                ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\r\n                    span.to == null ? null : span.to - endCh));\r\n            }\r\n        } }\r\n        return nw\r\n    }\r\n\r\n    // Given a change object, compute the new set of marker spans that\r\n    // cover the line in which the change took place. Removes spans\r\n    // entirely within the change, reconnects spans belonging to the\r\n    // same marker that appear on both sides of the change, and cuts off\r\n    // spans partially within the change. Returns an array of span\r\n    // arrays with one element for each line in (after) the change.\r\n    function stretchSpansOverChange(doc, change) {\r\n        if (change.full) { return null }\r\n        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\r\n        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\r\n        if (!oldFirst && !oldLast) { return null }\r\n\r\n        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\r\n        // Get the spans that 'stick out' on both sides\r\n        var first = markedSpansBefore(oldFirst, startCh, isInsert);\r\n        var last = markedSpansAfter(oldLast, endCh, isInsert);\r\n\r\n        // Next, merge those two ends\r\n        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\r\n        if (first) {\r\n            // Fix up .to properties of first\r\n            for (var i = 0; i < first.length; ++i) {\r\n                var span = first[i];\r\n                if (span.to == null) {\r\n                    var found = getMarkedSpanFor(last, span.marker);\r\n                    if (!found) { span.to = startCh; }\r\n                    else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\r\n                }\r\n            }\r\n        }\r\n        if (last) {\r\n            // Fix up .from in last (or move them into first in case of sameLine)\r\n            for (var i$1 = 0; i$1 < last.length; ++i$1) {\r\n                var span$1 = last[i$1];\r\n                if (span$1.to != null) { span$1.to += offset; }\r\n                if (span$1.from == null) {\r\n                    var found$1 = getMarkedSpanFor(first, span$1.marker);\r\n                    if (!found$1) {\r\n                        span$1.from = offset;\r\n                        if (sameLine) { (first || (first = [])).push(span$1); }\r\n                    }\r\n                } else {\r\n                    span$1.from += offset;\r\n                    if (sameLine) { (first || (first = [])).push(span$1); }\r\n                }\r\n            }\r\n        }\r\n        // Make sure we didn't create any zero-length spans\r\n        if (first) { first = clearEmptySpans(first); }\r\n        if (last && last != first) { last = clearEmptySpans(last); }\r\n\r\n        var newMarkers = [first];\r\n        if (!sameLine) {\r\n            // Fill gap with whole-line-spans\r\n            var gap = change.text.length - 2, gapMarkers;\r\n            if (gap > 0 && first)\r\n            { for (var i$2 = 0; i$2 < first.length; ++i$2)\r\n            { if (first[i$2].to == null)\r\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\r\n            for (var i$3 = 0; i$3 < gap; ++i$3)\r\n            { newMarkers.push(gapMarkers); }\r\n            newMarkers.push(last);\r\n        }\r\n        return newMarkers\r\n    }\r\n\r\n    // Remove spans that are empty and don't have a clearWhenEmpty\r\n    // option of false.\r\n    function clearEmptySpans(spans) {\r\n        for (var i = 0; i < spans.length; ++i) {\r\n            var span = spans[i];\r\n            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\r\n            { spans.splice(i--, 1); }\r\n        }\r\n        if (!spans.length) { return null }\r\n        return spans\r\n    }\r\n\r\n    // Used to 'clip' out readOnly ranges when making a change.\r\n    function removeReadOnlyRanges(doc, from, to) {\r\n        var markers = null;\r\n        doc.iter(from.line, to.line + 1, function (line) {\r\n            if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\r\n                var mark = line.markedSpans[i].marker;\r\n                if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\r\n                { (markers || (markers = [])).push(mark); }\r\n            } }\r\n        });\r\n        if (!markers) { return null }\r\n        var parts = [{from: from, to: to}];\r\n        for (var i = 0; i < markers.length; ++i) {\r\n            var mk = markers[i], m = mk.find(0);\r\n            for (var j = 0; j < parts.length; ++j) {\r\n                var p = parts[j];\r\n                if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\r\n                var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\r\n                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\r\n                { newParts.push({from: p.from, to: m.from}); }\r\n                if (dto > 0 || !mk.inclusiveRight && !dto)\r\n                { newParts.push({from: m.to, to: p.to}); }\r\n                parts.splice.apply(parts, newParts);\r\n                j += newParts.length - 3;\r\n            }\r\n        }\r\n        return parts\r\n    }\r\n\r\n    // Connect or disconnect spans from a line.\r\n    function detachMarkedSpans(line) {\r\n        var spans = line.markedSpans;\r\n        if (!spans) { return }\r\n        for (var i = 0; i < spans.length; ++i)\r\n        { spans[i].marker.detachLine(line); }\r\n        line.markedSpans = null;\r\n    }\r\n    function attachMarkedSpans(line, spans) {\r\n        if (!spans) { return }\r\n        for (var i = 0; i < spans.length; ++i)\r\n        { spans[i].marker.attachLine(line); }\r\n        line.markedSpans = spans;\r\n    }\r\n\r\n    // Helpers used when computing which overlapping collapsed span\r\n    // counts as the larger one.\r\n    function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\r\n    function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\r\n\r\n    // Returns a number indicating which of two overlapping collapsed\r\n    // spans is larger (and thus includes the other). Falls back to\r\n    // comparing ids when the spans cover exactly the same range.\r\n    function compareCollapsedMarkers(a, b) {\r\n        var lenDiff = a.lines.length - b.lines.length;\r\n        if (lenDiff != 0) { return lenDiff }\r\n        var aPos = a.find(), bPos = b.find();\r\n        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\r\n        if (fromCmp) { return -fromCmp }\r\n        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\r\n        if (toCmp) { return toCmp }\r\n        return b.id - a.id\r\n    }\r\n\r\n    // Find out whether a line ends or starts in a collapsed span. If\r\n    // so, return the marker for that span.\r\n    function collapsedSpanAtSide(line, start) {\r\n        var sps = sawCollapsedSpans && line.markedSpans, found;\r\n        if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\r\n            sp = sps[i];\r\n            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\r\n                (!found || compareCollapsedMarkers(found, sp.marker) < 0))\r\n            { found = sp.marker; }\r\n        } }\r\n        return found\r\n    }\r\n    function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\r\n    function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\r\n\r\n    function collapsedSpanAround(line, ch) {\r\n        var sps = sawCollapsedSpans && line.markedSpans, found;\r\n        if (sps) { for (var i = 0; i < sps.length; ++i) {\r\n            var sp = sps[i];\r\n            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\r\n                (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\r\n        } }\r\n        return found\r\n    }\r\n\r\n    // Test whether there exists a collapsed span that partially\r\n    // overlaps (covers the start or end, but not both) of a new span.\r\n    // Such overlap is not allowed.\r\n    function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\r\n        var line = getLine(doc, lineNo$$1);\r\n        var sps = sawCollapsedSpans && line.markedSpans;\r\n        if (sps) { for (var i = 0; i < sps.length; ++i) {\r\n            var sp = sps[i];\r\n            if (!sp.marker.collapsed) { continue }\r\n            var found = sp.marker.find(0);\r\n            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\r\n            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\r\n            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\r\n            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\r\n                fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\r\n            { return true }\r\n        } }\r\n    }\r\n\r\n    // A visual line is a line as drawn on the screen. Folding, for\r\n    // example, can cause multiple logical lines to appear on the same\r\n    // visual line. This finds the start of the visual line that the\r\n    // given line is part of (usually that is the line itself).\r\n    function visualLine(line) {\r\n        var merged;\r\n        while (merged = collapsedSpanAtStart(line))\r\n        { line = merged.find(-1, true).line; }\r\n        return line\r\n    }\r\n\r\n    function visualLineEnd(line) {\r\n        var merged;\r\n        while (merged = collapsedSpanAtEnd(line))\r\n        { line = merged.find(1, true).line; }\r\n        return line\r\n    }\r\n\r\n    // Returns an array of logical lines that continue the visual line\r\n    // started by the argument, or undefined if there are no such lines.\r\n    function visualLineContinued(line) {\r\n        var merged, lines;\r\n        while (merged = collapsedSpanAtEnd(line)) {\r\n            line = merged.find(1, true).line\r\n            ;(lines || (lines = [])).push(line);\r\n        }\r\n        return lines\r\n    }\r\n\r\n    // Get the line number of the start of the visual line that the\r\n    // given line number is part of.\r\n    function visualLineNo(doc, lineN) {\r\n        var line = getLine(doc, lineN), vis = visualLine(line);\r\n        if (line == vis) { return lineN }\r\n        return lineNo(vis)\r\n    }\r\n\r\n    // Get the line number of the start of the next visual line after\r\n    // the given line.\r\n    function visualLineEndNo(doc, lineN) {\r\n        if (lineN > doc.lastLine()) { return lineN }\r\n        var line = getLine(doc, lineN), merged;\r\n        if (!lineIsHidden(doc, line)) { return lineN }\r\n        while (merged = collapsedSpanAtEnd(line))\r\n        { line = merged.find(1, true).line; }\r\n        return lineNo(line) + 1\r\n    }\r\n\r\n    // Compute whether a line is hidden. Lines count as hidden when they\r\n    // are part of a visual line that starts with another line, or when\r\n    // they are entirely covered by collapsed, non-widget span.\r\n    function lineIsHidden(doc, line) {\r\n        var sps = sawCollapsedSpans && line.markedSpans;\r\n        if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\r\n            sp = sps[i];\r\n            if (!sp.marker.collapsed) { continue }\r\n            if (sp.from == null) { return true }\r\n            if (sp.marker.widgetNode) { continue }\r\n            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\r\n            { return true }\r\n        } }\r\n    }\r\n    function lineIsHiddenInner(doc, line, span) {\r\n        if (span.to == null) {\r\n            var end = span.marker.find(1, true);\r\n            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\r\n        }\r\n        if (span.marker.inclusiveRight && span.to == line.text.length)\r\n        { return true }\r\n        for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\r\n            sp = line.markedSpans[i];\r\n            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\r\n                (sp.to == null || sp.to != span.from) &&\r\n                (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\r\n                lineIsHiddenInner(doc, line, sp)) { return true }\r\n        }\r\n    }\r\n\r\n    // Find the height above the given line.\r\n    function heightAtLine(lineObj) {\r\n        lineObj = visualLine(lineObj);\r\n\r\n        var h = 0, chunk = lineObj.parent;\r\n        for (var i = 0; i < chunk.lines.length; ++i) {\r\n            var line = chunk.lines[i];\r\n            if (line == lineObj) { break }\r\n            else { h += line.height; }\r\n        }\r\n        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\r\n            for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\r\n                var cur = p.children[i$1];\r\n                if (cur == chunk) { break }\r\n                else { h += cur.height; }\r\n            }\r\n        }\r\n        return h\r\n    }\r\n\r\n    // Compute the character length of a line, taking into account\r\n    // collapsed ranges (see markText) that might hide parts, and join\r\n    // other lines onto it.\r\n    function lineLength(line) {\r\n        if (line.height == 0) { return 0 }\r\n        var len = line.text.length, merged, cur = line;\r\n        while (merged = collapsedSpanAtStart(cur)) {\r\n            var found = merged.find(0, true);\r\n            cur = found.from.line;\r\n            len += found.from.ch - found.to.ch;\r\n        }\r\n        cur = line;\r\n        while (merged = collapsedSpanAtEnd(cur)) {\r\n            var found$1 = merged.find(0, true);\r\n            len -= cur.text.length - found$1.from.ch;\r\n            cur = found$1.to.line;\r\n            len += cur.text.length - found$1.to.ch;\r\n        }\r\n        return len\r\n    }\r\n\r\n    // Find the longest line in the document.\r\n    function findMaxLine(cm) {\r\n        var d = cm.display, doc = cm.doc;\r\n        d.maxLine = getLine(doc, doc.first);\r\n        d.maxLineLength = lineLength(d.maxLine);\r\n        d.maxLineChanged = true;\r\n        doc.iter(function (line) {\r\n            var len = lineLength(line);\r\n            if (len > d.maxLineLength) {\r\n                d.maxLineLength = len;\r\n                d.maxLine = line;\r\n            }\r\n        });\r\n    }\r\n\r\n    // BIDI HELPERS\r\n\r\n    function iterateBidiSections(order, from, to, f) {\r\n        if (!order) { return f(from, to, \"ltr\", 0) }\r\n        var found = false;\r\n        for (var i = 0; i < order.length; ++i) {\r\n            var part = order[i];\r\n            if (part.from < to && part.to > from || from == to && part.to == from) {\r\n                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\r\n                found = true;\r\n            }\r\n        }\r\n        if (!found) { f(from, to, \"ltr\"); }\r\n    }\r\n\r\n    var bidiOther = null;\r\n    function getBidiPartAt(order, ch, sticky) {\r\n        var found;\r\n        bidiOther = null;\r\n        for (var i = 0; i < order.length; ++i) {\r\n            var cur = order[i];\r\n            if (cur.from < ch && cur.to > ch) { return i }\r\n            if (cur.to == ch) {\r\n                if (cur.from != cur.to && sticky == \"before\") { found = i; }\r\n                else { bidiOther = i; }\r\n            }\r\n            if (cur.from == ch) {\r\n                if (cur.from != cur.to && sticky != \"before\") { found = i; }\r\n                else { bidiOther = i; }\r\n            }\r\n        }\r\n        return found != null ? found : bidiOther\r\n    }\r\n\r\n    // Bidirectional ordering algorithm\r\n    // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\r\n    // that this (partially) implements.\r\n\r\n    // One-char codes used for character types:\r\n    // L (L):   Left-to-Right\r\n    // R (R):   Right-to-Left\r\n    // r (AL):  Right-to-Left Arabic\r\n    // 1 (EN):  European Number\r\n    // + (ES):  European Number Separator\r\n    // % (ET):  European Number Terminator\r\n    // n (AN):  Arabic Number\r\n    // , (CS):  Common Number Separator\r\n    // m (NSM): Non-Spacing Mark\r\n    // b (BN):  Boundary Neutral\r\n    // s (B):   Paragraph Separator\r\n    // t (S):   Segment Separator\r\n    // w (WS):  Whitespace\r\n    // N (ON):  Other Neutrals\r\n\r\n    // Returns null if characters are ordered as they appear\r\n    // (left-to-right), or an array of sections ({from, to, level}\r\n    // objects) in the order in which they occur visually.\r\n    var bidiOrdering = (function() {\r\n        // Character types for codepoints 0 to 0xff\r\n        var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\r\n        // Character types for codepoints 0x600 to 0x6f9\r\n        var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\r\n        function charType(code) {\r\n            if (code <= 0xf7) { return lowTypes.charAt(code) }\r\n            else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\r\n            else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\r\n            else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\r\n            else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\r\n            else if (code == 0x200c) { return \"b\" }\r\n            else { return \"L\" }\r\n        }\r\n\r\n        var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\r\n        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\r\n\r\n        function BidiSpan(level, from, to) {\r\n            this.level = level;\r\n            this.from = from; this.to = to;\r\n        }\r\n\r\n        return function(str, direction) {\r\n            var outerType = direction == \"ltr\" ? \"L\" : \"R\";\r\n\r\n            if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\r\n            var len = str.length, types = [];\r\n            for (var i = 0; i < len; ++i)\r\n            { types.push(charType(str.charCodeAt(i))); }\r\n\r\n            // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n            // change the type of the NSM to the type of the previous\r\n            // character. If the NSM is at the start of the level run, it will\r\n            // get the type of sor.\r\n            for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\r\n                var type = types[i$1];\r\n                if (type == \"m\") { types[i$1] = prev; }\r\n                else { prev = type; }\r\n            }\r\n\r\n            // W2. Search backwards from each instance of a European number\r\n            // until the first strong type (R, L, AL, or sor) is found. If an\r\n            // AL is found, change the type of the European number to Arabic\r\n            // number.\r\n            // W3. Change all ALs to R.\r\n            for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\r\n                var type$1 = types[i$2];\r\n                if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\r\n                else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\r\n            }\r\n\r\n            // W4. A single European separator between two European numbers\r\n            // changes to a European number. A single common separator between\r\n            // two numbers of the same type changes to that type.\r\n            for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\r\n                var type$2 = types[i$3];\r\n                if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\r\n                else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\r\n                    (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\r\n                prev$1 = type$2;\r\n            }\r\n\r\n            // W5. A sequence of European terminators adjacent to European\r\n            // numbers changes to all European numbers.\r\n            // W6. Otherwise, separators and terminators change to Other\r\n            // Neutral.\r\n            for (var i$4 = 0; i$4 < len; ++i$4) {\r\n                var type$3 = types[i$4];\r\n                if (type$3 == \",\") { types[i$4] = \"N\"; }\r\n                else if (type$3 == \"%\") {\r\n                    var end = (void 0);\r\n                    for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\r\n                    var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\r\n                    for (var j = i$4; j < end; ++j) { types[j] = replace; }\r\n                    i$4 = end - 1;\r\n                }\r\n            }\r\n\r\n            // W7. Search backwards from each instance of a European number\r\n            // until the first strong type (R, L, or sor) is found. If an L is\r\n            // found, then change the type of the European number to L.\r\n            for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\r\n                var type$4 = types[i$5];\r\n                if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\r\n                else if (isStrong.test(type$4)) { cur$1 = type$4; }\r\n            }\r\n\r\n            // N1. A sequence of neutrals takes the direction of the\r\n            // surrounding strong text if the text on both sides has the same\r\n            // direction. European and Arabic numbers act as if they were R in\r\n            // terms of their influence on neutrals. Start-of-level-run (sor)\r\n            // and end-of-level-run (eor) are used at level run boundaries.\r\n            // N2. Any remaining neutrals take the embedding direction.\r\n            for (var i$6 = 0; i$6 < len; ++i$6) {\r\n                if (isNeutral.test(types[i$6])) {\r\n                    var end$1 = (void 0);\r\n                    for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\r\n                    var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\r\n                    var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\r\n                    var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\r\n                    for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\r\n                    i$6 = end$1 - 1;\r\n                }\r\n            }\r\n\r\n            // Here we depart from the documented algorithm, in order to avoid\r\n            // building up an actual levels array. Since there are only three\r\n            // levels (0, 1, 2) in an implementation that doesn't take\r\n            // explicit embedding into account, we can build up the order on\r\n            // the fly, without following the level-based algorithm.\r\n            var order = [], m;\r\n            for (var i$7 = 0; i$7 < len;) {\r\n                if (countsAsLeft.test(types[i$7])) {\r\n                    var start = i$7;\r\n                    for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\r\n                    order.push(new BidiSpan(0, start, i$7));\r\n                } else {\r\n                    var pos = i$7, at = order.length;\r\n                    for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\r\n                    for (var j$2 = pos; j$2 < i$7;) {\r\n                        if (countsAsNum.test(types[j$2])) {\r\n                            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\r\n                            var nstart = j$2;\r\n                            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\r\n                            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\r\n                            pos = j$2;\r\n                        } else { ++j$2; }\r\n                    }\r\n                    if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\r\n                }\r\n            }\r\n            if (direction == \"ltr\") {\r\n                if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\r\n                    order[0].from = m[0].length;\r\n                    order.unshift(new BidiSpan(0, 0, m[0].length));\r\n                }\r\n                if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\r\n                    lst(order).to -= m[0].length;\r\n                    order.push(new BidiSpan(0, len - m[0].length, len));\r\n                }\r\n            }\r\n\r\n            return direction == \"rtl\" ? order.reverse() : order\r\n        }\r\n    })();\r\n\r\n    // Get the bidi ordering for the given line (and cache it). Returns\r\n    // false for lines that are fully left-to-right, and an array of\r\n    // BidiSpan objects otherwise.\r\n    function getOrder(line, direction) {\r\n        var order = line.order;\r\n        if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\r\n        return order\r\n    }\r\n\r\n    // EVENT HANDLING\r\n\r\n    // Lightweight event framework. on/off also work on DOM nodes,\r\n    // registering native DOM handlers.\r\n\r\n    var noHandlers = [];\r\n\r\n    var on = function(emitter, type, f) {\r\n        if (emitter.addEventListener) {\r\n            emitter.addEventListener(type, f, false);\r\n        } else if (emitter.attachEvent) {\r\n            emitter.attachEvent(\"on\" + type, f);\r\n        } else {\r\n            var map$$1 = emitter._handlers || (emitter._handlers = {});\r\n            map$$1[type] = (map$$1[type] || noHandlers).concat(f);\r\n        }\r\n    };\r\n\r\n    function getHandlers(emitter, type) {\r\n        return emitter._handlers && emitter._handlers[type] || noHandlers\r\n    }\r\n\r\n    function off(emitter, type, f) {\r\n        if (emitter.removeEventListener) {\r\n            emitter.removeEventListener(type, f, false);\r\n        } else if (emitter.detachEvent) {\r\n            emitter.detachEvent(\"on\" + type, f);\r\n        } else {\r\n            var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\r\n            if (arr) {\r\n                var index = indexOf(arr, f);\r\n                if (index > -1)\r\n                { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\r\n            }\r\n        }\r\n    }\r\n\r\n    function signal(emitter, type /*, values...*/) {\r\n        var handlers = getHandlers(emitter, type);\r\n        if (!handlers.length) { return }\r\n        var args = Array.prototype.slice.call(arguments, 2);\r\n        for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\r\n    }\r\n\r\n    // The DOM events that CodeMirror handles can be overridden by\r\n    // registering a (non-DOM) handler on the editor for the event name,\r\n    // and preventDefault-ing the event in that handler.\r\n    function signalDOMEvent(cm, e, override) {\r\n        if (typeof e == \"string\")\r\n        { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\r\n        signal(cm, override || e.type, cm, e);\r\n        return e_defaultPrevented(e) || e.codemirrorIgnore\r\n    }\r\n\r\n    function signalCursorActivity(cm) {\r\n        var arr = cm._handlers && cm._handlers.cursorActivity;\r\n        if (!arr) { return }\r\n        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\r\n        for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\r\n        { set.push(arr[i]); } }\r\n    }\r\n\r\n    function hasHandler(emitter, type) {\r\n        return getHandlers(emitter, type).length > 0\r\n    }\r\n\r\n    // Add on and off methods to a constructor's prototype, to make\r\n    // registering events on such objects more convenient.\r\n    function eventMixin(ctor) {\r\n        ctor.prototype.on = function(type, f) {on(this, type, f);};\r\n        ctor.prototype.off = function(type, f) {off(this, type, f);};\r\n    }\r\n\r\n    // Due to the fact that we still support jurassic IE versions, some\r\n    // compatibility wrappers are needed.\r\n\r\n    function e_preventDefault(e) {\r\n        if (e.preventDefault) { e.preventDefault(); }\r\n        else { e.returnValue = false; }\r\n    }\r\n    function e_stopPropagation(e) {\r\n        if (e.stopPropagation) { e.stopPropagation(); }\r\n        else { e.cancelBubble = true; }\r\n    }\r\n    function e_defaultPrevented(e) {\r\n        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\r\n    }\r\n    function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\r\n\r\n    function e_target(e) {return e.target || e.srcElement}\r\n    function e_button(e) {\r\n        var b = e.which;\r\n        if (b == null) {\r\n            if (e.button & 1) { b = 1; }\r\n            else if (e.button & 2) { b = 3; }\r\n            else if (e.button & 4) { b = 2; }\r\n        }\r\n        if (mac && e.ctrlKey && b == 1) { b = 3; }\r\n        return b\r\n    }\r\n\r\n    // Detect drag-and-drop\r\n    var dragAndDrop = function() {\r\n        // There is *some* kind of drag-and-drop support in IE6-8, but I\r\n        // couldn't get it to work yet.\r\n        if (ie && ie_version < 9) { return false }\r\n        var div = elt('div');\r\n        return \"draggable\" in div || \"dragDrop\" in div\r\n    }();\r\n\r\n    var zwspSupported;\r\n    function zeroWidthElement(measure) {\r\n        if (zwspSupported == null) {\r\n            var test = elt(\"span\", \"\\u200b\");\r\n            removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\r\n            if (measure.firstChild.offsetHeight != 0)\r\n            { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\r\n        }\r\n        var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\r\n            elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\r\n        node.setAttribute(\"cm-text\", \"\");\r\n        return node\r\n    }\r\n\r\n    // Feature-detect IE's crummy client rect reporting for bidi text\r\n    var badBidiRects;\r\n    function hasBadBidiRects(measure) {\r\n        if (badBidiRects != null) { return badBidiRects }\r\n        var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\r\n        var r0 = range(txt, 0, 1).getBoundingClientRect();\r\n        var r1 = range(txt, 1, 2).getBoundingClientRect();\r\n        removeChildren(measure);\r\n        if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\r\n        return badBidiRects = (r1.right - r0.right < 3)\r\n    }\r\n\r\n    // See if \"\".split is the broken IE version, if so, provide an\r\n    // alternative way to split lines.\r\n    var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\r\n        var pos = 0, result = [], l = string.length;\r\n        while (pos <= l) {\r\n            var nl = string.indexOf(\"\\n\", pos);\r\n            if (nl == -1) { nl = string.length; }\r\n            var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\r\n            var rt = line.indexOf(\"\\r\");\r\n            if (rt != -1) {\r\n                result.push(line.slice(0, rt));\r\n                pos += rt + 1;\r\n            } else {\r\n                result.push(line);\r\n                pos = nl + 1;\r\n            }\r\n        }\r\n        return result\r\n    } : function (string) { return string.split(/\\r\\n?|\\n/); };\r\n\r\n    var hasSelection = window.getSelection ? function (te) {\r\n        try { return te.selectionStart != te.selectionEnd }\r\n        catch(e) { return false }\r\n    } : function (te) {\r\n        var range$$1;\r\n        try {range$$1 = te.ownerDocument.selection.createRange();}\r\n        catch(e) {}\r\n        if (!range$$1 || range$$1.parentElement() != te) { return false }\r\n        return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\r\n    };\r\n\r\n    var hasCopyEvent = (function () {\r\n        var e = elt(\"div\");\r\n        if (\"oncopy\" in e) { return true }\r\n        e.setAttribute(\"oncopy\", \"return;\");\r\n        return typeof e.oncopy == \"function\"\r\n    })();\r\n\r\n    var badZoomedRects = null;\r\n    function hasBadZoomedRects(measure) {\r\n        if (badZoomedRects != null) { return badZoomedRects }\r\n        var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\r\n        var normal = node.getBoundingClientRect();\r\n        var fromRange = range(node, 0, 1).getBoundingClientRect();\r\n        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\r\n    }\r\n\r\n    // Known modes, by name and by MIME\r\n    var modes = {}, mimeModes = {};\r\n\r\n    // Extra arguments are stored as the mode's dependencies, which is\r\n    // used by (legacy) mechanisms like loadmode.js to automatically\r\n    // load a mode. (Preferred mechanism is the require/define calls.)\r\n    function defineMode(name, mode) {\r\n        if (arguments.length > 2)\r\n        { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\r\n        modes[name] = mode;\r\n    }\r\n\r\n    function defineMIME(mime, spec) {\r\n        mimeModes[mime] = spec;\r\n    }\r\n\r\n    // Given a MIME type, a {name, ...options} config object, or a name\r\n    // string, return a mode config object.\r\n    function resolveMode(spec) {\r\n        if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\r\n            spec = mimeModes[spec];\r\n        } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\r\n            var found = mimeModes[spec.name];\r\n            if (typeof found == \"string\") { found = {name: found}; }\r\n            spec = createObj(found, spec);\r\n            spec.name = found.name;\r\n        } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\r\n            return resolveMode(\"application/xml\")\r\n        } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\r\n            return resolveMode(\"application/json\")\r\n        }\r\n        if (typeof spec == \"string\") { return {name: spec} }\r\n        else { return spec || {name: \"null\"} }\r\n    }\r\n\r\n    // Given a mode spec (anything that resolveMode accepts), find and\r\n    // initialize an actual mode object.\r\n    function getMode(options, spec) {\r\n        spec = resolveMode(spec);\r\n        var mfactory = modes[spec.name];\r\n        if (!mfactory) { return getMode(options, \"text/plain\") }\r\n        var modeObj = mfactory(options, spec);\r\n        if (modeExtensions.hasOwnProperty(spec.name)) {\r\n            var exts = modeExtensions[spec.name];\r\n            for (var prop in exts) {\r\n                if (!exts.hasOwnProperty(prop)) { continue }\r\n                if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\r\n                modeObj[prop] = exts[prop];\r\n            }\r\n        }\r\n        modeObj.name = spec.name;\r\n        if (spec.helperType) { modeObj.helperType = spec.helperType; }\r\n        if (spec.modeProps) { for (var prop$1 in spec.modeProps)\r\n        { modeObj[prop$1] = spec.modeProps[prop$1]; } }\r\n\r\n        return modeObj\r\n    }\r\n\r\n    // This can be used to attach properties to mode objects from\r\n    // outside the actual mode definition.\r\n    var modeExtensions = {};\r\n    function extendMode(mode, properties) {\r\n        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\r\n        copyObj(properties, exts);\r\n    }\r\n\r\n    function copyState(mode, state) {\r\n        if (state === true) { return state }\r\n        if (mode.copyState) { return mode.copyState(state) }\r\n        var nstate = {};\r\n        for (var n in state) {\r\n            var val = state[n];\r\n            if (val instanceof Array) { val = val.concat([]); }\r\n            nstate[n] = val;\r\n        }\r\n        return nstate\r\n    }\r\n\r\n    // Given a mode and a state (for that mode), find the inner mode and\r\n    // state at the position that the state refers to.\r\n    function innerMode(mode, state) {\r\n        var info;\r\n        while (mode.innerMode) {\r\n            info = mode.innerMode(state);\r\n            if (!info || info.mode == mode) { break }\r\n            state = info.state;\r\n            mode = info.mode;\r\n        }\r\n        return info || {mode: mode, state: state}\r\n    }\r\n\r\n    function startState(mode, a1, a2) {\r\n        return mode.startState ? mode.startState(a1, a2) : true\r\n    }\r\n\r\n    // STRING STREAM\r\n\r\n    // Fed to the mode parsers, provides helper functions to make\r\n    // parsers more succinct.\r\n\r\n    var StringStream = function(string, tabSize, lineOracle) {\r\n        this.pos = this.start = 0;\r\n        this.string = string;\r\n        this.tabSize = tabSize || 8;\r\n        this.lastColumnPos = this.lastColumnValue = 0;\r\n        this.lineStart = 0;\r\n        this.lineOracle = lineOracle;\r\n    };\r\n\r\n    StringStream.prototype.eol = function () {return this.pos >= this.string.length};\r\n    StringStream.prototype.sol = function () {return this.pos == this.lineStart};\r\n    StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\r\n    StringStream.prototype.next = function () {\r\n        if (this.pos < this.string.length)\r\n        { return this.string.charAt(this.pos++) }\r\n    };\r\n    StringStream.prototype.eat = function (match) {\r\n        var ch = this.string.charAt(this.pos);\r\n        var ok;\r\n        if (typeof match == \"string\") { ok = ch == match; }\r\n        else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\r\n        if (ok) {++this.pos; return ch}\r\n    };\r\n    StringStream.prototype.eatWhile = function (match) {\r\n        var start = this.pos;\r\n        while (this.eat(match)){}\r\n        return this.pos > start\r\n    };\r\n    StringStream.prototype.eatSpace = function () {\r\n        var start = this.pos;\r\n        while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\r\n        return this.pos > start\r\n    };\r\n    StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\r\n    StringStream.prototype.skipTo = function (ch) {\r\n        var found = this.string.indexOf(ch, this.pos);\r\n        if (found > -1) {this.pos = found; return true}\r\n    };\r\n    StringStream.prototype.backUp = function (n) {this.pos -= n;};\r\n    StringStream.prototype.column = function () {\r\n        if (this.lastColumnPos < this.start) {\r\n            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\r\n            this.lastColumnPos = this.start;\r\n        }\r\n        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\r\n    };\r\n    StringStream.prototype.indentation = function () {\r\n        return countColumn(this.string, null, this.tabSize) -\r\n            (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\r\n    };\r\n    StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\r\n        if (typeof pattern == \"string\") {\r\n            var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\r\n            var substr = this.string.substr(this.pos, pattern.length);\r\n            if (cased(substr) == cased(pattern)) {\r\n                if (consume !== false) { this.pos += pattern.length; }\r\n                return true\r\n            }\r\n        } else {\r\n            var match = this.string.slice(this.pos).match(pattern);\r\n            if (match && match.index > 0) { return null }\r\n            if (match && consume !== false) { this.pos += match[0].length; }\r\n            return match\r\n        }\r\n    };\r\n    StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\r\n    StringStream.prototype.hideFirstChars = function (n, inner) {\r\n        this.lineStart += n;\r\n        try { return inner() }\r\n        finally { this.lineStart -= n; }\r\n    };\r\n    StringStream.prototype.lookAhead = function (n) {\r\n        var oracle = this.lineOracle;\r\n        return oracle && oracle.lookAhead(n)\r\n    };\r\n    StringStream.prototype.baseToken = function () {\r\n        var oracle = this.lineOracle;\r\n        return oracle && oracle.baseToken(this.pos)\r\n    };\r\n\r\n    var SavedContext = function(state, lookAhead) {\r\n        this.state = state;\r\n        this.lookAhead = lookAhead;\r\n    };\r\n\r\n    var Context = function(doc, state, line, lookAhead) {\r\n        this.state = state;\r\n        this.doc = doc;\r\n        this.line = line;\r\n        this.maxLookAhead = lookAhead || 0;\r\n        this.baseTokens = null;\r\n        this.baseTokenPos = 1;\r\n    };\r\n\r\n    Context.prototype.lookAhead = function (n) {\r\n        var line = this.doc.getLine(this.line + n);\r\n        if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\r\n        return line\r\n    };\r\n\r\n    Context.prototype.baseToken = function (n) {\r\n        if (!this.baseTokens) { return null }\r\n        while (this.baseTokens[this.baseTokenPos] <= n)\r\n        { this.baseTokenPos += 2; }\r\n        var type = this.baseTokens[this.baseTokenPos + 1];\r\n        return {type: type && type.replace(/( |^)overlay .*/, \"\"),\r\n            size: this.baseTokens[this.baseTokenPos] - n}\r\n    };\r\n\r\n    Context.prototype.nextLine = function () {\r\n        this.line++;\r\n        if (this.maxLookAhead > 0) { this.maxLookAhead--; }\r\n    };\r\n\r\n    Context.fromSaved = function (doc, saved, line) {\r\n        if (saved instanceof SavedContext)\r\n        { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\r\n        else\r\n        { return new Context(doc, copyState(doc.mode, saved), line) }\r\n    };\r\n\r\n    Context.prototype.save = function (copy) {\r\n        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\r\n        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\r\n    };\r\n\r\n\r\n    // Compute a style array (an array starting with a mode generation\r\n    // -- for invalidation -- followed by pairs of end positions and\r\n    // style strings), which is used to highlight the tokens on the\r\n    // line.\r\n    function highlightLine(cm, line, context, forceToEnd) {\r\n        // A styles array always starts with a number identifying the\r\n        // mode/overlays that it is based on (for easy invalidation).\r\n        var st = [cm.state.modeGen], lineClasses = {};\r\n        // Compute the base array of styles\r\n        runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\r\n            lineClasses, forceToEnd);\r\n        var state = context.state;\r\n\r\n        // Run overlays, adjust style array.\r\n        var loop = function ( o ) {\r\n            context.baseTokens = st;\r\n            var overlay = cm.state.overlays[o], i = 1, at = 0;\r\n            context.state = true;\r\n            runMode(cm, line.text, overlay.mode, context, function (end, style) {\r\n                var start = i;\r\n                // Ensure there's a token end at the current position, and that i points at it\r\n                while (at < end) {\r\n                    var i_end = st[i];\r\n                    if (i_end > end)\r\n                    { st.splice(i, 1, end, st[i+1], i_end); }\r\n                    i += 2;\r\n                    at = Math.min(end, i_end);\r\n                }\r\n                if (!style) { return }\r\n                if (overlay.opaque) {\r\n                    st.splice(start, i - start, end, \"overlay \" + style);\r\n                    i = start + 2;\r\n                } else {\r\n                    for (; start < i; start += 2) {\r\n                        var cur = st[start+1];\r\n                        st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\r\n                    }\r\n                }\r\n            }, lineClasses);\r\n            context.state = state;\r\n            context.baseTokens = null;\r\n            context.baseTokenPos = 1;\r\n        };\r\n\r\n        for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\r\n\r\n        return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\r\n    }\r\n\r\n    function getLineStyles(cm, line, updateFrontier) {\r\n        if (!line.styles || line.styles[0] != cm.state.modeGen) {\r\n            var context = getContextBefore(cm, lineNo(line));\r\n            var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\r\n            var result = highlightLine(cm, line, context);\r\n            if (resetState) { context.state = resetState; }\r\n            line.stateAfter = context.save(!resetState);\r\n            line.styles = result.styles;\r\n            if (result.classes) { line.styleClasses = result.classes; }\r\n            else if (line.styleClasses) { line.styleClasses = null; }\r\n            if (updateFrontier === cm.doc.highlightFrontier)\r\n            { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\r\n        }\r\n        return line.styles\r\n    }\r\n\r\n    function getContextBefore(cm, n, precise) {\r\n        var doc = cm.doc, display = cm.display;\r\n        if (!doc.mode.startState) { return new Context(doc, true, n) }\r\n        var start = findStartLine(cm, n, precise);\r\n        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\r\n        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\r\n\r\n        doc.iter(start, n, function (line) {\r\n            processLine(cm, line.text, context);\r\n            var pos = context.line;\r\n            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\r\n            context.nextLine();\r\n        });\r\n        if (precise) { doc.modeFrontier = context.line; }\r\n        return context\r\n    }\r\n\r\n    // Lightweight form of highlight -- proceed over this line and\r\n    // update state, but don't save a style array. Used for lines that\r\n    // aren't currently visible.\r\n    function processLine(cm, text, context, startAt) {\r\n        var mode = cm.doc.mode;\r\n        var stream = new StringStream(text, cm.options.tabSize, context);\r\n        stream.start = stream.pos = startAt || 0;\r\n        if (text == \"\") { callBlankLine(mode, context.state); }\r\n        while (!stream.eol()) {\r\n            readToken(mode, stream, context.state);\r\n            stream.start = stream.pos;\r\n        }\r\n    }\r\n\r\n    function callBlankLine(mode, state) {\r\n        if (mode.blankLine) { return mode.blankLine(state) }\r\n        if (!mode.innerMode) { return }\r\n        var inner = innerMode(mode, state);\r\n        if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\r\n    }\r\n\r\n    function readToken(mode, stream, state, inner) {\r\n        for (var i = 0; i < 10; i++) {\r\n            if (inner) { inner[0] = innerMode(mode, state).mode; }\r\n            var style = mode.token(stream, state);\r\n            if (stream.pos > stream.start) { return style }\r\n        }\r\n        throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\r\n    }\r\n\r\n    var Token = function(stream, type, state) {\r\n        this.start = stream.start; this.end = stream.pos;\r\n        this.string = stream.current();\r\n        this.type = type || null;\r\n        this.state = state;\r\n    };\r\n\r\n    // Utility for getTokenAt and getLineTokens\r\n    function takeToken(cm, pos, precise, asArray) {\r\n        var doc = cm.doc, mode = doc.mode, style;\r\n        pos = clipPos(doc, pos);\r\n        var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\r\n        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\r\n        if (asArray) { tokens = []; }\r\n        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\r\n            stream.start = stream.pos;\r\n            style = readToken(mode, stream, context.state);\r\n            if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\r\n        }\r\n        return asArray ? tokens : new Token(stream, style, context.state)\r\n    }\r\n\r\n    function extractLineClasses(type, output) {\r\n        if (type) { for (;;) {\r\n            var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n            if (!lineClass) { break }\r\n            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n            var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\r\n            if (output[prop] == null)\r\n            { output[prop] = lineClass[2]; }\r\n            else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\r\n            { output[prop] += \" \" + lineClass[2]; }\r\n        } }\r\n        return type\r\n    }\r\n\r\n    // Run the given mode's parser over a line, calling f for each token.\r\n    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\r\n        var flattenSpans = mode.flattenSpans;\r\n        if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\r\n        var curStart = 0, curStyle = null;\r\n        var stream = new StringStream(text, cm.options.tabSize, context), style;\r\n        var inner = cm.options.addModeClass && [null];\r\n        if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\r\n        while (!stream.eol()) {\r\n            if (stream.pos > cm.options.maxHighlightLength) {\r\n                flattenSpans = false;\r\n                if (forceToEnd) { processLine(cm, text, context, stream.pos); }\r\n                stream.pos = text.length;\r\n                style = null;\r\n            } else {\r\n                style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\r\n            }\r\n            if (inner) {\r\n                var mName = inner[0].name;\r\n                if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\r\n            }\r\n            if (!flattenSpans || curStyle != style) {\r\n                while (curStart < stream.start) {\r\n                    curStart = Math.min(stream.start, curStart + 5000);\r\n                    f(curStart, curStyle);\r\n                }\r\n                curStyle = style;\r\n            }\r\n            stream.start = stream.pos;\r\n        }\r\n        while (curStart < stream.pos) {\r\n            // Webkit seems to refuse to render text nodes longer than 57444\r\n            // characters, and returns inaccurate measurements in nodes\r\n            // starting around 5000 chars.\r\n            var pos = Math.min(stream.pos, curStart + 5000);\r\n            f(pos, curStyle);\r\n            curStart = pos;\r\n        }\r\n    }\r\n\r\n    // Finds the line to start with when starting a parse. Tries to\r\n    // find a line with a stateAfter, so that it can start with a\r\n    // valid state. If that fails, it returns the line with the\r\n    // smallest indentation, which tends to need the least context to\r\n    // parse correctly.\r\n    function findStartLine(cm, n, precise) {\r\n        var minindent, minline, doc = cm.doc;\r\n        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\r\n        for (var search = n; search > lim; --search) {\r\n            if (search <= doc.first) { return doc.first }\r\n            var line = getLine(doc, search - 1), after = line.stateAfter;\r\n            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\r\n            { return search }\r\n            var indented = countColumn(line.text, null, cm.options.tabSize);\r\n            if (minline == null || minindent > indented) {\r\n                minline = search - 1;\r\n                minindent = indented;\r\n            }\r\n        }\r\n        return minline\r\n    }\r\n\r\n    function retreatFrontier(doc, n) {\r\n        doc.modeFrontier = Math.min(doc.modeFrontier, n);\r\n        if (doc.highlightFrontier < n - 10) { return }\r\n        var start = doc.first;\r\n        for (var line = n - 1; line > start; line--) {\r\n            var saved = getLine(doc, line).stateAfter;\r\n            // change is on 3\r\n            // state on line 1 looked ahead 2 -- so saw 3\r\n            // test 1 + 2 < 3 should cover this\r\n            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\r\n                start = line + 1;\r\n                break\r\n            }\r\n        }\r\n        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\r\n    }\r\n\r\n    // LINE DATA STRUCTURE\r\n\r\n    // Line objects. These hold state related to a line, including\r\n    // highlighting info (the styles array).\r\n    var Line = function(text, markedSpans, estimateHeight) {\r\n        this.text = text;\r\n        attachMarkedSpans(this, markedSpans);\r\n        this.height = estimateHeight ? estimateHeight(this) : 1;\r\n    };\r\n\r\n    Line.prototype.lineNo = function () { return lineNo(this) };\r\n    eventMixin(Line);\r\n\r\n    // Change the content (text, markers) of a line. Automatically\r\n    // invalidates cached information and tries to re-estimate the\r\n    // line's height.\r\n    function updateLine(line, text, markedSpans, estimateHeight) {\r\n        line.text = text;\r\n        if (line.stateAfter) { line.stateAfter = null; }\r\n        if (line.styles) { line.styles = null; }\r\n        if (line.order != null) { line.order = null; }\r\n        detachMarkedSpans(line);\r\n        attachMarkedSpans(line, markedSpans);\r\n        var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n        if (estHeight != line.height) { updateLineHeight(line, estHeight); }\r\n    }\r\n\r\n    // Detach a line from the document tree and its markers.\r\n    function cleanUpLine(line) {\r\n        line.parent = null;\r\n        detachMarkedSpans(line);\r\n    }\r\n\r\n    // Convert a style as returned by a mode (either null, or a string\r\n    // containing one or more styles) to a CSS style. This is cached,\r\n    // and also looks for line-wide styles.\r\n    var styleToClassCache = {}, styleToClassCacheWithMode = {};\r\n    function interpretTokenStyle(style, options) {\r\n        if (!style || /^\\s*$/.test(style)) { return null }\r\n        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\r\n        return cache[style] ||\r\n            (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\r\n    }\r\n\r\n    // Render the DOM representation of the text of a line. Also builds\r\n    // up a 'line map', which points at the DOM nodes that represent\r\n    // specific stretches of text, and is used by the measuring code.\r\n    // The returned object contains the DOM node, this map, and\r\n    // information about line-wide styles that were set by the mode.\r\n    function buildLineContent(cm, lineView) {\r\n        // The padding-right forces the element to have a 'border', which\r\n        // is needed on Webkit to be able to get line-level bounding\r\n        // rectangles for it (in measureChar).\r\n        var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\r\n        var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\r\n            col: 0, pos: 0, cm: cm,\r\n            trailingSpace: false,\r\n            splitSpaces: cm.getOption(\"lineWrapping\")};\r\n        lineView.measure = {};\r\n\r\n        // Iterate over the logical lines that make up this visual line.\r\n        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\r\n            var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\r\n            builder.pos = 0;\r\n            builder.addToken = buildToken;\r\n            // Optionally wire in some hacks into the token-rendering\r\n            // algorithm, to deal with browser quirks.\r\n            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\r\n            { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\r\n            builder.map = [];\r\n            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\r\n            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\r\n            if (line.styleClasses) {\r\n                if (line.styleClasses.bgClass)\r\n                { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\r\n                if (line.styleClasses.textClass)\r\n                { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\r\n            }\r\n\r\n            // Ensure at least a single node is present, for measuring.\r\n            if (builder.map.length == 0)\r\n            { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\r\n\r\n            // Store the map and a cache object for the current logical line\r\n            if (i == 0) {\r\n                lineView.measure.map = builder.map;\r\n                lineView.measure.cache = {};\r\n            } else {\r\n                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\r\n                ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\r\n            }\r\n        }\r\n\r\n        // See issue #2901\r\n        if (webkit) {\r\n            var last = builder.content.lastChild;\r\n            if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\r\n            { builder.content.className = \"cm-tab-wrap-hack\"; }\r\n        }\r\n\r\n        signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\r\n        if (builder.pre.className)\r\n        { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\r\n\r\n        return builder\r\n    }\r\n\r\n    function defaultSpecialCharPlaceholder(ch) {\r\n        var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\r\n        token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\r\n        token.setAttribute(\"aria-label\", token.title);\r\n        return token\r\n    }\r\n\r\n    // Build up the DOM representation for a single token, and add it to\r\n    // the line map. Takes care to render special characters separately.\r\n    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\r\n        if (!text) { return }\r\n        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\r\n        var special = builder.cm.state.specialChars, mustWrap = false;\r\n        var content;\r\n        if (!special.test(text)) {\r\n            builder.col += text.length;\r\n            content = document.createTextNode(displayText);\r\n            builder.map.push(builder.pos, builder.pos + text.length, content);\r\n            if (ie && ie_version < 9) { mustWrap = true; }\r\n            builder.pos += text.length;\r\n        } else {\r\n            content = document.createDocumentFragment();\r\n            var pos = 0;\r\n            while (true) {\r\n                special.lastIndex = pos;\r\n                var m = special.exec(text);\r\n                var skipped = m ? m.index - pos : text.length - pos;\r\n                if (skipped) {\r\n                    var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\r\n                    if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\r\n                    else { content.appendChild(txt); }\r\n                    builder.map.push(builder.pos, builder.pos + skipped, txt);\r\n                    builder.col += skipped;\r\n                    builder.pos += skipped;\r\n                }\r\n                if (!m) { break }\r\n                pos += skipped + 1;\r\n                var txt$1 = (void 0);\r\n                if (m[0] == \"\\t\") {\r\n                    var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\r\n                    txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\r\n                    txt$1.setAttribute(\"role\", \"presentation\");\r\n                    txt$1.setAttribute(\"cm-text\", \"\\t\");\r\n                    builder.col += tabWidth;\r\n                } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\r\n                    txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\r\n                    txt$1.setAttribute(\"cm-text\", m[0]);\r\n                    builder.col += 1;\r\n                } else {\r\n                    txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\r\n                    txt$1.setAttribute(\"cm-text\", m[0]);\r\n                    if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\r\n                    else { content.appendChild(txt$1); }\r\n                    builder.col += 1;\r\n                }\r\n                builder.map.push(builder.pos, builder.pos + 1, txt$1);\r\n                builder.pos++;\r\n            }\r\n        }\r\n        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\r\n        if (style || startStyle || endStyle || mustWrap || css) {\r\n            var fullStyle = style || \"\";\r\n            if (startStyle) { fullStyle += startStyle; }\r\n            if (endStyle) { fullStyle += endStyle; }\r\n            var token = elt(\"span\", [content], fullStyle, css);\r\n            if (attributes) {\r\n                for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\r\n                { token.setAttribute(attr, attributes[attr]); } }\r\n            }\r\n            return builder.content.appendChild(token)\r\n        }\r\n        builder.content.appendChild(content);\r\n    }\r\n\r\n    // Change some spaces to NBSP to prevent the browser from collapsing\r\n    // trailing spaces at the end of a line when rendering text (issue #1362).\r\n    function splitSpaces(text, trailingBefore) {\r\n        if (text.length > 1 && !/  /.test(text)) { return text }\r\n        var spaceBefore = trailingBefore, result = \"\";\r\n        for (var i = 0; i < text.length; i++) {\r\n            var ch = text.charAt(i);\r\n            if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\r\n            { ch = \"\\u00a0\"; }\r\n            result += ch;\r\n            spaceBefore = ch == \" \";\r\n        }\r\n        return result\r\n    }\r\n\r\n    // Work around nonsense dimensions being reported for stretches of\r\n    // right-to-left text.\r\n    function buildTokenBadBidi(inner, order) {\r\n        return function (builder, text, style, startStyle, endStyle, css, attributes) {\r\n            style = style ? style + \" cm-force-border\" : \"cm-force-border\";\r\n            var start = builder.pos, end = start + text.length;\r\n            for (;;) {\r\n                // Find the part that overlaps with the start of this text\r\n                var part = (void 0);\r\n                for (var i = 0; i < order.length; i++) {\r\n                    part = order[i];\r\n                    if (part.to > start && part.from <= start) { break }\r\n                }\r\n                if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\r\n                inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\r\n                startStyle = null;\r\n                text = text.slice(part.to - start);\r\n                start = part.to;\r\n            }\r\n        }\r\n    }\r\n\r\n    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\r\n        var widget = !ignoreWidget && marker.widgetNode;\r\n        if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\r\n        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\r\n            if (!widget)\r\n            { widget = builder.content.appendChild(document.createElement(\"span\")); }\r\n            widget.setAttribute(\"cm-marker\", marker.id);\r\n        }\r\n        if (widget) {\r\n            builder.cm.display.input.setUneditable(widget);\r\n            builder.content.appendChild(widget);\r\n        }\r\n        builder.pos += size;\r\n        builder.trailingSpace = false;\r\n    }\r\n\r\n    // Outputs a number of spans to make up a line, taking highlighting\r\n    // and marked text into account.\r\n    function insertLineContent(line, builder, styles) {\r\n        var spans = line.markedSpans, allText = line.text, at = 0;\r\n        if (!spans) {\r\n            for (var i$1 = 1; i$1 < styles.length; i$1+=2)\r\n            { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\r\n            return\r\n        }\r\n\r\n        var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\r\n        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\r\n        for (;;) {\r\n            if (nextChange == pos) { // Update current marker set\r\n                spanStyle = spanEndStyle = spanStartStyle = css = \"\";\r\n                attributes = null;\r\n                collapsed = null; nextChange = Infinity;\r\n                var foundBookmarks = [], endStyles = (void 0);\r\n                for (var j = 0; j < spans.length; ++j) {\r\n                    var sp = spans[j], m = sp.marker;\r\n                    if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\r\n                        foundBookmarks.push(m);\r\n                    } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\r\n                        if (sp.to != null && sp.to != pos && nextChange > sp.to) {\r\n                            nextChange = sp.to;\r\n                            spanEndStyle = \"\";\r\n                        }\r\n                        if (m.className) { spanStyle += \" \" + m.className; }\r\n                        if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\r\n                        if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\r\n                        if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\r\n                        // support for the old title property\r\n                        // https://github.com/codemirror/CodeMirror/pull/5673\r\n                        if (m.title) { (attributes || (attributes = {})).title = m.title; }\r\n                        if (m.attributes) {\r\n                            for (var attr in m.attributes)\r\n                            { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\r\n                        }\r\n                        if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\r\n                        { collapsed = sp; }\r\n                    } else if (sp.from > pos && nextChange > sp.from) {\r\n                        nextChange = sp.from;\r\n                    }\r\n                }\r\n                if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\r\n                { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\r\n\r\n                if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\r\n                { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\r\n                if (collapsed && (collapsed.from || 0) == pos) {\r\n                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\r\n                        collapsed.marker, collapsed.from == null);\r\n                    if (collapsed.to == null) { return }\r\n                    if (collapsed.to == pos) { collapsed = false; }\r\n                }\r\n            }\r\n            if (pos >= len) { break }\r\n\r\n            var upto = Math.min(len, nextChange);\r\n            while (true) {\r\n                if (text) {\r\n                    var end = pos + text.length;\r\n                    if (!collapsed) {\r\n                        var tokenText = end > upto ? text.slice(0, upto - pos) : text;\r\n                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\r\n                            spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\r\n                    }\r\n                    if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\r\n                    pos = end;\r\n                    spanStartStyle = \"\";\r\n                }\r\n                text = allText.slice(at, at = styles[i++]);\r\n                style = interpretTokenStyle(styles[i++], builder.cm.options);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // These objects are used to represent the visible (currently drawn)\r\n    // part of the document. A LineView may correspond to multiple\r\n    // logical lines, if those are connected by collapsed ranges.\r\n    function LineView(doc, line, lineN) {\r\n        // The starting line\r\n        this.line = line;\r\n        // Continuing lines, if any\r\n        this.rest = visualLineContinued(line);\r\n        // Number of logical lines in this visual line\r\n        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\r\n        this.node = this.text = null;\r\n        this.hidden = lineIsHidden(doc, line);\r\n    }\r\n\r\n    // Create a range of LineView objects for the given lines.\r\n    function buildViewArray(cm, from, to) {\r\n        var array = [], nextPos;\r\n        for (var pos = from; pos < to; pos = nextPos) {\r\n            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\r\n            nextPos = pos + view.size;\r\n            array.push(view);\r\n        }\r\n        return array\r\n    }\r\n\r\n    var operationGroup = null;\r\n\r\n    function pushOperation(op) {\r\n        if (operationGroup) {\r\n            operationGroup.ops.push(op);\r\n        } else {\r\n            op.ownsGroup = operationGroup = {\r\n                ops: [op],\r\n                delayedCallbacks: []\r\n            };\r\n        }\r\n    }\r\n\r\n    function fireCallbacksForOps(group) {\r\n        // Calls delayed callbacks and cursorActivity handlers until no\r\n        // new ones appear\r\n        var callbacks = group.delayedCallbacks, i = 0;\r\n        do {\r\n            for (; i < callbacks.length; i++)\r\n            { callbacks[i].call(null); }\r\n            for (var j = 0; j < group.ops.length; j++) {\r\n                var op = group.ops[j];\r\n                if (op.cursorActivityHandlers)\r\n                { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\r\n                { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\r\n            }\r\n        } while (i < callbacks.length)\r\n    }\r\n\r\n    function finishOperation(op, endCb) {\r\n        var group = op.ownsGroup;\r\n        if (!group) { return }\r\n\r\n        try { fireCallbacksForOps(group); }\r\n        finally {\r\n            operationGroup = null;\r\n            endCb(group);\r\n        }\r\n    }\r\n\r\n    var orphanDelayedCallbacks = null;\r\n\r\n    // Often, we want to signal events at a point where we are in the\r\n    // middle of some work, but don't want the handler to start calling\r\n    // other methods on the editor, which might be in an inconsistent\r\n    // state or simply not expect any other events to happen.\r\n    // signalLater looks whether there are any handlers, and schedules\r\n    // them to be executed when the last operation ends, or, if no\r\n    // operation is active, when a timeout fires.\r\n    function signalLater(emitter, type /*, values...*/) {\r\n        var arr = getHandlers(emitter, type);\r\n        if (!arr.length) { return }\r\n        var args = Array.prototype.slice.call(arguments, 2), list;\r\n        if (operationGroup) {\r\n            list = operationGroup.delayedCallbacks;\r\n        } else if (orphanDelayedCallbacks) {\r\n            list = orphanDelayedCallbacks;\r\n        } else {\r\n            list = orphanDelayedCallbacks = [];\r\n            setTimeout(fireOrphanDelayed, 0);\r\n        }\r\n        var loop = function ( i ) {\r\n            list.push(function () { return arr[i].apply(null, args); });\r\n        };\r\n\r\n        for (var i = 0; i < arr.length; ++i)\r\n            loop( i );\r\n    }\r\n\r\n    function fireOrphanDelayed() {\r\n        var delayed = orphanDelayedCallbacks;\r\n        orphanDelayedCallbacks = null;\r\n        for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\r\n    }\r\n\r\n    // When an aspect of a line changes, a string is added to\r\n    // lineView.changes. This updates the relevant part of the line's\r\n    // DOM structure.\r\n    function updateLineForChanges(cm, lineView, lineN, dims) {\r\n        for (var j = 0; j < lineView.changes.length; j++) {\r\n            var type = lineView.changes[j];\r\n            if (type == \"text\") { updateLineText(cm, lineView); }\r\n            else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\r\n            else if (type == \"class\") { updateLineClasses(cm, lineView); }\r\n            else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\r\n        }\r\n        lineView.changes = null;\r\n    }\r\n\r\n    // Lines with gutter elements, widgets or a background class need to\r\n    // be wrapped, and have the extra elements added to the wrapper div\r\n    function ensureLineWrapped(lineView) {\r\n        if (lineView.node == lineView.text) {\r\n            lineView.node = elt(\"div\", null, null, \"position: relative\");\r\n            if (lineView.text.parentNode)\r\n            { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\r\n            lineView.node.appendChild(lineView.text);\r\n            if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\r\n        }\r\n        return lineView.node\r\n    }\r\n\r\n    function updateLineBackground(cm, lineView) {\r\n        var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\r\n        if (cls) { cls += \" CodeMirror-linebackground\"; }\r\n        if (lineView.background) {\r\n            if (cls) { lineView.background.className = cls; }\r\n            else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\r\n        } else if (cls) {\r\n            var wrap = ensureLineWrapped(lineView);\r\n            lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\r\n            cm.display.input.setUneditable(lineView.background);\r\n        }\r\n    }\r\n\r\n    // Wrapper around buildLineContent which will reuse the structure\r\n    // in display.externalMeasured when possible.\r\n    function getLineContent(cm, lineView) {\r\n        var ext = cm.display.externalMeasured;\r\n        if (ext && ext.line == lineView.line) {\r\n            cm.display.externalMeasured = null;\r\n            lineView.measure = ext.measure;\r\n            return ext.built\r\n        }\r\n        return buildLineContent(cm, lineView)\r\n    }\r\n\r\n    // Redraw the line's text. Interacts with the background and text\r\n    // classes because the mode may output tokens that influence these\r\n    // classes.\r\n    function updateLineText(cm, lineView) {\r\n        var cls = lineView.text.className;\r\n        var built = getLineContent(cm, lineView);\r\n        if (lineView.text == lineView.node) { lineView.node = built.pre; }\r\n        lineView.text.parentNode.replaceChild(built.pre, lineView.text);\r\n        lineView.text = built.pre;\r\n        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\r\n            lineView.bgClass = built.bgClass;\r\n            lineView.textClass = built.textClass;\r\n            updateLineClasses(cm, lineView);\r\n        } else if (cls) {\r\n            lineView.text.className = cls;\r\n        }\r\n    }\r\n\r\n    function updateLineClasses(cm, lineView) {\r\n        updateLineBackground(cm, lineView);\r\n        if (lineView.line.wrapClass)\r\n        { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\r\n        else if (lineView.node != lineView.text)\r\n        { lineView.node.className = \"\"; }\r\n        var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\r\n        lineView.text.className = textClass || \"\";\r\n    }\r\n\r\n    function updateLineGutter(cm, lineView, lineN, dims) {\r\n        if (lineView.gutter) {\r\n            lineView.node.removeChild(lineView.gutter);\r\n            lineView.gutter = null;\r\n        }\r\n        if (lineView.gutterBackground) {\r\n            lineView.node.removeChild(lineView.gutterBackground);\r\n            lineView.gutterBackground = null;\r\n        }\r\n        if (lineView.line.gutterClass) {\r\n            var wrap = ensureLineWrapped(lineView);\r\n            lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\r\n                (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\r\n            cm.display.input.setUneditable(lineView.gutterBackground);\r\n            wrap.insertBefore(lineView.gutterBackground, lineView.text);\r\n        }\r\n        var markers = lineView.line.gutterMarkers;\r\n        if (cm.options.lineNumbers || markers) {\r\n            var wrap$1 = ensureLineWrapped(lineView);\r\n            var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\r\n            cm.display.input.setUneditable(gutterWrap);\r\n            wrap$1.insertBefore(gutterWrap, lineView.text);\r\n            if (lineView.line.gutterClass)\r\n            { gutterWrap.className += \" \" + lineView.line.gutterClass; }\r\n            if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\r\n            { lineView.lineNumber = gutterWrap.appendChild(\r\n                elt(\"div\", lineNumberFor(cm.options, lineN),\r\n                    \"CodeMirror-linenumber CodeMirror-gutter-elt\",\r\n                    (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\r\n            if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\r\n                var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\r\n                if (found)\r\n                { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\r\n                    (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\r\n            } }\r\n        }\r\n    }\r\n\r\n    function updateLineWidgets(cm, lineView, dims) {\r\n        if (lineView.alignable) { lineView.alignable = null; }\r\n        for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\r\n            next = node.nextSibling;\r\n            if (node.className == \"CodeMirror-linewidget\")\r\n            { lineView.node.removeChild(node); }\r\n        }\r\n        insertLineWidgets(cm, lineView, dims);\r\n    }\r\n\r\n    // Build a line's DOM representation from scratch\r\n    function buildLineElement(cm, lineView, lineN, dims) {\r\n        var built = getLineContent(cm, lineView);\r\n        lineView.text = lineView.node = built.pre;\r\n        if (built.bgClass) { lineView.bgClass = built.bgClass; }\r\n        if (built.textClass) { lineView.textClass = built.textClass; }\r\n\r\n        updateLineClasses(cm, lineView);\r\n        updateLineGutter(cm, lineView, lineN, dims);\r\n        insertLineWidgets(cm, lineView, dims);\r\n        return lineView.node\r\n    }\r\n\r\n    // A lineView may contain multiple logical lines (when merged by\r\n    // collapsed spans). The widgets for all of them need to be drawn.\r\n    function insertLineWidgets(cm, lineView, dims) {\r\n        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\r\n        if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\r\n        { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\r\n    }\r\n\r\n    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\r\n        if (!line.widgets) { return }\r\n        var wrap = ensureLineWrapped(lineView);\r\n        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\r\n            var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\r\n            if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\r\n            positionLineWidget(widget, node, lineView, dims);\r\n            cm.display.input.setUneditable(node);\r\n            if (allowAbove && widget.above)\r\n            { wrap.insertBefore(node, lineView.gutter || lineView.text); }\r\n            else\r\n            { wrap.appendChild(node); }\r\n            signalLater(widget, \"redraw\");\r\n        }\r\n    }\r\n\r\n    function positionLineWidget(widget, node, lineView, dims) {\r\n        if (widget.noHScroll) {\r\n            (lineView.alignable || (lineView.alignable = [])).push(node);\r\n            var width = dims.wrapperWidth;\r\n            node.style.left = dims.fixedPos + \"px\";\r\n            if (!widget.coverGutter) {\r\n                width -= dims.gutterTotalWidth;\r\n                node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\r\n            }\r\n            node.style.width = width + \"px\";\r\n        }\r\n        if (widget.coverGutter) {\r\n            node.style.zIndex = 5;\r\n            node.style.position = \"relative\";\r\n            if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\r\n        }\r\n    }\r\n\r\n    function widgetHeight(widget) {\r\n        if (widget.height != null) { return widget.height }\r\n        var cm = widget.doc.cm;\r\n        if (!cm) { return 0 }\r\n        if (!contains(document.body, widget.node)) {\r\n            var parentStyle = \"position: relative;\";\r\n            if (widget.coverGutter)\r\n            { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\r\n            if (widget.noHScroll)\r\n            { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\r\n            removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\r\n        }\r\n        return widget.height = widget.node.parentNode.offsetHeight\r\n    }\r\n\r\n    // Return true when the given mouse event happened in a widget\r\n    function eventInWidget(display, e) {\r\n        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\r\n            if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\r\n                (n.parentNode == display.sizer && n != display.mover))\r\n            { return true }\r\n        }\r\n    }\r\n\r\n    // POSITION MEASUREMENT\r\n\r\n    function paddingTop(display) {return display.lineSpace.offsetTop}\r\n    function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\r\n    function paddingH(display) {\r\n        if (display.cachedPaddingH) { return display.cachedPaddingH }\r\n        var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\r\n        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\r\n        var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\r\n        if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\r\n        return data\r\n    }\r\n\r\n    function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\r\n    function displayWidth(cm) {\r\n        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\r\n    }\r\n    function displayHeight(cm) {\r\n        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\r\n    }\r\n\r\n    // Ensure the lineView.wrapping.heights array is populated. This is\r\n    // an array of bottom offsets for the lines that make up a drawn\r\n    // line. When lineWrapping is on, there might be more than one\r\n    // height.\r\n    function ensureLineHeights(cm, lineView, rect) {\r\n        var wrapping = cm.options.lineWrapping;\r\n        var curWidth = wrapping && displayWidth(cm);\r\n        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\r\n            var heights = lineView.measure.heights = [];\r\n            if (wrapping) {\r\n                lineView.measure.width = curWidth;\r\n                var rects = lineView.text.firstChild.getClientRects();\r\n                for (var i = 0; i < rects.length - 1; i++) {\r\n                    var cur = rects[i], next = rects[i + 1];\r\n                    if (Math.abs(cur.bottom - next.bottom) > 2)\r\n                    { heights.push((cur.bottom + next.top) / 2 - rect.top); }\r\n                }\r\n            }\r\n            heights.push(rect.bottom - rect.top);\r\n        }\r\n    }\r\n\r\n    // Find a line map (mapping character offsets to text nodes) and a\r\n    // measurement cache for the given line number. (A line view might\r\n    // contain multiple lines when collapsed ranges are present.)\r\n    function mapFromLineView(lineView, line, lineN) {\r\n        if (lineView.line == line)\r\n        { return {map: lineView.measure.map, cache: lineView.measure.cache} }\r\n        for (var i = 0; i < lineView.rest.length; i++)\r\n        { if (lineView.rest[i] == line)\r\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\r\n        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\r\n        { if (lineNo(lineView.rest[i$1]) > lineN)\r\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\r\n    }\r\n\r\n    // Render a line into the hidden node display.externalMeasured. Used\r\n    // when measurement is needed for a line that's not in the viewport.\r\n    function updateExternalMeasurement(cm, line) {\r\n        line = visualLine(line);\r\n        var lineN = lineNo(line);\r\n        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\r\n        view.lineN = lineN;\r\n        var built = view.built = buildLineContent(cm, view);\r\n        view.text = built.pre;\r\n        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\r\n        return view\r\n    }\r\n\r\n    // Get a {top, bottom, left, right} box (in line-local coordinates)\r\n    // for a given character.\r\n    function measureChar(cm, line, ch, bias) {\r\n        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\r\n    }\r\n\r\n    // Find a line view that corresponds to the given line number.\r\n    function findViewForLine(cm, lineN) {\r\n        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\r\n        { return cm.display.view[findViewIndex(cm, lineN)] }\r\n        var ext = cm.display.externalMeasured;\r\n        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\r\n        { return ext }\r\n    }\r\n\r\n    // Measurement can be split in two steps, the set-up work that\r\n    // applies to the whole line, and the measurement of the actual\r\n    // character. Functions like coordsChar, that need to do a lot of\r\n    // measurements in a row, can thus ensure that the set-up work is\r\n    // only done once.\r\n    function prepareMeasureForLine(cm, line) {\r\n        var lineN = lineNo(line);\r\n        var view = findViewForLine(cm, lineN);\r\n        if (view && !view.text) {\r\n            view = null;\r\n        } else if (view && view.changes) {\r\n            updateLineForChanges(cm, view, lineN, getDimensions(cm));\r\n            cm.curOp.forceUpdate = true;\r\n        }\r\n        if (!view)\r\n        { view = updateExternalMeasurement(cm, line); }\r\n\r\n        var info = mapFromLineView(view, line, lineN);\r\n        return {\r\n            line: line, view: view, rect: null,\r\n            map: info.map, cache: info.cache, before: info.before,\r\n            hasHeights: false\r\n        }\r\n    }\r\n\r\n    // Given a prepared measurement object, measures the position of an\r\n    // actual character (or fetches it from the cache).\r\n    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\r\n        if (prepared.before) { ch = -1; }\r\n        var key = ch + (bias || \"\"), found;\r\n        if (prepared.cache.hasOwnProperty(key)) {\r\n            found = prepared.cache[key];\r\n        } else {\r\n            if (!prepared.rect)\r\n            { prepared.rect = prepared.view.text.getBoundingClientRect(); }\r\n            if (!prepared.hasHeights) {\r\n                ensureLineHeights(cm, prepared.view, prepared.rect);\r\n                prepared.hasHeights = true;\r\n            }\r\n            found = measureCharInner(cm, prepared, ch, bias);\r\n            if (!found.bogus) { prepared.cache[key] = found; }\r\n        }\r\n        return {left: found.left, right: found.right,\r\n            top: varHeight ? found.rtop : found.top,\r\n            bottom: varHeight ? found.rbottom : found.bottom}\r\n    }\r\n\r\n    var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\r\n\r\n    function nodeAndOffsetInLineMap(map$$1, ch, bias) {\r\n        var node, start, end, collapse, mStart, mEnd;\r\n        // First, search the line map for the text node corresponding to,\r\n        // or closest to, the target character.\r\n        for (var i = 0; i < map$$1.length; i += 3) {\r\n            mStart = map$$1[i];\r\n            mEnd = map$$1[i + 1];\r\n            if (ch < mStart) {\r\n                start = 0; end = 1;\r\n                collapse = \"left\";\r\n            } else if (ch < mEnd) {\r\n                start = ch - mStart;\r\n                end = start + 1;\r\n            } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\r\n                end = mEnd - mStart;\r\n                start = end - 1;\r\n                if (ch >= mEnd) { collapse = \"right\"; }\r\n            }\r\n            if (start != null) {\r\n                node = map$$1[i + 2];\r\n                if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\r\n                { collapse = bias; }\r\n                if (bias == \"left\" && start == 0)\r\n                { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\r\n                    node = map$$1[(i -= 3) + 2];\r\n                    collapse = \"left\";\r\n                } }\r\n                if (bias == \"right\" && start == mEnd - mStart)\r\n                { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\r\n                    node = map$$1[(i += 3) + 2];\r\n                    collapse = \"right\";\r\n                } }\r\n                break\r\n            }\r\n        }\r\n        return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\r\n    }\r\n\r\n    function getUsefulRect(rects, bias) {\r\n        var rect = nullRect;\r\n        if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\r\n            if ((rect = rects[i]).left != rect.right) { break }\r\n        } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\r\n            if ((rect = rects[i$1]).left != rect.right) { break }\r\n        } }\r\n        return rect\r\n    }\r\n\r\n    function measureCharInner(cm, prepared, ch, bias) {\r\n        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\r\n        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\r\n\r\n        var rect;\r\n        if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\r\n            for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\r\n                while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\r\n                while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\r\n                if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\r\n                { rect = node.parentNode.getBoundingClientRect(); }\r\n                else\r\n                { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\r\n                if (rect.left || rect.right || start == 0) { break }\r\n                end = start;\r\n                start = start - 1;\r\n                collapse = \"right\";\r\n            }\r\n            if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\r\n        } else { // If it is a widget, simply get the box for the whole widget.\r\n            if (start > 0) { collapse = bias = \"right\"; }\r\n            var rects;\r\n            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\r\n            { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\r\n            else\r\n            { rect = node.getBoundingClientRect(); }\r\n        }\r\n        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\r\n            var rSpan = node.parentNode.getClientRects()[0];\r\n            if (rSpan)\r\n            { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\r\n            else\r\n            { rect = nullRect; }\r\n        }\r\n\r\n        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\r\n        var mid = (rtop + rbot) / 2;\r\n        var heights = prepared.view.measure.heights;\r\n        var i = 0;\r\n        for (; i < heights.length - 1; i++)\r\n        { if (mid < heights[i]) { break } }\r\n        var top = i ? heights[i - 1] : 0, bot = heights[i];\r\n        var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\r\n            right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\r\n            top: top, bottom: bot};\r\n        if (!rect.left && !rect.right) { result.bogus = true; }\r\n        if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\r\n\r\n        return result\r\n    }\r\n\r\n    // Work around problem with bounding client rects on ranges being\r\n    // returned incorrectly when zoomed on IE10 and below.\r\n    function maybeUpdateRectForZooming(measure, rect) {\r\n        if (!window.screen || screen.logicalXDPI == null ||\r\n            screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\r\n        { return rect }\r\n        var scaleX = screen.logicalXDPI / screen.deviceXDPI;\r\n        var scaleY = screen.logicalYDPI / screen.deviceYDPI;\r\n        return {left: rect.left * scaleX, right: rect.right * scaleX,\r\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\r\n    }\r\n\r\n    function clearLineMeasurementCacheFor(lineView) {\r\n        if (lineView.measure) {\r\n            lineView.measure.cache = {};\r\n            lineView.measure.heights = null;\r\n            if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\r\n            { lineView.measure.caches[i] = {}; } }\r\n        }\r\n    }\r\n\r\n    function clearLineMeasurementCache(cm) {\r\n        cm.display.externalMeasure = null;\r\n        removeChildren(cm.display.lineMeasure);\r\n        for (var i = 0; i < cm.display.view.length; i++)\r\n        { clearLineMeasurementCacheFor(cm.display.view[i]); }\r\n    }\r\n\r\n    function clearCaches(cm) {\r\n        clearLineMeasurementCache(cm);\r\n        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\r\n        if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\r\n        cm.display.lineNumChars = null;\r\n    }\r\n\r\n    function pageScrollX() {\r\n        // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\r\n        // which causes page_Offset and bounding client rects to use\r\n        // different reference viewports and invalidate our calculations.\r\n        if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\r\n        return window.pageXOffset || (document.documentElement || document.body).scrollLeft\r\n    }\r\n    function pageScrollY() {\r\n        if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\r\n        return window.pageYOffset || (document.documentElement || document.body).scrollTop\r\n    }\r\n\r\n    function widgetTopHeight(lineObj) {\r\n        var height = 0;\r\n        if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\r\n        { height += widgetHeight(lineObj.widgets[i]); } } }\r\n        return height\r\n    }\r\n\r\n    // Converts a {top, bottom, left, right} box from line-local\r\n    // coordinates into another coordinate system. Context may be one of\r\n    // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\r\n    // or \"page\".\r\n    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\r\n        if (!includeWidgets) {\r\n            var height = widgetTopHeight(lineObj);\r\n            rect.top += height; rect.bottom += height;\r\n        }\r\n        if (context == \"line\") { return rect }\r\n        if (!context) { context = \"local\"; }\r\n        var yOff = heightAtLine(lineObj);\r\n        if (context == \"local\") { yOff += paddingTop(cm.display); }\r\n        else { yOff -= cm.display.viewOffset; }\r\n        if (context == \"page\" || context == \"window\") {\r\n            var lOff = cm.display.lineSpace.getBoundingClientRect();\r\n            yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\r\n            var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\r\n            rect.left += xOff; rect.right += xOff;\r\n        }\r\n        rect.top += yOff; rect.bottom += yOff;\r\n        return rect\r\n    }\r\n\r\n    // Coverts a box from \"div\" coords to another coordinate system.\r\n    // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\r\n    function fromCoordSystem(cm, coords, context) {\r\n        if (context == \"div\") { return coords }\r\n        var left = coords.left, top = coords.top;\r\n        // First move into \"page\" coordinate system\r\n        if (context == \"page\") {\r\n            left -= pageScrollX();\r\n            top -= pageScrollY();\r\n        } else if (context == \"local\" || !context) {\r\n            var localBox = cm.display.sizer.getBoundingClientRect();\r\n            left += localBox.left;\r\n            top += localBox.top;\r\n        }\r\n\r\n        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\r\n        return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\r\n    }\r\n\r\n    function charCoords(cm, pos, context, lineObj, bias) {\r\n        if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\r\n        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\r\n    }\r\n\r\n    // Returns a box for a given cursor position, which may have an\r\n    // 'other' property containing the position of the secondary cursor\r\n    // on a bidi boundary.\r\n    // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\r\n    // and after `char - 1` in writing order of `char - 1`\r\n    // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\r\n    // and before `char` in writing order of `char`\r\n    // Examples (upper-case letters are RTL, lower-case are LTR):\r\n    //     Pos(0, 1, ...)\r\n    //     before   after\r\n    // ab     a|b     a|b\r\n    // aB     a|B     aB|\r\n    // Ab     |Ab     A|b\r\n    // AB     B|A     B|A\r\n    // Every position after the last character on a line is considered to stick\r\n    // to the last character on the line.\r\n    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\r\n        lineObj = lineObj || getLine(cm.doc, pos.line);\r\n        if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\r\n        function get(ch, right) {\r\n            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\r\n            if (right) { m.left = m.right; } else { m.right = m.left; }\r\n            return intoCoordSystem(cm, lineObj, m, context)\r\n        }\r\n        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\r\n        if (ch >= lineObj.text.length) {\r\n            ch = lineObj.text.length;\r\n            sticky = \"before\";\r\n        } else if (ch <= 0) {\r\n            ch = 0;\r\n            sticky = \"after\";\r\n        }\r\n        if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\r\n\r\n        function getBidi(ch, partPos, invert) {\r\n            var part = order[partPos], right = part.level == 1;\r\n            return get(invert ? ch - 1 : ch, right != invert)\r\n        }\r\n        var partPos = getBidiPartAt(order, ch, sticky);\r\n        var other = bidiOther;\r\n        var val = getBidi(ch, partPos, sticky == \"before\");\r\n        if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\r\n        return val\r\n    }\r\n\r\n    // Used to cheaply estimate the coordinates for a position. Used for\r\n    // intermediate scroll updates.\r\n    function estimateCoords(cm, pos) {\r\n        var left = 0;\r\n        pos = clipPos(cm.doc, pos);\r\n        if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\r\n        var lineObj = getLine(cm.doc, pos.line);\r\n        var top = heightAtLine(lineObj) + paddingTop(cm.display);\r\n        return {left: left, right: left, top: top, bottom: top + lineObj.height}\r\n    }\r\n\r\n    // Positions returned by coordsChar contain some extra information.\r\n    // xRel is the relative x position of the input coordinates compared\r\n    // to the found position (so xRel > 0 means the coordinates are to\r\n    // the right of the character position, for example). When outside\r\n    // is true, that means the coordinates lie outside the line's\r\n    // vertical range.\r\n    function PosWithInfo(line, ch, sticky, outside, xRel) {\r\n        var pos = Pos(line, ch, sticky);\r\n        pos.xRel = xRel;\r\n        if (outside) { pos.outside = true; }\r\n        return pos\r\n    }\r\n\r\n    // Compute the character position closest to the given coordinates.\r\n    // Input must be lineSpace-local (\"div\" coordinate system).\r\n    function coordsChar(cm, x, y) {\r\n        var doc = cm.doc;\r\n        y += cm.display.viewOffset;\r\n        if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\r\n        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\r\n        if (lineN > last)\r\n        { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\r\n        if (x < 0) { x = 0; }\r\n\r\n        var lineObj = getLine(doc, lineN);\r\n        for (;;) {\r\n            var found = coordsCharInner(cm, lineObj, lineN, x, y);\r\n            var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\r\n            if (!collapsed) { return found }\r\n            var rangeEnd = collapsed.find(1);\r\n            if (rangeEnd.line == lineN) { return rangeEnd }\r\n            lineObj = getLine(doc, lineN = rangeEnd.line);\r\n        }\r\n    }\r\n\r\n    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\r\n        y -= widgetTopHeight(lineObj);\r\n        var end = lineObj.text.length;\r\n        var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\r\n        end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\r\n        return {begin: begin, end: end}\r\n    }\r\n\r\n    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\r\n        if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\r\n        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\r\n        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\r\n    }\r\n\r\n    // Returns true if the given side of a box is after the given\r\n    // coordinates, in top-to-bottom, left-to-right order.\r\n    function boxIsAfter(box, x, y, left) {\r\n        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\r\n    }\r\n\r\n    function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\r\n        // Move y into line-local coordinate space\r\n        y -= heightAtLine(lineObj);\r\n        var preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n        // When directly calling `measureCharPrepared`, we have to adjust\r\n        // for the widgets at this line.\r\n        var widgetHeight$$1 = widgetTopHeight(lineObj);\r\n        var begin = 0, end = lineObj.text.length, ltr = true;\r\n\r\n        var order = getOrder(lineObj, cm.doc.direction);\r\n        // If the line isn't plain left-to-right text, first figure out\r\n        // which bidi section the coordinates fall into.\r\n        if (order) {\r\n            var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\r\n            (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\r\n            ltr = part.level != 1;\r\n            // The awkward -1 offsets are needed because findFirst (called\r\n            // on these below) will treat its first bound as inclusive,\r\n            // second as exclusive, but we want to actually address the\r\n            // characters in the part's range\r\n            begin = ltr ? part.from : part.to - 1;\r\n            end = ltr ? part.to : part.from - 1;\r\n        }\r\n\r\n        // A binary search to find the first character whose bounding box\r\n        // starts after the coordinates. If we run across any whose box wrap\r\n        // the coordinates, store that.\r\n        var chAround = null, boxAround = null;\r\n        var ch = findFirst(function (ch) {\r\n            var box = measureCharPrepared(cm, preparedMeasure, ch);\r\n            box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\r\n            if (!boxIsAfter(box, x, y, false)) { return false }\r\n            if (box.top <= y && box.left <= x) {\r\n                chAround = ch;\r\n                boxAround = box;\r\n            }\r\n            return true\r\n        }, begin, end);\r\n\r\n        var baseX, sticky, outside = false;\r\n        // If a box around the coordinates was found, use that\r\n        if (boxAround) {\r\n            // Distinguish coordinates nearer to the left or right side of the box\r\n            var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\r\n            ch = chAround + (atStart ? 0 : 1);\r\n            sticky = atStart ? \"after\" : \"before\";\r\n            baseX = atLeft ? boxAround.left : boxAround.right;\r\n        } else {\r\n            // (Adjust for extended bound, if necessary.)\r\n            if (!ltr && (ch == end || ch == begin)) { ch++; }\r\n            // To determine which side to associate with, get the box to the\r\n            // left of the character and compare it's vertical position to the\r\n            // coordinates\r\n            sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\r\n                (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\r\n                    \"after\" : \"before\";\r\n            // Now get accurate coordinates for this place, in order to get a\r\n            // base X position\r\n            var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\r\n            baseX = coords.left;\r\n            outside = y < coords.top || y >= coords.bottom;\r\n        }\r\n\r\n        ch = skipExtendingChars(lineObj.text, ch, 1);\r\n        return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\r\n    }\r\n\r\n    function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\r\n        // Bidi parts are sorted left-to-right, and in a non-line-wrapping\r\n        // situation, we can take this ordering to correspond to the visual\r\n        // ordering. This finds the first part whose end is after the given\r\n        // coordinates.\r\n        var index = findFirst(function (i) {\r\n            var part = order[i], ltr = part.level != 1;\r\n            return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\r\n                \"line\", lineObj, preparedMeasure), x, y, true)\r\n        }, 0, order.length - 1);\r\n        var part = order[index];\r\n        // If this isn't the first part, the part's start is also after\r\n        // the coordinates, and the coordinates aren't on the same line as\r\n        // that start, move one part back.\r\n        if (index > 0) {\r\n            var ltr = part.level != 1;\r\n            var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\r\n                \"line\", lineObj, preparedMeasure);\r\n            if (boxIsAfter(start, x, y, true) && start.top > y)\r\n            { part = order[index - 1]; }\r\n        }\r\n        return part\r\n    }\r\n\r\n    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\r\n        // In a wrapped line, rtl text on wrapping boundaries can do things\r\n        // that don't correspond to the ordering in our `order` array at\r\n        // all, so a binary search doesn't work, and we want to return a\r\n        // part that only spans one line so that the binary search in\r\n        // coordsCharInner is safe. As such, we first find the extent of the\r\n        // wrapped line, and then do a flat search in which we discard any\r\n        // spans that aren't on the line.\r\n        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\r\n        var begin = ref.begin;\r\n        var end = ref.end;\r\n        if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\r\n        var part = null, closestDist = null;\r\n        for (var i = 0; i < order.length; i++) {\r\n            var p = order[i];\r\n            if (p.from >= end || p.to <= begin) { continue }\r\n            var ltr = p.level != 1;\r\n            var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\r\n            // Weigh against spans ending before this, so that they are only\r\n            // picked if nothing ends after\r\n            var dist = endX < x ? x - endX + 1e9 : endX - x;\r\n            if (!part || closestDist > dist) {\r\n                part = p;\r\n                closestDist = dist;\r\n            }\r\n        }\r\n        if (!part) { part = order[order.length - 1]; }\r\n        // Clip the part to the wrapped line.\r\n        if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\r\n        if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\r\n        return part\r\n    }\r\n\r\n    var measureText;\r\n    // Compute the default text height.\r\n    function textHeight(display) {\r\n        if (display.cachedTextHeight != null) { return display.cachedTextHeight }\r\n        if (measureText == null) {\r\n            measureText = elt(\"pre\");\r\n            // Measure a bunch of lines, for browsers that compute\r\n            // fractional heights.\r\n            for (var i = 0; i < 49; ++i) {\r\n                measureText.appendChild(document.createTextNode(\"x\"));\r\n                measureText.appendChild(elt(\"br\"));\r\n            }\r\n            measureText.appendChild(document.createTextNode(\"x\"));\r\n        }\r\n        removeChildrenAndAdd(display.measure, measureText);\r\n        var height = measureText.offsetHeight / 50;\r\n        if (height > 3) { display.cachedTextHeight = height; }\r\n        removeChildren(display.measure);\r\n        return height || 1\r\n    }\r\n\r\n    // Compute the default character width.\r\n    function charWidth(display) {\r\n        if (display.cachedCharWidth != null) { return display.cachedCharWidth }\r\n        var anchor = elt(\"span\", \"xxxxxxxxxx\");\r\n        var pre = elt(\"pre\", [anchor]);\r\n        removeChildrenAndAdd(display.measure, pre);\r\n        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\r\n        if (width > 2) { display.cachedCharWidth = width; }\r\n        return width || 10\r\n    }\r\n\r\n    // Do a bulk-read of the DOM positions and sizes needed to draw the\r\n    // view, so that we don't interleave reading and writing to the DOM.\r\n    function getDimensions(cm) {\r\n        var d = cm.display, left = {}, width = {};\r\n        var gutterLeft = d.gutters.clientLeft;\r\n        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\r\n            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\r\n            width[cm.options.gutters[i]] = n.clientWidth;\r\n        }\r\n        return {fixedPos: compensateForHScroll(d),\r\n            gutterTotalWidth: d.gutters.offsetWidth,\r\n            gutterLeft: left,\r\n            gutterWidth: width,\r\n            wrapperWidth: d.wrapper.clientWidth}\r\n    }\r\n\r\n    // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\r\n    // but using getBoundingClientRect to get a sub-pixel-accurate\r\n    // result.\r\n    function compensateForHScroll(display) {\r\n        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\r\n    }\r\n\r\n    // Returns a function that estimates the height of a line, to use as\r\n    // first approximation until the line becomes visible (and is thus\r\n    // properly measurable).\r\n    function estimateHeight(cm) {\r\n        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\r\n        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\r\n        return function (line) {\r\n            if (lineIsHidden(cm.doc, line)) { return 0 }\r\n\r\n            var widgetsHeight = 0;\r\n            if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\r\n                if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\r\n            } }\r\n\r\n            if (wrapping)\r\n            { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\r\n            else\r\n            { return widgetsHeight + th }\r\n        }\r\n    }\r\n\r\n    function estimateLineHeights(cm) {\r\n        var doc = cm.doc, est = estimateHeight(cm);\r\n        doc.iter(function (line) {\r\n            var estHeight = est(line);\r\n            if (estHeight != line.height) { updateLineHeight(line, estHeight); }\r\n        });\r\n    }\r\n\r\n    // Given a mouse event, find the corresponding position. If liberal\r\n    // is false, it checks whether a gutter or scrollbar was clicked,\r\n    // and returns null if it was. forRect is used by rectangular\r\n    // selections, and tries to estimate a character position even for\r\n    // coordinates beyond the right of the text.\r\n    function posFromMouse(cm, e, liberal, forRect) {\r\n        var display = cm.display;\r\n        if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\r\n\r\n        var x, y, space = display.lineSpace.getBoundingClientRect();\r\n        // Fails unpredictably on IE[67] when mouse is dragged around quickly.\r\n        try { x = e.clientX - space.left; y = e.clientY - space.top; }\r\n        catch (e) { return null }\r\n        var coords = coordsChar(cm, x, y), line;\r\n        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\r\n            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\r\n            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\r\n        }\r\n        return coords\r\n    }\r\n\r\n    // Find the view element corresponding to a given line. Return null\r\n    // when the line isn't visible.\r\n    function findViewIndex(cm, n) {\r\n        if (n >= cm.display.viewTo) { return null }\r\n        n -= cm.display.viewFrom;\r\n        if (n < 0) { return null }\r\n        var view = cm.display.view;\r\n        for (var i = 0; i < view.length; i++) {\r\n            n -= view[i].size;\r\n            if (n < 0) { return i }\r\n        }\r\n    }\r\n\r\n    function updateSelection(cm) {\r\n        cm.display.input.showSelection(cm.display.input.prepareSelection());\r\n    }\r\n\r\n    function prepareSelection(cm, primary) {\r\n        if ( primary === void 0 ) primary = true;\r\n\r\n        var doc = cm.doc, result = {};\r\n        var curFragment = result.cursors = document.createDocumentFragment();\r\n        var selFragment = result.selection = document.createDocumentFragment();\r\n\r\n        for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n            if (!primary && i == doc.sel.primIndex) { continue }\r\n            var range$$1 = doc.sel.ranges[i];\r\n            if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\r\n            var collapsed = range$$1.empty();\r\n            if (collapsed || cm.options.showCursorWhenSelecting)\r\n            { drawSelectionCursor(cm, range$$1.head, curFragment); }\r\n            if (!collapsed)\r\n            { drawSelectionRange(cm, range$$1, selFragment); }\r\n        }\r\n        return result\r\n    }\r\n\r\n    // Draws a cursor for the given range\r\n    function drawSelectionCursor(cm, head, output) {\r\n        var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\r\n\r\n        var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\r\n        cursor.style.left = pos.left + \"px\";\r\n        cursor.style.top = pos.top + \"px\";\r\n        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\r\n\r\n        if (pos.other) {\r\n            // Secondary cursor, shown when on a 'jump' in bi-directional text\r\n            var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\r\n            otherCursor.style.display = \"\";\r\n            otherCursor.style.left = pos.other.left + \"px\";\r\n            otherCursor.style.top = pos.other.top + \"px\";\r\n            otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\r\n        }\r\n    }\r\n\r\n    function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\r\n\r\n    // Draws the given range as a highlighted selection\r\n    function drawSelectionRange(cm, range$$1, output) {\r\n        var display = cm.display, doc = cm.doc;\r\n        var fragment = document.createDocumentFragment();\r\n        var padding = paddingH(cm.display), leftSide = padding.left;\r\n        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\r\n        var docLTR = doc.direction == \"ltr\";\r\n\r\n        function add(left, top, width, bottom) {\r\n            if (top < 0) { top = 0; }\r\n            top = Math.round(top);\r\n            bottom = Math.round(bottom);\r\n            fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\r\n        }\r\n\r\n        function drawForLine(line, fromArg, toArg) {\r\n            var lineObj = getLine(doc, line);\r\n            var lineLen = lineObj.text.length;\r\n            var start, end;\r\n            function coords(ch, bias) {\r\n                return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\r\n            }\r\n\r\n            function wrapX(pos, dir, side) {\r\n                var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\r\n                var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\r\n                var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\r\n                return coords(ch, prop)[prop]\r\n            }\r\n\r\n            var order = getOrder(lineObj, doc.direction);\r\n            iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\r\n                var ltr = dir == \"ltr\";\r\n                var fromPos = coords(from, ltr ? \"left\" : \"right\");\r\n                var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\r\n\r\n                var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\r\n                var first = i == 0, last = !order || i == order.length - 1;\r\n                if (toPos.top - fromPos.top <= 3) { // Single line\r\n                    var openLeft = (docLTR ? openStart : openEnd) && first;\r\n                    var openRight = (docLTR ? openEnd : openStart) && last;\r\n                    var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\r\n                    var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\r\n                    add(left, fromPos.top, right - left, fromPos.bottom);\r\n                } else { // Multiple lines\r\n                    var topLeft, topRight, botLeft, botRight;\r\n                    if (ltr) {\r\n                        topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\r\n                        topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\r\n                        botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\r\n                        botRight = docLTR && openEnd && last ? rightSide : toPos.right;\r\n                    } else {\r\n                        topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\r\n                        topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\r\n                        botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\r\n                        botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\r\n                    }\r\n                    add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\r\n                    if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\r\n                    add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\r\n                }\r\n\r\n                if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\r\n                if (cmpCoords(toPos, start) < 0) { start = toPos; }\r\n                if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\r\n                if (cmpCoords(toPos, end) < 0) { end = toPos; }\r\n            });\r\n            return {start: start, end: end}\r\n        }\r\n\r\n        var sFrom = range$$1.from(), sTo = range$$1.to();\r\n        if (sFrom.line == sTo.line) {\r\n            drawForLine(sFrom.line, sFrom.ch, sTo.ch);\r\n        } else {\r\n            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\r\n            var singleVLine = visualLine(fromLine) == visualLine(toLine);\r\n            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\r\n            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\r\n            if (singleVLine) {\r\n                if (leftEnd.top < rightStart.top - 2) {\r\n                    add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\r\n                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\r\n                } else {\r\n                    add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\r\n                }\r\n            }\r\n            if (leftEnd.bottom < rightStart.top)\r\n            { add(leftSide, leftEnd.bottom, null, rightStart.top); }\r\n        }\r\n\r\n        output.appendChild(fragment);\r\n    }\r\n\r\n    // Cursor-blinking\r\n    function restartBlink(cm) {\r\n        if (!cm.state.focused) { return }\r\n        var display = cm.display;\r\n        clearInterval(display.blinker);\r\n        var on = true;\r\n        display.cursorDiv.style.visibility = \"\";\r\n        if (cm.options.cursorBlinkRate > 0)\r\n        { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\r\n            cm.options.cursorBlinkRate); }\r\n        else if (cm.options.cursorBlinkRate < 0)\r\n        { display.cursorDiv.style.visibility = \"hidden\"; }\r\n    }\r\n\r\n    function ensureFocus(cm) {\r\n        if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\r\n    }\r\n\r\n    function delayBlurEvent(cm) {\r\n        cm.state.delayingBlurEvent = true;\r\n        setTimeout(function () { if (cm.state.delayingBlurEvent) {\r\n            cm.state.delayingBlurEvent = false;\r\n            onBlur(cm);\r\n        } }, 100);\r\n    }\r\n\r\n    function onFocus(cm, e) {\r\n        if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\r\n\r\n        if (cm.options.readOnly == \"nocursor\") { return }\r\n        if (!cm.state.focused) {\r\n            signal(cm, \"focus\", cm, e);\r\n            cm.state.focused = true;\r\n            addClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n            // This test prevents this from firing when a context\r\n            // menu is closed (since the input reset would kill the\r\n            // select-all detection hack)\r\n            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\r\n                cm.display.input.reset();\r\n                if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\r\n            }\r\n            cm.display.input.receivedFocus();\r\n        }\r\n        restartBlink(cm);\r\n    }\r\n    function onBlur(cm, e) {\r\n        if (cm.state.delayingBlurEvent) { return }\r\n\r\n        if (cm.state.focused) {\r\n            signal(cm, \"blur\", cm, e);\r\n            cm.state.focused = false;\r\n            rmClass(cm.display.wrapper, \"CodeMirror-focused\");\r\n        }\r\n        clearInterval(cm.display.blinker);\r\n        setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\r\n    }\r\n\r\n    // Read the actual heights of the rendered lines, and update their\r\n    // stored heights to match.\r\n    function updateHeightsInViewport(cm) {\r\n        var display = cm.display;\r\n        var prevBottom = display.lineDiv.offsetTop;\r\n        for (var i = 0; i < display.view.length; i++) {\r\n            var cur = display.view[i], wrapping = cm.options.lineWrapping;\r\n            var height = (void 0), width = 0;\r\n            if (cur.hidden) { continue }\r\n            if (ie && ie_version < 8) {\r\n                var bot = cur.node.offsetTop + cur.node.offsetHeight;\r\n                height = bot - prevBottom;\r\n                prevBottom = bot;\r\n            } else {\r\n                var box = cur.node.getBoundingClientRect();\r\n                height = box.bottom - box.top;\r\n                // Check that lines don't extend past the right of the current\r\n                // editor width\r\n                if (!wrapping && cur.text.firstChild)\r\n                { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\r\n            }\r\n            var diff = cur.line.height - height;\r\n            if (height < 2) { height = textHeight(display); }\r\n            if (diff > .005 || diff < -.005) {\r\n                updateLineHeight(cur.line, height);\r\n                updateWidgetHeight(cur.line);\r\n                if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\r\n                { updateWidgetHeight(cur.rest[j]); } }\r\n            }\r\n            if (width > cm.display.sizerWidth) {\r\n                var chWidth = Math.ceil(width / charWidth(cm.display));\r\n                if (chWidth > cm.display.maxLineLength) {\r\n                    cm.display.maxLineLength = chWidth;\r\n                    cm.display.maxLine = cur.line;\r\n                    cm.display.maxLineChanged = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Read and store the height of line widgets associated with the\r\n    // given line.\r\n    function updateWidgetHeight(line) {\r\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\r\n            var w = line.widgets[i], parent = w.node.parentNode;\r\n            if (parent) { w.height = parent.offsetHeight; }\r\n        } }\r\n    }\r\n\r\n    // Compute the lines that are visible in a given viewport (defaults\r\n    // the the current scroll position). viewport may contain top,\r\n    // height, and ensure (see op.scrollToPos) properties.\r\n    function visibleLines(display, doc, viewport) {\r\n        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\r\n        top = Math.floor(top - paddingTop(display));\r\n        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\r\n\r\n        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\r\n        // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\r\n        // forces those lines into the viewport (if possible).\r\n        if (viewport && viewport.ensure) {\r\n            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\r\n            if (ensureFrom < from) {\r\n                from = ensureFrom;\r\n                to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\r\n            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\r\n                from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\r\n                to = ensureTo;\r\n            }\r\n        }\r\n        return {from: from, to: Math.max(to, from + 1)}\r\n    }\r\n\r\n    // Re-align line numbers and gutter marks to compensate for\r\n    // horizontal scrolling.\r\n    function alignHorizontally(cm) {\r\n        var display = cm.display, view = display.view;\r\n        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\r\n        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\r\n        var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\r\n        for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\r\n            if (cm.options.fixedGutter) {\r\n                if (view[i].gutter)\r\n                { view[i].gutter.style.left = left; }\r\n                if (view[i].gutterBackground)\r\n                { view[i].gutterBackground.style.left = left; }\r\n            }\r\n            var align = view[i].alignable;\r\n            if (align) { for (var j = 0; j < align.length; j++)\r\n            { align[j].style.left = left; } }\r\n        } }\r\n        if (cm.options.fixedGutter)\r\n        { display.gutters.style.left = (comp + gutterW) + \"px\"; }\r\n    }\r\n\r\n    // Used to ensure that the line number gutter is still the right\r\n    // size for the current document size. Returns true when an update\r\n    // is needed.\r\n    function maybeUpdateLineNumberWidth(cm) {\r\n        if (!cm.options.lineNumbers) { return false }\r\n        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\r\n        if (last.length != display.lineNumChars) {\r\n            var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\r\n                \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\r\n            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\r\n            display.lineGutter.style.width = \"\";\r\n            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\r\n            display.lineNumWidth = display.lineNumInnerWidth + padding;\r\n            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\r\n            display.lineGutter.style.width = display.lineNumWidth + \"px\";\r\n            updateGutterSpace(cm);\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    // SCROLLING THINGS INTO VIEW\r\n\r\n    // If an editor sits on the top or bottom of the window, partially\r\n    // scrolled out of view, this ensures that the cursor is visible.\r\n    function maybeScrollWindow(cm, rect) {\r\n        if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\r\n\r\n        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\r\n        if (rect.top + box.top < 0) { doScroll = true; }\r\n        else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\r\n        if (doScroll != null && !phantom) {\r\n            var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\r\n            cm.display.lineSpace.appendChild(scrollNode);\r\n            scrollNode.scrollIntoView(doScroll);\r\n            cm.display.lineSpace.removeChild(scrollNode);\r\n        }\r\n    }\r\n\r\n    // Scroll a given position into view (immediately), verifying that\r\n    // it actually became visible (as line heights are accurately\r\n    // measured, the position of something may 'drift' during drawing).\r\n    function scrollPosIntoView(cm, pos, end, margin) {\r\n        if (margin == null) { margin = 0; }\r\n        var rect;\r\n        if (!cm.options.lineWrapping && pos == end) {\r\n            // Set pos and end to the cursor positions around the character pos sticks to\r\n            // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\r\n            // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\r\n            pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\r\n            end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\r\n        }\r\n        for (var limit = 0; limit < 5; limit++) {\r\n            var changed = false;\r\n            var coords = cursorCoords(cm, pos);\r\n            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\r\n            rect = {left: Math.min(coords.left, endCoords.left),\r\n                top: Math.min(coords.top, endCoords.top) - margin,\r\n                right: Math.max(coords.left, endCoords.left),\r\n                bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\r\n            var scrollPos = calculateScrollPos(cm, rect);\r\n            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\r\n            if (scrollPos.scrollTop != null) {\r\n                updateScrollTop(cm, scrollPos.scrollTop);\r\n                if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\r\n            }\r\n            if (scrollPos.scrollLeft != null) {\r\n                setScrollLeft(cm, scrollPos.scrollLeft);\r\n                if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\r\n            }\r\n            if (!changed) { break }\r\n        }\r\n        return rect\r\n    }\r\n\r\n    // Scroll a given set of coordinates into view (immediately).\r\n    function scrollIntoView(cm, rect) {\r\n        var scrollPos = calculateScrollPos(cm, rect);\r\n        if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\r\n        if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\r\n    }\r\n\r\n    // Calculate a new scroll position needed to scroll the given\r\n    // rectangle into view. Returns an object with scrollTop and\r\n    // scrollLeft properties. When these are undefined, the\r\n    // vertical/horizontal position does not need to be adjusted.\r\n    function calculateScrollPos(cm, rect) {\r\n        var display = cm.display, snapMargin = textHeight(cm.display);\r\n        if (rect.top < 0) { rect.top = 0; }\r\n        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\r\n        var screen = displayHeight(cm), result = {};\r\n        if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\r\n        var docBottom = cm.doc.height + paddingVert(display);\r\n        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\r\n        if (rect.top < screentop) {\r\n            result.scrollTop = atTop ? 0 : rect.top;\r\n        } else if (rect.bottom > screentop + screen) {\r\n            var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\r\n            if (newTop != screentop) { result.scrollTop = newTop; }\r\n        }\r\n\r\n        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\r\n        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\r\n        var tooWide = rect.right - rect.left > screenw;\r\n        if (tooWide) { rect.right = rect.left + screenw; }\r\n        if (rect.left < 10)\r\n        { result.scrollLeft = 0; }\r\n        else if (rect.left < screenleft)\r\n        { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\r\n        else if (rect.right > screenw + screenleft - 3)\r\n        { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\r\n        return result\r\n    }\r\n\r\n    // Store a relative adjustment to the scroll position in the current\r\n    // operation (to be applied when the operation finishes).\r\n    function addToScrollTop(cm, top) {\r\n        if (top == null) { return }\r\n        resolveScrollToPos(cm);\r\n        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\r\n    }\r\n\r\n    // Make sure that at the end of the operation the current cursor is\r\n    // shown.\r\n    function ensureCursorVisible(cm) {\r\n        resolveScrollToPos(cm);\r\n        var cur = cm.getCursor();\r\n        cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\r\n    }\r\n\r\n    function scrollToCoords(cm, x, y) {\r\n        if (x != null || y != null) { resolveScrollToPos(cm); }\r\n        if (x != null) { cm.curOp.scrollLeft = x; }\r\n        if (y != null) { cm.curOp.scrollTop = y; }\r\n    }\r\n\r\n    function scrollToRange(cm, range$$1) {\r\n        resolveScrollToPos(cm);\r\n        cm.curOp.scrollToPos = range$$1;\r\n    }\r\n\r\n    // When an operation has its scrollToPos property set, and another\r\n    // scroll action is applied before the end of the operation, this\r\n    // 'simulates' scrolling that position into view in a cheap way, so\r\n    // that the effect of intermediate scroll commands is not ignored.\r\n    function resolveScrollToPos(cm) {\r\n        var range$$1 = cm.curOp.scrollToPos;\r\n        if (range$$1) {\r\n            cm.curOp.scrollToPos = null;\r\n            var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\r\n            scrollToCoordsRange(cm, from, to, range$$1.margin);\r\n        }\r\n    }\r\n\r\n    function scrollToCoordsRange(cm, from, to, margin) {\r\n        var sPos = calculateScrollPos(cm, {\r\n            left: Math.min(from.left, to.left),\r\n            top: Math.min(from.top, to.top) - margin,\r\n            right: Math.max(from.right, to.right),\r\n            bottom: Math.max(from.bottom, to.bottom) + margin\r\n        });\r\n        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\r\n    }\r\n\r\n    // Sync the scrollable area and scrollbars, ensure the viewport\r\n    // covers the visible area.\r\n    function updateScrollTop(cm, val) {\r\n        if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\r\n        if (!gecko) { updateDisplaySimple(cm, {top: val}); }\r\n        setScrollTop(cm, val, true);\r\n        if (gecko) { updateDisplaySimple(cm); }\r\n        startWorker(cm, 100);\r\n    }\r\n\r\n    function setScrollTop(cm, val, forceScroll) {\r\n        val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\r\n        if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\r\n        cm.doc.scrollTop = val;\r\n        cm.display.scrollbars.setScrollTop(val);\r\n        if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\r\n    }\r\n\r\n    // Sync scroller and scrollbar, ensure the gutter elements are\r\n    // aligned.\r\n    function setScrollLeft(cm, val, isScroller, forceScroll) {\r\n        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\r\n        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\r\n        cm.doc.scrollLeft = val;\r\n        alignHorizontally(cm);\r\n        if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\r\n        cm.display.scrollbars.setScrollLeft(val);\r\n    }\r\n\r\n    // SCROLLBARS\r\n\r\n    // Prepare DOM reads needed to update the scrollbars. Done in one\r\n    // shot to minimize update/measure roundtrips.\r\n    function measureForScrollbars(cm) {\r\n        var d = cm.display, gutterW = d.gutters.offsetWidth;\r\n        var docH = Math.round(cm.doc.height + paddingVert(cm.display));\r\n        return {\r\n            clientHeight: d.scroller.clientHeight,\r\n            viewHeight: d.wrapper.clientHeight,\r\n            scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\r\n            viewWidth: d.wrapper.clientWidth,\r\n            barLeft: cm.options.fixedGutter ? gutterW : 0,\r\n            docHeight: docH,\r\n            scrollHeight: docH + scrollGap(cm) + d.barHeight,\r\n            nativeBarWidth: d.nativeBarWidth,\r\n            gutterWidth: gutterW\r\n        }\r\n    }\r\n\r\n    var NativeScrollbars = function(place, scroll, cm) {\r\n        this.cm = cm;\r\n        var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\r\n        var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\r\n        vert.tabIndex = horiz.tabIndex = -1;\r\n        place(vert); place(horiz);\r\n\r\n        on(vert, \"scroll\", function () {\r\n            if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\r\n        });\r\n        on(horiz, \"scroll\", function () {\r\n            if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\r\n        });\r\n\r\n        this.checkedZeroWidth = false;\r\n        // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\r\n        if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\r\n    };\r\n\r\n    NativeScrollbars.prototype.update = function (measure) {\r\n        var needsH = measure.scrollWidth > measure.clientWidth + 1;\r\n        var needsV = measure.scrollHeight > measure.clientHeight + 1;\r\n        var sWidth = measure.nativeBarWidth;\r\n\r\n        if (needsV) {\r\n            this.vert.style.display = \"block\";\r\n            this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\r\n            var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\r\n            // A bug in IE8 can cause this value to be negative, so guard it.\r\n            this.vert.firstChild.style.height =\r\n                Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\r\n        } else {\r\n            this.vert.style.display = \"\";\r\n            this.vert.firstChild.style.height = \"0\";\r\n        }\r\n\r\n        if (needsH) {\r\n            this.horiz.style.display = \"block\";\r\n            this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\r\n            this.horiz.style.left = measure.barLeft + \"px\";\r\n            var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\r\n            this.horiz.firstChild.style.width =\r\n                Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\r\n        } else {\r\n            this.horiz.style.display = \"\";\r\n            this.horiz.firstChild.style.width = \"0\";\r\n        }\r\n\r\n        if (!this.checkedZeroWidth && measure.clientHeight > 0) {\r\n            if (sWidth == 0) { this.zeroWidthHack(); }\r\n            this.checkedZeroWidth = true;\r\n        }\r\n\r\n        return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\r\n    };\r\n\r\n    NativeScrollbars.prototype.setScrollLeft = function (pos) {\r\n        if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\r\n        if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\r\n    };\r\n\r\n    NativeScrollbars.prototype.setScrollTop = function (pos) {\r\n        if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\r\n        if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\r\n    };\r\n\r\n    NativeScrollbars.prototype.zeroWidthHack = function () {\r\n        var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\r\n        this.horiz.style.height = this.vert.style.width = w;\r\n        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\r\n        this.disableHoriz = new Delayed;\r\n        this.disableVert = new Delayed;\r\n    };\r\n\r\n    NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\r\n        bar.style.pointerEvents = \"auto\";\r\n        function maybeDisable() {\r\n            // To find out whether the scrollbar is still visible, we\r\n            // check whether the element under the pixel in the bottom\r\n            // right corner of the scrollbar box is the scrollbar box\r\n            // itself (when the bar is still visible) or its filler child\r\n            // (when the bar is hidden). If it is still visible, we keep\r\n            // it enabled, if it's hidden, we disable pointer events.\r\n            var box = bar.getBoundingClientRect();\r\n            var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\r\n                : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\r\n            if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\r\n            else { delay.set(1000, maybeDisable); }\r\n        }\r\n        delay.set(1000, maybeDisable);\r\n    };\r\n\r\n    NativeScrollbars.prototype.clear = function () {\r\n        var parent = this.horiz.parentNode;\r\n        parent.removeChild(this.horiz);\r\n        parent.removeChild(this.vert);\r\n    };\r\n\r\n    var NullScrollbars = function () {};\r\n\r\n    NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\r\n    NullScrollbars.prototype.setScrollLeft = function () {};\r\n    NullScrollbars.prototype.setScrollTop = function () {};\r\n    NullScrollbars.prototype.clear = function () {};\r\n\r\n    function updateScrollbars(cm, measure) {\r\n        if (!measure) { measure = measureForScrollbars(cm); }\r\n        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\r\n        updateScrollbarsInner(cm, measure);\r\n        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\r\n            if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\r\n            { updateHeightsInViewport(cm); }\r\n            updateScrollbarsInner(cm, measureForScrollbars(cm));\r\n            startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\r\n        }\r\n    }\r\n\r\n    // Re-synchronize the fake scrollbars with the actual size of the\r\n    // content.\r\n    function updateScrollbarsInner(cm, measure) {\r\n        var d = cm.display;\r\n        var sizes = d.scrollbars.update(measure);\r\n\r\n        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\r\n        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\r\n        d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\r\n\r\n        if (sizes.right && sizes.bottom) {\r\n            d.scrollbarFiller.style.display = \"block\";\r\n            d.scrollbarFiller.style.height = sizes.bottom + \"px\";\r\n            d.scrollbarFiller.style.width = sizes.right + \"px\";\r\n        } else { d.scrollbarFiller.style.display = \"\"; }\r\n        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\r\n            d.gutterFiller.style.display = \"block\";\r\n            d.gutterFiller.style.height = sizes.bottom + \"px\";\r\n            d.gutterFiller.style.width = measure.gutterWidth + \"px\";\r\n        } else { d.gutterFiller.style.display = \"\"; }\r\n    }\r\n\r\n    var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\r\n\r\n    function initScrollbars(cm) {\r\n        if (cm.display.scrollbars) {\r\n            cm.display.scrollbars.clear();\r\n            if (cm.display.scrollbars.addClass)\r\n            { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\r\n        }\r\n\r\n        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\r\n            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\r\n            // Prevent clicks in the scrollbars from killing focus\r\n            on(node, \"mousedown\", function () {\r\n                if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\r\n            });\r\n            node.setAttribute(\"cm-not-content\", \"true\");\r\n        }, function (pos, axis) {\r\n            if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\r\n            else { updateScrollTop(cm, pos); }\r\n        }, cm);\r\n        if (cm.display.scrollbars.addClass)\r\n        { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\r\n    }\r\n\r\n    // Operations are used to wrap a series of changes to the editor\r\n    // state in such a way that each change won't have to update the\r\n    // cursor and display (which would be awkward, slow, and\r\n    // error-prone). Instead, display updates are batched and then all\r\n    // combined and executed at once.\r\n\r\n    var nextOpId = 0;\r\n    // Start a new operation.\r\n    function startOperation(cm) {\r\n        cm.curOp = {\r\n            cm: cm,\r\n            viewChanged: false,      // Flag that indicates that lines might need to be redrawn\r\n            startHeight: cm.doc.height, // Used to detect need to update scrollbar\r\n            forceUpdate: false,      // Used to force a redraw\r\n            updateInput: 0,       // Whether to reset the input textarea\r\n            typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\r\n            changeObjs: null,        // Accumulated changes, for firing change events\r\n            cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\r\n            cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\r\n            selectionChanged: false, // Whether the selection needs to be redrawn\r\n            updateMaxLine: false,    // Set when the widest line needs to be determined anew\r\n            scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\r\n            scrollToPos: null,       // Used to scroll to a specific position\r\n            focus: false,\r\n            id: ++nextOpId           // Unique ID\r\n        };\r\n        pushOperation(cm.curOp);\r\n    }\r\n\r\n    // Finish an operation, updating the display and signalling delayed events\r\n    function endOperation(cm) {\r\n        var op = cm.curOp;\r\n        if (op) { finishOperation(op, function (group) {\r\n            for (var i = 0; i < group.ops.length; i++)\r\n            { group.ops[i].cm.curOp = null; }\r\n            endOperations(group);\r\n        }); }\r\n    }\r\n\r\n    // The DOM updates done when an operation finishes are batched so\r\n    // that the minimum number of relayouts are required.\r\n    function endOperations(group) {\r\n        var ops = group.ops;\r\n        for (var i = 0; i < ops.length; i++) // Read DOM\r\n        { endOperation_R1(ops[i]); }\r\n        for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\r\n        { endOperation_W1(ops[i$1]); }\r\n        for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\r\n        { endOperation_R2(ops[i$2]); }\r\n        for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\r\n        { endOperation_W2(ops[i$3]); }\r\n        for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\r\n        { endOperation_finish(ops[i$4]); }\r\n    }\r\n\r\n    function endOperation_R1(op) {\r\n        var cm = op.cm, display = cm.display;\r\n        maybeClipScrollbars(cm);\r\n        if (op.updateMaxLine) { findMaxLine(cm); }\r\n\r\n        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\r\n            op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\r\n                op.scrollToPos.to.line >= display.viewTo) ||\r\n            display.maxLineChanged && cm.options.lineWrapping;\r\n        op.update = op.mustUpdate &&\r\n            new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\r\n    }\r\n\r\n    function endOperation_W1(op) {\r\n        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\r\n    }\r\n\r\n    function endOperation_R2(op) {\r\n        var cm = op.cm, display = cm.display;\r\n        if (op.updatedDisplay) { updateHeightsInViewport(cm); }\r\n\r\n        op.barMeasure = measureForScrollbars(cm);\r\n\r\n        // If the max line changed since it was last measured, measure it,\r\n        // and ensure the document's width matches it.\r\n        // updateDisplay_W2 will use these properties to do the actual resizing\r\n        if (display.maxLineChanged && !cm.options.lineWrapping) {\r\n            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\r\n            cm.display.sizerWidth = op.adjustWidthTo;\r\n            op.barMeasure.scrollWidth =\r\n                Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\r\n            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\r\n        }\r\n\r\n        if (op.updatedDisplay || op.selectionChanged)\r\n        { op.preparedSelection = display.input.prepareSelection(); }\r\n    }\r\n\r\n    function endOperation_W2(op) {\r\n        var cm = op.cm;\r\n\r\n        if (op.adjustWidthTo != null) {\r\n            cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\r\n            if (op.maxScrollLeft < cm.doc.scrollLeft)\r\n            { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\r\n            cm.display.maxLineChanged = false;\r\n        }\r\n\r\n        var takeFocus = op.focus && op.focus == activeElt();\r\n        if (op.preparedSelection)\r\n        { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\r\n        if (op.updatedDisplay || op.startHeight != cm.doc.height)\r\n        { updateScrollbars(cm, op.barMeasure); }\r\n        if (op.updatedDisplay)\r\n        { setDocumentHeight(cm, op.barMeasure); }\r\n\r\n        if (op.selectionChanged) { restartBlink(cm); }\r\n\r\n        if (cm.state.focused && op.updateInput)\r\n        { cm.display.input.reset(op.typing); }\r\n        if (takeFocus) { ensureFocus(op.cm); }\r\n    }\r\n\r\n    function endOperation_finish(op) {\r\n        var cm = op.cm, display = cm.display, doc = cm.doc;\r\n\r\n        if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\r\n\r\n        // Abort mouse wheel delta measurement, when scrolling explicitly\r\n        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\r\n        { display.wheelStartX = display.wheelStartY = null; }\r\n\r\n        // Propagate the scroll position to the actual DOM scroller\r\n        if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\r\n\r\n        if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\r\n        // If we need to scroll a specific position into view, do so.\r\n        if (op.scrollToPos) {\r\n            var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\r\n                clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\r\n            maybeScrollWindow(cm, rect);\r\n        }\r\n\r\n        // Fire events for markers that are hidden/unidden by editing or\r\n        // undoing\r\n        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\r\n        if (hidden) { for (var i = 0; i < hidden.length; ++i)\r\n        { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\r\n        if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\r\n        { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\r\n\r\n        if (display.wrapper.offsetHeight)\r\n        { doc.scrollTop = cm.display.scroller.scrollTop; }\r\n\r\n        // Fire change events, and delayed event handlers\r\n        if (op.changeObjs)\r\n        { signal(cm, \"changes\", cm, op.changeObjs); }\r\n        if (op.update)\r\n        { op.update.finish(); }\r\n    }\r\n\r\n    // Run the given function in an operation\r\n    function runInOp(cm, f) {\r\n        if (cm.curOp) { return f() }\r\n        startOperation(cm);\r\n        try { return f() }\r\n        finally { endOperation(cm); }\r\n    }\r\n    // Wraps a function in an operation. Returns the wrapped function.\r\n    function operation(cm, f) {\r\n        return function() {\r\n            if (cm.curOp) { return f.apply(cm, arguments) }\r\n            startOperation(cm);\r\n            try { return f.apply(cm, arguments) }\r\n            finally { endOperation(cm); }\r\n        }\r\n    }\r\n    // Used to add methods to editor and doc instances, wrapping them in\r\n    // operations.\r\n    function methodOp(f) {\r\n        return function() {\r\n            if (this.curOp) { return f.apply(this, arguments) }\r\n            startOperation(this);\r\n            try { return f.apply(this, arguments) }\r\n            finally { endOperation(this); }\r\n        }\r\n    }\r\n    function docMethodOp(f) {\r\n        return function() {\r\n            var cm = this.cm;\r\n            if (!cm || cm.curOp) { return f.apply(this, arguments) }\r\n            startOperation(cm);\r\n            try { return f.apply(this, arguments) }\r\n            finally { endOperation(cm); }\r\n        }\r\n    }\r\n\r\n    // Updates the display.view data structure for a given change to the\r\n    // document. From and to are in pre-change coordinates. Lendiff is\r\n    // the amount of lines added or subtracted by the change. This is\r\n    // used for changes that span multiple lines, or change the way\r\n    // lines are divided into visual lines. regLineChange (below)\r\n    // registers single-line changes.\r\n    function regChange(cm, from, to, lendiff) {\r\n        if (from == null) { from = cm.doc.first; }\r\n        if (to == null) { to = cm.doc.first + cm.doc.size; }\r\n        if (!lendiff) { lendiff = 0; }\r\n\r\n        var display = cm.display;\r\n        if (lendiff && to < display.viewTo &&\r\n            (display.updateLineNumbers == null || display.updateLineNumbers > from))\r\n        { display.updateLineNumbers = from; }\r\n\r\n        cm.curOp.viewChanged = true;\r\n\r\n        if (from >= display.viewTo) { // Change after\r\n            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\r\n            { resetView(cm); }\r\n        } else if (to <= display.viewFrom) { // Change before\r\n            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\r\n                resetView(cm);\r\n            } else {\r\n                display.viewFrom += lendiff;\r\n                display.viewTo += lendiff;\r\n            }\r\n        } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\r\n            resetView(cm);\r\n        } else if (from <= display.viewFrom) { // Top overlap\r\n            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n            if (cut) {\r\n                display.view = display.view.slice(cut.index);\r\n                display.viewFrom = cut.lineN;\r\n                display.viewTo += lendiff;\r\n            } else {\r\n                resetView(cm);\r\n            }\r\n        } else if (to >= display.viewTo) { // Bottom overlap\r\n            var cut$1 = viewCuttingPoint(cm, from, from, -1);\r\n            if (cut$1) {\r\n                display.view = display.view.slice(0, cut$1.index);\r\n                display.viewTo = cut$1.lineN;\r\n            } else {\r\n                resetView(cm);\r\n            }\r\n        } else { // Gap in the middle\r\n            var cutTop = viewCuttingPoint(cm, from, from, -1);\r\n            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n            if (cutTop && cutBot) {\r\n                display.view = display.view.slice(0, cutTop.index)\r\n                    .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\r\n                    .concat(display.view.slice(cutBot.index));\r\n                display.viewTo += lendiff;\r\n            } else {\r\n                resetView(cm);\r\n            }\r\n        }\r\n\r\n        var ext = display.externalMeasured;\r\n        if (ext) {\r\n            if (to < ext.lineN)\r\n            { ext.lineN += lendiff; }\r\n            else if (from < ext.lineN + ext.size)\r\n            { display.externalMeasured = null; }\r\n        }\r\n    }\r\n\r\n    // Register a change to a single line. Type must be one of \"text\",\r\n    // \"gutter\", \"class\", \"widget\"\r\n    function regLineChange(cm, line, type) {\r\n        cm.curOp.viewChanged = true;\r\n        var display = cm.display, ext = cm.display.externalMeasured;\r\n        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\r\n        { display.externalMeasured = null; }\r\n\r\n        if (line < display.viewFrom || line >= display.viewTo) { return }\r\n        var lineView = display.view[findViewIndex(cm, line)];\r\n        if (lineView.node == null) { return }\r\n        var arr = lineView.changes || (lineView.changes = []);\r\n        if (indexOf(arr, type) == -1) { arr.push(type); }\r\n    }\r\n\r\n    // Clear the view.\r\n    function resetView(cm) {\r\n        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\r\n        cm.display.view = [];\r\n        cm.display.viewOffset = 0;\r\n    }\r\n\r\n    function viewCuttingPoint(cm, oldN, newN, dir) {\r\n        var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\r\n        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\r\n        { return {index: index, lineN: newN} }\r\n        var n = cm.display.viewFrom;\r\n        for (var i = 0; i < index; i++)\r\n        { n += view[i].size; }\r\n        if (n != oldN) {\r\n            if (dir > 0) {\r\n                if (index == view.length - 1) { return null }\r\n                diff = (n + view[index].size) - oldN;\r\n                index++;\r\n            } else {\r\n                diff = n - oldN;\r\n            }\r\n            oldN += diff; newN += diff;\r\n        }\r\n        while (visualLineNo(cm.doc, newN) != newN) {\r\n            if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\r\n            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\r\n            index += dir;\r\n        }\r\n        return {index: index, lineN: newN}\r\n    }\r\n\r\n    // Force the view to cover a given range, adding empty view element\r\n    // or clipping off existing ones as needed.\r\n    function adjustView(cm, from, to) {\r\n        var display = cm.display, view = display.view;\r\n        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\r\n            display.view = buildViewArray(cm, from, to);\r\n            display.viewFrom = from;\r\n        } else {\r\n            if (display.viewFrom > from)\r\n            { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\r\n            else if (display.viewFrom < from)\r\n            { display.view = display.view.slice(findViewIndex(cm, from)); }\r\n            display.viewFrom = from;\r\n            if (display.viewTo < to)\r\n            { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\r\n            else if (display.viewTo > to)\r\n            { display.view = display.view.slice(0, findViewIndex(cm, to)); }\r\n        }\r\n        display.viewTo = to;\r\n    }\r\n\r\n    // Count the number of lines in the view whose DOM representation is\r\n    // out of date (or nonexistent).\r\n    function countDirtyView(cm) {\r\n        var view = cm.display.view, dirty = 0;\r\n        for (var i = 0; i < view.length; i++) {\r\n            var lineView = view[i];\r\n            if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\r\n        }\r\n        return dirty\r\n    }\r\n\r\n    // HIGHLIGHT WORKER\r\n\r\n    function startWorker(cm, time) {\r\n        if (cm.doc.highlightFrontier < cm.display.viewTo)\r\n        { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\r\n    }\r\n\r\n    function highlightWorker(cm) {\r\n        var doc = cm.doc;\r\n        if (doc.highlightFrontier >= cm.display.viewTo) { return }\r\n        var end = +new Date + cm.options.workTime;\r\n        var context = getContextBefore(cm, doc.highlightFrontier);\r\n        var changedLines = [];\r\n\r\n        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\r\n            if (context.line >= cm.display.viewFrom) { // Visible\r\n                var oldStyles = line.styles;\r\n                var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\r\n                var highlighted = highlightLine(cm, line, context, true);\r\n                if (resetState) { context.state = resetState; }\r\n                line.styles = highlighted.styles;\r\n                var oldCls = line.styleClasses, newCls = highlighted.classes;\r\n                if (newCls) { line.styleClasses = newCls; }\r\n                else if (oldCls) { line.styleClasses = null; }\r\n                var ischange = !oldStyles || oldStyles.length != line.styles.length ||\r\n                    oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\r\n                for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\r\n                if (ischange) { changedLines.push(context.line); }\r\n                line.stateAfter = context.save();\r\n                context.nextLine();\r\n            } else {\r\n                if (line.text.length <= cm.options.maxHighlightLength)\r\n                { processLine(cm, line.text, context); }\r\n                line.stateAfter = context.line % 5 == 0 ? context.save() : null;\r\n                context.nextLine();\r\n            }\r\n            if (+new Date > end) {\r\n                startWorker(cm, cm.options.workDelay);\r\n                return true\r\n            }\r\n        });\r\n        doc.highlightFrontier = context.line;\r\n        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\r\n        if (changedLines.length) { runInOp(cm, function () {\r\n            for (var i = 0; i < changedLines.length; i++)\r\n            { regLineChange(cm, changedLines[i], \"text\"); }\r\n        }); }\r\n    }\r\n\r\n    // DISPLAY DRAWING\r\n\r\n    var DisplayUpdate = function(cm, viewport, force) {\r\n        var display = cm.display;\r\n\r\n        this.viewport = viewport;\r\n        // Store some values that we'll need later (but don't want to force a relayout for)\r\n        this.visible = visibleLines(display, cm.doc, viewport);\r\n        this.editorIsHidden = !display.wrapper.offsetWidth;\r\n        this.wrapperHeight = display.wrapper.clientHeight;\r\n        this.wrapperWidth = display.wrapper.clientWidth;\r\n        this.oldDisplayWidth = displayWidth(cm);\r\n        this.force = force;\r\n        this.dims = getDimensions(cm);\r\n        this.events = [];\r\n    };\r\n\r\n    DisplayUpdate.prototype.signal = function (emitter, type) {\r\n        if (hasHandler(emitter, type))\r\n        { this.events.push(arguments); }\r\n    };\r\n    DisplayUpdate.prototype.finish = function () {\r\n        for (var i = 0; i < this.events.length; i++)\r\n        { signal.apply(null, this.events[i]); }\r\n    };\r\n\r\n    function maybeClipScrollbars(cm) {\r\n        var display = cm.display;\r\n        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\r\n            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\r\n            display.heightForcer.style.height = scrollGap(cm) + \"px\";\r\n            display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\r\n            display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\r\n            display.scrollbarsClipped = true;\r\n        }\r\n    }\r\n\r\n    function selectionSnapshot(cm) {\r\n        if (cm.hasFocus()) { return null }\r\n        var active = activeElt();\r\n        if (!active || !contains(cm.display.lineDiv, active)) { return null }\r\n        var result = {activeElt: active};\r\n        if (window.getSelection) {\r\n            var sel = window.getSelection();\r\n            if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\r\n                result.anchorNode = sel.anchorNode;\r\n                result.anchorOffset = sel.anchorOffset;\r\n                result.focusNode = sel.focusNode;\r\n                result.focusOffset = sel.focusOffset;\r\n            }\r\n        }\r\n        return result\r\n    }\r\n\r\n    function restoreSelection(snapshot) {\r\n        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\r\n        snapshot.activeElt.focus();\r\n        if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\r\n            var sel = window.getSelection(), range$$1 = document.createRange();\r\n            range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\r\n            range$$1.collapse(false);\r\n            sel.removeAllRanges();\r\n            sel.addRange(range$$1);\r\n            sel.extend(snapshot.focusNode, snapshot.focusOffset);\r\n        }\r\n    }\r\n\r\n    // Does the actual updating of the line display. Bails out\r\n    // (returning false) when there is nothing to be done and forced is\r\n    // false.\r\n    function updateDisplayIfNeeded(cm, update) {\r\n        var display = cm.display, doc = cm.doc;\r\n\r\n        if (update.editorIsHidden) {\r\n            resetView(cm);\r\n            return false\r\n        }\r\n\r\n        // Bail out if the visible area is already rendered and nothing changed.\r\n        if (!update.force &&\r\n            update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\r\n            (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\r\n            display.renderedView == display.view && countDirtyView(cm) == 0)\r\n        { return false }\r\n\r\n        if (maybeUpdateLineNumberWidth(cm)) {\r\n            resetView(cm);\r\n            update.dims = getDimensions(cm);\r\n        }\r\n\r\n        // Compute a suitable new viewport (from & to)\r\n        var end = doc.first + doc.size;\r\n        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\r\n        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\r\n        if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\r\n        if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\r\n        if (sawCollapsedSpans) {\r\n            from = visualLineNo(cm.doc, from);\r\n            to = visualLineEndNo(cm.doc, to);\r\n        }\r\n\r\n        var different = from != display.viewFrom || to != display.viewTo ||\r\n            display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\r\n        adjustView(cm, from, to);\r\n\r\n        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\r\n        // Position the mover div to align with the current scroll position\r\n        cm.display.mover.style.top = display.viewOffset + \"px\";\r\n\r\n        var toUpdate = countDirtyView(cm);\r\n        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\r\n            (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\r\n        { return false }\r\n\r\n        // For big changes, we hide the enclosing element during the\r\n        // update, since that speeds up the operations on most browsers.\r\n        var selSnapshot = selectionSnapshot(cm);\r\n        if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\r\n        patchDisplay(cm, display.updateLineNumbers, update.dims);\r\n        if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\r\n        display.renderedView = display.view;\r\n        // There might have been a widget with a focused element that got\r\n        // hidden or updated, if so re-focus it.\r\n        restoreSelection(selSnapshot);\r\n\r\n        // Prevent selection and cursors from interfering with the scroll\r\n        // width and height.\r\n        removeChildren(display.cursorDiv);\r\n        removeChildren(display.selectionDiv);\r\n        display.gutters.style.height = display.sizer.style.minHeight = 0;\r\n\r\n        if (different) {\r\n            display.lastWrapHeight = update.wrapperHeight;\r\n            display.lastWrapWidth = update.wrapperWidth;\r\n            startWorker(cm, 400);\r\n        }\r\n\r\n        display.updateLineNumbers = null;\r\n\r\n        return true\r\n    }\r\n\r\n    function postUpdateDisplay(cm, update) {\r\n        var viewport = update.viewport;\r\n\r\n        for (var first = true;; first = false) {\r\n            if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\r\n                // Clip forced viewport to actual scrollable area.\r\n                if (viewport && viewport.top != null)\r\n                { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\r\n                // Updated line heights might result in the drawn area not\r\n                // actually covering the viewport. Keep looping until it does.\r\n                update.visible = visibleLines(cm.display, cm.doc, viewport);\r\n                if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\r\n                { break }\r\n            }\r\n            if (!updateDisplayIfNeeded(cm, update)) { break }\r\n            updateHeightsInViewport(cm);\r\n            var barMeasure = measureForScrollbars(cm);\r\n            updateSelection(cm);\r\n            updateScrollbars(cm, barMeasure);\r\n            setDocumentHeight(cm, barMeasure);\r\n            update.force = false;\r\n        }\r\n\r\n        update.signal(cm, \"update\", cm);\r\n        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\r\n            update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\r\n            cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\r\n        }\r\n    }\r\n\r\n    function updateDisplaySimple(cm, viewport) {\r\n        var update = new DisplayUpdate(cm, viewport);\r\n        if (updateDisplayIfNeeded(cm, update)) {\r\n            updateHeightsInViewport(cm);\r\n            postUpdateDisplay(cm, update);\r\n            var barMeasure = measureForScrollbars(cm);\r\n            updateSelection(cm);\r\n            updateScrollbars(cm, barMeasure);\r\n            setDocumentHeight(cm, barMeasure);\r\n            update.finish();\r\n        }\r\n    }\r\n\r\n    // Sync the actual display DOM structure with display.view, removing\r\n    // nodes for lines that are no longer in view, and creating the ones\r\n    // that are not there yet, and updating the ones that are out of\r\n    // date.\r\n    function patchDisplay(cm, updateNumbersFrom, dims) {\r\n        var display = cm.display, lineNumbers = cm.options.lineNumbers;\r\n        var container = display.lineDiv, cur = container.firstChild;\r\n\r\n        function rm(node) {\r\n            var next = node.nextSibling;\r\n            // Works around a throw-scroll bug in OS X Webkit\r\n            if (webkit && mac && cm.display.currentWheelTarget == node)\r\n            { node.style.display = \"none\"; }\r\n            else\r\n            { node.parentNode.removeChild(node); }\r\n            return next\r\n        }\r\n\r\n        var view = display.view, lineN = display.viewFrom;\r\n        // Loop over the elements in the view, syncing cur (the DOM nodes\r\n        // in display.lineDiv) with the view as we go.\r\n        for (var i = 0; i < view.length; i++) {\r\n            var lineView = view[i];\r\n            if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\r\n                var node = buildLineElement(cm, lineView, lineN, dims);\r\n                container.insertBefore(node, cur);\r\n            } else { // Already drawn\r\n                while (cur != lineView.node) { cur = rm(cur); }\r\n                var updateNumber = lineNumbers && updateNumbersFrom != null &&\r\n                    updateNumbersFrom <= lineN && lineView.lineNumber;\r\n                if (lineView.changes) {\r\n                    if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\r\n                    updateLineForChanges(cm, lineView, lineN, dims);\r\n                }\r\n                if (updateNumber) {\r\n                    removeChildren(lineView.lineNumber);\r\n                    lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\r\n                }\r\n                cur = lineView.node.nextSibling;\r\n            }\r\n            lineN += lineView.size;\r\n        }\r\n        while (cur) { cur = rm(cur); }\r\n    }\r\n\r\n    function updateGutterSpace(cm) {\r\n        var width = cm.display.gutters.offsetWidth;\r\n        cm.display.sizer.style.marginLeft = width + \"px\";\r\n    }\r\n\r\n    function setDocumentHeight(cm, measure) {\r\n        cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\r\n        cm.display.heightForcer.style.top = measure.docHeight + \"px\";\r\n        cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\r\n    }\r\n\r\n    // Rebuild the gutter elements, ensure the margin to the left of the\r\n    // code matches their width.\r\n    function updateGutters(cm) {\r\n        var gutters = cm.display.gutters, specs = cm.options.gutters;\r\n        removeChildren(gutters);\r\n        var i = 0;\r\n        for (; i < specs.length; ++i) {\r\n            var gutterClass = specs[i];\r\n            var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\r\n            if (gutterClass == \"CodeMirror-linenumbers\") {\r\n                cm.display.lineGutter = gElt;\r\n                gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\r\n            }\r\n        }\r\n        gutters.style.display = i ? \"\" : \"none\";\r\n        updateGutterSpace(cm);\r\n    }\r\n\r\n    // Make sure the gutters options contains the element\r\n    // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\r\n    function setGuttersForLineNumbers(options) {\r\n        var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\r\n        if (found == -1 && options.lineNumbers) {\r\n            options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\r\n        } else if (found > -1 && !options.lineNumbers) {\r\n            options.gutters = options.gutters.slice(0);\r\n            options.gutters.splice(found, 1);\r\n        }\r\n    }\r\n\r\n    // Since the delta values reported on mouse wheel events are\r\n    // unstandardized between browsers and even browser versions, and\r\n    // generally horribly unpredictable, this code starts by measuring\r\n    // the scroll effect that the first few mouse wheel events have,\r\n    // and, from that, detects the way it can convert deltas to pixel\r\n    // offsets afterwards.\r\n    //\r\n    // The reason we want to know the amount a wheel event will scroll\r\n    // is that it gives us a chance to update the display before the\r\n    // actual scrolling happens, reducing flickering.\r\n\r\n    var wheelSamples = 0, wheelPixelsPerUnit = null;\r\n    // Fill in a browser-detected starting value on browsers where we\r\n    // know one. These don't have to be accurate -- the result of them\r\n    // being wrong would just be a slight flicker on the first wheel\r\n    // scroll (if it is large enough).\r\n    if (ie) { wheelPixelsPerUnit = -.53; }\r\n    else if (gecko) { wheelPixelsPerUnit = 15; }\r\n    else if (chrome) { wheelPixelsPerUnit = -.7; }\r\n    else if (safari) { wheelPixelsPerUnit = -1/3; }\r\n\r\n    function wheelEventDelta(e) {\r\n        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\r\n        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\r\n        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\r\n        else if (dy == null) { dy = e.wheelDelta; }\r\n        return {x: dx, y: dy}\r\n    }\r\n    function wheelEventPixels(e) {\r\n        var delta = wheelEventDelta(e);\r\n        delta.x *= wheelPixelsPerUnit;\r\n        delta.y *= wheelPixelsPerUnit;\r\n        return delta\r\n    }\r\n\r\n    function onScrollWheel(cm, e) {\r\n        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\r\n\r\n        var display = cm.display, scroll = display.scroller;\r\n        // Quit if there's nothing to scroll here\r\n        var canScrollX = scroll.scrollWidth > scroll.clientWidth;\r\n        var canScrollY = scroll.scrollHeight > scroll.clientHeight;\r\n        if (!(dx && canScrollX || dy && canScrollY)) { return }\r\n\r\n        // Webkit browsers on OS X abort momentum scrolls when the target\r\n        // of the scroll event is removed from the scrollable element.\r\n        // This hack (see related code in patchDisplay) makes sure the\r\n        // element is kept around.\r\n        if (dy && mac && webkit) {\r\n            outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\r\n                for (var i = 0; i < view.length; i++) {\r\n                    if (view[i].node == cur) {\r\n                        cm.display.currentWheelTarget = cur;\r\n                        break outer\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // On some browsers, horizontal scrolling will cause redraws to\r\n        // happen before the gutter has been realigned, causing it to\r\n        // wriggle around in a most unseemly way. When we have an\r\n        // estimated pixels/delta value, we just handle horizontal\r\n        // scrolling entirely here. It'll be slightly off from native, but\r\n        // better than glitching out.\r\n        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\r\n            if (dy && canScrollY)\r\n            { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\r\n            setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\r\n            // Only prevent default scrolling if vertical scrolling is\r\n            // actually possible. Otherwise, it causes vertical scroll\r\n            // jitter on OSX trackpads when deltaX is small and deltaY\r\n            // is large (issue #3579)\r\n            if (!dy || (dy && canScrollY))\r\n            { e_preventDefault(e); }\r\n            display.wheelStartX = null; // Abort measurement, if in progress\r\n            return\r\n        }\r\n\r\n        // 'Project' the visible viewport to cover the area that is being\r\n        // scrolled into view (if we know enough to estimate it).\r\n        if (dy && wheelPixelsPerUnit != null) {\r\n            var pixels = dy * wheelPixelsPerUnit;\r\n            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\r\n            if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\r\n            else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\r\n            updateDisplaySimple(cm, {top: top, bottom: bot});\r\n        }\r\n\r\n        if (wheelSamples < 20) {\r\n            if (display.wheelStartX == null) {\r\n                display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\r\n                display.wheelDX = dx; display.wheelDY = dy;\r\n                setTimeout(function () {\r\n                    if (display.wheelStartX == null) { return }\r\n                    var movedX = scroll.scrollLeft - display.wheelStartX;\r\n                    var movedY = scroll.scrollTop - display.wheelStartY;\r\n                    var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\r\n                        (movedX && display.wheelDX && movedX / display.wheelDX);\r\n                    display.wheelStartX = display.wheelStartY = null;\r\n                    if (!sample) { return }\r\n                    wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\r\n                    ++wheelSamples;\r\n                }, 200);\r\n            } else {\r\n                display.wheelDX += dx; display.wheelDY += dy;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Selection objects are immutable. A new one is created every time\r\n    // the selection changes. A selection is one or more non-overlapping\r\n    // (and non-touching) ranges, sorted, and an integer that indicates\r\n    // which one is the primary selection (the one that's scrolled into\r\n    // view, that getCursor returns, etc).\r\n    var Selection = function(ranges, primIndex) {\r\n        this.ranges = ranges;\r\n        this.primIndex = primIndex;\r\n    };\r\n\r\n    Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\r\n\r\n    Selection.prototype.equals = function (other) {\r\n        if (other == this) { return true }\r\n        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\r\n        for (var i = 0; i < this.ranges.length; i++) {\r\n            var here = this.ranges[i], there = other.ranges[i];\r\n            if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\r\n        }\r\n        return true\r\n    };\r\n\r\n    Selection.prototype.deepCopy = function () {\r\n        var out = [];\r\n        for (var i = 0; i < this.ranges.length; i++)\r\n        { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\r\n        return new Selection(out, this.primIndex)\r\n    };\r\n\r\n    Selection.prototype.somethingSelected = function () {\r\n        for (var i = 0; i < this.ranges.length; i++)\r\n        { if (!this.ranges[i].empty()) { return true } }\r\n        return false\r\n    };\r\n\r\n    Selection.prototype.contains = function (pos, end) {\r\n        if (!end) { end = pos; }\r\n        for (var i = 0; i < this.ranges.length; i++) {\r\n            var range = this.ranges[i];\r\n            if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\r\n            { return i }\r\n        }\r\n        return -1\r\n    };\r\n\r\n    var Range = function(anchor, head) {\r\n        this.anchor = anchor; this.head = head;\r\n    };\r\n\r\n    Range.prototype.from = function () { return minPos(this.anchor, this.head) };\r\n    Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\r\n    Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\r\n\r\n    // Take an unsorted, potentially overlapping set of ranges, and\r\n    // build a selection out of it. 'Consumes' ranges array (modifying\r\n    // it).\r\n    function normalizeSelection(cm, ranges, primIndex) {\r\n        var mayTouch = cm && cm.options.selectionsMayTouch;\r\n        var prim = ranges[primIndex];\r\n        ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\r\n        primIndex = indexOf(ranges, prim);\r\n        for (var i = 1; i < ranges.length; i++) {\r\n            var cur = ranges[i], prev = ranges[i - 1];\r\n            var diff = cmp(prev.to(), cur.from());\r\n            if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\r\n                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\r\n                var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n                if (i <= primIndex) { --primIndex; }\r\n                ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n            }\r\n        }\r\n        return new Selection(ranges, primIndex)\r\n    }\r\n\r\n    function simpleSelection(anchor, head) {\r\n        return new Selection([new Range(anchor, head || anchor)], 0)\r\n    }\r\n\r\n    // Compute the position of the end of a change (its 'to' property\r\n    // refers to the pre-change end).\r\n    function changeEnd(change) {\r\n        if (!change.text) { return change.to }\r\n        return Pos(change.from.line + change.text.length - 1,\r\n            lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\r\n    }\r\n\r\n    // Adjust a position to refer to the post-change position of the\r\n    // same text, or the end of the change if the change covers it.\r\n    function adjustForChange(pos, change) {\r\n        if (cmp(pos, change.from) < 0) { return pos }\r\n        if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\r\n\r\n        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\r\n        if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\r\n        return Pos(line, ch)\r\n    }\r\n\r\n    function computeSelAfterChange(doc, change) {\r\n        var out = [];\r\n        for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n            var range = doc.sel.ranges[i];\r\n            out.push(new Range(adjustForChange(range.anchor, change),\r\n                adjustForChange(range.head, change)));\r\n        }\r\n        return normalizeSelection(doc.cm, out, doc.sel.primIndex)\r\n    }\r\n\r\n    function offsetPos(pos, old, nw) {\r\n        if (pos.line == old.line)\r\n        { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\r\n        else\r\n        { return Pos(nw.line + (pos.line - old.line), pos.ch) }\r\n    }\r\n\r\n    // Used by replaceSelections to allow moving the selection to the\r\n    // start or around the replaced test. Hint may be \"start\" or \"around\".\r\n    function computeReplacedSel(doc, changes, hint) {\r\n        var out = [];\r\n        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\r\n        for (var i = 0; i < changes.length; i++) {\r\n            var change = changes[i];\r\n            var from = offsetPos(change.from, oldPrev, newPrev);\r\n            var to = offsetPos(changeEnd(change), oldPrev, newPrev);\r\n            oldPrev = change.to;\r\n            newPrev = to;\r\n            if (hint == \"around\") {\r\n                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\r\n                out[i] = new Range(inv ? to : from, inv ? from : to);\r\n            } else {\r\n                out[i] = new Range(from, from);\r\n            }\r\n        }\r\n        return new Selection(out, doc.sel.primIndex)\r\n    }\r\n\r\n    // Used to get the editor into a consistent state again when options change.\r\n\r\n    function loadMode(cm) {\r\n        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\r\n        resetModeState(cm);\r\n    }\r\n\r\n    function resetModeState(cm) {\r\n        cm.doc.iter(function (line) {\r\n            if (line.stateAfter) { line.stateAfter = null; }\r\n            if (line.styles) { line.styles = null; }\r\n        });\r\n        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\r\n        startWorker(cm, 100);\r\n        cm.state.modeGen++;\r\n        if (cm.curOp) { regChange(cm); }\r\n    }\r\n\r\n    // DOCUMENT DATA STRUCTURE\r\n\r\n    // By default, updates that start and end at the beginning of a line\r\n    // are treated specially, in order to make the association of line\r\n    // widgets and marker elements with the text behave more intuitive.\r\n    function isWholeLineUpdate(doc, change) {\r\n        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\r\n            (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\r\n    }\r\n\r\n    // Perform a change on the document data structure.\r\n    function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\r\n        function spansFor(n) {return markedSpans ? markedSpans[n] : null}\r\n        function update(line, text, spans) {\r\n            updateLine(line, text, spans, estimateHeight$$1);\r\n            signalLater(line, \"change\", line, change);\r\n        }\r\n        function linesFor(start, end) {\r\n            var result = [];\r\n            for (var i = start; i < end; ++i)\r\n            { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\r\n            return result\r\n        }\r\n\r\n        var from = change.from, to = change.to, text = change.text;\r\n        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\r\n        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\r\n\r\n        // Adjust the line structure\r\n        if (change.full) {\r\n            doc.insert(0, linesFor(0, text.length));\r\n            doc.remove(text.length, doc.size - text.length);\r\n        } else if (isWholeLineUpdate(doc, change)) {\r\n            // This is a whole-line replace. Treated specially to make\r\n            // sure line objects move the way they are supposed to.\r\n            var added = linesFor(0, text.length - 1);\r\n            update(lastLine, lastLine.text, lastSpans);\r\n            if (nlines) { doc.remove(from.line, nlines); }\r\n            if (added.length) { doc.insert(from.line, added); }\r\n        } else if (firstLine == lastLine) {\r\n            if (text.length == 1) {\r\n                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\r\n            } else {\r\n                var added$1 = linesFor(1, text.length - 1);\r\n                added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\r\n                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n                doc.insert(from.line + 1, added$1);\r\n            }\r\n        } else if (text.length == 1) {\r\n            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\r\n            doc.remove(from.line + 1, nlines);\r\n        } else {\r\n            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\r\n            var added$2 = linesFor(1, text.length - 1);\r\n            if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\r\n            doc.insert(from.line + 1, added$2);\r\n        }\r\n\r\n        signalLater(doc, \"change\", doc, change);\r\n    }\r\n\r\n    // Call f for all linked documents.\r\n    function linkedDocs(doc, f, sharedHistOnly) {\r\n        function propagate(doc, skip, sharedHist) {\r\n            if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\r\n                var rel = doc.linked[i];\r\n                if (rel.doc == skip) { continue }\r\n                var shared = sharedHist && rel.sharedHist;\r\n                if (sharedHistOnly && !shared) { continue }\r\n                f(rel.doc, shared);\r\n                propagate(rel.doc, doc, shared);\r\n            } }\r\n        }\r\n        propagate(doc, null, true);\r\n    }\r\n\r\n    // Attach a document to an editor.\r\n    function attachDoc(cm, doc) {\r\n        if (doc.cm) { throw new Error(\"This document is already in use.\") }\r\n        cm.doc = doc;\r\n        doc.cm = cm;\r\n        estimateLineHeights(cm);\r\n        loadMode(cm);\r\n        setDirectionClass(cm);\r\n        if (!cm.options.lineWrapping) { findMaxLine(cm); }\r\n        cm.options.mode = doc.modeOption;\r\n        regChange(cm);\r\n    }\r\n\r\n    function setDirectionClass(cm) {\r\n        (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\r\n    }\r\n\r\n    function directionChanged(cm) {\r\n        runInOp(cm, function () {\r\n            setDirectionClass(cm);\r\n            regChange(cm);\r\n        });\r\n    }\r\n\r\n    function History(startGen) {\r\n        // Arrays of change events and selections. Doing something adds an\r\n        // event to done and clears undo. Undoing moves events from done\r\n        // to undone, redoing moves them in the other direction.\r\n        this.done = []; this.undone = [];\r\n        this.undoDepth = Infinity;\r\n        // Used to track when changes can be merged into a single undo\r\n        // event\r\n        this.lastModTime = this.lastSelTime = 0;\r\n        this.lastOp = this.lastSelOp = null;\r\n        this.lastOrigin = this.lastSelOrigin = null;\r\n        // Used by the isClean() method\r\n        this.generation = this.maxGeneration = startGen || 1;\r\n    }\r\n\r\n    // Create a history change event from an updateDoc-style change\r\n    // object.\r\n    function historyChangeFromChange(doc, change) {\r\n        var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\r\n        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n        linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\r\n        return histChange\r\n    }\r\n\r\n    // Pop all selection events off the end of a history array. Stop at\r\n    // a change event.\r\n    function clearSelectionEvents(array) {\r\n        while (array.length) {\r\n            var last = lst(array);\r\n            if (last.ranges) { array.pop(); }\r\n            else { break }\r\n        }\r\n    }\r\n\r\n    // Find the top change event in the history. Pop off selection\r\n    // events that are in the way.\r\n    function lastChangeEvent(hist, force) {\r\n        if (force) {\r\n            clearSelectionEvents(hist.done);\r\n            return lst(hist.done)\r\n        } else if (hist.done.length && !lst(hist.done).ranges) {\r\n            return lst(hist.done)\r\n        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n            hist.done.pop();\r\n            return lst(hist.done)\r\n        }\r\n    }\r\n\r\n    // Register a change in the history. Merges changes that are within\r\n    // a single operation, or are close together with an origin that\r\n    // allows merging (starting with \"+\") into a single event.\r\n    function addChangeToHistory(doc, change, selAfter, opId) {\r\n        var hist = doc.history;\r\n        hist.undone.length = 0;\r\n        var time = +new Date, cur;\r\n        var last;\r\n\r\n        if ((hist.lastOp == opId ||\r\n            hist.lastOrigin == change.origin && change.origin &&\r\n            ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\r\n                change.origin.charAt(0) == \"*\")) &&\r\n            (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n            // Merge this change into the last event\r\n            last = lst(cur.changes);\r\n            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\r\n                // Optimized case for simple insertion -- don't want to add\r\n                // new changesets for every character typed\r\n                last.to = changeEnd(change);\r\n            } else {\r\n                // Add new sub-event\r\n                cur.changes.push(historyChangeFromChange(doc, change));\r\n            }\r\n        } else {\r\n            // Can not be merged, start a new event.\r\n            var before = lst(hist.done);\r\n            if (!before || !before.ranges)\r\n            { pushSelectionToHistory(doc.sel, hist.done); }\r\n            cur = {changes: [historyChangeFromChange(doc, change)],\r\n                generation: hist.generation};\r\n            hist.done.push(cur);\r\n            while (hist.done.length > hist.undoDepth) {\r\n                hist.done.shift();\r\n                if (!hist.done[0].ranges) { hist.done.shift(); }\r\n            }\r\n        }\r\n        hist.done.push(selAfter);\r\n        hist.generation = ++hist.maxGeneration;\r\n        hist.lastModTime = hist.lastSelTime = time;\r\n        hist.lastOp = hist.lastSelOp = opId;\r\n        hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n\r\n        if (!last) { signal(doc, \"historyAdded\"); }\r\n    }\r\n\r\n    function selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n        var ch = origin.charAt(0);\r\n        return ch == \"*\" ||\r\n            ch == \"+\" &&\r\n            prev.ranges.length == sel.ranges.length &&\r\n            prev.somethingSelected() == sel.somethingSelected() &&\r\n            new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\r\n    }\r\n\r\n    // Called whenever the selection changes, sets the new selection as\r\n    // the pending selection in the history, and pushes the old pending\r\n    // selection into the 'done' array when it was significantly\r\n    // different (in number of selected ranges, emptiness, or time).\r\n    function addSelectionToHistory(doc, sel, opId, options) {\r\n        var hist = doc.history, origin = options && options.origin;\r\n\r\n        // A new event is started when the previous origin does not match\r\n        // the current, or the origins don't allow matching. Origins\r\n        // starting with * are always merged, those starting with + are\r\n        // merged when similar and close together in time.\r\n        if (opId == hist.lastSelOp ||\r\n            (origin && hist.lastSelOrigin == origin &&\r\n                (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\r\n                    selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\r\n        { hist.done[hist.done.length - 1] = sel; }\r\n        else\r\n        { pushSelectionToHistory(sel, hist.done); }\r\n\r\n        hist.lastSelTime = +new Date;\r\n        hist.lastSelOrigin = origin;\r\n        hist.lastSelOp = opId;\r\n        if (options && options.clearRedo !== false)\r\n        { clearSelectionEvents(hist.undone); }\r\n    }\r\n\r\n    function pushSelectionToHistory(sel, dest) {\r\n        var top = lst(dest);\r\n        if (!(top && top.ranges && top.equals(sel)))\r\n        { dest.push(sel); }\r\n    }\r\n\r\n    // Used to store marked span information in the history.\r\n    function attachLocalSpans(doc, change, from, to) {\r\n        var existing = change[\"spans_\" + doc.id], n = 0;\r\n        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\r\n            if (line.markedSpans)\r\n            { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\r\n            ++n;\r\n        });\r\n    }\r\n\r\n    // When un/re-doing restores text containing marked spans, those\r\n    // that have been explicitly cleared should not be restored.\r\n    function removeClearedSpans(spans) {\r\n        if (!spans) { return null }\r\n        var out;\r\n        for (var i = 0; i < spans.length; ++i) {\r\n            if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\r\n            else if (out) { out.push(spans[i]); }\r\n        }\r\n        return !out ? spans : out.length ? out : null\r\n    }\r\n\r\n    // Retrieve and filter the old marked spans stored in a change event.\r\n    function getOldSpans(doc, change) {\r\n        var found = change[\"spans_\" + doc.id];\r\n        if (!found) { return null }\r\n        var nw = [];\r\n        for (var i = 0; i < change.text.length; ++i)\r\n        { nw.push(removeClearedSpans(found[i])); }\r\n        return nw\r\n    }\r\n\r\n    // Used for un/re-doing changes from the history. Combines the\r\n    // result of computing the existing spans with the set of spans that\r\n    // existed in the history (so that deleting around a span and then\r\n    // undoing brings back the span).\r\n    function mergeOldSpans(doc, change) {\r\n        var old = getOldSpans(doc, change);\r\n        var stretched = stretchSpansOverChange(doc, change);\r\n        if (!old) { return stretched }\r\n        if (!stretched) { return old }\r\n\r\n        for (var i = 0; i < old.length; ++i) {\r\n            var oldCur = old[i], stretchCur = stretched[i];\r\n            if (oldCur && stretchCur) {\r\n                spans: for (var j = 0; j < stretchCur.length; ++j) {\r\n                    var span = stretchCur[j];\r\n                    for (var k = 0; k < oldCur.length; ++k)\r\n                    { if (oldCur[k].marker == span.marker) { continue spans } }\r\n                    oldCur.push(span);\r\n                }\r\n            } else if (stretchCur) {\r\n                old[i] = stretchCur;\r\n            }\r\n        }\r\n        return old\r\n    }\r\n\r\n    // Used both to provide a JSON-safe object in .getHistory, and, when\r\n    // detaching a document, to split the history in two\r\n    function copyHistoryArray(events, newGroup, instantiateSel) {\r\n        var copy = [];\r\n        for (var i = 0; i < events.length; ++i) {\r\n            var event = events[i];\r\n            if (event.ranges) {\r\n                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n                continue\r\n            }\r\n            var changes = event.changes, newChanges = [];\r\n            copy.push({changes: newChanges});\r\n            for (var j = 0; j < changes.length; ++j) {\r\n                var change = changes[j], m = (void 0);\r\n                newChanges.push({from: change.from, to: change.to, text: change.text});\r\n                if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\r\n                    if (indexOf(newGroup, Number(m[1])) > -1) {\r\n                        lst(newChanges)[prop] = change[prop];\r\n                        delete change[prop];\r\n                    }\r\n                } } }\r\n            }\r\n        }\r\n        return copy\r\n    }\r\n\r\n    // The 'scroll' parameter given to many of these indicated whether\r\n    // the new cursor position should be scrolled into view after\r\n    // modifying the selection.\r\n\r\n    // If shift is held or the extend flag is set, extends a range to\r\n    // include a given position (and optionally a second position).\r\n    // Otherwise, simply returns the range between the given positions.\r\n    // Used for cursor motion and such.\r\n    function extendRange(range, head, other, extend) {\r\n        if (extend) {\r\n            var anchor = range.anchor;\r\n            if (other) {\r\n                var posBefore = cmp(head, anchor) < 0;\r\n                if (posBefore != (cmp(other, anchor) < 0)) {\r\n                    anchor = head;\r\n                    head = other;\r\n                } else if (posBefore != (cmp(head, other) < 0)) {\r\n                    head = other;\r\n                }\r\n            }\r\n            return new Range(anchor, head)\r\n        } else {\r\n            return new Range(other || head, head)\r\n        }\r\n    }\r\n\r\n    // Extend the primary selection range, discard the rest.\r\n    function extendSelection(doc, head, other, options, extend) {\r\n        if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\r\n        setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\r\n    }\r\n\r\n    // Extend all selections (pos is an array of selections with length\r\n    // equal the number of selections)\r\n    function extendSelections(doc, heads, options) {\r\n        var out = [];\r\n        var extend = doc.cm && (doc.cm.display.shift || doc.extend);\r\n        for (var i = 0; i < doc.sel.ranges.length; i++)\r\n        { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\r\n        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\r\n        setSelection(doc, newSel, options);\r\n    }\r\n\r\n    // Updates a single range in the selection.\r\n    function replaceOneSelection(doc, i, range, options) {\r\n        var ranges = doc.sel.ranges.slice(0);\r\n        ranges[i] = range;\r\n        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\r\n    }\r\n\r\n    // Reset the selection to a single range.\r\n    function setSimpleSelection(doc, anchor, head, options) {\r\n        setSelection(doc, simpleSelection(anchor, head), options);\r\n    }\r\n\r\n    // Give beforeSelectionChange handlers a change to influence a\r\n    // selection update.\r\n    function filterSelectionChange(doc, sel, options) {\r\n        var obj = {\r\n            ranges: sel.ranges,\r\n            update: function(ranges) {\r\n                this.ranges = [];\r\n                for (var i = 0; i < ranges.length; i++)\r\n                { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\r\n                    clipPos(doc, ranges[i].head)); }\r\n            },\r\n            origin: options && options.origin\r\n        };\r\n        signal(doc, \"beforeSelectionChange\", doc, obj);\r\n        if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\r\n        if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\r\n        else { return sel }\r\n    }\r\n\r\n    function setSelectionReplaceHistory(doc, sel, options) {\r\n        var done = doc.history.done, last = lst(done);\r\n        if (last && last.ranges) {\r\n            done[done.length - 1] = sel;\r\n            setSelectionNoUndo(doc, sel, options);\r\n        } else {\r\n            setSelection(doc, sel, options);\r\n        }\r\n    }\r\n\r\n    // Set a new selection.\r\n    function setSelection(doc, sel, options) {\r\n        setSelectionNoUndo(doc, sel, options);\r\n        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\r\n    }\r\n\r\n    function setSelectionNoUndo(doc, sel, options) {\r\n        if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\r\n        { sel = filterSelectionChange(doc, sel, options); }\r\n\r\n        var bias = options && options.bias ||\r\n            (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\r\n        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\r\n\r\n        if (!(options && options.scroll === false) && doc.cm)\r\n        { ensureCursorVisible(doc.cm); }\r\n    }\r\n\r\n    function setSelectionInner(doc, sel) {\r\n        if (sel.equals(doc.sel)) { return }\r\n\r\n        doc.sel = sel;\r\n\r\n        if (doc.cm) {\r\n            doc.cm.curOp.updateInput = 1;\r\n            doc.cm.curOp.selectionChanged = true;\r\n            signalCursorActivity(doc.cm);\r\n        }\r\n        signalLater(doc, \"cursorActivity\", doc);\r\n    }\r\n\r\n    // Verify that the selection does not partially select any atomic\r\n    // marked ranges.\r\n    function reCheckSelection(doc) {\r\n        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\r\n    }\r\n\r\n    // Return a selection that does not partially select any atomic\r\n    // ranges.\r\n    function skipAtomicInSelection(doc, sel, bias, mayClear) {\r\n        var out;\r\n        for (var i = 0; i < sel.ranges.length; i++) {\r\n            var range = sel.ranges[i];\r\n            var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\r\n            var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\r\n            var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\r\n            if (out || newAnchor != range.anchor || newHead != range.head) {\r\n                if (!out) { out = sel.ranges.slice(0, i); }\r\n                out[i] = new Range(newAnchor, newHead);\r\n            }\r\n        }\r\n        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\r\n    }\r\n\r\n    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\r\n        var line = getLine(doc, pos.line);\r\n        if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\r\n            var sp = line.markedSpans[i], m = sp.marker;\r\n            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\r\n                (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\r\n                if (mayClear) {\r\n                    signal(m, \"beforeCursorEnter\");\r\n                    if (m.explicitlyCleared) {\r\n                        if (!line.markedSpans) { break }\r\n                        else {--i; continue}\r\n                    }\r\n                }\r\n                if (!m.atomic) { continue }\r\n\r\n                if (oldPos) {\r\n                    var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\r\n                    if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\r\n                    { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\r\n                    if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\r\n                    { return skipAtomicInner(doc, near, pos, dir, mayClear) }\r\n                }\r\n\r\n                var far = m.find(dir < 0 ? -1 : 1);\r\n                if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\r\n                { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\r\n                return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\r\n            }\r\n        } }\r\n        return pos\r\n    }\r\n\r\n    // Ensure a given position is not inside an atomic range.\r\n    function skipAtomic(doc, pos, oldPos, bias, mayClear) {\r\n        var dir = bias || 1;\r\n        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\r\n            (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\r\n            skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\r\n            (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\r\n        if (!found) {\r\n            doc.cantEdit = true;\r\n            return Pos(doc.first, 0)\r\n        }\r\n        return found\r\n    }\r\n\r\n    function movePos(doc, pos, dir, line) {\r\n        if (dir < 0 && pos.ch == 0) {\r\n            if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\r\n            else { return null }\r\n        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\r\n            if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\r\n            else { return null }\r\n        } else {\r\n            return new Pos(pos.line, pos.ch + dir)\r\n        }\r\n    }\r\n\r\n    function selectAll(cm) {\r\n        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\r\n    }\r\n\r\n    // UPDATING\r\n\r\n    // Allow \"beforeChange\" event handlers to influence a change\r\n    function filterChange(doc, change, update) {\r\n        var obj = {\r\n            canceled: false,\r\n            from: change.from,\r\n            to: change.to,\r\n            text: change.text,\r\n            origin: change.origin,\r\n            cancel: function () { return obj.canceled = true; }\r\n        };\r\n        if (update) { obj.update = function (from, to, text, origin) {\r\n            if (from) { obj.from = clipPos(doc, from); }\r\n            if (to) { obj.to = clipPos(doc, to); }\r\n            if (text) { obj.text = text; }\r\n            if (origin !== undefined) { obj.origin = origin; }\r\n        }; }\r\n        signal(doc, \"beforeChange\", doc, obj);\r\n        if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\r\n\r\n        if (obj.canceled) {\r\n            if (doc.cm) { doc.cm.curOp.updateInput = 2; }\r\n            return null\r\n        }\r\n        return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\r\n    }\r\n\r\n    // Apply a change to a document, and add it to the document's\r\n    // history, and propagating it to all linked documents.\r\n    function makeChange(doc, change, ignoreReadOnly) {\r\n        if (doc.cm) {\r\n            if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\r\n            if (doc.cm.state.suppressEdits) { return }\r\n        }\r\n\r\n        if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\r\n            change = filterChange(doc, change, true);\r\n            if (!change) { return }\r\n        }\r\n\r\n        // Possibly split or suppress the update based on the presence\r\n        // of read-only spans in its range.\r\n        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\r\n        if (split) {\r\n            for (var i = split.length - 1; i >= 0; --i)\r\n            { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\r\n        } else {\r\n            makeChangeInner(doc, change);\r\n        }\r\n    }\r\n\r\n    function makeChangeInner(doc, change) {\r\n        if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\r\n        var selAfter = computeSelAfterChange(doc, change);\r\n        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\r\n\r\n        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\r\n        var rebased = [];\r\n\r\n        linkedDocs(doc, function (doc, sharedHist) {\r\n            if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n                rebaseHist(doc.history, change);\r\n                rebased.push(doc.history);\r\n            }\r\n            makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\r\n        });\r\n    }\r\n\r\n    // Revert a change stored in a document's history.\r\n    function makeChangeFromHistory(doc, type, allowSelectionOnly) {\r\n        var suppress = doc.cm && doc.cm.state.suppressEdits;\r\n        if (suppress && !allowSelectionOnly) { return }\r\n\r\n        var hist = doc.history, event, selAfter = doc.sel;\r\n        var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\r\n\r\n        // Verify that there is a useable event (so that ctrl-z won't\r\n        // needlessly clear selection events)\r\n        var i = 0;\r\n        for (; i < source.length; i++) {\r\n            event = source[i];\r\n            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\r\n            { break }\r\n        }\r\n        if (i == source.length) { return }\r\n        hist.lastOrigin = hist.lastSelOrigin = null;\r\n\r\n        for (;;) {\r\n            event = source.pop();\r\n            if (event.ranges) {\r\n                pushSelectionToHistory(event, dest);\r\n                if (allowSelectionOnly && !event.equals(doc.sel)) {\r\n                    setSelection(doc, event, {clearRedo: false});\r\n                    return\r\n                }\r\n                selAfter = event;\r\n            } else if (suppress) {\r\n                source.push(event);\r\n                return\r\n            } else { break }\r\n        }\r\n\r\n        // Build up a reverse change object to add to the opposite history\r\n        // stack (redo when undoing, and vice versa).\r\n        var antiChanges = [];\r\n        pushSelectionToHistory(selAfter, dest);\r\n        dest.push({changes: antiChanges, generation: hist.generation});\r\n        hist.generation = event.generation || ++hist.maxGeneration;\r\n\r\n        var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\r\n\r\n        var loop = function ( i ) {\r\n            var change = event.changes[i];\r\n            change.origin = type;\r\n            if (filter && !filterChange(doc, change, false)) {\r\n                source.length = 0;\r\n                return {}\r\n            }\r\n\r\n            antiChanges.push(historyChangeFromChange(doc, change));\r\n\r\n            var after = i ? computeSelAfterChange(doc, change) : lst(source);\r\n            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\r\n            if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\r\n            var rebased = [];\r\n\r\n            // Propagate to the linked documents\r\n            linkedDocs(doc, function (doc, sharedHist) {\r\n                if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n                    rebaseHist(doc.history, change);\r\n                    rebased.push(doc.history);\r\n                }\r\n                makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\r\n            });\r\n        };\r\n\r\n        for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\r\n            var returned = loop( i$1 );\r\n\r\n            if ( returned ) return returned.v;\r\n        }\r\n    }\r\n\r\n    // Sub-views need their line numbers shifted when text is added\r\n    // above or below them in the parent document.\r\n    function shiftDoc(doc, distance) {\r\n        if (distance == 0) { return }\r\n        doc.first += distance;\r\n        doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\r\n            Pos(range.anchor.line + distance, range.anchor.ch),\r\n            Pos(range.head.line + distance, range.head.ch)\r\n        ); }), doc.sel.primIndex);\r\n        if (doc.cm) {\r\n            regChange(doc.cm, doc.first, doc.first - distance, distance);\r\n            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\r\n            { regLineChange(doc.cm, l, \"gutter\"); }\r\n        }\r\n    }\r\n\r\n    // More lower-level change function, handling only a single document\r\n    // (not linked ones).\r\n    function makeChangeSingleDoc(doc, change, selAfter, spans) {\r\n        if (doc.cm && !doc.cm.curOp)\r\n        { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\r\n\r\n        if (change.to.line < doc.first) {\r\n            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\r\n            return\r\n        }\r\n        if (change.from.line > doc.lastLine()) { return }\r\n\r\n        // Clip the change to the size of this doc\r\n        if (change.from.line < doc.first) {\r\n            var shift = change.text.length - 1 - (doc.first - change.from.line);\r\n            shiftDoc(doc, shift);\r\n            change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\r\n                text: [lst(change.text)], origin: change.origin};\r\n        }\r\n        var last = doc.lastLine();\r\n        if (change.to.line > last) {\r\n            change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\r\n                text: [change.text[0]], origin: change.origin};\r\n        }\r\n\r\n        change.removed = getBetween(doc, change.from, change.to);\r\n\r\n        if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\r\n        if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\r\n        else { updateDoc(doc, change, spans); }\r\n        setSelectionNoUndo(doc, selAfter, sel_dontScroll);\r\n    }\r\n\r\n    // Handle the interaction of a change to a document with the editor\r\n    // that this document is part of.\r\n    function makeChangeSingleDocInEditor(cm, change, spans) {\r\n        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\r\n\r\n        var recomputeMaxLength = false, checkWidthStart = from.line;\r\n        if (!cm.options.lineWrapping) {\r\n            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\r\n            doc.iter(checkWidthStart, to.line + 1, function (line) {\r\n                if (line == display.maxLine) {\r\n                    recomputeMaxLength = true;\r\n                    return true\r\n                }\r\n            });\r\n        }\r\n\r\n        if (doc.sel.contains(change.from, change.to) > -1)\r\n        { signalCursorActivity(cm); }\r\n\r\n        updateDoc(doc, change, spans, estimateHeight(cm));\r\n\r\n        if (!cm.options.lineWrapping) {\r\n            doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\r\n                var len = lineLength(line);\r\n                if (len > display.maxLineLength) {\r\n                    display.maxLine = line;\r\n                    display.maxLineLength = len;\r\n                    display.maxLineChanged = true;\r\n                    recomputeMaxLength = false;\r\n                }\r\n            });\r\n            if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\r\n        }\r\n\r\n        retreatFrontier(doc, from.line);\r\n        startWorker(cm, 400);\r\n\r\n        var lendiff = change.text.length - (to.line - from.line) - 1;\r\n        // Remember that these lines changed, for updating the display\r\n        if (change.full)\r\n        { regChange(cm); }\r\n        else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\r\n        { regLineChange(cm, from.line, \"text\"); }\r\n        else\r\n        { regChange(cm, from.line, to.line + 1, lendiff); }\r\n\r\n        var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\r\n        if (changeHandler || changesHandler) {\r\n            var obj = {\r\n                from: from, to: to,\r\n                text: change.text,\r\n                removed: change.removed,\r\n                origin: change.origin\r\n            };\r\n            if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\r\n            if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\r\n        }\r\n        cm.display.selForContextMenu = null;\r\n    }\r\n\r\n    function replaceRange(doc, code, from, to, origin) {\r\n        var assign;\r\n\r\n        if (!to) { to = from; }\r\n        if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\r\n        if (typeof code == \"string\") { code = doc.splitLines(code); }\r\n        makeChange(doc, {from: from, to: to, text: code, origin: origin});\r\n    }\r\n\r\n    // Rebasing/resetting history to deal with externally-sourced changes\r\n\r\n    function rebaseHistSelSingle(pos, from, to, diff) {\r\n        if (to < pos.line) {\r\n            pos.line += diff;\r\n        } else if (from < pos.line) {\r\n            pos.line = from;\r\n            pos.ch = 0;\r\n        }\r\n    }\r\n\r\n    // Tries to rebase an array of history events given a change in the\r\n    // document. If the change touches the same lines as the event, the\r\n    // event, and everything 'behind' it, is discarded. If the change is\r\n    // before the event, the event's positions are updated. Uses a\r\n    // copy-on-write scheme for the positions, to avoid having to\r\n    // reallocate them all on every rebase, but also avoid problems with\r\n    // shared position objects being unsafely updated.\r\n    function rebaseHistArray(array, from, to, diff) {\r\n        for (var i = 0; i < array.length; ++i) {\r\n            var sub = array[i], ok = true;\r\n            if (sub.ranges) {\r\n                if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\r\n                for (var j = 0; j < sub.ranges.length; j++) {\r\n                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\r\n                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\r\n                }\r\n                continue\r\n            }\r\n            for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\r\n                var cur = sub.changes[j$1];\r\n                if (to < cur.from.line) {\r\n                    cur.from = Pos(cur.from.line + diff, cur.from.ch);\r\n                    cur.to = Pos(cur.to.line + diff, cur.to.ch);\r\n                } else if (from <= cur.to.line) {\r\n                    ok = false;\r\n                    break\r\n                }\r\n            }\r\n            if (!ok) {\r\n                array.splice(0, i + 1);\r\n                i = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function rebaseHist(hist, change) {\r\n        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\r\n        rebaseHistArray(hist.done, from, to, diff);\r\n        rebaseHistArray(hist.undone, from, to, diff);\r\n    }\r\n\r\n    // Utility for applying a change to a line by handle or number,\r\n    // returning the number and optionally registering the line as\r\n    // changed.\r\n    function changeLine(doc, handle, changeType, op) {\r\n        var no = handle, line = handle;\r\n        if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\r\n        else { no = lineNo(handle); }\r\n        if (no == null) { return null }\r\n        if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\r\n        return line\r\n    }\r\n\r\n    // The document is represented as a BTree consisting of leaves, with\r\n    // chunk of lines in them, and branches, with up to ten leaves or\r\n    // other branch nodes below them. The top node is always a branch\r\n    // node, and is the document object itself (meaning it has\r\n    // additional methods and properties).\r\n    //\r\n    // All nodes have parent links. The tree is used both to go from\r\n    // line numbers to line objects, and to go from objects to numbers.\r\n    // It also indexes by height, and is used to convert between height\r\n    // and line object, and to find the total height of the document.\r\n    //\r\n    // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n\r\n    function LeafChunk(lines) {\r\n        this.lines = lines;\r\n        this.parent = null;\r\n        var height = 0;\r\n        for (var i = 0; i < lines.length; ++i) {\r\n            lines[i].parent = this;\r\n            height += lines[i].height;\r\n        }\r\n        this.height = height;\r\n    }\r\n\r\n    LeafChunk.prototype = {\r\n        chunkSize: function() { return this.lines.length },\r\n\r\n        // Remove the n lines at offset 'at'.\r\n        removeInner: function(at, n) {\r\n            for (var i = at, e = at + n; i < e; ++i) {\r\n                var line = this.lines[i];\r\n                this.height -= line.height;\r\n                cleanUpLine(line);\r\n                signalLater(line, \"delete\");\r\n            }\r\n            this.lines.splice(at, n);\r\n        },\r\n\r\n        // Helper used to collapse a small branch into a single leaf.\r\n        collapse: function(lines) {\r\n            lines.push.apply(lines, this.lines);\r\n        },\r\n\r\n        // Insert the given array of lines at offset 'at', count them as\r\n        // having the given height.\r\n        insertInner: function(at, lines, height) {\r\n            this.height += height;\r\n            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n            for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\r\n        },\r\n\r\n        // Used to iterate over a part of the tree.\r\n        iterN: function(at, n, op) {\r\n            for (var e = at + n; at < e; ++at)\r\n            { if (op(this.lines[at])) { return true } }\r\n        }\r\n    };\r\n\r\n    function BranchChunk(children) {\r\n        this.children = children;\r\n        var size = 0, height = 0;\r\n        for (var i = 0; i < children.length; ++i) {\r\n            var ch = children[i];\r\n            size += ch.chunkSize(); height += ch.height;\r\n            ch.parent = this;\r\n        }\r\n        this.size = size;\r\n        this.height = height;\r\n        this.parent = null;\r\n    }\r\n\r\n    BranchChunk.prototype = {\r\n        chunkSize: function() { return this.size },\r\n\r\n        removeInner: function(at, n) {\r\n            this.size -= n;\r\n            for (var i = 0; i < this.children.length; ++i) {\r\n                var child = this.children[i], sz = child.chunkSize();\r\n                if (at < sz) {\r\n                    var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n                    child.removeInner(at, rm);\r\n                    this.height -= oldHeight - child.height;\r\n                    if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\r\n                    if ((n -= rm) == 0) { break }\r\n                    at = 0;\r\n                } else { at -= sz; }\r\n            }\r\n            // If the result is smaller than 25 lines, ensure that it is a\r\n            // single leaf node.\r\n            if (this.size - n < 25 &&\r\n                (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n                var lines = [];\r\n                this.collapse(lines);\r\n                this.children = [new LeafChunk(lines)];\r\n                this.children[0].parent = this;\r\n            }\r\n        },\r\n\r\n        collapse: function(lines) {\r\n            for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\r\n        },\r\n\r\n        insertInner: function(at, lines, height) {\r\n            this.size += lines.length;\r\n            this.height += height;\r\n            for (var i = 0; i < this.children.length; ++i) {\r\n                var child = this.children[i], sz = child.chunkSize();\r\n                if (at <= sz) {\r\n                    child.insertInner(at, lines, height);\r\n                    if (child.lines && child.lines.length > 50) {\r\n                        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\r\n                        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\r\n                        var remaining = child.lines.length % 25 + 25;\r\n                        for (var pos = remaining; pos < child.lines.length;) {\r\n                            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\r\n                            child.height -= leaf.height;\r\n                            this.children.splice(++i, 0, leaf);\r\n                            leaf.parent = this;\r\n                        }\r\n                        child.lines = child.lines.slice(0, remaining);\r\n                        this.maybeSpill();\r\n                    }\r\n                    break\r\n                }\r\n                at -= sz;\r\n            }\r\n        },\r\n\r\n        // When a node has grown, check whether it should be split.\r\n        maybeSpill: function() {\r\n            if (this.children.length <= 10) { return }\r\n            var me = this;\r\n            do {\r\n                var spilled = me.children.splice(me.children.length - 5, 5);\r\n                var sibling = new BranchChunk(spilled);\r\n                if (!me.parent) { // Become the parent node\r\n                    var copy = new BranchChunk(me.children);\r\n                    copy.parent = me;\r\n                    me.children = [copy, sibling];\r\n                    me = copy;\r\n                } else {\r\n                    me.size -= sibling.size;\r\n                    me.height -= sibling.height;\r\n                    var myIndex = indexOf(me.parent.children, me);\r\n                    me.parent.children.splice(myIndex + 1, 0, sibling);\r\n                }\r\n                sibling.parent = me.parent;\r\n            } while (me.children.length > 10)\r\n            me.parent.maybeSpill();\r\n        },\r\n\r\n        iterN: function(at, n, op) {\r\n            for (var i = 0; i < this.children.length; ++i) {\r\n                var child = this.children[i], sz = child.chunkSize();\r\n                if (at < sz) {\r\n                    var used = Math.min(n, sz - at);\r\n                    if (child.iterN(at, used, op)) { return true }\r\n                    if ((n -= used) == 0) { break }\r\n                    at = 0;\r\n                } else { at -= sz; }\r\n            }\r\n        }\r\n    };\r\n\r\n    // Line widgets are block elements displayed above or below a line.\r\n\r\n    var LineWidget = function(doc, node, options) {\r\n        if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\r\n        { this[opt] = options[opt]; } } }\r\n        this.doc = doc;\r\n        this.node = node;\r\n    };\r\n\r\n    LineWidget.prototype.clear = function () {\r\n        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\r\n        if (no == null || !ws) { return }\r\n        for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\r\n        if (!ws.length) { line.widgets = null; }\r\n        var height = widgetHeight(this);\r\n        updateLineHeight(line, Math.max(0, line.height - height));\r\n        if (cm) {\r\n            runInOp(cm, function () {\r\n                adjustScrollWhenAboveVisible(cm, line, -height);\r\n                regLineChange(cm, no, \"widget\");\r\n            });\r\n            signalLater(cm, \"lineWidgetCleared\", cm, this, no);\r\n        }\r\n    };\r\n\r\n    LineWidget.prototype.changed = function () {\r\n        var this$1 = this;\r\n\r\n        var oldH = this.height, cm = this.doc.cm, line = this.line;\r\n        this.height = null;\r\n        var diff = widgetHeight(this) - oldH;\r\n        if (!diff) { return }\r\n        if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\r\n        if (cm) {\r\n            runInOp(cm, function () {\r\n                cm.curOp.forceUpdate = true;\r\n                adjustScrollWhenAboveVisible(cm, line, diff);\r\n                signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\r\n            });\r\n        }\r\n    };\r\n    eventMixin(LineWidget);\r\n\r\n    function adjustScrollWhenAboveVisible(cm, line, diff) {\r\n        if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\r\n        { addToScrollTop(cm, diff); }\r\n    }\r\n\r\n    function addLineWidget(doc, handle, node, options) {\r\n        var widget = new LineWidget(doc, node, options);\r\n        var cm = doc.cm;\r\n        if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\r\n        changeLine(doc, handle, \"widget\", function (line) {\r\n            var widgets = line.widgets || (line.widgets = []);\r\n            if (widget.insertAt == null) { widgets.push(widget); }\r\n            else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\r\n            widget.line = line;\r\n            if (cm && !lineIsHidden(doc, line)) {\r\n                var aboveVisible = heightAtLine(line) < doc.scrollTop;\r\n                updateLineHeight(line, line.height + widgetHeight(widget));\r\n                if (aboveVisible) { addToScrollTop(cm, widget.height); }\r\n                cm.curOp.forceUpdate = true;\r\n            }\r\n            return true\r\n        });\r\n        if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\r\n        return widget\r\n    }\r\n\r\n    // TEXTMARKERS\r\n\r\n    // Created with markText and setBookmark methods. A TextMarker is a\r\n    // handle that can be used to clear or find a marked position in the\r\n    // document. Line objects hold arrays (markedSpans) containing\r\n    // {from, to, marker} object pointing to such marker objects, and\r\n    // indicating that such a marker is present on that line. Multiple\r\n    // lines may point to the same marker when it spans across lines.\r\n    // The spans will have null for their from/to properties when the\r\n    // marker continues beyond the start/end of the line. Markers have\r\n    // links back to the lines they currently touch.\r\n\r\n    // Collapsed markers have unique ids, in order to be able to order\r\n    // them, which is needed for uniquely determining an outer marker\r\n    // when they overlap (they may nest, but not partially overlap).\r\n    var nextMarkerId = 0;\r\n\r\n    var TextMarker = function(doc, type) {\r\n        this.lines = [];\r\n        this.type = type;\r\n        this.doc = doc;\r\n        this.id = ++nextMarkerId;\r\n    };\r\n\r\n    // Clear the marker.\r\n    TextMarker.prototype.clear = function () {\r\n        if (this.explicitlyCleared) { return }\r\n        var cm = this.doc.cm, withOp = cm && !cm.curOp;\r\n        if (withOp) { startOperation(cm); }\r\n        if (hasHandler(this, \"clear\")) {\r\n            var found = this.find();\r\n            if (found) { signalLater(this, \"clear\", found.from, found.to); }\r\n        }\r\n        var min = null, max = null;\r\n        for (var i = 0; i < this.lines.length; ++i) {\r\n            var line = this.lines[i];\r\n            var span = getMarkedSpanFor(line.markedSpans, this);\r\n            if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\r\n            else if (cm) {\r\n                if (span.to != null) { max = lineNo(line); }\r\n                if (span.from != null) { min = lineNo(line); }\r\n            }\r\n            line.markedSpans = removeMarkedSpan(line.markedSpans, span);\r\n            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\r\n            { updateLineHeight(line, textHeight(cm.display)); }\r\n        }\r\n        if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\r\n            var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\r\n            if (len > cm.display.maxLineLength) {\r\n                cm.display.maxLine = visual;\r\n                cm.display.maxLineLength = len;\r\n                cm.display.maxLineChanged = true;\r\n            }\r\n        } }\r\n\r\n        if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\r\n        this.lines.length = 0;\r\n        this.explicitlyCleared = true;\r\n        if (this.atomic && this.doc.cantEdit) {\r\n            this.doc.cantEdit = false;\r\n            if (cm) { reCheckSelection(cm.doc); }\r\n        }\r\n        if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\r\n        if (withOp) { endOperation(cm); }\r\n        if (this.parent) { this.parent.clear(); }\r\n    };\r\n\r\n    // Find the position of the marker in the document. Returns a {from,\r\n    // to} object by default. Side can be passed to get a specific side\r\n    // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\r\n    // Pos objects returned contain a line object, rather than a line\r\n    // number (used to prevent looking up the same line twice).\r\n    TextMarker.prototype.find = function (side, lineObj) {\r\n        if (side == null && this.type == \"bookmark\") { side = 1; }\r\n        var from, to;\r\n        for (var i = 0; i < this.lines.length; ++i) {\r\n            var line = this.lines[i];\r\n            var span = getMarkedSpanFor(line.markedSpans, this);\r\n            if (span.from != null) {\r\n                from = Pos(lineObj ? line : lineNo(line), span.from);\r\n                if (side == -1) { return from }\r\n            }\r\n            if (span.to != null) {\r\n                to = Pos(lineObj ? line : lineNo(line), span.to);\r\n                if (side == 1) { return to }\r\n            }\r\n        }\r\n        return from && {from: from, to: to}\r\n    };\r\n\r\n    // Signals that the marker's widget changed, and surrounding layout\r\n    // should be recomputed.\r\n    TextMarker.prototype.changed = function () {\r\n        var this$1 = this;\r\n\r\n        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\r\n        if (!pos || !cm) { return }\r\n        runInOp(cm, function () {\r\n            var line = pos.line, lineN = lineNo(pos.line);\r\n            var view = findViewForLine(cm, lineN);\r\n            if (view) {\r\n                clearLineMeasurementCacheFor(view);\r\n                cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\r\n            }\r\n            cm.curOp.updateMaxLine = true;\r\n            if (!lineIsHidden(widget.doc, line) && widget.height != null) {\r\n                var oldHeight = widget.height;\r\n                widget.height = null;\r\n                var dHeight = widgetHeight(widget) - oldHeight;\r\n                if (dHeight)\r\n                { updateLineHeight(line, line.height + dHeight); }\r\n            }\r\n            signalLater(cm, \"markerChanged\", cm, this$1);\r\n        });\r\n    };\r\n\r\n    TextMarker.prototype.attachLine = function (line) {\r\n        if (!this.lines.length && this.doc.cm) {\r\n            var op = this.doc.cm.curOp;\r\n            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\r\n            { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\r\n        }\r\n        this.lines.push(line);\r\n    };\r\n\r\n    TextMarker.prototype.detachLine = function (line) {\r\n        this.lines.splice(indexOf(this.lines, line), 1);\r\n        if (!this.lines.length && this.doc.cm) {\r\n            var op = this.doc.cm.curOp\r\n            ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\r\n        }\r\n    };\r\n    eventMixin(TextMarker);\r\n\r\n    // Create a marker, wire it up to the right lines, and\r\n    function markText(doc, from, to, options, type) {\r\n        // Shared markers (across linked documents) are handled separately\r\n        // (markTextShared will call out to this again, once per\r\n        // document).\r\n        if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\r\n        // Ensure we are in an operation.\r\n        if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\r\n\r\n        var marker = new TextMarker(doc, type), diff = cmp(from, to);\r\n        if (options) { copyObj(options, marker, false); }\r\n        // Don't connect empty markers unless clearWhenEmpty is false\r\n        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\r\n        { return marker }\r\n        if (marker.replacedWith) {\r\n            // Showing up as a widget implies collapsed (widget replaces text)\r\n            marker.collapsed = true;\r\n            marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\r\n            if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\r\n            if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\r\n        }\r\n        if (marker.collapsed) {\r\n            if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\r\n                from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\r\n            { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\r\n            seeCollapsedSpans();\r\n        }\r\n\r\n        if (marker.addToHistory)\r\n        { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\r\n\r\n        var curLine = from.line, cm = doc.cm, updateMaxLine;\r\n        doc.iter(curLine, to.line + 1, function (line) {\r\n            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\r\n            { updateMaxLine = true; }\r\n            if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\r\n            addMarkedSpan(line, new MarkedSpan(marker,\r\n                curLine == from.line ? from.ch : null,\r\n                curLine == to.line ? to.ch : null));\r\n            ++curLine;\r\n        });\r\n        // lineIsHidden depends on the presence of the spans, so needs a second pass\r\n        if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\r\n            if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\r\n        }); }\r\n\r\n        if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\r\n\r\n        if (marker.readOnly) {\r\n            seeReadOnlySpans();\r\n            if (doc.history.done.length || doc.history.undone.length)\r\n            { doc.clearHistory(); }\r\n        }\r\n        if (marker.collapsed) {\r\n            marker.id = ++nextMarkerId;\r\n            marker.atomic = true;\r\n        }\r\n        if (cm) {\r\n            // Sync editor state\r\n            if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\r\n            if (marker.collapsed)\r\n            { regChange(cm, from.line, to.line + 1); }\r\n            else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\r\n                marker.attributes || marker.title)\r\n            { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\r\n            if (marker.atomic) { reCheckSelection(cm.doc); }\r\n            signalLater(cm, \"markerAdded\", cm, marker);\r\n        }\r\n        return marker\r\n    }\r\n\r\n    // SHARED TEXTMARKERS\r\n\r\n    // A shared marker spans multiple linked documents. It is\r\n    // implemented as a meta-marker-object controlling multiple normal\r\n    // markers.\r\n    var SharedTextMarker = function(markers, primary) {\r\n        this.markers = markers;\r\n        this.primary = primary;\r\n        for (var i = 0; i < markers.length; ++i)\r\n        { markers[i].parent = this; }\r\n    };\r\n\r\n    SharedTextMarker.prototype.clear = function () {\r\n        if (this.explicitlyCleared) { return }\r\n        this.explicitlyCleared = true;\r\n        for (var i = 0; i < this.markers.length; ++i)\r\n        { this.markers[i].clear(); }\r\n        signalLater(this, \"clear\");\r\n    };\r\n\r\n    SharedTextMarker.prototype.find = function (side, lineObj) {\r\n        return this.primary.find(side, lineObj)\r\n    };\r\n    eventMixin(SharedTextMarker);\r\n\r\n    function markTextShared(doc, from, to, options, type) {\r\n        options = copyObj(options);\r\n        options.shared = false;\r\n        var markers = [markText(doc, from, to, options, type)], primary = markers[0];\r\n        var widget = options.widgetNode;\r\n        linkedDocs(doc, function (doc) {\r\n            if (widget) { options.widgetNode = widget.cloneNode(true); }\r\n            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\r\n            for (var i = 0; i < doc.linked.length; ++i)\r\n            { if (doc.linked[i].isParent) { return } }\r\n            primary = lst(markers);\r\n        });\r\n        return new SharedTextMarker(markers, primary)\r\n    }\r\n\r\n    function findSharedMarkers(doc) {\r\n        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\r\n    }\r\n\r\n    function copySharedMarkers(doc, markers) {\r\n        for (var i = 0; i < markers.length; i++) {\r\n            var marker = markers[i], pos = marker.find();\r\n            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\r\n            if (cmp(mFrom, mTo)) {\r\n                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\r\n                marker.markers.push(subMark);\r\n                subMark.parent = marker;\r\n            }\r\n        }\r\n    }\r\n\r\n    function detachSharedMarkers(markers) {\r\n        var loop = function ( i ) {\r\n            var marker = markers[i], linked = [marker.primary.doc];\r\n            linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\r\n            for (var j = 0; j < marker.markers.length; j++) {\r\n                var subMarker = marker.markers[j];\r\n                if (indexOf(linked, subMarker.doc) == -1) {\r\n                    subMarker.parent = null;\r\n                    marker.markers.splice(j--, 1);\r\n                }\r\n            }\r\n        };\r\n\r\n        for (var i = 0; i < markers.length; i++) loop( i );\r\n    }\r\n\r\n    var nextDocId = 0;\r\n    var Doc = function(text, mode, firstLine, lineSep, direction) {\r\n        if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\r\n        if (firstLine == null) { firstLine = 0; }\r\n\r\n        BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\r\n        this.first = firstLine;\r\n        this.scrollTop = this.scrollLeft = 0;\r\n        this.cantEdit = false;\r\n        this.cleanGeneration = 1;\r\n        this.modeFrontier = this.highlightFrontier = firstLine;\r\n        var start = Pos(firstLine, 0);\r\n        this.sel = simpleSelection(start);\r\n        this.history = new History(null);\r\n        this.id = ++nextDocId;\r\n        this.modeOption = mode;\r\n        this.lineSep = lineSep;\r\n        this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\r\n        this.extend = false;\r\n\r\n        if (typeof text == \"string\") { text = this.splitLines(text); }\r\n        updateDoc(this, {from: start, to: start, text: text});\r\n        setSelection(this, simpleSelection(start), sel_dontScroll);\r\n    };\r\n\r\n    Doc.prototype = createObj(BranchChunk.prototype, {\r\n        constructor: Doc,\r\n        // Iterate over the document. Supports two forms -- with only one\r\n        // argument, it calls that for each line in the document. With\r\n        // three, it iterates over the range given by the first two (with\r\n        // the second being non-inclusive).\r\n        iter: function(from, to, op) {\r\n            if (op) { this.iterN(from - this.first, to - from, op); }\r\n            else { this.iterN(this.first, this.first + this.size, from); }\r\n        },\r\n\r\n        // Non-public interface for adding and removing lines.\r\n        insert: function(at, lines) {\r\n            var height = 0;\r\n            for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\r\n            this.insertInner(at - this.first, lines, height);\r\n        },\r\n        remove: function(at, n) { this.removeInner(at - this.first, n); },\r\n\r\n        // From here, the methods are part of the public interface. Most\r\n        // are also available from CodeMirror (editor) instances.\r\n\r\n        getValue: function(lineSep, lineFilter) {\r\n            var lines = getLines(this, this.first, this.first + this.size, lineFilter);\r\n            if (lineSep === false) { return lines }\r\n            return lines.join(lineSep || this.lineSeparator())\r\n        },\r\n        setValue: docMethodOp(function(code) {\r\n            var top = Pos(this.first, 0), last = this.first + this.size - 1;\r\n            makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\r\n                text: this.splitLines(code), origin: \"setValue\", full: true}, true);\r\n            if (this.cm) { scrollToCoords(this.cm, 0, 0); }\r\n            setSelection(this, simpleSelection(top), sel_dontScroll);\r\n        }),\r\n        replaceRange: function(code, from, to, origin) {\r\n            from = clipPos(this, from);\r\n            to = to ? clipPos(this, to) : from;\r\n            replaceRange(this, code, from, to, origin);\r\n        },\r\n        getRange: function(from, to, lineSep) {\r\n            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\r\n            if (lineSep === false) { return lines }\r\n            return lines.join(lineSep || this.lineSeparator())\r\n        },\r\n\r\n        getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\r\n\r\n        getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\r\n        getLineNumber: function(line) {return lineNo(line)},\r\n\r\n        getLineHandleVisualStart: function(line) {\r\n            if (typeof line == \"number\") { line = getLine(this, line); }\r\n            return visualLine(line)\r\n        },\r\n\r\n        lineCount: function() {return this.size},\r\n        firstLine: function() {return this.first},\r\n        lastLine: function() {return this.first + this.size - 1},\r\n\r\n        clipPos: function(pos) {return clipPos(this, pos)},\r\n\r\n        getCursor: function(start) {\r\n            var range$$1 = this.sel.primary(), pos;\r\n            if (start == null || start == \"head\") { pos = range$$1.head; }\r\n            else if (start == \"anchor\") { pos = range$$1.anchor; }\r\n            else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\r\n            else { pos = range$$1.from(); }\r\n            return pos\r\n        },\r\n        listSelections: function() { return this.sel.ranges },\r\n        somethingSelected: function() {return this.sel.somethingSelected()},\r\n\r\n        setCursor: docMethodOp(function(line, ch, options) {\r\n            setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\r\n        }),\r\n        setSelection: docMethodOp(function(anchor, head, options) {\r\n            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\r\n        }),\r\n        extendSelection: docMethodOp(function(head, other, options) {\r\n            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\r\n        }),\r\n        extendSelections: docMethodOp(function(heads, options) {\r\n            extendSelections(this, clipPosArray(this, heads), options);\r\n        }),\r\n        extendSelectionsBy: docMethodOp(function(f, options) {\r\n            var heads = map(this.sel.ranges, f);\r\n            extendSelections(this, clipPosArray(this, heads), options);\r\n        }),\r\n        setSelections: docMethodOp(function(ranges, primary, options) {\r\n            if (!ranges.length) { return }\r\n            var out = [];\r\n            for (var i = 0; i < ranges.length; i++)\r\n            { out[i] = new Range(clipPos(this, ranges[i].anchor),\r\n                clipPos(this, ranges[i].head)); }\r\n            if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\r\n            setSelection(this, normalizeSelection(this.cm, out, primary), options);\r\n        }),\r\n        addSelection: docMethodOp(function(anchor, head, options) {\r\n            var ranges = this.sel.ranges.slice(0);\r\n            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\r\n            setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\r\n        }),\r\n\r\n        getSelection: function(lineSep) {\r\n            var ranges = this.sel.ranges, lines;\r\n            for (var i = 0; i < ranges.length; i++) {\r\n                var sel = getBetween(this, ranges[i].from(), ranges[i].to());\r\n                lines = lines ? lines.concat(sel) : sel;\r\n            }\r\n            if (lineSep === false) { return lines }\r\n            else { return lines.join(lineSep || this.lineSeparator()) }\r\n        },\r\n        getSelections: function(lineSep) {\r\n            var parts = [], ranges = this.sel.ranges;\r\n            for (var i = 0; i < ranges.length; i++) {\r\n                var sel = getBetween(this, ranges[i].from(), ranges[i].to());\r\n                if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\r\n                parts[i] = sel;\r\n            }\r\n            return parts\r\n        },\r\n        replaceSelection: function(code, collapse, origin) {\r\n            var dup = [];\r\n            for (var i = 0; i < this.sel.ranges.length; i++)\r\n            { dup[i] = code; }\r\n            this.replaceSelections(dup, collapse, origin || \"+input\");\r\n        },\r\n        replaceSelections: docMethodOp(function(code, collapse, origin) {\r\n            var changes = [], sel = this.sel;\r\n            for (var i = 0; i < sel.ranges.length; i++) {\r\n                var range$$1 = sel.ranges[i];\r\n                changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this.splitLines(code[i]), origin: origin};\r\n            }\r\n            var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\r\n            for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\r\n            { makeChange(this, changes[i$1]); }\r\n            if (newSel) { setSelectionReplaceHistory(this, newSel); }\r\n            else if (this.cm) { ensureCursorVisible(this.cm); }\r\n        }),\r\n        undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\r\n        redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\r\n        undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\r\n        redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\r\n\r\n        setExtending: function(val) {this.extend = val;},\r\n        getExtending: function() {return this.extend},\r\n\r\n        historySize: function() {\r\n            var hist = this.history, done = 0, undone = 0;\r\n            for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\r\n            for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\r\n            return {undo: done, redo: undone}\r\n        },\r\n        clearHistory: function() {this.history = new History(this.history.maxGeneration);},\r\n\r\n        markClean: function() {\r\n            this.cleanGeneration = this.changeGeneration(true);\r\n        },\r\n        changeGeneration: function(forceSplit) {\r\n            if (forceSplit)\r\n            { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\r\n            return this.history.generation\r\n        },\r\n        isClean: function (gen) {\r\n            return this.history.generation == (gen || this.cleanGeneration)\r\n        },\r\n\r\n        getHistory: function() {\r\n            return {done: copyHistoryArray(this.history.done),\r\n                undone: copyHistoryArray(this.history.undone)}\r\n        },\r\n        setHistory: function(histData) {\r\n            var hist = this.history = new History(this.history.maxGeneration);\r\n            hist.done = copyHistoryArray(histData.done.slice(0), null, true);\r\n            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\r\n        },\r\n\r\n        setGutterMarker: docMethodOp(function(line, gutterID, value) {\r\n            return changeLine(this, line, \"gutter\", function (line) {\r\n                var markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n                markers[gutterID] = value;\r\n                if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\r\n                return true\r\n            })\r\n        }),\r\n\r\n        clearGutter: docMethodOp(function(gutterID) {\r\n            var this$1 = this;\r\n\r\n            this.iter(function (line) {\r\n                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n                    changeLine(this$1, line, \"gutter\", function () {\r\n                        line.gutterMarkers[gutterID] = null;\r\n                        if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\r\n                        return true\r\n                    });\r\n                }\r\n            });\r\n        }),\r\n\r\n        lineInfo: function(line) {\r\n            var n;\r\n            if (typeof line == \"number\") {\r\n                if (!isLine(this, line)) { return null }\r\n                n = line;\r\n                line = getLine(this, line);\r\n                if (!line) { return null }\r\n            } else {\r\n                n = lineNo(line);\r\n                if (n == null) { return null }\r\n            }\r\n            return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\r\n                textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\r\n                widgets: line.widgets}\r\n        },\r\n\r\n        addLineClass: docMethodOp(function(handle, where, cls) {\r\n            return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\r\n                var prop = where == \"text\" ? \"textClass\"\r\n                    : where == \"background\" ? \"bgClass\"\r\n                        : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n                if (!line[prop]) { line[prop] = cls; }\r\n                else if (classTest(cls).test(line[prop])) { return false }\r\n                else { line[prop] += \" \" + cls; }\r\n                return true\r\n            })\r\n        }),\r\n        removeLineClass: docMethodOp(function(handle, where, cls) {\r\n            return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\r\n                var prop = where == \"text\" ? \"textClass\"\r\n                    : where == \"background\" ? \"bgClass\"\r\n                        : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\r\n                var cur = line[prop];\r\n                if (!cur) { return false }\r\n                else if (cls == null) { line[prop] = null; }\r\n                else {\r\n                    var found = cur.match(classTest(cls));\r\n                    if (!found) { return false }\r\n                    var end = found.index + found[0].length;\r\n                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\r\n                }\r\n                return true\r\n            })\r\n        }),\r\n\r\n        addLineWidget: docMethodOp(function(handle, node, options) {\r\n            return addLineWidget(this, handle, node, options)\r\n        }),\r\n        removeLineWidget: function(widget) { widget.clear(); },\r\n\r\n        markText: function(from, to, options) {\r\n            return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\r\n        },\r\n        setBookmark: function(pos, options) {\r\n            var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n                insertLeft: options && options.insertLeft,\r\n                clearWhenEmpty: false, shared: options && options.shared,\r\n                handleMouseEvents: options && options.handleMouseEvents};\r\n            pos = clipPos(this, pos);\r\n            return markText(this, pos, pos, realOpts, \"bookmark\")\r\n        },\r\n        findMarksAt: function(pos) {\r\n            pos = clipPos(this, pos);\r\n            var markers = [], spans = getLine(this, pos.line).markedSpans;\r\n            if (spans) { for (var i = 0; i < spans.length; ++i) {\r\n                var span = spans[i];\r\n                if ((span.from == null || span.from <= pos.ch) &&\r\n                    (span.to == null || span.to >= pos.ch))\r\n                { markers.push(span.marker.parent || span.marker); }\r\n            } }\r\n            return markers\r\n        },\r\n        findMarks: function(from, to, filter) {\r\n            from = clipPos(this, from); to = clipPos(this, to);\r\n            var found = [], lineNo$$1 = from.line;\r\n            this.iter(from.line, to.line + 1, function (line) {\r\n                var spans = line.markedSpans;\r\n                if (spans) { for (var i = 0; i < spans.length; i++) {\r\n                    var span = spans[i];\r\n                    if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\r\n                        span.from == null && lineNo$$1 != from.line ||\r\n                        span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\r\n                        (!filter || filter(span.marker)))\r\n                    { found.push(span.marker.parent || span.marker); }\r\n                } }\r\n                ++lineNo$$1;\r\n            });\r\n            return found\r\n        },\r\n        getAllMarks: function() {\r\n            var markers = [];\r\n            this.iter(function (line) {\r\n                var sps = line.markedSpans;\r\n                if (sps) { for (var i = 0; i < sps.length; ++i)\r\n                { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\r\n            });\r\n            return markers\r\n        },\r\n\r\n        posFromIndex: function(off) {\r\n            var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\r\n            this.iter(function (line) {\r\n                var sz = line.text.length + sepSize;\r\n                if (sz > off) { ch = off; return true }\r\n                off -= sz;\r\n                ++lineNo$$1;\r\n            });\r\n            return clipPos(this, Pos(lineNo$$1, ch))\r\n        },\r\n        indexFromPos: function (coords) {\r\n            coords = clipPos(this, coords);\r\n            var index = coords.ch;\r\n            if (coords.line < this.first || coords.ch < 0) { return 0 }\r\n            var sepSize = this.lineSeparator().length;\r\n            this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\r\n                index += line.text.length + sepSize;\r\n            });\r\n            return index\r\n        },\r\n\r\n        copy: function(copyHistory) {\r\n            var doc = new Doc(getLines(this, this.first, this.first + this.size),\r\n                this.modeOption, this.first, this.lineSep, this.direction);\r\n            doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\r\n            doc.sel = this.sel;\r\n            doc.extend = false;\r\n            if (copyHistory) {\r\n                doc.history.undoDepth = this.history.undoDepth;\r\n                doc.setHistory(this.getHistory());\r\n            }\r\n            return doc\r\n        },\r\n\r\n        linkedDoc: function(options) {\r\n            if (!options) { options = {}; }\r\n            var from = this.first, to = this.first + this.size;\r\n            if (options.from != null && options.from > from) { from = options.from; }\r\n            if (options.to != null && options.to < to) { to = options.to; }\r\n            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\r\n            if (options.sharedHist) { copy.history = this.history\r\n            ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\r\n            copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\r\n            copySharedMarkers(copy, findSharedMarkers(this));\r\n            return copy\r\n        },\r\n        unlinkDoc: function(other) {\r\n            if (other instanceof CodeMirror) { other = other.doc; }\r\n            if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\r\n                var link = this.linked[i];\r\n                if (link.doc != other) { continue }\r\n                this.linked.splice(i, 1);\r\n                other.unlinkDoc(this);\r\n                detachSharedMarkers(findSharedMarkers(this));\r\n                break\r\n            } }\r\n            // If the histories were shared, split them again\r\n            if (other.history == this.history) {\r\n                var splitIds = [other.id];\r\n                linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\r\n                other.history = new History(null);\r\n                other.history.done = copyHistoryArray(this.history.done, splitIds);\r\n                other.history.undone = copyHistoryArray(this.history.undone, splitIds);\r\n            }\r\n        },\r\n        iterLinkedDocs: function(f) {linkedDocs(this, f);},\r\n\r\n        getMode: function() {return this.mode},\r\n        getEditor: function() {return this.cm},\r\n\r\n        splitLines: function(str) {\r\n            if (this.lineSep) { return str.split(this.lineSep) }\r\n            return splitLinesAuto(str)\r\n        },\r\n        lineSeparator: function() { return this.lineSep || \"\\n\" },\r\n\r\n        setDirection: docMethodOp(function (dir) {\r\n            if (dir != \"rtl\") { dir = \"ltr\"; }\r\n            if (dir == this.direction) { return }\r\n            this.direction = dir;\r\n            this.iter(function (line) { return line.order = null; });\r\n            if (this.cm) { directionChanged(this.cm); }\r\n        })\r\n    });\r\n\r\n    // Public alias.\r\n    Doc.prototype.eachLine = Doc.prototype.iter;\r\n\r\n    // Kludge to work around strange IE behavior where it'll sometimes\r\n    // re-fire a series of drag-related events right after the drop (#1551)\r\n    var lastDrop = 0;\r\n\r\n    function onDrop(e) {\r\n        var cm = this;\r\n        clearDragCursor(cm);\r\n        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\r\n        { return }\r\n        e_preventDefault(e);\r\n        if (ie) { lastDrop = +new Date; }\r\n        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\r\n        if (!pos || cm.isReadOnly()) { return }\r\n        // Might be a file drop, in which case we simply extract the text\r\n        // and insert it.\r\n        if (files && files.length && window.FileReader && window.File) {\r\n            var n = files.length, text = Array(n), read = 0;\r\n            var loadFile = function (file, i) {\r\n                if (cm.options.allowDropFileTypes &&\r\n                    indexOf(cm.options.allowDropFileTypes, file.type) == -1)\r\n                { return }\r\n\r\n                var reader = new FileReader;\r\n                reader.onload = operation(cm, function () {\r\n                    var content = reader.result;\r\n                    if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\r\n                    text[i] = content;\r\n                    if (++read == n) {\r\n                        pos = clipPos(cm.doc, pos);\r\n                        var change = {from: pos, to: pos,\r\n                            text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\r\n                            origin: \"paste\"};\r\n                        makeChange(cm.doc, change);\r\n                        setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\r\n                    }\r\n                });\r\n                reader.readAsText(file);\r\n            };\r\n            for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\r\n        } else { // Normal drop\r\n            // Don't do a replace if the drop happened inside of the selected text.\r\n            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\r\n                cm.state.draggingText(e);\r\n                // Ensure the editor is re-focused\r\n                setTimeout(function () { return cm.display.input.focus(); }, 20);\r\n                return\r\n            }\r\n            try {\r\n                var text$1 = e.dataTransfer.getData(\"Text\");\r\n                if (text$1) {\r\n                    var selected;\r\n                    if (cm.state.draggingText && !cm.state.draggingText.copy)\r\n                    { selected = cm.listSelections(); }\r\n                    setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\r\n                    if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\r\n                    { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\r\n                    cm.replaceSelection(text$1, \"around\", \"paste\");\r\n                    cm.display.input.focus();\r\n                }\r\n            }\r\n            catch(e){}\r\n        }\r\n    }\r\n\r\n    function onDragStart(cm, e) {\r\n        if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\r\n        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\r\n\r\n        e.dataTransfer.setData(\"Text\", cm.getSelection());\r\n        e.dataTransfer.effectAllowed = \"copyMove\";\r\n\r\n        // Use dummy image instead of default browsers image.\r\n        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\r\n        if (e.dataTransfer.setDragImage && !safari) {\r\n            var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\r\n            img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\r\n            if (presto) {\r\n                img.width = img.height = 1;\r\n                cm.display.wrapper.appendChild(img);\r\n                // Force a relayout, or Opera won't use our image for some obscure reason\r\n                img._top = img.offsetTop;\r\n            }\r\n            e.dataTransfer.setDragImage(img, 0, 0);\r\n            if (presto) { img.parentNode.removeChild(img); }\r\n        }\r\n    }\r\n\r\n    function onDragOver(cm, e) {\r\n        var pos = posFromMouse(cm, e);\r\n        if (!pos) { return }\r\n        var frag = document.createDocumentFragment();\r\n        drawSelectionCursor(cm, pos, frag);\r\n        if (!cm.display.dragCursor) {\r\n            cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\r\n            cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\r\n        }\r\n        removeChildrenAndAdd(cm.display.dragCursor, frag);\r\n    }\r\n\r\n    function clearDragCursor(cm) {\r\n        if (cm.display.dragCursor) {\r\n            cm.display.lineSpace.removeChild(cm.display.dragCursor);\r\n            cm.display.dragCursor = null;\r\n        }\r\n    }\r\n\r\n    // These must be handled carefully, because naively registering a\r\n    // handler for each editor will cause the editors to never be\r\n    // garbage collected.\r\n\r\n    function forEachCodeMirror(f) {\r\n        if (!document.getElementsByClassName) { return }\r\n        var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\r\n        for (var i = 0; i < byClass.length; i++) {\r\n            var cm = byClass[i].CodeMirror;\r\n            if (cm) { editors.push(cm); }\r\n        }\r\n        if (editors.length) { editors[0].operation(function () {\r\n            for (var i = 0; i < editors.length; i++) { f(editors[i]); }\r\n        }); }\r\n    }\r\n\r\n    var globalsRegistered = false;\r\n    function ensureGlobalHandlers() {\r\n        if (globalsRegistered) { return }\r\n        registerGlobalHandlers();\r\n        globalsRegistered = true;\r\n    }\r\n    function registerGlobalHandlers() {\r\n        // When the window resizes, we need to refresh active editors.\r\n        var resizeTimer;\r\n        on(window, \"resize\", function () {\r\n            if (resizeTimer == null) { resizeTimer = setTimeout(function () {\r\n                resizeTimer = null;\r\n                forEachCodeMirror(onResize);\r\n            }, 100); }\r\n        });\r\n        // When the window loses focus, we want to show the editor as blurred\r\n        on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\r\n    }\r\n    // Called when the window resizes\r\n    function onResize(cm) {\r\n        var d = cm.display;\r\n        // Might be a text scaling operation, clear size caches.\r\n        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n        d.scrollbarsClipped = false;\r\n        cm.setSize();\r\n    }\r\n\r\n    var keyNames = {\r\n        3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\r\n        19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\r\n        36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\r\n        46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\r\n        106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\", 145: \"ScrollLock\",\r\n        173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\r\n        221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\r\n        63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\r\n    };\r\n\r\n    // Number keys\r\n    for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\r\n    // Alphabetic keys\r\n    for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\r\n    // Function keys\r\n    for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\r\n\r\n    var keyMap = {};\r\n\r\n    keyMap.basic = {\r\n        \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\r\n        \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\r\n        \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\r\n        \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\r\n        \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\r\n        \"Esc\": \"singleSelection\"\r\n    };\r\n    // Note that the save and find-related commands aren't defined by\r\n    // default. User code or addons can define them. Unknown commands\r\n    // are simply ignored.\r\n    keyMap.pcDefault = {\r\n        \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\r\n        \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\r\n        \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\r\n        \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\r\n        \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\r\n        \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\r\n        \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\r\n        \"fallthrough\": \"basic\"\r\n    };\r\n    // Very basic readline/emacs-style bindings, which are standard on Mac.\r\n    keyMap.emacsy = {\r\n        \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\r\n        \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\r\n        \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\r\n        \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\r\n        \"Ctrl-O\": \"openLine\"\r\n    };\r\n    keyMap.macDefault = {\r\n        \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\r\n        \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\r\n        \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\r\n        \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\r\n        \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\r\n        \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\r\n        \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\r\n        \"fallthrough\": [\"basic\", \"emacsy\"]\r\n    };\r\n    keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\r\n\r\n    // KEYMAP DISPATCH\r\n\r\n    function normalizeKeyName(name) {\r\n        var parts = name.split(/-(?!$)/);\r\n        name = parts[parts.length - 1];\r\n        var alt, ctrl, shift, cmd;\r\n        for (var i = 0; i < parts.length - 1; i++) {\r\n            var mod = parts[i];\r\n            if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\r\n            else if (/^a(lt)?$/i.test(mod)) { alt = true; }\r\n            else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\r\n            else if (/^s(hift)?$/i.test(mod)) { shift = true; }\r\n            else { throw new Error(\"Unrecognized modifier name: \" + mod) }\r\n        }\r\n        if (alt) { name = \"Alt-\" + name; }\r\n        if (ctrl) { name = \"Ctrl-\" + name; }\r\n        if (cmd) { name = \"Cmd-\" + name; }\r\n        if (shift) { name = \"Shift-\" + name; }\r\n        return name\r\n    }\r\n\r\n    // This is a kludge to keep keymaps mostly working as raw objects\r\n    // (backwards compatibility) while at the same time support features\r\n    // like normalization and multi-stroke key bindings. It compiles a\r\n    // new normalized keymap, and then updates the old object to reflect\r\n    // this.\r\n    function normalizeKeyMap(keymap) {\r\n        var copy = {};\r\n        for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\r\n            var value = keymap[keyname];\r\n            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\r\n            if (value == \"...\") { delete keymap[keyname]; continue }\r\n\r\n            var keys = map(keyname.split(\" \"), normalizeKeyName);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var val = (void 0), name = (void 0);\r\n                if (i == keys.length - 1) {\r\n                    name = keys.join(\" \");\r\n                    val = value;\r\n                } else {\r\n                    name = keys.slice(0, i + 1).join(\" \");\r\n                    val = \"...\";\r\n                }\r\n                var prev = copy[name];\r\n                if (!prev) { copy[name] = val; }\r\n                else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\r\n            }\r\n            delete keymap[keyname];\r\n        } }\r\n        for (var prop in copy) { keymap[prop] = copy[prop]; }\r\n        return keymap\r\n    }\r\n\r\n    function lookupKey(key, map$$1, handle, context) {\r\n        map$$1 = getKeyMap(map$$1);\r\n        var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\r\n        if (found === false) { return \"nothing\" }\r\n        if (found === \"...\") { return \"multi\" }\r\n        if (found != null && handle(found)) { return \"handled\" }\r\n\r\n        if (map$$1.fallthrough) {\r\n            if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\r\n            { return lookupKey(key, map$$1.fallthrough, handle, context) }\r\n            for (var i = 0; i < map$$1.fallthrough.length; i++) {\r\n                var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\r\n                if (result) { return result }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Modifier key presses don't count as 'real' key presses for the\r\n    // purpose of keymap fallthrough.\r\n    function isModifierKey(value) {\r\n        var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\r\n        return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\r\n    }\r\n\r\n    function addModifierNames(name, event, noShift) {\r\n        var base = name;\r\n        if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\r\n        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\r\n        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\r\n        if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\r\n        return name\r\n    }\r\n\r\n    // Look up the name of a key as indicated by an event object.\r\n    function keyName(event, noShift) {\r\n        if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\r\n        var name = keyNames[event.keyCode];\r\n        if (name == null || event.altGraphKey) { return false }\r\n        // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\r\n        // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\r\n        if (event.keyCode == 3 && event.code) { name = event.code; }\r\n        return addModifierNames(name, event, noShift)\r\n    }\r\n\r\n    function getKeyMap(val) {\r\n        return typeof val == \"string\" ? keyMap[val] : val\r\n    }\r\n\r\n    // Helper for deleting text near the selection(s), used to implement\r\n    // backspace, delete, and similar functionality.\r\n    function deleteNearSelection(cm, compute) {\r\n        var ranges = cm.doc.sel.ranges, kill = [];\r\n        // Build up a set of ranges to kill first, merging overlapping\r\n        // ranges.\r\n        for (var i = 0; i < ranges.length; i++) {\r\n            var toKill = compute(ranges[i]);\r\n            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\r\n                var replaced = kill.pop();\r\n                if (cmp(replaced.from, toKill.from) < 0) {\r\n                    toKill.from = replaced.from;\r\n                    break\r\n                }\r\n            }\r\n            kill.push(toKill);\r\n        }\r\n        // Next, remove those actual ranges.\r\n        runInOp(cm, function () {\r\n            for (var i = kill.length - 1; i >= 0; i--)\r\n            { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\r\n            ensureCursorVisible(cm);\r\n        });\r\n    }\r\n\r\n    function moveCharLogically(line, ch, dir) {\r\n        var target = skipExtendingChars(line.text, ch + dir, dir);\r\n        return target < 0 || target > line.text.length ? null : target\r\n    }\r\n\r\n    function moveLogically(line, start, dir) {\r\n        var ch = moveCharLogically(line, start.ch, dir);\r\n        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\r\n    }\r\n\r\n    function endOfLine(visually, cm, lineObj, lineNo, dir) {\r\n        if (visually) {\r\n            var order = getOrder(lineObj, cm.doc.direction);\r\n            if (order) {\r\n                var part = dir < 0 ? lst(order) : order[0];\r\n                var moveInStorageOrder = (dir < 0) == (part.level == 1);\r\n                var sticky = moveInStorageOrder ? \"after\" : \"before\";\r\n                var ch;\r\n                // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\r\n                // it could be that the last bidi part is not on the last visual line,\r\n                // since visual lines contain content order-consecutive chunks.\r\n                // Thus, in rtl, we are looking for the first (content-order) character\r\n                // in the rtl chunk that is on the last line (that is, the same line\r\n                // as the last (content-order) character).\r\n                if (part.level > 0 || cm.doc.direction == \"rtl\") {\r\n                    var prep = prepareMeasureForLine(cm, lineObj);\r\n                    ch = dir < 0 ? lineObj.text.length - 1 : 0;\r\n                    var targetTop = measureCharPrepared(cm, prep, ch).top;\r\n                    ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\r\n                    if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\r\n                } else { ch = dir < 0 ? part.to : part.from; }\r\n                return new Pos(lineNo, ch, sticky)\r\n            }\r\n        }\r\n        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\r\n    }\r\n\r\n    function moveVisually(cm, line, start, dir) {\r\n        var bidi = getOrder(line, cm.doc.direction);\r\n        if (!bidi) { return moveLogically(line, start, dir) }\r\n        if (start.ch >= line.text.length) {\r\n            start.ch = line.text.length;\r\n            start.sticky = \"before\";\r\n        } else if (start.ch <= 0) {\r\n            start.ch = 0;\r\n            start.sticky = \"after\";\r\n        }\r\n        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\r\n        if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\r\n            // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\r\n            // nothing interesting happens.\r\n            return moveLogically(line, start, dir)\r\n        }\r\n\r\n        var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\r\n        var prep;\r\n        var getWrappedLineExtent = function (ch) {\r\n            if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\r\n            prep = prep || prepareMeasureForLine(cm, line);\r\n            return wrappedLineExtentChar(cm, line, prep, ch)\r\n        };\r\n        var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\r\n\r\n        if (cm.doc.direction == \"rtl\" || part.level == 1) {\r\n            var moveInStorageOrder = (part.level == 1) == (dir < 0);\r\n            var ch = mv(start, moveInStorageOrder ? 1 : -1);\r\n            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\r\n                // Case 2: We move within an rtl part or in an rtl editor on the same visual line\r\n                var sticky = moveInStorageOrder ? \"before\" : \"after\";\r\n                return new Pos(start.line, ch, sticky)\r\n            }\r\n        }\r\n\r\n        // Case 3: Could not move within this bidi part in this visual line, so leave\r\n        // the current bidi part\r\n\r\n        var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\r\n            var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\r\n                ? new Pos(start.line, mv(ch, 1), \"before\")\r\n                : new Pos(start.line, ch, \"after\"); };\r\n\r\n            for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\r\n                var part = bidi[partPos];\r\n                var moveInStorageOrder = (dir > 0) == (part.level != 1);\r\n                var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\r\n                if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\r\n                ch = moveInStorageOrder ? part.from : mv(part.to, -1);\r\n                if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\r\n            }\r\n        };\r\n\r\n        // Case 3a: Look for other bidi parts on the same visual line\r\n        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\r\n        if (res) { return res }\r\n\r\n        // Case 3b: Look for other bidi parts on the next visual line\r\n        var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\r\n        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\r\n            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\r\n            if (res) { return res }\r\n        }\r\n\r\n        // Case 4: Nowhere to move\r\n        return null\r\n    }\r\n\r\n    // Commands are parameter-less actions that can be performed on an\r\n    // editor, mostly used for keybindings.\r\n    var commands = {\r\n        selectAll: selectAll,\r\n        singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\r\n        killLine: function (cm) { return deleteNearSelection(cm, function (range) {\r\n            if (range.empty()) {\r\n                var len = getLine(cm.doc, range.head.line).text.length;\r\n                if (range.head.ch == len && range.head.line < cm.lastLine())\r\n                { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\r\n                else\r\n                { return {from: range.head, to: Pos(range.head.line, len)} }\r\n            } else {\r\n                return {from: range.from(), to: range.to()}\r\n            }\r\n        }); },\r\n        deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\r\n            from: Pos(range.from().line, 0),\r\n            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\r\n        }); }); },\r\n        delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\r\n            from: Pos(range.from().line, 0), to: range.from()\r\n        }); }); },\r\n        delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\r\n            var top = cm.charCoords(range.head, \"div\").top + 5;\r\n            var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n            return {from: leftPos, to: range.from()}\r\n        }); },\r\n        delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\r\n            var top = cm.charCoords(range.head, \"div\").top + 5;\r\n            var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\r\n            return {from: range.from(), to: rightPos }\r\n        }); },\r\n        undo: function (cm) { return cm.undo(); },\r\n        redo: function (cm) { return cm.redo(); },\r\n        undoSelection: function (cm) { return cm.undoSelection(); },\r\n        redoSelection: function (cm) { return cm.redoSelection(); },\r\n        goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\r\n        goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\r\n        goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\r\n            {origin: \"+move\", bias: 1}\r\n        ); },\r\n        goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\r\n            {origin: \"+move\", bias: 1}\r\n        ); },\r\n        goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\r\n            {origin: \"+move\", bias: -1}\r\n        ); },\r\n        goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n            var top = cm.cursorCoords(range.head, \"div\").top + 5;\r\n            return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\r\n        }, sel_move); },\r\n        goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n            var top = cm.cursorCoords(range.head, \"div\").top + 5;\r\n            return cm.coordsChar({left: 0, top: top}, \"div\")\r\n        }, sel_move); },\r\n        goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\r\n            var top = cm.cursorCoords(range.head, \"div\").top + 5;\r\n            var pos = cm.coordsChar({left: 0, top: top}, \"div\");\r\n            if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\r\n            return pos\r\n        }, sel_move); },\r\n        goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\r\n        goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\r\n        goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\r\n        goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\r\n        goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\r\n        goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\r\n        goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\r\n        goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\r\n        goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\r\n        goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\r\n        goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\r\n        goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\r\n        delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\r\n        delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\r\n        delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\r\n        delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\r\n        delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\r\n        delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\r\n        indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\r\n        indentMore: function (cm) { return cm.indentSelection(\"add\"); },\r\n        indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\r\n        insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\r\n        insertSoftTab: function (cm) {\r\n            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\r\n            for (var i = 0; i < ranges.length; i++) {\r\n                var pos = ranges[i].from();\r\n                var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\r\n                spaces.push(spaceStr(tabSize - col % tabSize));\r\n            }\r\n            cm.replaceSelections(spaces);\r\n        },\r\n        defaultTab: function (cm) {\r\n            if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\r\n            else { cm.execCommand(\"insertTab\"); }\r\n        },\r\n        // Swap the two chars left and right of each selection's head.\r\n        // Move cursor behind the two swapped characters afterwards.\r\n        //\r\n        // Doesn't consider line feeds a character.\r\n        // Doesn't scan more than one line above to find a character.\r\n        // Doesn't do anything on an empty line.\r\n        // Doesn't do anything with non-empty selections.\r\n        transposeChars: function (cm) { return runInOp(cm, function () {\r\n            var ranges = cm.listSelections(), newSel = [];\r\n            for (var i = 0; i < ranges.length; i++) {\r\n                if (!ranges[i].empty()) { continue }\r\n                var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\r\n                if (line) {\r\n                    if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\r\n                    if (cur.ch > 0) {\r\n                        cur = new Pos(cur.line, cur.ch + 1);\r\n                        cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\r\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\r\n                    } else if (cur.line > cm.doc.first) {\r\n                        var prev = getLine(cm.doc, cur.line - 1).text;\r\n                        if (prev) {\r\n                            cur = new Pos(cur.line, 1);\r\n                            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\r\n                                prev.charAt(prev.length - 1),\r\n                                Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\r\n                        }\r\n                    }\r\n                }\r\n                newSel.push(new Range(cur, cur));\r\n            }\r\n            cm.setSelections(newSel);\r\n        }); },\r\n        newlineAndIndent: function (cm) { return runInOp(cm, function () {\r\n            var sels = cm.listSelections();\r\n            for (var i = sels.length - 1; i >= 0; i--)\r\n            { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\r\n            sels = cm.listSelections();\r\n            for (var i$1 = 0; i$1 < sels.length; i$1++)\r\n            { cm.indentLine(sels[i$1].from().line, null, true); }\r\n            ensureCursorVisible(cm);\r\n        }); },\r\n        openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\r\n        toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\r\n    };\r\n\r\n\r\n    function lineStart(cm, lineN) {\r\n        var line = getLine(cm.doc, lineN);\r\n        var visual = visualLine(line);\r\n        if (visual != line) { lineN = lineNo(visual); }\r\n        return endOfLine(true, cm, visual, lineN, 1)\r\n    }\r\n    function lineEnd(cm, lineN) {\r\n        var line = getLine(cm.doc, lineN);\r\n        var visual = visualLineEnd(line);\r\n        if (visual != line) { lineN = lineNo(visual); }\r\n        return endOfLine(true, cm, line, lineN, -1)\r\n    }\r\n    function lineStartSmart(cm, pos) {\r\n        var start = lineStart(cm, pos.line);\r\n        var line = getLine(cm.doc, start.line);\r\n        var order = getOrder(line, cm.doc.direction);\r\n        if (!order || order[0].level == 0) {\r\n            var firstNonWS = Math.max(0, line.text.search(/\\S/));\r\n            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\r\n            return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\r\n        }\r\n        return start\r\n    }\r\n\r\n    // Run a handler that was bound to a key.\r\n    function doHandleBinding(cm, bound, dropShift) {\r\n        if (typeof bound == \"string\") {\r\n            bound = commands[bound];\r\n            if (!bound) { return false }\r\n        }\r\n        // Ensure previous input has been read, so that the handler sees a\r\n        // consistent view of the document\r\n        cm.display.input.ensurePolled();\r\n        var prevShift = cm.display.shift, done = false;\r\n        try {\r\n            if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\r\n            if (dropShift) { cm.display.shift = false; }\r\n            done = bound(cm) != Pass;\r\n        } finally {\r\n            cm.display.shift = prevShift;\r\n            cm.state.suppressEdits = false;\r\n        }\r\n        return done\r\n    }\r\n\r\n    function lookupKeyForEditor(cm, name, handle) {\r\n        for (var i = 0; i < cm.state.keyMaps.length; i++) {\r\n            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\r\n            if (result) { return result }\r\n        }\r\n        return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\r\n            || lookupKey(name, cm.options.keyMap, handle, cm)\r\n    }\r\n\r\n    // Note that, despite the name, this function is also used to check\r\n    // for bound mouse clicks.\r\n\r\n    var stopSeq = new Delayed;\r\n\r\n    function dispatchKey(cm, name, e, handle) {\r\n        var seq = cm.state.keySeq;\r\n        if (seq) {\r\n            if (isModifierKey(name)) { return \"handled\" }\r\n            if (/\\'$/.test(name))\r\n            { cm.state.keySeq = null; }\r\n            else\r\n            { stopSeq.set(50, function () {\r\n                if (cm.state.keySeq == seq) {\r\n                    cm.state.keySeq = null;\r\n                    cm.display.input.reset();\r\n                }\r\n            }); }\r\n            if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\r\n        }\r\n        return dispatchKeyInner(cm, name, e, handle)\r\n    }\r\n\r\n    function dispatchKeyInner(cm, name, e, handle) {\r\n        var result = lookupKeyForEditor(cm, name, handle);\r\n\r\n        if (result == \"multi\")\r\n        { cm.state.keySeq = name; }\r\n        if (result == \"handled\")\r\n        { signalLater(cm, \"keyHandled\", cm, name, e); }\r\n\r\n        if (result == \"handled\" || result == \"multi\") {\r\n            e_preventDefault(e);\r\n            restartBlink(cm);\r\n        }\r\n\r\n        return !!result\r\n    }\r\n\r\n    // Handle a key from the keydown event.\r\n    function handleKeyBinding(cm, e) {\r\n        var name = keyName(e, true);\r\n        if (!name) { return false }\r\n\r\n        if (e.shiftKey && !cm.state.keySeq) {\r\n            // First try to resolve full name (including 'Shift-'). Failing\r\n            // that, see if there is a cursor-motion command (starting with\r\n            // 'go') bound to the keyname without 'Shift-'.\r\n            return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\r\n                || dispatchKey(cm, name, e, function (b) {\r\n                    if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\r\n                    { return doHandleBinding(cm, b) }\r\n                })\r\n        } else {\r\n            return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\r\n        }\r\n    }\r\n\r\n    // Handle a key from the keypress event\r\n    function handleCharBinding(cm, e, ch) {\r\n        return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\r\n    }\r\n\r\n    var lastStoppedKey = null;\r\n    function onKeyDown(e) {\r\n        var cm = this;\r\n        cm.curOp.focus = activeElt();\r\n        if (signalDOMEvent(cm, e)) { return }\r\n        // IE does strange things with escape.\r\n        if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\r\n        var code = e.keyCode;\r\n        cm.display.shift = code == 16 || e.shiftKey;\r\n        var handled = handleKeyBinding(cm, e);\r\n        if (presto) {\r\n            lastStoppedKey = handled ? code : null;\r\n            // Opera has no cut event... we try to at least catch the key combo\r\n            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\r\n            { cm.replaceSelection(\"\", null, \"cut\"); }\r\n        }\r\n\r\n        // Turn mouse into crosshair when Alt is held on Mac.\r\n        if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\r\n        { showCrossHair(cm); }\r\n    }\r\n\r\n    function showCrossHair(cm) {\r\n        var lineDiv = cm.display.lineDiv;\r\n        addClass(lineDiv, \"CodeMirror-crosshair\");\r\n\r\n        function up(e) {\r\n            if (e.keyCode == 18 || !e.altKey) {\r\n                rmClass(lineDiv, \"CodeMirror-crosshair\");\r\n                off(document, \"keyup\", up);\r\n                off(document, \"mouseover\", up);\r\n            }\r\n        }\r\n        on(document, \"keyup\", up);\r\n        on(document, \"mouseover\", up);\r\n    }\r\n\r\n    function onKeyUp(e) {\r\n        if (e.keyCode == 16) { this.doc.sel.shift = false; }\r\n        signalDOMEvent(this, e);\r\n    }\r\n\r\n    function onKeyPress(e) {\r\n        var cm = this;\r\n        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\r\n        var keyCode = e.keyCode, charCode = e.charCode;\r\n        if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\r\n        if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\r\n        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\r\n        // Some browsers fire keypress events for backspace\r\n        if (ch == \"\\x08\") { return }\r\n        if (handleCharBinding(cm, e, ch)) { return }\r\n        cm.display.input.onKeyPress(e);\r\n    }\r\n\r\n    var DOUBLECLICK_DELAY = 400;\r\n\r\n    var PastClick = function(time, pos, button) {\r\n        this.time = time;\r\n        this.pos = pos;\r\n        this.button = button;\r\n    };\r\n\r\n    PastClick.prototype.compare = function (time, pos, button) {\r\n        return this.time + DOUBLECLICK_DELAY > time &&\r\n            cmp(pos, this.pos) == 0 && button == this.button\r\n    };\r\n\r\n    var lastClick, lastDoubleClick;\r\n    function clickRepeat(pos, button) {\r\n        var now = +new Date;\r\n        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\r\n            lastClick = lastDoubleClick = null;\r\n            return \"triple\"\r\n        } else if (lastClick && lastClick.compare(now, pos, button)) {\r\n            lastDoubleClick = new PastClick(now, pos, button);\r\n            lastClick = null;\r\n            return \"double\"\r\n        } else {\r\n            lastClick = new PastClick(now, pos, button);\r\n            lastDoubleClick = null;\r\n            return \"single\"\r\n        }\r\n    }\r\n\r\n    // A mouse down can be a single click, double click, triple click,\r\n    // start of selection drag, start of text drag, new cursor\r\n    // (ctrl-click), rectangle drag (alt-drag), or xwin\r\n    // middle-click-paste. Or it might be a click on something we should\r\n    // not interfere with, such as a scrollbar or widget.\r\n    function onMouseDown(e) {\r\n        var cm = this, display = cm.display;\r\n        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\r\n        display.input.ensurePolled();\r\n        display.shift = e.shiftKey;\r\n\r\n        if (eventInWidget(display, e)) {\r\n            if (!webkit) {\r\n                // Briefly turn off draggability, to allow widgets to do\r\n                // normal dragging things.\r\n                display.scroller.draggable = false;\r\n                setTimeout(function () { return display.scroller.draggable = true; }, 100);\r\n            }\r\n            return\r\n        }\r\n        if (clickInGutter(cm, e)) { return }\r\n        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\r\n        window.focus();\r\n\r\n        // #3261: make sure, that we're not starting a second selection\r\n        if (button == 1 && cm.state.selectingText)\r\n        { cm.state.selectingText(e); }\r\n\r\n        if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\r\n\r\n        if (button == 1) {\r\n            if (pos) { leftButtonDown(cm, pos, repeat, e); }\r\n            else if (e_target(e) == display.scroller) { e_preventDefault(e); }\r\n        } else if (button == 2) {\r\n            if (pos) { extendSelection(cm.doc, pos); }\r\n            setTimeout(function () { return display.input.focus(); }, 20);\r\n        } else if (button == 3) {\r\n            if (captureRightClick) { cm.display.input.onContextMenu(e); }\r\n            else { delayBlurEvent(cm); }\r\n        }\r\n    }\r\n\r\n    function handleMappedButton(cm, button, pos, repeat, event) {\r\n        var name = \"Click\";\r\n        if (repeat == \"double\") { name = \"Double\" + name; }\r\n        else if (repeat == \"triple\") { name = \"Triple\" + name; }\r\n        name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\r\n\r\n        return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\r\n            if (typeof bound == \"string\") { bound = commands[bound]; }\r\n            if (!bound) { return false }\r\n            var done = false;\r\n            try {\r\n                if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\r\n                done = bound(cm, pos) != Pass;\r\n            } finally {\r\n                cm.state.suppressEdits = false;\r\n            }\r\n            return done\r\n        })\r\n    }\r\n\r\n    function configureMouse(cm, repeat, event) {\r\n        var option = cm.getOption(\"configureMouse\");\r\n        var value = option ? option(cm, repeat, event) : {};\r\n        if (value.unit == null) {\r\n            var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\r\n            value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\r\n        }\r\n        if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\r\n        if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\r\n        if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\r\n        return value\r\n    }\r\n\r\n    function leftButtonDown(cm, pos, repeat, event) {\r\n        if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\r\n        else { cm.curOp.focus = activeElt(); }\r\n\r\n        var behavior = configureMouse(cm, repeat, event);\r\n\r\n        var sel = cm.doc.sel, contained;\r\n        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\r\n            repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\r\n            (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\r\n            (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\r\n        { leftButtonStartDrag(cm, event, pos, behavior); }\r\n        else\r\n        { leftButtonSelect(cm, event, pos, behavior); }\r\n    }\r\n\r\n    // Start a text drag. When it ends, see if any dragging actually\r\n    // happen, and treat as a click if it didn't.\r\n    function leftButtonStartDrag(cm, event, pos, behavior) {\r\n        var display = cm.display, moved = false;\r\n        var dragEnd = operation(cm, function (e) {\r\n            if (webkit) { display.scroller.draggable = false; }\r\n            cm.state.draggingText = false;\r\n            off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\r\n            off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\r\n            off(display.scroller, \"dragstart\", dragStart);\r\n            off(display.scroller, \"drop\", dragEnd);\r\n            if (!moved) {\r\n                e_preventDefault(e);\r\n                if (!behavior.addNew)\r\n                { extendSelection(cm.doc, pos, null, null, behavior.extend); }\r\n                // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\r\n                if (webkit || ie && ie_version == 9)\r\n                { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }\r\n                else\r\n                { display.input.focus(); }\r\n            }\r\n        });\r\n        var mouseMove = function(e2) {\r\n            moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\r\n        };\r\n        var dragStart = function () { return moved = true; };\r\n        // Let the drag handler handle this.\r\n        if (webkit) { display.scroller.draggable = true; }\r\n        cm.state.draggingText = dragEnd;\r\n        dragEnd.copy = !behavior.moveOnDrag;\r\n        // IE's approach to draggable\r\n        if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\r\n        on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\r\n        on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\r\n        on(display.scroller, \"dragstart\", dragStart);\r\n        on(display.scroller, \"drop\", dragEnd);\r\n\r\n        delayBlurEvent(cm);\r\n        setTimeout(function () { return display.input.focus(); }, 20);\r\n    }\r\n\r\n    function rangeForUnit(cm, pos, unit) {\r\n        if (unit == \"char\") { return new Range(pos, pos) }\r\n        if (unit == \"word\") { return cm.findWordAt(pos) }\r\n        if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\r\n        var result = unit(cm, pos);\r\n        return new Range(result.from, result.to)\r\n    }\r\n\r\n    // Normal selection, as opposed to text dragging.\r\n    function leftButtonSelect(cm, event, start, behavior) {\r\n        var display = cm.display, doc = cm.doc;\r\n        e_preventDefault(event);\r\n\r\n        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\r\n        if (behavior.addNew && !behavior.extend) {\r\n            ourIndex = doc.sel.contains(start);\r\n            if (ourIndex > -1)\r\n            { ourRange = ranges[ourIndex]; }\r\n            else\r\n            { ourRange = new Range(start, start); }\r\n        } else {\r\n            ourRange = doc.sel.primary();\r\n            ourIndex = doc.sel.primIndex;\r\n        }\r\n\r\n        if (behavior.unit == \"rectangle\") {\r\n            if (!behavior.addNew) { ourRange = new Range(start, start); }\r\n            start = posFromMouse(cm, event, true, true);\r\n            ourIndex = -1;\r\n        } else {\r\n            var range$$1 = rangeForUnit(cm, start, behavior.unit);\r\n            if (behavior.extend)\r\n            { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\r\n            else\r\n            { ourRange = range$$1; }\r\n        }\r\n\r\n        if (!behavior.addNew) {\r\n            ourIndex = 0;\r\n            setSelection(doc, new Selection([ourRange], 0), sel_mouse);\r\n            startSel = doc.sel;\r\n        } else if (ourIndex == -1) {\r\n            ourIndex = ranges.length;\r\n            setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\r\n                {scroll: false, origin: \"*mouse\"});\r\n        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\r\n            setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\r\n                {scroll: false, origin: \"*mouse\"});\r\n            startSel = doc.sel;\r\n        } else {\r\n            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\r\n        }\r\n\r\n        var lastPos = start;\r\n        function extendTo(pos) {\r\n            if (cmp(lastPos, pos) == 0) { return }\r\n            lastPos = pos;\r\n\r\n            if (behavior.unit == \"rectangle\") {\r\n                var ranges = [], tabSize = cm.options.tabSize;\r\n                var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\r\n                var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\r\n                var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\r\n                for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\r\n                     line <= end; line++) {\r\n                    var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\r\n                    if (left == right)\r\n                    { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\r\n                    else if (text.length > leftPos)\r\n                    { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\r\n                }\r\n                if (!ranges.length) { ranges.push(new Range(start, start)); }\r\n                setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\r\n                    {origin: \"*mouse\", scroll: false});\r\n                cm.scrollIntoView(pos);\r\n            } else {\r\n                var oldRange = ourRange;\r\n                var range$$1 = rangeForUnit(cm, pos, behavior.unit);\r\n                var anchor = oldRange.anchor, head;\r\n                if (cmp(range$$1.anchor, anchor) > 0) {\r\n                    head = range$$1.head;\r\n                    anchor = minPos(oldRange.from(), range$$1.anchor);\r\n                } else {\r\n                    head = range$$1.anchor;\r\n                    anchor = maxPos(oldRange.to(), range$$1.head);\r\n                }\r\n                var ranges$1 = startSel.ranges.slice(0);\r\n                ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\r\n                setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\r\n            }\r\n        }\r\n\r\n        var editorSize = display.wrapper.getBoundingClientRect();\r\n        // Used to ensure timeout re-tries don't fire when another extend\r\n        // happened in the meantime (clearTimeout isn't reliable -- at\r\n        // least on Chrome, the timeouts still happen even when cleared,\r\n        // if the clear happens after their scheduled firing time).\r\n        var counter = 0;\r\n\r\n        function extend(e) {\r\n            var curCount = ++counter;\r\n            var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\r\n            if (!cur) { return }\r\n            if (cmp(cur, lastPos) != 0) {\r\n                cm.curOp.focus = activeElt();\r\n                extendTo(cur);\r\n                var visible = visibleLines(display, doc);\r\n                if (cur.line >= visible.to || cur.line < visible.from)\r\n                { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\r\n            } else {\r\n                var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\r\n                if (outside) { setTimeout(operation(cm, function () {\r\n                    if (counter != curCount) { return }\r\n                    display.scroller.scrollTop += outside;\r\n                    extend(e);\r\n                }), 50); }\r\n            }\r\n        }\r\n\r\n        function done(e) {\r\n            cm.state.selectingText = false;\r\n            counter = Infinity;\r\n            e_preventDefault(e);\r\n            display.input.focus();\r\n            off(display.wrapper.ownerDocument, \"mousemove\", move);\r\n            off(display.wrapper.ownerDocument, \"mouseup\", up);\r\n            doc.history.lastSelOrigin = null;\r\n        }\r\n\r\n        var move = operation(cm, function (e) {\r\n            if (e.buttons === 0 || !e_button(e)) { done(e); }\r\n            else { extend(e); }\r\n        });\r\n        var up = operation(cm, done);\r\n        cm.state.selectingText = up;\r\n        on(display.wrapper.ownerDocument, \"mousemove\", move);\r\n        on(display.wrapper.ownerDocument, \"mouseup\", up);\r\n    }\r\n\r\n    // Used when mouse-selecting to adjust the anchor to the proper side\r\n    // of a bidi jump depending on the visual position of the head.\r\n    function bidiSimplify(cm, range$$1) {\r\n        var anchor = range$$1.anchor;\r\n        var head = range$$1.head;\r\n        var anchorLine = getLine(cm.doc, anchor.line);\r\n        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\r\n        var order = getOrder(anchorLine);\r\n        if (!order) { return range$$1 }\r\n        var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\r\n        if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\r\n        var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\r\n        if (boundary == 0 || boundary == order.length) { return range$$1 }\r\n\r\n        // Compute the relative visual position of the head compared to the\r\n        // anchor (<0 is to the left, >0 to the right)\r\n        var leftSide;\r\n        if (head.line != anchor.line) {\r\n            leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\r\n        } else {\r\n            var headIndex = getBidiPartAt(order, head.ch, head.sticky);\r\n            var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\r\n            if (headIndex == boundary - 1 || headIndex == boundary)\r\n            { leftSide = dir < 0; }\r\n            else\r\n            { leftSide = dir > 0; }\r\n        }\r\n\r\n        var usePart = order[boundary + (leftSide ? -1 : 0)];\r\n        var from = leftSide == (usePart.level == 1);\r\n        var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\r\n        return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\r\n    }\r\n\r\n\r\n    // Determines whether an event happened in the gutter, and fires the\r\n    // handlers for the corresponding event.\r\n    function gutterEvent(cm, e, type, prevent) {\r\n        var mX, mY;\r\n        if (e.touches) {\r\n            mX = e.touches[0].clientX;\r\n            mY = e.touches[0].clientY;\r\n        } else {\r\n            try { mX = e.clientX; mY = e.clientY; }\r\n            catch(e) { return false }\r\n        }\r\n        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\r\n        if (prevent) { e_preventDefault(e); }\r\n\r\n        var display = cm.display;\r\n        var lineBox = display.lineDiv.getBoundingClientRect();\r\n\r\n        if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\r\n        mY -= lineBox.top - display.viewOffset;\r\n\r\n        for (var i = 0; i < cm.options.gutters.length; ++i) {\r\n            var g = display.gutters.childNodes[i];\r\n            if (g && g.getBoundingClientRect().right >= mX) {\r\n                var line = lineAtHeight(cm.doc, mY);\r\n                var gutter = cm.options.gutters[i];\r\n                signal(cm, type, cm, line, gutter, e);\r\n                return e_defaultPrevented(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    function clickInGutter(cm, e) {\r\n        return gutterEvent(cm, e, \"gutterClick\", true)\r\n    }\r\n\r\n    // CONTEXT MENU HANDLING\r\n\r\n    // To make the context menu work, we need to briefly unhide the\r\n    // textarea (making it as unobtrusive as possible) to let the\r\n    // right-click take effect on it.\r\n    function onContextMenu(cm, e) {\r\n        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\r\n        if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\r\n        if (!captureRightClick) { cm.display.input.onContextMenu(e); }\r\n    }\r\n\r\n    function contextMenuInGutter(cm, e) {\r\n        if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\r\n        return gutterEvent(cm, e, \"gutterContextMenu\", false)\r\n    }\r\n\r\n    function themeChanged(cm) {\r\n        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\r\n            cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\r\n        clearCaches(cm);\r\n    }\r\n\r\n    var Init = {toString: function(){return \"CodeMirror.Init\"}};\r\n\r\n    var defaults = {};\r\n    var optionHandlers = {};\r\n\r\n    function defineOptions(CodeMirror) {\r\n        var optionHandlers = CodeMirror.optionHandlers;\r\n\r\n        function option(name, deflt, handle, notOnInit) {\r\n            CodeMirror.defaults[name] = deflt;\r\n            if (handle) { optionHandlers[name] =\r\n                notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\r\n        }\r\n\r\n        CodeMirror.defineOption = option;\r\n\r\n        // Passed to option handlers when there is no old value.\r\n        CodeMirror.Init = Init;\r\n\r\n        // These two are, on init, called from the constructor because they\r\n        // have to be initialized before the editor can start at all.\r\n        option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\r\n        option(\"mode\", null, function (cm, val) {\r\n            cm.doc.modeOption = val;\r\n            loadMode(cm);\r\n        }, true);\r\n\r\n        option(\"indentUnit\", 2, loadMode, true);\r\n        option(\"indentWithTabs\", false);\r\n        option(\"smartIndent\", true);\r\n        option(\"tabSize\", 4, function (cm) {\r\n            resetModeState(cm);\r\n            clearCaches(cm);\r\n            regChange(cm);\r\n        }, true);\r\n\r\n        option(\"lineSeparator\", null, function (cm, val) {\r\n            cm.doc.lineSep = val;\r\n            if (!val) { return }\r\n            var newBreaks = [], lineNo = cm.doc.first;\r\n            cm.doc.iter(function (line) {\r\n                for (var pos = 0;;) {\r\n                    var found = line.text.indexOf(val, pos);\r\n                    if (found == -1) { break }\r\n                    pos = found + val.length;\r\n                    newBreaks.push(Pos(lineNo, found));\r\n                }\r\n                lineNo++;\r\n            });\r\n            for (var i = newBreaks.length - 1; i >= 0; i--)\r\n            { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\r\n        });\r\n        option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\r\n            cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\r\n            if (old != Init) { cm.refresh(); }\r\n        });\r\n        option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\r\n        option(\"electricChars\", true);\r\n        option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\r\n            throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\r\n        }, true);\r\n        option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\r\n        option(\"rtlMoveVisually\", !windows);\r\n        option(\"wholeLineUpdateBefore\", true);\r\n\r\n        option(\"theme\", \"default\", function (cm) {\r\n            themeChanged(cm);\r\n            guttersChanged(cm);\r\n        }, true);\r\n        option(\"keyMap\", \"default\", function (cm, val, old) {\r\n            var next = getKeyMap(val);\r\n            var prev = old != Init && getKeyMap(old);\r\n            if (prev && prev.detach) { prev.detach(cm, next); }\r\n            if (next.attach) { next.attach(cm, prev || null); }\r\n        });\r\n        option(\"extraKeys\", null);\r\n        option(\"configureMouse\", null);\r\n\r\n        option(\"lineWrapping\", false, wrappingChanged, true);\r\n        option(\"gutters\", [], function (cm) {\r\n            setGuttersForLineNumbers(cm.options);\r\n            guttersChanged(cm);\r\n        }, true);\r\n        option(\"fixedGutter\", true, function (cm, val) {\r\n            cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\r\n            cm.refresh();\r\n        }, true);\r\n        option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\r\n        option(\"scrollbarStyle\", \"native\", function (cm) {\r\n            initScrollbars(cm);\r\n            updateScrollbars(cm);\r\n            cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\r\n            cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\r\n        }, true);\r\n        option(\"lineNumbers\", false, function (cm) {\r\n            setGuttersForLineNumbers(cm.options);\r\n            guttersChanged(cm);\r\n        }, true);\r\n        option(\"firstLineNumber\", 1, guttersChanged, true);\r\n        option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\r\n        option(\"showCursorWhenSelecting\", false, updateSelection, true);\r\n\r\n        option(\"resetSelectionOnContextMenu\", true);\r\n        option(\"lineWiseCopyCut\", true);\r\n        option(\"pasteLinesPerSelection\", true);\r\n        option(\"selectionsMayTouch\", false);\r\n\r\n        option(\"readOnly\", false, function (cm, val) {\r\n            if (val == \"nocursor\") {\r\n                onBlur(cm);\r\n                cm.display.input.blur();\r\n            }\r\n            cm.display.input.readOnlyChanged(val);\r\n        });\r\n        option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\r\n        option(\"dragDrop\", true, dragDropChanged);\r\n        option(\"allowDropFileTypes\", null);\r\n\r\n        option(\"cursorBlinkRate\", 530);\r\n        option(\"cursorScrollMargin\", 0);\r\n        option(\"cursorHeight\", 1, updateSelection, true);\r\n        option(\"singleCursorHeightPerLine\", true, updateSelection, true);\r\n        option(\"workTime\", 100);\r\n        option(\"workDelay\", 100);\r\n        option(\"flattenSpans\", true, resetModeState, true);\r\n        option(\"addModeClass\", false, resetModeState, true);\r\n        option(\"pollInterval\", 100);\r\n        option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\r\n        option(\"historyEventDelay\", 1250);\r\n        option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\r\n        option(\"maxHighlightLength\", 10000, resetModeState, true);\r\n        option(\"moveInputWithCursor\", true, function (cm, val) {\r\n            if (!val) { cm.display.input.resetPosition(); }\r\n        });\r\n\r\n        option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\r\n        option(\"autofocus\", null);\r\n        option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\r\n        option(\"phrases\", null);\r\n    }\r\n\r\n    function guttersChanged(cm) {\r\n        updateGutters(cm);\r\n        regChange(cm);\r\n        alignHorizontally(cm);\r\n    }\r\n\r\n    function dragDropChanged(cm, value, old) {\r\n        var wasOn = old && old != Init;\r\n        if (!value != !wasOn) {\r\n            var funcs = cm.display.dragFunctions;\r\n            var toggle = value ? on : off;\r\n            toggle(cm.display.scroller, \"dragstart\", funcs.start);\r\n            toggle(cm.display.scroller, \"dragenter\", funcs.enter);\r\n            toggle(cm.display.scroller, \"dragover\", funcs.over);\r\n            toggle(cm.display.scroller, \"dragleave\", funcs.leave);\r\n            toggle(cm.display.scroller, \"drop\", funcs.drop);\r\n        }\r\n    }\r\n\r\n    function wrappingChanged(cm) {\r\n        if (cm.options.lineWrapping) {\r\n            addClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n            cm.display.sizer.style.minWidth = \"\";\r\n            cm.display.sizerWidth = null;\r\n        } else {\r\n            rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\r\n            findMaxLine(cm);\r\n        }\r\n        estimateLineHeights(cm);\r\n        regChange(cm);\r\n        clearCaches(cm);\r\n        setTimeout(function () { return updateScrollbars(cm); }, 100);\r\n    }\r\n\r\n    // A CodeMirror instance represents an editor. This is the object\r\n    // that user code is usually dealing with.\r\n\r\n    function CodeMirror(place, options) {\r\n        var this$1 = this;\r\n\r\n        if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\r\n\r\n        this.options = options = options ? copyObj(options) : {};\r\n        // Determine effective options based on given values and defaults.\r\n        copyObj(defaults, options, false);\r\n        setGuttersForLineNumbers(options);\r\n\r\n        var doc = options.value;\r\n        if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\r\n        else if (options.mode) { doc.modeOption = options.mode; }\r\n        this.doc = doc;\r\n\r\n        var input = new CodeMirror.inputStyles[options.inputStyle](this);\r\n        var display = this.display = new Display(place, doc, input);\r\n        display.wrapper.CodeMirror = this;\r\n        updateGutters(this);\r\n        themeChanged(this);\r\n        if (options.lineWrapping)\r\n        { this.display.wrapper.className += \" CodeMirror-wrap\"; }\r\n        initScrollbars(this);\r\n\r\n        this.state = {\r\n            keyMaps: [],  // stores maps added by addKeyMap\r\n            overlays: [], // highlighting overlays, as added by addOverlay\r\n            modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\r\n            overwrite: false,\r\n            delayingBlurEvent: false,\r\n            focused: false,\r\n            suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\r\n            pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\r\n            selectingText: false,\r\n            draggingText: false,\r\n            highlight: new Delayed(), // stores highlight worker timeout\r\n            keySeq: null,  // Unfinished key sequence\r\n            specialChars: null\r\n        };\r\n\r\n        if (options.autofocus && !mobile) { display.input.focus(); }\r\n\r\n        // Override magic textarea content restore that IE sometimes does\r\n        // on our hidden textarea on reload\r\n        if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\r\n\r\n        registerEventHandlers(this);\r\n        ensureGlobalHandlers();\r\n\r\n        startOperation(this);\r\n        this.curOp.forceUpdate = true;\r\n        attachDoc(this, doc);\r\n\r\n        if ((options.autofocus && !mobile) || this.hasFocus())\r\n        { setTimeout(bind(onFocus, this), 20); }\r\n        else\r\n        { onBlur(this); }\r\n\r\n        for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\r\n        { optionHandlers[opt](this, options[opt], Init); } }\r\n        maybeUpdateLineNumberWidth(this);\r\n        if (options.finishInit) { options.finishInit(this); }\r\n        for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\r\n        endOperation(this);\r\n        // Suppress optimizelegibility in Webkit, since it breaks text\r\n        // measuring on line wrapping boundaries.\r\n        if (webkit && options.lineWrapping &&\r\n            getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\r\n        { display.lineDiv.style.textRendering = \"auto\"; }\r\n    }\r\n\r\n    // The default configuration options.\r\n    CodeMirror.defaults = defaults;\r\n    // Functions to run when options are changed.\r\n    CodeMirror.optionHandlers = optionHandlers;\r\n\r\n    // Attach the necessary event handlers when initializing the editor\r\n    function registerEventHandlers(cm) {\r\n        var d = cm.display;\r\n        on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\r\n        // Older IE's will not fire a second mousedown for a double click\r\n        if (ie && ie_version < 11)\r\n        { on(d.scroller, \"dblclick\", operation(cm, function (e) {\r\n            if (signalDOMEvent(cm, e)) { return }\r\n            var pos = posFromMouse(cm, e);\r\n            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\r\n            e_preventDefault(e);\r\n            var word = cm.findWordAt(pos);\r\n            extendSelection(cm.doc, word.anchor, word.head);\r\n        })); }\r\n        else\r\n        { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\r\n        // Some browsers fire contextmenu *after* opening the menu, at\r\n        // which point we can't mess with it anymore. Context menu is\r\n        // handled in onMouseDown for these browsers.\r\n        on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\r\n\r\n        // Used to suppress mouse event handling when a touch happens\r\n        var touchFinished, prevTouch = {end: 0};\r\n        function finishTouch() {\r\n            if (d.activeTouch) {\r\n                touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\r\n                prevTouch = d.activeTouch;\r\n                prevTouch.end = +new Date;\r\n            }\r\n        }\r\n        function isMouseLikeTouchEvent(e) {\r\n            if (e.touches.length != 1) { return false }\r\n            var touch = e.touches[0];\r\n            return touch.radiusX <= 1 && touch.radiusY <= 1\r\n        }\r\n        function farAway(touch, other) {\r\n            if (other.left == null) { return true }\r\n            var dx = other.left - touch.left, dy = other.top - touch.top;\r\n            return dx * dx + dy * dy > 20 * 20\r\n        }\r\n        on(d.scroller, \"touchstart\", function (e) {\r\n            if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\r\n                d.input.ensurePolled();\r\n                clearTimeout(touchFinished);\r\n                var now = +new Date;\r\n                d.activeTouch = {start: now, moved: false,\r\n                    prev: now - prevTouch.end <= 300 ? prevTouch : null};\r\n                if (e.touches.length == 1) {\r\n                    d.activeTouch.left = e.touches[0].pageX;\r\n                    d.activeTouch.top = e.touches[0].pageY;\r\n                }\r\n            }\r\n        });\r\n        on(d.scroller, \"touchmove\", function () {\r\n            if (d.activeTouch) { d.activeTouch.moved = true; }\r\n        });\r\n        on(d.scroller, \"touchend\", function (e) {\r\n            var touch = d.activeTouch;\r\n            if (touch && !eventInWidget(d, e) && touch.left != null &&\r\n                !touch.moved && new Date - touch.start < 300) {\r\n                var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\r\n                if (!touch.prev || farAway(touch, touch.prev)) // Single tap\r\n                { range = new Range(pos, pos); }\r\n                else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\r\n                { range = cm.findWordAt(pos); }\r\n                else // Triple tap\r\n                { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\r\n                cm.setSelection(range.anchor, range.head);\r\n                cm.focus();\r\n                e_preventDefault(e);\r\n            }\r\n            finishTouch();\r\n        });\r\n        on(d.scroller, \"touchcancel\", finishTouch);\r\n\r\n        // Sync scrolling between fake scrollbars and real scrollable\r\n        // area, ensure viewport is updated when scrolling.\r\n        on(d.scroller, \"scroll\", function () {\r\n            if (d.scroller.clientHeight) {\r\n                updateScrollTop(cm, d.scroller.scrollTop);\r\n                setScrollLeft(cm, d.scroller.scrollLeft, true);\r\n                signal(cm, \"scroll\", cm);\r\n            }\r\n        });\r\n\r\n        // Listen to wheel events in order to try and update the viewport on time.\r\n        on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\r\n        on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\r\n\r\n        // Prevent wrapper from ever scrolling\r\n        on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\r\n\r\n        d.dragFunctions = {\r\n            enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\r\n            over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\r\n            start: function (e) { return onDragStart(cm, e); },\r\n            drop: operation(cm, onDrop),\r\n            leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\r\n        };\r\n\r\n        var inp = d.input.getField();\r\n        on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\r\n        on(inp, \"keydown\", operation(cm, onKeyDown));\r\n        on(inp, \"keypress\", operation(cm, onKeyPress));\r\n        on(inp, \"focus\", function (e) { return onFocus(cm, e); });\r\n        on(inp, \"blur\", function (e) { return onBlur(cm, e); });\r\n    }\r\n\r\n    var initHooks = [];\r\n    CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\r\n\r\n    // Indent the given line. The how parameter can be \"smart\",\r\n    // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\r\n    // (typically set to true for forced single-line indents), empty\r\n    // lines are not indented, and places where the mode returns Pass\r\n    // are left alone.\r\n    function indentLine(cm, n, how, aggressive) {\r\n        var doc = cm.doc, state;\r\n        if (how == null) { how = \"add\"; }\r\n        if (how == \"smart\") {\r\n            // Fall back to \"prev\" when the mode doesn't have an indentation\r\n            // method.\r\n            if (!doc.mode.indent) { how = \"prev\"; }\r\n            else { state = getContextBefore(cm, n).state; }\r\n        }\r\n\r\n        var tabSize = cm.options.tabSize;\r\n        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\r\n        if (line.stateAfter) { line.stateAfter = null; }\r\n        var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\r\n        if (!aggressive && !/\\S/.test(line.text)) {\r\n            indentation = 0;\r\n            how = \"not\";\r\n        } else if (how == \"smart\") {\r\n            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\r\n            if (indentation == Pass || indentation > 150) {\r\n                if (!aggressive) { return }\r\n                how = \"prev\";\r\n            }\r\n        }\r\n        if (how == \"prev\") {\r\n            if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\r\n            else { indentation = 0; }\r\n        } else if (how == \"add\") {\r\n            indentation = curSpace + cm.options.indentUnit;\r\n        } else if (how == \"subtract\") {\r\n            indentation = curSpace - cm.options.indentUnit;\r\n        } else if (typeof how == \"number\") {\r\n            indentation = curSpace + how;\r\n        }\r\n        indentation = Math.max(0, indentation);\r\n\r\n        var indentString = \"\", pos = 0;\r\n        if (cm.options.indentWithTabs)\r\n        { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\r\n        if (pos < indentation) { indentString += spaceStr(indentation - pos); }\r\n\r\n        if (indentString != curSpaceString) {\r\n            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\r\n            line.stateAfter = null;\r\n            return true\r\n        } else {\r\n            // Ensure that, if the cursor was in the whitespace at the start\r\n            // of the line, it is moved to the end of that space.\r\n            for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\r\n                var range = doc.sel.ranges[i$1];\r\n                if (range.head.line == n && range.head.ch < curSpaceString.length) {\r\n                    var pos$1 = Pos(n, curSpaceString.length);\r\n                    replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // This will be set to a {lineWise: bool, text: [string]} object, so\r\n    // that, when pasting, we know what kind of selections the copied\r\n    // text was made out of.\r\n    var lastCopied = null;\r\n\r\n    function setLastCopied(newLastCopied) {\r\n        lastCopied = newLastCopied;\r\n    }\r\n\r\n    function applyTextInput(cm, inserted, deleted, sel, origin) {\r\n        var doc = cm.doc;\r\n        cm.display.shift = false;\r\n        if (!sel) { sel = doc.sel; }\r\n\r\n        var paste = cm.state.pasteIncoming || origin == \"paste\";\r\n        var textLines = splitLinesAuto(inserted), multiPaste = null;\r\n        // When pasting N lines into N selections, insert one line per selection\r\n        if (paste && sel.ranges.length > 1) {\r\n            if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\r\n                if (sel.ranges.length % lastCopied.text.length == 0) {\r\n                    multiPaste = [];\r\n                    for (var i = 0; i < lastCopied.text.length; i++)\r\n                    { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\r\n                }\r\n            } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\r\n                multiPaste = map(textLines, function (l) { return [l]; });\r\n            }\r\n        }\r\n\r\n        var updateInput = cm.curOp.updateInput;\r\n        // Normal behavior is to insert the new text into every selection\r\n        for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\r\n            var range$$1 = sel.ranges[i$1];\r\n            var from = range$$1.from(), to = range$$1.to();\r\n            if (range$$1.empty()) {\r\n                if (deleted && deleted > 0) // Handle deletion\r\n                { from = Pos(from.line, from.ch - deleted); }\r\n                else if (cm.state.overwrite && !paste) // Handle overwrite\r\n                { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\r\n                else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\r\n                { from = to = Pos(from.line, 0); }\r\n            }\r\n            var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\r\n                origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\r\n            makeChange(cm.doc, changeEvent);\r\n            signalLater(cm, \"inputRead\", cm, changeEvent);\r\n        }\r\n        if (inserted && !paste)\r\n        { triggerElectric(cm, inserted); }\r\n\r\n        ensureCursorVisible(cm);\r\n        if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\r\n        cm.curOp.typing = true;\r\n        cm.state.pasteIncoming = cm.state.cutIncoming = false;\r\n    }\r\n\r\n    function handlePaste(e, cm) {\r\n        var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\r\n        if (pasted) {\r\n            e.preventDefault();\r\n            if (!cm.isReadOnly() && !cm.options.disableInput)\r\n            { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\r\n            return true\r\n        }\r\n    }\r\n\r\n    function triggerElectric(cm, inserted) {\r\n        // When an 'electric' character is inserted, immediately trigger a reindent\r\n        if (!cm.options.electricChars || !cm.options.smartIndent) { return }\r\n        var sel = cm.doc.sel;\r\n\r\n        for (var i = sel.ranges.length - 1; i >= 0; i--) {\r\n            var range$$1 = sel.ranges[i];\r\n            if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\r\n            var mode = cm.getModeAt(range$$1.head);\r\n            var indented = false;\r\n            if (mode.electricChars) {\r\n                for (var j = 0; j < mode.electricChars.length; j++)\r\n                { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\r\n                    indented = indentLine(cm, range$$1.head.line, \"smart\");\r\n                    break\r\n                } }\r\n            } else if (mode.electricInput) {\r\n                if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\r\n                { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\r\n            }\r\n            if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\r\n        }\r\n    }\r\n\r\n    function copyableRanges(cm) {\r\n        var text = [], ranges = [];\r\n        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\r\n            var line = cm.doc.sel.ranges[i].head.line;\r\n            var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\r\n            ranges.push(lineRange);\r\n            text.push(cm.getRange(lineRange.anchor, lineRange.head));\r\n        }\r\n        return {text: text, ranges: ranges}\r\n    }\r\n\r\n    function disableBrowserMagic(field, spellcheck) {\r\n        field.setAttribute(\"autocorrect\", \"off\");\r\n        field.setAttribute(\"autocapitalize\", \"off\");\r\n        field.setAttribute(\"spellcheck\", !!spellcheck);\r\n    }\r\n\r\n    function hiddenTextarea() {\r\n        var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\r\n        var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\r\n        // The textarea is kept positioned near the cursor to prevent the\r\n        // fact that it'll be scrolled into view on input from scrolling\r\n        // our fake cursor out of view. On webkit, when wrap=off, paste is\r\n        // very slow. So make the area wide instead.\r\n        if (webkit) { te.style.width = \"1000px\"; }\r\n        else { te.setAttribute(\"wrap\", \"off\"); }\r\n        // If border: 0; -- iOS fails to open keyboard (issue #1287)\r\n        if (ios) { te.style.border = \"1px solid black\"; }\r\n        disableBrowserMagic(te);\r\n        return div\r\n    }\r\n\r\n    // The publicly visible API. Note that methodOp(f) means\r\n    // 'wrap f in an operation, performed on its `this` parameter'.\r\n\r\n    // This is not the complete set of editor methods. Most of the\r\n    // methods defined on the Doc type are also injected into\r\n    // CodeMirror.prototype, for backwards compatibility and\r\n    // convenience.\r\n\r\n    function addEditorMethods(CodeMirror) {\r\n        var optionHandlers = CodeMirror.optionHandlers;\r\n\r\n        var helpers = CodeMirror.helpers = {};\r\n\r\n        CodeMirror.prototype = {\r\n            constructor: CodeMirror,\r\n            focus: function(){window.focus(); this.display.input.focus();},\r\n\r\n            setOption: function(option, value) {\r\n                var options = this.options, old = options[option];\r\n                if (options[option] == value && option != \"mode\") { return }\r\n                options[option] = value;\r\n                if (optionHandlers.hasOwnProperty(option))\r\n                { operation(this, optionHandlers[option])(this, value, old); }\r\n                signal(this, \"optionChange\", this, option);\r\n            },\r\n\r\n            getOption: function(option) {return this.options[option]},\r\n            getDoc: function() {return this.doc},\r\n\r\n            addKeyMap: function(map$$1, bottom) {\r\n                this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\r\n            },\r\n            removeKeyMap: function(map$$1) {\r\n                var maps = this.state.keyMaps;\r\n                for (var i = 0; i < maps.length; ++i)\r\n                { if (maps[i] == map$$1 || maps[i].name == map$$1) {\r\n                    maps.splice(i, 1);\r\n                    return true\r\n                } }\r\n            },\r\n\r\n            addOverlay: methodOp(function(spec, options) {\r\n                var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\r\n                if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\r\n                insertSorted(this.state.overlays,\r\n                    {mode: mode, modeSpec: spec, opaque: options && options.opaque,\r\n                        priority: (options && options.priority) || 0},\r\n                    function (overlay) { return overlay.priority; });\r\n                this.state.modeGen++;\r\n                regChange(this);\r\n            }),\r\n            removeOverlay: methodOp(function(spec) {\r\n                var overlays = this.state.overlays;\r\n                for (var i = 0; i < overlays.length; ++i) {\r\n                    var cur = overlays[i].modeSpec;\r\n                    if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\r\n                        overlays.splice(i, 1);\r\n                        this.state.modeGen++;\r\n                        regChange(this);\r\n                        return\r\n                    }\r\n                }\r\n            }),\r\n\r\n            indentLine: methodOp(function(n, dir, aggressive) {\r\n                if (typeof dir != \"string\" && typeof dir != \"number\") {\r\n                    if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\r\n                    else { dir = dir ? \"add\" : \"subtract\"; }\r\n                }\r\n                if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\r\n            }),\r\n            indentSelection: methodOp(function(how) {\r\n                var ranges = this.doc.sel.ranges, end = -1;\r\n                for (var i = 0; i < ranges.length; i++) {\r\n                    var range$$1 = ranges[i];\r\n                    if (!range$$1.empty()) {\r\n                        var from = range$$1.from(), to = range$$1.to();\r\n                        var start = Math.max(end, from.line);\r\n                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\r\n                        for (var j = start; j < end; ++j)\r\n                        { indentLine(this, j, how); }\r\n                        var newRanges = this.doc.sel.ranges;\r\n                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\r\n                        { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\r\n                    } else if (range$$1.head.line > end) {\r\n                        indentLine(this, range$$1.head.line, how, true);\r\n                        end = range$$1.head.line;\r\n                        if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\r\n                    }\r\n                }\r\n            }),\r\n\r\n            // Fetch the parser token for a given character. Useful for hacks\r\n            // that want to inspect the mode state (say, for completion).\r\n            getTokenAt: function(pos, precise) {\r\n                return takeToken(this, pos, precise)\r\n            },\r\n\r\n            getLineTokens: function(line, precise) {\r\n                return takeToken(this, Pos(line), precise, true)\r\n            },\r\n\r\n            getTokenTypeAt: function(pos) {\r\n                pos = clipPos(this.doc, pos);\r\n                var styles = getLineStyles(this, getLine(this.doc, pos.line));\r\n                var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\r\n                var type;\r\n                if (ch == 0) { type = styles[2]; }\r\n                else { for (;;) {\r\n                    var mid = (before + after) >> 1;\r\n                    if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\r\n                    else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\r\n                    else { type = styles[mid * 2 + 2]; break }\r\n                } }\r\n                var cut = type ? type.indexOf(\"overlay \") : -1;\r\n                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\r\n            },\r\n\r\n            getModeAt: function(pos) {\r\n                var mode = this.doc.mode;\r\n                if (!mode.innerMode) { return mode }\r\n                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\r\n            },\r\n\r\n            getHelper: function(pos, type) {\r\n                return this.getHelpers(pos, type)[0]\r\n            },\r\n\r\n            getHelpers: function(pos, type) {\r\n                var found = [];\r\n                if (!helpers.hasOwnProperty(type)) { return found }\r\n                var help = helpers[type], mode = this.getModeAt(pos);\r\n                if (typeof mode[type] == \"string\") {\r\n                    if (help[mode[type]]) { found.push(help[mode[type]]); }\r\n                } else if (mode[type]) {\r\n                    for (var i = 0; i < mode[type].length; i++) {\r\n                        var val = help[mode[type][i]];\r\n                        if (val) { found.push(val); }\r\n                    }\r\n                } else if (mode.helperType && help[mode.helperType]) {\r\n                    found.push(help[mode.helperType]);\r\n                } else if (help[mode.name]) {\r\n                    found.push(help[mode.name]);\r\n                }\r\n                for (var i$1 = 0; i$1 < help._global.length; i$1++) {\r\n                    var cur = help._global[i$1];\r\n                    if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\r\n                    { found.push(cur.val); }\r\n                }\r\n                return found\r\n            },\r\n\r\n            getStateAfter: function(line, precise) {\r\n                var doc = this.doc;\r\n                line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\r\n                return getContextBefore(this, line + 1, precise).state\r\n            },\r\n\r\n            cursorCoords: function(start, mode) {\r\n                var pos, range$$1 = this.doc.sel.primary();\r\n                if (start == null) { pos = range$$1.head; }\r\n                else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\r\n                else { pos = start ? range$$1.from() : range$$1.to(); }\r\n                return cursorCoords(this, pos, mode || \"page\")\r\n            },\r\n\r\n            charCoords: function(pos, mode) {\r\n                return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\r\n            },\r\n\r\n            coordsChar: function(coords, mode) {\r\n                coords = fromCoordSystem(this, coords, mode || \"page\");\r\n                return coordsChar(this, coords.left, coords.top)\r\n            },\r\n\r\n            lineAtHeight: function(height, mode) {\r\n                height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\r\n                return lineAtHeight(this.doc, height + this.display.viewOffset)\r\n            },\r\n            heightAtLine: function(line, mode, includeWidgets) {\r\n                var end = false, lineObj;\r\n                if (typeof line == \"number\") {\r\n                    var last = this.doc.first + this.doc.size - 1;\r\n                    if (line < this.doc.first) { line = this.doc.first; }\r\n                    else if (line > last) { line = last; end = true; }\r\n                    lineObj = getLine(this.doc, line);\r\n                } else {\r\n                    lineObj = line;\r\n                }\r\n                return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\r\n                    (end ? this.doc.height - heightAtLine(lineObj) : 0)\r\n            },\r\n\r\n            defaultTextHeight: function() { return textHeight(this.display) },\r\n            defaultCharWidth: function() { return charWidth(this.display) },\r\n\r\n            getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\r\n\r\n            addWidget: function(pos, node, scroll, vert, horiz) {\r\n                var display = this.display;\r\n                pos = cursorCoords(this, clipPos(this.doc, pos));\r\n                var top = pos.bottom, left = pos.left;\r\n                node.style.position = \"absolute\";\r\n                node.setAttribute(\"cm-ignore-events\", \"true\");\r\n                this.display.input.setUneditable(node);\r\n                display.sizer.appendChild(node);\r\n                if (vert == \"over\") {\r\n                    top = pos.top;\r\n                } else if (vert == \"above\" || vert == \"near\") {\r\n                    var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\r\n                        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\r\n                    // Default to positioning above (if specified and possible); otherwise default to positioning below\r\n                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\r\n                    { top = pos.top - node.offsetHeight; }\r\n                    else if (pos.bottom + node.offsetHeight <= vspace)\r\n                    { top = pos.bottom; }\r\n                    if (left + node.offsetWidth > hspace)\r\n                    { left = hspace - node.offsetWidth; }\r\n                }\r\n                node.style.top = top + \"px\";\r\n                node.style.left = node.style.right = \"\";\r\n                if (horiz == \"right\") {\r\n                    left = display.sizer.clientWidth - node.offsetWidth;\r\n                    node.style.right = \"0px\";\r\n                } else {\r\n                    if (horiz == \"left\") { left = 0; }\r\n                    else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\r\n                    node.style.left = left + \"px\";\r\n                }\r\n                if (scroll)\r\n                { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\r\n            },\r\n\r\n            triggerOnKeyDown: methodOp(onKeyDown),\r\n            triggerOnKeyPress: methodOp(onKeyPress),\r\n            triggerOnKeyUp: onKeyUp,\r\n            triggerOnMouseDown: methodOp(onMouseDown),\r\n\r\n            execCommand: function(cmd) {\r\n                if (commands.hasOwnProperty(cmd))\r\n                { return commands[cmd].call(null, this) }\r\n            },\r\n\r\n            triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\r\n\r\n            findPosH: function(from, amount, unit, visually) {\r\n                var dir = 1;\r\n                if (amount < 0) { dir = -1; amount = -amount; }\r\n                var cur = clipPos(this.doc, from);\r\n                for (var i = 0; i < amount; ++i) {\r\n                    cur = findPosH(this.doc, cur, dir, unit, visually);\r\n                    if (cur.hitSide) { break }\r\n                }\r\n                return cur\r\n            },\r\n\r\n            moveH: methodOp(function(dir, unit) {\r\n                var this$1 = this;\r\n\r\n                this.extendSelectionsBy(function (range$$1) {\r\n                    if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\r\n                    { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\r\n                    else\r\n                    { return dir < 0 ? range$$1.from() : range$$1.to() }\r\n                }, sel_move);\r\n            }),\r\n\r\n            deleteH: methodOp(function(dir, unit) {\r\n                var sel = this.doc.sel, doc = this.doc;\r\n                if (sel.somethingSelected())\r\n                { doc.replaceSelection(\"\", null, \"+delete\"); }\r\n                else\r\n                { deleteNearSelection(this, function (range$$1) {\r\n                    var other = findPosH(doc, range$$1.head, dir, unit, false);\r\n                    return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\r\n                }); }\r\n            }),\r\n\r\n            findPosV: function(from, amount, unit, goalColumn) {\r\n                var dir = 1, x = goalColumn;\r\n                if (amount < 0) { dir = -1; amount = -amount; }\r\n                var cur = clipPos(this.doc, from);\r\n                for (var i = 0; i < amount; ++i) {\r\n                    var coords = cursorCoords(this, cur, \"div\");\r\n                    if (x == null) { x = coords.left; }\r\n                    else { coords.left = x; }\r\n                    cur = findPosV(this, coords, dir, unit);\r\n                    if (cur.hitSide) { break }\r\n                }\r\n                return cur\r\n            },\r\n\r\n            moveV: methodOp(function(dir, unit) {\r\n                var this$1 = this;\r\n\r\n                var doc = this.doc, goals = [];\r\n                var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\r\n                doc.extendSelectionsBy(function (range$$1) {\r\n                    if (collapse)\r\n                    { return dir < 0 ? range$$1.from() : range$$1.to() }\r\n                    var headPos = cursorCoords(this$1, range$$1.head, \"div\");\r\n                    if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\r\n                    goals.push(headPos.left);\r\n                    var pos = findPosV(this$1, headPos, dir, unit);\r\n                    if (unit == \"page\" && range$$1 == doc.sel.primary())\r\n                    { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\r\n                    return pos\r\n                }, sel_move);\r\n                if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\r\n                { doc.sel.ranges[i].goalColumn = goals[i]; } }\r\n            }),\r\n\r\n            // Find the word at the given position (as returned by coordsChar).\r\n            findWordAt: function(pos) {\r\n                var doc = this.doc, line = getLine(doc, pos.line).text;\r\n                var start = pos.ch, end = pos.ch;\r\n                if (line) {\r\n                    var helper = this.getHelper(pos, \"wordChars\");\r\n                    if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\r\n                    var startChar = line.charAt(start);\r\n                    var check = isWordChar(startChar, helper)\r\n                        ? function (ch) { return isWordChar(ch, helper); }\r\n                        : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\r\n                            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\r\n                    while (start > 0 && check(line.charAt(start - 1))) { --start; }\r\n                    while (end < line.length && check(line.charAt(end))) { ++end; }\r\n                }\r\n                return new Range(Pos(pos.line, start), Pos(pos.line, end))\r\n            },\r\n\r\n            toggleOverwrite: function(value) {\r\n                if (value != null && value == this.state.overwrite) { return }\r\n                if (this.state.overwrite = !this.state.overwrite)\r\n                { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\r\n                else\r\n                { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\r\n\r\n                signal(this, \"overwriteToggle\", this, this.state.overwrite);\r\n            },\r\n            hasFocus: function() { return this.display.input.getField() == activeElt() },\r\n            isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\r\n\r\n            scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\r\n            getScrollInfo: function() {\r\n                var scroller = this.display.scroller;\r\n                return {left: scroller.scrollLeft, top: scroller.scrollTop,\r\n                    height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\r\n                    width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\r\n                    clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\r\n            },\r\n\r\n            scrollIntoView: methodOp(function(range$$1, margin) {\r\n                if (range$$1 == null) {\r\n                    range$$1 = {from: this.doc.sel.primary().head, to: null};\r\n                    if (margin == null) { margin = this.options.cursorScrollMargin; }\r\n                } else if (typeof range$$1 == \"number\") {\r\n                    range$$1 = {from: Pos(range$$1, 0), to: null};\r\n                } else if (range$$1.from == null) {\r\n                    range$$1 = {from: range$$1, to: null};\r\n                }\r\n                if (!range$$1.to) { range$$1.to = range$$1.from; }\r\n                range$$1.margin = margin || 0;\r\n\r\n                if (range$$1.from.line != null) {\r\n                    scrollToRange(this, range$$1);\r\n                } else {\r\n                    scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\r\n                }\r\n            }),\r\n\r\n            setSize: methodOp(function(width, height) {\r\n                var this$1 = this;\r\n\r\n                var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\r\n                if (width != null) { this.display.wrapper.style.width = interpret(width); }\r\n                if (height != null) { this.display.wrapper.style.height = interpret(height); }\r\n                if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\r\n                var lineNo$$1 = this.display.viewFrom;\r\n                this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\r\n                    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\r\n                    { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\r\n                    ++lineNo$$1;\r\n                });\r\n                this.curOp.forceUpdate = true;\r\n                signal(this, \"refresh\", this);\r\n            }),\r\n\r\n            operation: function(f){return runInOp(this, f)},\r\n            startOperation: function(){return startOperation(this)},\r\n            endOperation: function(){return endOperation(this)},\r\n\r\n            refresh: methodOp(function() {\r\n                var oldHeight = this.display.cachedTextHeight;\r\n                regChange(this);\r\n                this.curOp.forceUpdate = true;\r\n                clearCaches(this);\r\n                scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\r\n                updateGutterSpace(this);\r\n                if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\r\n                { estimateLineHeights(this); }\r\n                signal(this, \"refresh\", this);\r\n            }),\r\n\r\n            swapDoc: methodOp(function(doc) {\r\n                var old = this.doc;\r\n                old.cm = null;\r\n                attachDoc(this, doc);\r\n                clearCaches(this);\r\n                this.display.input.reset();\r\n                scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\r\n                this.curOp.forceScroll = true;\r\n                signalLater(this, \"swapDoc\", this, old);\r\n                return old\r\n            }),\r\n\r\n            phrase: function(phraseText) {\r\n                var phrases = this.options.phrases;\r\n                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\r\n            },\r\n\r\n            getInputField: function(){return this.display.input.getField()},\r\n            getWrapperElement: function(){return this.display.wrapper},\r\n            getScrollerElement: function(){return this.display.scroller},\r\n            getGutterElement: function(){return this.display.gutters}\r\n        };\r\n        eventMixin(CodeMirror);\r\n\r\n        CodeMirror.registerHelper = function(type, name, value) {\r\n            if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\r\n            helpers[type][name] = value;\r\n        };\r\n        CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\r\n            CodeMirror.registerHelper(type, name, value);\r\n            helpers[type]._global.push({pred: predicate, val: value});\r\n        };\r\n    }\r\n\r\n    // Used for horizontal relative motion. Dir is -1 or 1 (left or\r\n    // right), unit can be \"char\", \"column\" (like char, but doesn't\r\n    // cross line boundaries), \"word\" (across next word), or \"group\" (to\r\n    // the start of next group of word or non-word-non-whitespace\r\n    // chars). The visually param controls whether, in right-to-left\r\n    // text, direction 1 means to move towards the next index in the\r\n    // string, or towards the character to the right of the current\r\n    // position. The resulting position will have a hitSide=true\r\n    // property if it reached the end of the document.\r\n    function findPosH(doc, pos, dir, unit, visually) {\r\n        var oldPos = pos;\r\n        var origDir = dir;\r\n        var lineObj = getLine(doc, pos.line);\r\n        function findNextLine() {\r\n            var l = pos.line + dir;\r\n            if (l < doc.first || l >= doc.first + doc.size) { return false }\r\n            pos = new Pos(l, pos.ch, pos.sticky);\r\n            return lineObj = getLine(doc, l)\r\n        }\r\n        function moveOnce(boundToLine) {\r\n            var next;\r\n            if (visually) {\r\n                next = moveVisually(doc.cm, lineObj, pos, dir);\r\n            } else {\r\n                next = moveLogically(lineObj, pos, dir);\r\n            }\r\n            if (next == null) {\r\n                if (!boundToLine && findNextLine())\r\n                { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\r\n                else\r\n                { return false }\r\n            } else {\r\n                pos = next;\r\n            }\r\n            return true\r\n        }\r\n\r\n        if (unit == \"char\") {\r\n            moveOnce();\r\n        } else if (unit == \"column\") {\r\n            moveOnce(true);\r\n        } else if (unit == \"word\" || unit == \"group\") {\r\n            var sawType = null, group = unit == \"group\";\r\n            var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\r\n            for (var first = true;; first = false) {\r\n                if (dir < 0 && !moveOnce(!first)) { break }\r\n                var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\r\n                var type = isWordChar(cur, helper) ? \"w\"\r\n                    : group && cur == \"\\n\" ? \"n\"\r\n                        : !group || /\\s/.test(cur) ? null\r\n                            : \"p\";\r\n                if (group && !first && !type) { type = \"s\"; }\r\n                if (sawType && sawType != type) {\r\n                    if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\r\n                    break\r\n                }\r\n\r\n                if (type) { sawType = type; }\r\n                if (dir > 0 && !moveOnce(!first)) { break }\r\n            }\r\n        }\r\n        var result = skipAtomic(doc, pos, oldPos, origDir, true);\r\n        if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\r\n        return result\r\n    }\r\n\r\n    // For relative vertical movement. Dir may be -1 or 1. Unit can be\r\n    // \"page\" or \"line\". The resulting position will have a hitSide=true\r\n    // property if it reached the end of the document.\r\n    function findPosV(cm, pos, dir, unit) {\r\n        var doc = cm.doc, x = pos.left, y;\r\n        if (unit == \"page\") {\r\n            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\r\n            var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\r\n            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\r\n\r\n        } else if (unit == \"line\") {\r\n            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\r\n        }\r\n        var target;\r\n        for (;;) {\r\n            target = coordsChar(cm, x, y);\r\n            if (!target.outside) { break }\r\n            if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\r\n            y += dir * 5;\r\n        }\r\n        return target\r\n    }\r\n\r\n    // CONTENTEDITABLE INPUT STYLE\r\n\r\n    var ContentEditableInput = function(cm) {\r\n        this.cm = cm;\r\n        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\r\n        this.polling = new Delayed();\r\n        this.composing = null;\r\n        this.gracePeriod = false;\r\n        this.readDOMTimeout = null;\r\n    };\r\n\r\n    ContentEditableInput.prototype.init = function (display) {\r\n        var this$1 = this;\r\n\r\n        var input = this, cm = input.cm;\r\n        var div = input.div = display.lineDiv;\r\n        disableBrowserMagic(div, cm.options.spellcheck);\r\n\r\n        on(div, \"paste\", function (e) {\r\n            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\r\n            // IE doesn't fire input events, so we schedule a read for the pasted content in this way\r\n            if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\r\n        });\r\n\r\n        on(div, \"compositionstart\", function (e) {\r\n            this$1.composing = {data: e.data, done: false};\r\n        });\r\n        on(div, \"compositionupdate\", function (e) {\r\n            if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\r\n        });\r\n        on(div, \"compositionend\", function (e) {\r\n            if (this$1.composing) {\r\n                if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\r\n                this$1.composing.done = true;\r\n            }\r\n        });\r\n\r\n        on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\r\n\r\n        on(div, \"input\", function () {\r\n            if (!this$1.composing) { this$1.readFromDOMSoon(); }\r\n        });\r\n\r\n        function onCopyCut(e) {\r\n            if (signalDOMEvent(cm, e)) { return }\r\n            if (cm.somethingSelected()) {\r\n                setLastCopied({lineWise: false, text: cm.getSelections()});\r\n                if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\r\n            } else if (!cm.options.lineWiseCopyCut) {\r\n                return\r\n            } else {\r\n                var ranges = copyableRanges(cm);\r\n                setLastCopied({lineWise: true, text: ranges.text});\r\n                if (e.type == \"cut\") {\r\n                    cm.operation(function () {\r\n                        cm.setSelections(ranges.ranges, 0, sel_dontScroll);\r\n                        cm.replaceSelection(\"\", null, \"cut\");\r\n                    });\r\n                }\r\n            }\r\n            if (e.clipboardData) {\r\n                e.clipboardData.clearData();\r\n                var content = lastCopied.text.join(\"\\n\");\r\n                // iOS exposes the clipboard API, but seems to discard content inserted into it\r\n                e.clipboardData.setData(\"Text\", content);\r\n                if (e.clipboardData.getData(\"Text\") == content) {\r\n                    e.preventDefault();\r\n                    return\r\n                }\r\n            }\r\n            // Old-fashioned briefly-focus-a-textarea hack\r\n            var kludge = hiddenTextarea(), te = kludge.firstChild;\r\n            cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\r\n            te.value = lastCopied.text.join(\"\\n\");\r\n            var hadFocus = document.activeElement;\r\n            selectInput(te);\r\n            setTimeout(function () {\r\n                cm.display.lineSpace.removeChild(kludge);\r\n                hadFocus.focus();\r\n                if (hadFocus == div) { input.showPrimarySelection(); }\r\n            }, 50);\r\n        }\r\n        on(div, \"copy\", onCopyCut);\r\n        on(div, \"cut\", onCopyCut);\r\n    };\r\n\r\n    ContentEditableInput.prototype.prepareSelection = function () {\r\n        var result = prepareSelection(this.cm, false);\r\n        result.focus = this.cm.state.focused;\r\n        return result\r\n    };\r\n\r\n    ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\r\n        if (!info || !this.cm.display.view.length) { return }\r\n        if (info.focus || takeFocus) { this.showPrimarySelection(); }\r\n        this.showMultipleSelections(info);\r\n    };\r\n\r\n    ContentEditableInput.prototype.getSelection = function () {\r\n        return this.cm.display.wrapper.ownerDocument.getSelection()\r\n    };\r\n\r\n    ContentEditableInput.prototype.showPrimarySelection = function () {\r\n        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\r\n        var from = prim.from(), to = prim.to();\r\n\r\n        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\r\n            sel.removeAllRanges();\r\n            return\r\n        }\r\n\r\n        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\r\n            cmp(minPos(curAnchor, curFocus), from) == 0 &&\r\n            cmp(maxPos(curAnchor, curFocus), to) == 0)\r\n        { return }\r\n\r\n        var view = cm.display.view;\r\n        var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\r\n            {node: view[0].measure.map[2], offset: 0};\r\n        var end = to.line < cm.display.viewTo && posToDOM(cm, to);\r\n        if (!end) {\r\n            var measure = view[view.length - 1].measure;\r\n            var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\r\n            end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\r\n        }\r\n\r\n        if (!start || !end) {\r\n            sel.removeAllRanges();\r\n            return\r\n        }\r\n\r\n        var old = sel.rangeCount && sel.getRangeAt(0), rng;\r\n        try { rng = range(start.node, start.offset, end.offset, end.node); }\r\n        catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\r\n        if (rng) {\r\n            if (!gecko && cm.state.focused) {\r\n                sel.collapse(start.node, start.offset);\r\n                if (!rng.collapsed) {\r\n                    sel.removeAllRanges();\r\n                    sel.addRange(rng);\r\n                }\r\n            } else {\r\n                sel.removeAllRanges();\r\n                sel.addRange(rng);\r\n            }\r\n            if (old && sel.anchorNode == null) { sel.addRange(old); }\r\n            else if (gecko) { this.startGracePeriod(); }\r\n        }\r\n        this.rememberSelection();\r\n    };\r\n\r\n    ContentEditableInput.prototype.startGracePeriod = function () {\r\n        var this$1 = this;\r\n\r\n        clearTimeout(this.gracePeriod);\r\n        this.gracePeriod = setTimeout(function () {\r\n            this$1.gracePeriod = false;\r\n            if (this$1.selectionChanged())\r\n            { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\r\n        }, 20);\r\n    };\r\n\r\n    ContentEditableInput.prototype.showMultipleSelections = function (info) {\r\n        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\r\n        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\r\n    };\r\n\r\n    ContentEditableInput.prototype.rememberSelection = function () {\r\n        var sel = this.getSelection();\r\n        this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\r\n        this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\r\n    };\r\n\r\n    ContentEditableInput.prototype.selectionInEditor = function () {\r\n        var sel = this.getSelection();\r\n        if (!sel.rangeCount) { return false }\r\n        var node = sel.getRangeAt(0).commonAncestorContainer;\r\n        return contains(this.div, node)\r\n    };\r\n\r\n    ContentEditableInput.prototype.focus = function () {\r\n        if (this.cm.options.readOnly != \"nocursor\") {\r\n            if (!this.selectionInEditor())\r\n            { this.showSelection(this.prepareSelection(), true); }\r\n            this.div.focus();\r\n        }\r\n    };\r\n    ContentEditableInput.prototype.blur = function () { this.div.blur(); };\r\n    ContentEditableInput.prototype.getField = function () { return this.div };\r\n\r\n    ContentEditableInput.prototype.supportsTouch = function () { return true };\r\n\r\n    ContentEditableInput.prototype.receivedFocus = function () {\r\n        var input = this;\r\n        if (this.selectionInEditor())\r\n        { this.pollSelection(); }\r\n        else\r\n        { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\r\n\r\n        function poll() {\r\n            if (input.cm.state.focused) {\r\n                input.pollSelection();\r\n                input.polling.set(input.cm.options.pollInterval, poll);\r\n            }\r\n        }\r\n        this.polling.set(this.cm.options.pollInterval, poll);\r\n    };\r\n\r\n    ContentEditableInput.prototype.selectionChanged = function () {\r\n        var sel = this.getSelection();\r\n        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\r\n            sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\r\n    };\r\n\r\n    ContentEditableInput.prototype.pollSelection = function () {\r\n        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\r\n        var sel = this.getSelection(), cm = this.cm;\r\n        // On Android Chrome (version 56, at least), backspacing into an\r\n        // uneditable block element will put the cursor in that element,\r\n        // and then, because it's not editable, hide the virtual keyboard.\r\n        // Because Android doesn't allow us to actually detect backspace\r\n        // presses in a sane way, this code checks for when that happens\r\n        // and simulates a backspace press in this case.\r\n        if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\r\n            this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\r\n            this.blur();\r\n            this.focus();\r\n            return\r\n        }\r\n        if (this.composing) { return }\r\n        this.rememberSelection();\r\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n        if (anchor && head) { runInOp(cm, function () {\r\n            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\r\n            if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\r\n        }); }\r\n    };\r\n\r\n    ContentEditableInput.prototype.pollContent = function () {\r\n        if (this.readDOMTimeout != null) {\r\n            clearTimeout(this.readDOMTimeout);\r\n            this.readDOMTimeout = null;\r\n        }\r\n\r\n        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\r\n        var from = sel.from(), to = sel.to();\r\n        if (from.ch == 0 && from.line > cm.firstLine())\r\n        { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\r\n        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\r\n        { to = Pos(to.line + 1, 0); }\r\n        if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\r\n\r\n        var fromIndex, fromLine, fromNode;\r\n        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\r\n            fromLine = lineNo(display.view[0].line);\r\n            fromNode = display.view[0].node;\r\n        } else {\r\n            fromLine = lineNo(display.view[fromIndex].line);\r\n            fromNode = display.view[fromIndex - 1].node.nextSibling;\r\n        }\r\n        var toIndex = findViewIndex(cm, to.line);\r\n        var toLine, toNode;\r\n        if (toIndex == display.view.length - 1) {\r\n            toLine = display.viewTo - 1;\r\n            toNode = display.lineDiv.lastChild;\r\n        } else {\r\n            toLine = lineNo(display.view[toIndex + 1].line) - 1;\r\n            toNode = display.view[toIndex + 1].node.previousSibling;\r\n        }\r\n\r\n        if (!fromNode) { return false }\r\n        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\r\n        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\r\n        while (newText.length > 1 && oldText.length > 1) {\r\n            if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\r\n            else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\r\n            else { break }\r\n        }\r\n\r\n        var cutFront = 0, cutEnd = 0;\r\n        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\r\n        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\r\n        { ++cutFront; }\r\n        var newBot = lst(newText), oldBot = lst(oldText);\r\n        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\r\n            oldBot.length - (oldText.length == 1 ? cutFront : 0));\r\n        while (cutEnd < maxCutEnd &&\r\n        newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\r\n        { ++cutEnd; }\r\n        // Try to move start of change to start of selection if ambiguous\r\n        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\r\n            while (cutFront && cutFront > from.ch &&\r\n            newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\r\n                cutFront--;\r\n                cutEnd++;\r\n            }\r\n        }\r\n\r\n        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\r\n        newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\r\n\r\n        var chFrom = Pos(fromLine, cutFront);\r\n        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\r\n        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\r\n            replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\r\n            return true\r\n        }\r\n    };\r\n\r\n    ContentEditableInput.prototype.ensurePolled = function () {\r\n        this.forceCompositionEnd();\r\n    };\r\n    ContentEditableInput.prototype.reset = function () {\r\n        this.forceCompositionEnd();\r\n    };\r\n    ContentEditableInput.prototype.forceCompositionEnd = function () {\r\n        if (!this.composing) { return }\r\n        clearTimeout(this.readDOMTimeout);\r\n        this.composing = null;\r\n        this.updateFromDOM();\r\n        this.div.blur();\r\n        this.div.focus();\r\n    };\r\n    ContentEditableInput.prototype.readFromDOMSoon = function () {\r\n        var this$1 = this;\r\n\r\n        if (this.readDOMTimeout != null) { return }\r\n        this.readDOMTimeout = setTimeout(function () {\r\n            this$1.readDOMTimeout = null;\r\n            if (this$1.composing) {\r\n                if (this$1.composing.done) { this$1.composing = null; }\r\n                else { return }\r\n            }\r\n            this$1.updateFromDOM();\r\n        }, 80);\r\n    };\r\n\r\n    ContentEditableInput.prototype.updateFromDOM = function () {\r\n        var this$1 = this;\r\n\r\n        if (this.cm.isReadOnly() || !this.pollContent())\r\n        { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\r\n    };\r\n\r\n    ContentEditableInput.prototype.setUneditable = function (node) {\r\n        node.contentEditable = \"false\";\r\n    };\r\n\r\n    ContentEditableInput.prototype.onKeyPress = function (e) {\r\n        if (e.charCode == 0 || this.composing) { return }\r\n        e.preventDefault();\r\n        if (!this.cm.isReadOnly())\r\n        { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\r\n    };\r\n\r\n    ContentEditableInput.prototype.readOnlyChanged = function (val) {\r\n        this.div.contentEditable = String(val != \"nocursor\");\r\n    };\r\n\r\n    ContentEditableInput.prototype.onContextMenu = function () {};\r\n    ContentEditableInput.prototype.resetPosition = function () {};\r\n\r\n    ContentEditableInput.prototype.needsContentAttribute = true;\r\n\r\n    function posToDOM(cm, pos) {\r\n        var view = findViewForLine(cm, pos.line);\r\n        if (!view || view.hidden) { return null }\r\n        var line = getLine(cm.doc, pos.line);\r\n        var info = mapFromLineView(view, line, pos.line);\r\n\r\n        var order = getOrder(line, cm.doc.direction), side = \"left\";\r\n        if (order) {\r\n            var partPos = getBidiPartAt(order, pos.ch);\r\n            side = partPos % 2 ? \"right\" : \"left\";\r\n        }\r\n        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\r\n        result.offset = result.collapse == \"right\" ? result.end : result.start;\r\n        return result\r\n    }\r\n\r\n    function isInGutter(node) {\r\n        for (var scan = node; scan; scan = scan.parentNode)\r\n        { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\r\n        return false\r\n    }\r\n\r\n    function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\r\n\r\n    function domTextBetween(cm, from, to, fromLine, toLine) {\r\n        var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\r\n        function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\r\n        function close() {\r\n            if (closing) {\r\n                text += lineSep;\r\n                if (extraLinebreak) { text += lineSep; }\r\n                closing = extraLinebreak = false;\r\n            }\r\n        }\r\n        function addText(str) {\r\n            if (str) {\r\n                close();\r\n                text += str;\r\n            }\r\n        }\r\n        function walk(node) {\r\n            if (node.nodeType == 1) {\r\n                var cmText = node.getAttribute(\"cm-text\");\r\n                if (cmText) {\r\n                    addText(cmText);\r\n                    return\r\n                }\r\n                var markerID = node.getAttribute(\"cm-marker\"), range$$1;\r\n                if (markerID) {\r\n                    var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\r\n                    if (found.length && (range$$1 = found[0].find(0)))\r\n                    { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\r\n                    return\r\n                }\r\n                if (node.getAttribute(\"contenteditable\") == \"false\") { return }\r\n                var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\r\n                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\r\n\r\n                if (isBlock) { close(); }\r\n                for (var i = 0; i < node.childNodes.length; i++)\r\n                { walk(node.childNodes[i]); }\r\n\r\n                if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\r\n                if (isBlock) { closing = true; }\r\n            } else if (node.nodeType == 3) {\r\n                addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\r\n            }\r\n        }\r\n        for (;;) {\r\n            walk(from);\r\n            if (from == to) { break }\r\n            from = from.nextSibling;\r\n            extraLinebreak = false;\r\n        }\r\n        return text\r\n    }\r\n\r\n    function domToPos(cm, node, offset) {\r\n        var lineNode;\r\n        if (node == cm.display.lineDiv) {\r\n            lineNode = cm.display.lineDiv.childNodes[offset];\r\n            if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\r\n            node = null; offset = 0;\r\n        } else {\r\n            for (lineNode = node;; lineNode = lineNode.parentNode) {\r\n                if (!lineNode || lineNode == cm.display.lineDiv) { return null }\r\n                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\r\n            }\r\n        }\r\n        for (var i = 0; i < cm.display.view.length; i++) {\r\n            var lineView = cm.display.view[i];\r\n            if (lineView.node == lineNode)\r\n            { return locateNodeInLineView(lineView, node, offset) }\r\n        }\r\n    }\r\n\r\n    function locateNodeInLineView(lineView, node, offset) {\r\n        var wrapper = lineView.text.firstChild, bad = false;\r\n        if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\r\n        if (node == wrapper) {\r\n            bad = true;\r\n            node = wrapper.childNodes[offset];\r\n            offset = 0;\r\n            if (!node) {\r\n                var line = lineView.rest ? lst(lineView.rest) : lineView.line;\r\n                return badPos(Pos(lineNo(line), line.text.length), bad)\r\n            }\r\n        }\r\n\r\n        var textNode = node.nodeType == 3 ? node : null, topNode = node;\r\n        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\r\n            textNode = node.firstChild;\r\n            if (offset) { offset = textNode.nodeValue.length; }\r\n        }\r\n        while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\r\n        var measure = lineView.measure, maps = measure.maps;\r\n\r\n        function find(textNode, topNode, offset) {\r\n            for (var i = -1; i < (maps ? maps.length : 0); i++) {\r\n                var map$$1 = i < 0 ? measure.map : maps[i];\r\n                for (var j = 0; j < map$$1.length; j += 3) {\r\n                    var curNode = map$$1[j + 2];\r\n                    if (curNode == textNode || curNode == topNode) {\r\n                        var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\r\n                        var ch = map$$1[j] + offset;\r\n                        if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\r\n                        return Pos(line, ch)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var found = find(textNode, topNode, offset);\r\n        if (found) { return badPos(found, bad) }\r\n\r\n        // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\r\n        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\r\n            found = find(after, after.firstChild, 0);\r\n            if (found)\r\n            { return badPos(Pos(found.line, found.ch - dist), bad) }\r\n            else\r\n            { dist += after.textContent.length; }\r\n        }\r\n        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\r\n            found = find(before, before.firstChild, -1);\r\n            if (found)\r\n            { return badPos(Pos(found.line, found.ch + dist$1), bad) }\r\n            else\r\n            { dist$1 += before.textContent.length; }\r\n        }\r\n    }\r\n\r\n    // TEXTAREA INPUT STYLE\r\n\r\n    var TextareaInput = function(cm) {\r\n        this.cm = cm;\r\n        // See input.poll and input.reset\r\n        this.prevInput = \"\";\r\n\r\n        // Flag that indicates whether we expect input to appear real soon\r\n        // now (after some event like 'keypress' or 'input') and are\r\n        // polling intensively.\r\n        this.pollingFast = false;\r\n        // Self-resetting timeout for the poller\r\n        this.polling = new Delayed();\r\n        // Used to work around IE issue with selection being forgotten when focus moves away from textarea\r\n        this.hasSelection = false;\r\n        this.composing = null;\r\n    };\r\n\r\n    TextareaInput.prototype.init = function (display) {\r\n        var this$1 = this;\r\n\r\n        var input = this, cm = this.cm;\r\n        this.createField(display);\r\n        var te = this.textarea;\r\n\r\n        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\r\n\r\n        // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\r\n        if (ios) { te.style.width = \"0px\"; }\r\n\r\n        on(te, \"input\", function () {\r\n            if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\r\n            input.poll();\r\n        });\r\n\r\n        on(te, \"paste\", function (e) {\r\n            if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\r\n\r\n            cm.state.pasteIncoming = true;\r\n            input.fastPoll();\r\n        });\r\n\r\n        function prepareCopyCut(e) {\r\n            if (signalDOMEvent(cm, e)) { return }\r\n            if (cm.somethingSelected()) {\r\n                setLastCopied({lineWise: false, text: cm.getSelections()});\r\n            } else if (!cm.options.lineWiseCopyCut) {\r\n                return\r\n            } else {\r\n                var ranges = copyableRanges(cm);\r\n                setLastCopied({lineWise: true, text: ranges.text});\r\n                if (e.type == \"cut\") {\r\n                    cm.setSelections(ranges.ranges, null, sel_dontScroll);\r\n                } else {\r\n                    input.prevInput = \"\";\r\n                    te.value = ranges.text.join(\"\\n\");\r\n                    selectInput(te);\r\n                }\r\n            }\r\n            if (e.type == \"cut\") { cm.state.cutIncoming = true; }\r\n        }\r\n        on(te, \"cut\", prepareCopyCut);\r\n        on(te, \"copy\", prepareCopyCut);\r\n\r\n        on(display.scroller, \"paste\", function (e) {\r\n            if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\r\n            cm.state.pasteIncoming = true;\r\n            input.focus();\r\n        });\r\n\r\n        // Prevent normal selection in the editor (we handle our own)\r\n        on(display.lineSpace, \"selectstart\", function (e) {\r\n            if (!eventInWidget(display, e)) { e_preventDefault(e); }\r\n        });\r\n\r\n        on(te, \"compositionstart\", function () {\r\n            var start = cm.getCursor(\"from\");\r\n            if (input.composing) { input.composing.range.clear(); }\r\n            input.composing = {\r\n                start: start,\r\n                range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\r\n            };\r\n        });\r\n        on(te, \"compositionend\", function () {\r\n            if (input.composing) {\r\n                input.poll();\r\n                input.composing.range.clear();\r\n                input.composing = null;\r\n            }\r\n        });\r\n    };\r\n\r\n    TextareaInput.prototype.createField = function (_display) {\r\n        // Wraps and hides input textarea\r\n        this.wrapper = hiddenTextarea();\r\n        // The semihidden textarea that is focused when the editor is\r\n        // focused, and receives input.\r\n        this.textarea = this.wrapper.firstChild;\r\n    };\r\n\r\n    TextareaInput.prototype.prepareSelection = function () {\r\n        // Redraw the selection and/or cursor\r\n        var cm = this.cm, display = cm.display, doc = cm.doc;\r\n        var result = prepareSelection(cm);\r\n\r\n        // Move the hidden textarea near the cursor to prevent scrolling artifacts\r\n        if (cm.options.moveInputWithCursor) {\r\n            var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\r\n            var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\r\n            result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\r\n                headPos.top + lineOff.top - wrapOff.top));\r\n            result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\r\n                headPos.left + lineOff.left - wrapOff.left));\r\n        }\r\n\r\n        return result\r\n    };\r\n\r\n    TextareaInput.prototype.showSelection = function (drawn) {\r\n        var cm = this.cm, display = cm.display;\r\n        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\r\n        removeChildrenAndAdd(display.selectionDiv, drawn.selection);\r\n        if (drawn.teTop != null) {\r\n            this.wrapper.style.top = drawn.teTop + \"px\";\r\n            this.wrapper.style.left = drawn.teLeft + \"px\";\r\n        }\r\n    };\r\n\r\n    // Reset the input to correspond to the selection (or to be empty,\r\n    // when not typing and nothing is selected)\r\n    TextareaInput.prototype.reset = function (typing) {\r\n        if (this.contextMenuPending || this.composing) { return }\r\n        var cm = this.cm;\r\n        if (cm.somethingSelected()) {\r\n            this.prevInput = \"\";\r\n            var content = cm.getSelection();\r\n            this.textarea.value = content;\r\n            if (cm.state.focused) { selectInput(this.textarea); }\r\n            if (ie && ie_version >= 9) { this.hasSelection = content; }\r\n        } else if (!typing) {\r\n            this.prevInput = this.textarea.value = \"\";\r\n            if (ie && ie_version >= 9) { this.hasSelection = null; }\r\n        }\r\n    };\r\n\r\n    TextareaInput.prototype.getField = function () { return this.textarea };\r\n\r\n    TextareaInput.prototype.supportsTouch = function () { return false };\r\n\r\n    TextareaInput.prototype.focus = function () {\r\n        if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\r\n            try { this.textarea.focus(); }\r\n            catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\r\n        }\r\n    };\r\n\r\n    TextareaInput.prototype.blur = function () { this.textarea.blur(); };\r\n\r\n    TextareaInput.prototype.resetPosition = function () {\r\n        this.wrapper.style.top = this.wrapper.style.left = 0;\r\n    };\r\n\r\n    TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\r\n\r\n    // Poll for input changes, using the normal rate of polling. This\r\n    // runs as long as the editor is focused.\r\n    TextareaInput.prototype.slowPoll = function () {\r\n        var this$1 = this;\r\n\r\n        if (this.pollingFast) { return }\r\n        this.polling.set(this.cm.options.pollInterval, function () {\r\n            this$1.poll();\r\n            if (this$1.cm.state.focused) { this$1.slowPoll(); }\r\n        });\r\n    };\r\n\r\n    // When an event has just come in that is likely to add or change\r\n    // something in the input textarea, we poll faster, to ensure that\r\n    // the change appears on the screen quickly.\r\n    TextareaInput.prototype.fastPoll = function () {\r\n        var missed = false, input = this;\r\n        input.pollingFast = true;\r\n        function p() {\r\n            var changed = input.poll();\r\n            if (!changed && !missed) {missed = true; input.polling.set(60, p);}\r\n            else {input.pollingFast = false; input.slowPoll();}\r\n        }\r\n        input.polling.set(20, p);\r\n    };\r\n\r\n    // Read input from the textarea, and update the document to match.\r\n    // When something is selected, it is present in the textarea, and\r\n    // selected (unless it is huge, in which case a placeholder is\r\n    // used). When nothing is selected, the cursor sits after previously\r\n    // seen text (can be empty), which is stored in prevInput (we must\r\n    // not reset the textarea when typing, because that breaks IME).\r\n    TextareaInput.prototype.poll = function () {\r\n        var this$1 = this;\r\n\r\n        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\r\n        // Since this is called a *lot*, try to bail out as cheaply as\r\n        // possible when it is clear that nothing happened. hasSelection\r\n        // will be the case when there is a lot of text in the textarea,\r\n        // in which case reading its value would be expensive.\r\n        if (this.contextMenuPending || !cm.state.focused ||\r\n            (hasSelection(input) && !prevInput && !this.composing) ||\r\n            cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\r\n        { return false }\r\n\r\n        var text = input.value;\r\n        // If nothing changed, bail.\r\n        if (text == prevInput && !cm.somethingSelected()) { return false }\r\n        // Work around nonsensical selection resetting in IE9/10, and\r\n        // inexplicable appearance of private area unicode characters on\r\n        // some key combos in Mac (#2689).\r\n        if (ie && ie_version >= 9 && this.hasSelection === text ||\r\n            mac && /[\\uf700-\\uf7ff]/.test(text)) {\r\n            cm.display.input.reset();\r\n            return false\r\n        }\r\n\r\n        if (cm.doc.sel == cm.display.selForContextMenu) {\r\n            var first = text.charCodeAt(0);\r\n            if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\r\n            if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\r\n        }\r\n        // Find the part of the input that is actually new\r\n        var same = 0, l = Math.min(prevInput.length, text.length);\r\n        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\r\n\r\n        runInOp(cm, function () {\r\n            applyTextInput(cm, text.slice(same), prevInput.length - same,\r\n                null, this$1.composing ? \"*compose\" : null);\r\n\r\n            // Don't leave long text in the textarea, since it makes further polling slow\r\n            if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\r\n            else { this$1.prevInput = text; }\r\n\r\n            if (this$1.composing) {\r\n                this$1.composing.range.clear();\r\n                this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\r\n                    {className: \"CodeMirror-composing\"});\r\n            }\r\n        });\r\n        return true\r\n    };\r\n\r\n    TextareaInput.prototype.ensurePolled = function () {\r\n        if (this.pollingFast && this.poll()) { this.pollingFast = false; }\r\n    };\r\n\r\n    TextareaInput.prototype.onKeyPress = function () {\r\n        if (ie && ie_version >= 9) { this.hasSelection = null; }\r\n        this.fastPoll();\r\n    };\r\n\r\n    TextareaInput.prototype.onContextMenu = function (e) {\r\n        var input = this, cm = input.cm, display = cm.display, te = input.textarea;\r\n        if (input.contextMenuPending) { input.contextMenuPending(); }\r\n        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\r\n        if (!pos || presto) { return } // Opera is difficult.\r\n\r\n        // Reset the current text selection only if the click is done outside of the selection\r\n        // and 'resetSelectionOnContextMenu' option is true.\r\n        var reset = cm.options.resetSelectionOnContextMenu;\r\n        if (reset && cm.doc.sel.contains(pos) == -1)\r\n        { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\r\n\r\n        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\r\n        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\r\n        input.wrapper.style.cssText = \"position: static\";\r\n        te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\r\n        var oldScrollY;\r\n        if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\r\n        display.input.focus();\r\n        if (webkit) { window.scrollTo(null, oldScrollY); }\r\n        display.input.reset();\r\n        // Adds \"Select all\" to context menu in FF\r\n        if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\r\n        input.contextMenuPending = rehide;\r\n        display.selForContextMenu = cm.doc.sel;\r\n        clearTimeout(display.detectingSelectAll);\r\n\r\n        // Select-all will be greyed out if there's nothing to select, so\r\n        // this adds a zero-width space so that we can later check whether\r\n        // it got selected.\r\n        function prepareSelectAllHack() {\r\n            if (te.selectionStart != null) {\r\n                var selected = cm.somethingSelected();\r\n                var extval = \"\\u200b\" + (selected ? te.value : \"\");\r\n                te.value = \"\\u21da\"; // Used to catch context-menu undo\r\n                te.value = extval;\r\n                input.prevInput = selected ? \"\" : \"\\u200b\";\r\n                te.selectionStart = 1; te.selectionEnd = extval.length;\r\n                // Re-set this, in case some other handler touched the\r\n                // selection in the meantime.\r\n                display.selForContextMenu = cm.doc.sel;\r\n            }\r\n        }\r\n        function rehide() {\r\n            if (input.contextMenuPending != rehide) { return }\r\n            input.contextMenuPending = false;\r\n            input.wrapper.style.cssText = oldWrapperCSS;\r\n            te.style.cssText = oldCSS;\r\n            if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\r\n\r\n            // Try to detect the user choosing select-all\r\n            if (te.selectionStart != null) {\r\n                if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\r\n                var i = 0, poll = function () {\r\n                    if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\r\n                        te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\r\n                        operation(cm, selectAll)(cm);\r\n                    } else if (i++ < 10) {\r\n                        display.detectingSelectAll = setTimeout(poll, 500);\r\n                    } else {\r\n                        display.selForContextMenu = null;\r\n                        display.input.reset();\r\n                    }\r\n                };\r\n                display.detectingSelectAll = setTimeout(poll, 200);\r\n            }\r\n        }\r\n\r\n        if (ie && ie_version >= 9) { prepareSelectAllHack(); }\r\n        if (captureRightClick) {\r\n            e_stop(e);\r\n            var mouseup = function () {\r\n                off(window, \"mouseup\", mouseup);\r\n                setTimeout(rehide, 20);\r\n            };\r\n            on(window, \"mouseup\", mouseup);\r\n        } else {\r\n            setTimeout(rehide, 50);\r\n        }\r\n    };\r\n\r\n    TextareaInput.prototype.readOnlyChanged = function (val) {\r\n        if (!val) { this.reset(); }\r\n        this.textarea.disabled = val == \"nocursor\";\r\n    };\r\n\r\n    TextareaInput.prototype.setUneditable = function () {};\r\n\r\n    TextareaInput.prototype.needsContentAttribute = false;\r\n\r\n    function fromTextArea(textarea, options) {\r\n        options = options ? copyObj(options) : {};\r\n        options.value = textarea.value;\r\n        if (!options.tabindex && textarea.tabIndex)\r\n        { options.tabindex = textarea.tabIndex; }\r\n        if (!options.placeholder && textarea.placeholder)\r\n        { options.placeholder = textarea.placeholder; }\r\n        // Set autofocus to true if this textarea is focused, or if it has\r\n        // autofocus and no other element is focused.\r\n        if (options.autofocus == null) {\r\n            var hasFocus = activeElt();\r\n            options.autofocus = hasFocus == textarea ||\r\n                textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\r\n        }\r\n\r\n        function save() {textarea.value = cm.getValue();}\r\n\r\n        var realSubmit;\r\n        if (textarea.form) {\r\n            on(textarea.form, \"submit\", save);\r\n            // Deplorable hack to make the submit method do the right thing.\r\n            if (!options.leaveSubmitMethodAlone) {\r\n                var form = textarea.form;\r\n                realSubmit = form.submit;\r\n                try {\r\n                    var wrappedSubmit = form.submit = function () {\r\n                        save();\r\n                        form.submit = realSubmit;\r\n                        form.submit();\r\n                        form.submit = wrappedSubmit;\r\n                    };\r\n                } catch(e) {}\r\n            }\r\n        }\r\n\r\n        options.finishInit = function (cm) {\r\n            cm.save = save;\r\n            cm.getTextArea = function () { return textarea; };\r\n            cm.toTextArea = function () {\r\n                cm.toTextArea = isNaN; // Prevent this from being ran twice\r\n                save();\r\n                textarea.parentNode.removeChild(cm.getWrapperElement());\r\n                textarea.style.display = \"\";\r\n                if (textarea.form) {\r\n                    off(textarea.form, \"submit\", save);\r\n                    if (typeof textarea.form.submit == \"function\")\r\n                    { textarea.form.submit = realSubmit; }\r\n                }\r\n            };\r\n        };\r\n\r\n        textarea.style.display = \"none\";\r\n        var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\r\n            options);\r\n        return cm\r\n    }\r\n\r\n    function addLegacyProps(CodeMirror) {\r\n        CodeMirror.off = off;\r\n        CodeMirror.on = on;\r\n        CodeMirror.wheelEventPixels = wheelEventPixels;\r\n        CodeMirror.Doc = Doc;\r\n        CodeMirror.splitLines = splitLinesAuto;\r\n        CodeMirror.countColumn = countColumn;\r\n        CodeMirror.findColumn = findColumn;\r\n        CodeMirror.isWordChar = isWordCharBasic;\r\n        CodeMirror.Pass = Pass;\r\n        CodeMirror.signal = signal;\r\n        CodeMirror.Line = Line;\r\n        CodeMirror.changeEnd = changeEnd;\r\n        CodeMirror.scrollbarModel = scrollbarModel;\r\n        CodeMirror.Pos = Pos;\r\n        CodeMirror.cmpPos = cmp;\r\n        CodeMirror.modes = modes;\r\n        CodeMirror.mimeModes = mimeModes;\r\n        CodeMirror.resolveMode = resolveMode;\r\n        CodeMirror.getMode = getMode;\r\n        CodeMirror.modeExtensions = modeExtensions;\r\n        CodeMirror.extendMode = extendMode;\r\n        CodeMirror.copyState = copyState;\r\n        CodeMirror.startState = startState;\r\n        CodeMirror.innerMode = innerMode;\r\n        CodeMirror.commands = commands;\r\n        CodeMirror.keyMap = keyMap;\r\n        CodeMirror.keyName = keyName;\r\n        CodeMirror.isModifierKey = isModifierKey;\r\n        CodeMirror.lookupKey = lookupKey;\r\n        CodeMirror.normalizeKeyMap = normalizeKeyMap;\r\n        CodeMirror.StringStream = StringStream;\r\n        CodeMirror.SharedTextMarker = SharedTextMarker;\r\n        CodeMirror.TextMarker = TextMarker;\r\n        CodeMirror.LineWidget = LineWidget;\r\n        CodeMirror.e_preventDefault = e_preventDefault;\r\n        CodeMirror.e_stopPropagation = e_stopPropagation;\r\n        CodeMirror.e_stop = e_stop;\r\n        CodeMirror.addClass = addClass;\r\n        CodeMirror.contains = contains;\r\n        CodeMirror.rmClass = rmClass;\r\n        CodeMirror.keyNames = keyNames;\r\n    }\r\n\r\n    // EDITOR CONSTRUCTOR\r\n\r\n    defineOptions(CodeMirror);\r\n\r\n    addEditorMethods(CodeMirror);\r\n\r\n    // Set up methods on CodeMirror's prototype to redirect to the editor's document.\r\n    var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\r\n    for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\r\n    { CodeMirror.prototype[prop] = (function(method) {\r\n        return function() {return method.apply(this.doc, arguments)}\r\n    })(Doc.prototype[prop]); } }\r\n\r\n    eventMixin(Doc);\r\n    CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\r\n\r\n    // Extra arguments are stored as the mode's dependencies, which is\r\n    // used by (legacy) mechanisms like loadmode.js to automatically\r\n    // load a mode. (Preferred mechanism is the require/define calls.)\r\n    CodeMirror.defineMode = function(name/*, mode, …*/) {\r\n        if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\r\n        defineMode.apply(this, arguments);\r\n    };\r\n\r\n    CodeMirror.defineMIME = defineMIME;\r\n\r\n    // Minimal default mode.\r\n    CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\r\n    CodeMirror.defineMIME(\"text/plain\", \"null\");\r\n\r\n    // EXTENSIONS\r\n\r\n    CodeMirror.defineExtension = function (name, func) {\r\n        CodeMirror.prototype[name] = func;\r\n    };\r\n    CodeMirror.defineDocExtension = function (name, func) {\r\n        Doc.prototype[name] = func;\r\n    };\r\n\r\n    CodeMirror.fromTextArea = fromTextArea;\r\n\r\n    addLegacyProps(CodeMirror);\r\n\r\n    CodeMirror.version = \"5.42.2\";\r\n\r\n    return CodeMirror;\r\n\r\n})));"

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var overArg = __webpack_require__(209);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19),
    root = __webpack_require__(10);
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(30),
    isMasked = __webpack_require__(394),
    isObject = __webpack_require__(11),
    toSource = __webpack_require__(211);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(25);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreJsData = __webpack_require__(395);
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(10);
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19),
    root = __webpack_require__(10);
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(19),
    root = __webpack_require__(10);
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(20),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(20),
    isLength = __webpack_require__(75),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsMatch = __webpack_require__(403),
    getMatchData = __webpack_require__(433),
    matchesStrictComparable = __webpack_require__(222);
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(77),
    baseIsEqual = __webpack_require__(213);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(52);
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(52);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(52);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(52);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(51);
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(51),
    Map = __webpack_require__(74),
    MapCache = __webpack_require__(78);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Hash = __webpack_require__(415),
    ListCache = __webpack_require__(51),
    Map = __webpack_require__(74);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hashClear = __webpack_require__(416),
    hashDelete = __webpack_require__(417),
    hashGet = __webpack_require__(418),
    hashHas = __webpack_require__(419),
    hashSet = __webpack_require__(420);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(53);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(53);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(53);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(53);
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(54);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(54);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(54);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(54);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(77),
    equalArrays = __webpack_require__(214),
    equalByTag = __webpack_require__(429),
    equalObjects = __webpack_require__(431),
    getTag = __webpack_require__(24),
    isArray = __webpack_require__(0),
    isBuffer = __webpack_require__(49),
    isTypedArray = __webpack_require__(76);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(25),
    Uint8Array = __webpack_require__(216),
    eq = __webpack_require__(33),
    equalArrays = __webpack_require__(214),
    mapToArray = __webpack_require__(430),
    setToArray = __webpack_require__(81);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getAllKeys = __webpack_require__(217);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isStrictComparable = __webpack_require__(221),
    keys = __webpack_require__(5);
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqual = __webpack_require__(213),
    get = __webpack_require__(85),
    hasIn = __webpack_require__(439),
    isKey = __webpack_require__(87),
    isStrictComparable = __webpack_require__(221),
    matchesStrictComparable = __webpack_require__(222),
    toKey = __webpack_require__(34);
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoizeCapped = __webpack_require__(436);
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoize = __webpack_require__(437);
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(78);
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(25),
    arrayMap = __webpack_require__(32),
    isArray = __webpack_require__(0),
    isSymbol = __webpack_require__(57);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseHasIn = __webpack_require__(440),
    hasPath = __webpack_require__(224);
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseProperty = __webpack_require__(225),
    basePropertyDeep = __webpack_require__(442),
    isKey = __webpack_require__(87),
    toKey = __webpack_require__(34);
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(86);
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(21),
    isArrayLike = __webpack_require__(8);
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */


function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFor = __webpack_require__(445),
    keys = __webpack_require__(5);
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createBaseFor = __webpack_require__(446);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArrayLike = __webpack_require__(8);
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(35);
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(32);
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */


function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(77),
    arrayEach = __webpack_require__(226),
    assignValue = __webpack_require__(58),
    baseAssign = __webpack_require__(452),
    baseAssignIn = __webpack_require__(453),
    cloneBuffer = __webpack_require__(456),
    copyArray = __webpack_require__(457),
    copySymbols = __webpack_require__(458),
    copySymbolsIn = __webpack_require__(459),
    getAllKeys = __webpack_require__(217),
    getAllKeysIn = __webpack_require__(230),
    getTag = __webpack_require__(24),
    initCloneArray = __webpack_require__(460),
    initCloneByTag = __webpack_require__(461),
    initCloneObject = __webpack_require__(466),
    isArray = __webpack_require__(0),
    isBuffer = __webpack_require__(49),
    isMap = __webpack_require__(468),
    isObject = __webpack_require__(11),
    isSet = __webpack_require__(470),
    keys = __webpack_require__(5),
    keysIn = __webpack_require__(59);
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copyObject = __webpack_require__(36),
    keys = __webpack_require__(5);
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copyObject = __webpack_require__(36),
    keysIn = __webpack_require__(59);
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(11),
    isPrototype = __webpack_require__(29),
    nativeKeysIn = __webpack_require__(455);
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var root = __webpack_require__(10);
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(44)(module)))

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copyObject = __webpack_require__(36),
    getSymbols = __webpack_require__(83);
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var copyObject = __webpack_require__(36),
    getSymbolsIn = __webpack_require__(228);
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cloneArrayBuffer = __webpack_require__(89),
    cloneDataView = __webpack_require__(462),
    cloneRegExp = __webpack_require__(463),
    cloneSymbol = __webpack_require__(464),
    cloneTypedArray = __webpack_require__(465);
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cloneArrayBuffer = __webpack_require__(89);
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(25);
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var cloneArrayBuffer = __webpack_require__(89);
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseCreate = __webpack_require__(467),
    getPrototype = __webpack_require__(229),
    isPrototype = __webpack_require__(29);
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(11);
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsMap = __webpack_require__(469),
    baseUnary = __webpack_require__(31),
    nodeUtil = __webpack_require__(50);
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getTag = __webpack_require__(24),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsSet = __webpack_require__(471),
    baseUnary = __webpack_require__(31),
    nodeUtil = __webpack_require__(50);
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getTag = __webpack_require__(24),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PRINT_WARNING = exports.PRINT_ERROR = void 0;

function PRINT_ERROR(msg) {
  /* istanbul ignore else - can't override global.console in node.js */
  if (console && console.error) {
    console.error("Error: ".concat(msg));
  }
}

exports.PRINT_ERROR = PRINT_ERROR;

function PRINT_WARNING(msg) {
  /* istanbul ignore else - can't override global.console in node.js*/
  if (console && console.warn) {
    // TODO: modify docs accordingly
    console.warn("Warning: ".concat(msg));
  }
}

exports.PRINT_WARNING = PRINT_WARNING;

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timer = void 0;

function timer(func) {
  var start = new Date().getTime();
  var val = func();
  var end = new Date().getTime();
  var total = end - start;
  return {
    time: total,
    value: val
  };
}

exports.timer = timer;

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFastProperties = void 0; // based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216

function toFastProperties(toBecomeFast) {
  function FakeConstructor() {} // If our object is used as a constructor it would receive


  FakeConstructor.prototype = toBecomeFast;
  var fakeInstance = new FakeConstructor();

  function fakeAccess() {
    return _typeof(fakeInstance.bar);
  } // help V8 understand this is a "real" prototype by actually using
  // the fake instance.


  fakeAccess();
  fakeAccess(); // Always true condition to suppress the Firefox warning of unreachable
  // code after a return statement.

  if (1) return toBecomeFast; // Eval prevents optimization of this method (even though this is dead code)

  /* istanbul ignore next */
  // tslint:disable-next-line

  eval(toBecomeFast);
}

exports.toFastProperties = toFastProperties;

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildInProdFollowPrefix = exports.buildBetweenProdsFollowPrefix = exports.computeAllProdsFollows = exports.ResyncFollowsWalker = void 0;

var rest_1 = __webpack_require__(90);

var first_1 = __webpack_require__(234);

var forEach_1 = __importDefault(__webpack_require__(3));

var assign_1 = __importDefault(__webpack_require__(60));

var constants_1 = __webpack_require__(237);

var gast_1 = __webpack_require__(2); // This ResyncFollowsWalker computes all of the follows required for RESYNC
// (skipping reference production).


var ResyncFollowsWalker =
/** @class */
function (_super) {
  __extends(ResyncFollowsWalker, _super);

  function ResyncFollowsWalker(topProd) {
    var _this = _super.call(this) || this;

    _this.topProd = topProd;
    _this.follows = {};
    return _this;
  }

  ResyncFollowsWalker.prototype.startWalking = function () {
    this.walk(this.topProd);
    return this.follows;
  };

  ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {// do nothing! just like in the public sector after 13:00
  };

  ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
    var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
    var fullRest = currRest.concat(prevRest);
    var restProd = new gast_1.Alternative({
      definition: fullRest
    });
    var t_in_topProd_follows = (0, first_1.first)(restProd);
    this.follows[followName] = t_in_topProd_follows;
  };

  return ResyncFollowsWalker;
}(rest_1.RestWalker);

exports.ResyncFollowsWalker = ResyncFollowsWalker;

function computeAllProdsFollows(topProductions) {
  var reSyncFollows = {};
  (0, forEach_1["default"])(topProductions, function (topProd) {
    var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
    (0, assign_1["default"])(reSyncFollows, currRefsFollow);
  });
  return reSyncFollows;
}

exports.computeAllProdsFollows = computeAllProdsFollows;

function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
  return inner.name + occurenceInParent + constants_1.IN;
}

exports.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;

function buildInProdFollowPrefix(terminal) {
  var terminalName = terminal.terminalType.name;
  return terminalName + terminal.idx + constants_1.IN;
}

exports.buildInProdFollowPrefix = buildInProdFollowPrefix;

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toNumber = __webpack_require__(477);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */

function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }

  value = toNumber(value);

  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }

  return value === value ? value : 0;
}

module.exports = toFinite;

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTrim = __webpack_require__(478),
    isObject = __webpack_require__(11),
    isSymbol = __webpack_require__(57);
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var trimmedEndIndex = __webpack_require__(479);
/** Used to match leading whitespace. */


var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

module.exports = baseTrim;

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

module.exports = trimmedEndIndex;

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(20),
    isObjectLike = __webpack_require__(12);
/** `Object#toString` result references. */


var regexpTag = '[object RegExp]';
/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */

function baseIsRegExp(value) {
  return isObjectLike(value) && baseGetTag(value) == regexpTag;
}

module.exports = baseIsRegExp;

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(86),
    baseSet = __webpack_require__(482),
    castPath = __webpack_require__(56);
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */


function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }

  return result;
}

module.exports = basePickBy;

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assignValue = __webpack_require__(58),
    castPath = __webpack_require__(56),
    isIndex = __webpack_require__(55),
    isObject = __webpack_require__(11),
    toKey = __webpack_require__(34);
/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */


function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

module.exports = baseSet;

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseRest = __webpack_require__(94),
    isIterateeCall = __webpack_require__(61);
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */


function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

module.exports = createAssigner;

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = __webpack_require__(485);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSetToString = __webpack_require__(487),
    shortOut = __webpack_require__(489);
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constant = __webpack_require__(488),
    defineProperty = __webpack_require__(227),
    identity = __webpack_require__(35);
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GAstVisitor = void 0;

var model_1 = __webpack_require__(93);

var GAstVisitor =
/** @class */
function () {
  function GAstVisitor() {}

  GAstVisitor.prototype.visit = function (node) {
    var nodeAny = node;

    switch (nodeAny.constructor) {
      case model_1.NonTerminal:
        return this.visitNonTerminal(nodeAny);

      case model_1.Alternative:
        return this.visitAlternative(nodeAny);

      case model_1.Option:
        return this.visitOption(nodeAny);

      case model_1.RepetitionMandatory:
        return this.visitRepetitionMandatory(nodeAny);

      case model_1.RepetitionMandatoryWithSeparator:
        return this.visitRepetitionMandatoryWithSeparator(nodeAny);

      case model_1.RepetitionWithSeparator:
        return this.visitRepetitionWithSeparator(nodeAny);

      case model_1.Repetition:
        return this.visitRepetition(nodeAny);

      case model_1.Alternation:
        return this.visitAlternation(nodeAny);

      case model_1.Terminal:
        return this.visitTerminal(nodeAny);

      case model_1.Rule:
        return this.visitRule(nodeAny);

      /* istanbul ignore next */

      default:
        throw Error("non exhaustive match");
    }
  };
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitNonTerminal = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitAlternative = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitOption = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitRepetition = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitRepetitionMandatory = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitRepetitionWithSeparator = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitAlternation = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitTerminal = function (node) {};
  /* istanbul ignore next - testing the fact a NOOP function exists is non-trivial  */


  GAstVisitor.prototype.visitRule = function (node) {};

  return GAstVisitor;
}();

exports.GAstVisitor = GAstVisitor;

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProductionDslName = exports.isBranchingProd = exports.isOptionalProd = exports.isSequenceProd = void 0;

var some_1 = __importDefault(__webpack_require__(95));

var every_1 = __importDefault(__webpack_require__(62));

var includes_1 = __importDefault(__webpack_require__(18));

var model_1 = __webpack_require__(93);

function isSequenceProd(prod) {
  return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
}

exports.isSequenceProd = isSequenceProd;

function isOptionalProd(prod, alreadyVisited) {
  if (alreadyVisited === void 0) {
    alreadyVisited = [];
  }

  var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;

  if (isDirectlyOptional) {
    return true;
  } // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
  // empty optional top rule
  // may be indirectly optional ((A?B?C?) | (D?E?F?))


  if (prod instanceof model_1.Alternation) {
    // for OR its enough for just one of the alternatives to be optional
    return (0, some_1["default"])(prod.definition, function (subProd) {
      return isOptionalProd(subProd, alreadyVisited);
    });
  } else if (prod instanceof model_1.NonTerminal && (0, includes_1["default"])(alreadyVisited, prod)) {
    // avoiding stack overflow due to infinite recursion
    return false;
  } else if (prod instanceof model_1.AbstractProduction) {
    if (prod instanceof model_1.NonTerminal) {
      alreadyVisited.push(prod);
    }

    return (0, every_1["default"])(prod.definition, function (subProd) {
      return isOptionalProd(subProd, alreadyVisited);
    });
  } else {
    return false;
  }
}

exports.isOptionalProd = isOptionalProd;

function isBranchingProd(prod) {
  return prod instanceof model_1.Alternation;
}

exports.isBranchingProd = isBranchingProd;

function getProductionDslName(prod) {
  /* istanbul ignore else */
  if (prod instanceof model_1.NonTerminal) {
    return "SUBRULE";
  } else if (prod instanceof model_1.Option) {
    return "OPTION";
  } else if (prod instanceof model_1.Alternation) {
    return "OR";
  } else if (prod instanceof model_1.RepetitionMandatory) {
    return "AT_LEAST_ONE";
  } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
    return "AT_LEAST_ONE_SEP";
  } else if (prod instanceof model_1.RepetitionWithSeparator) {
    return "MANY_SEP";
  } else if (prod instanceof model_1.Repetition) {
    return "MANY";
  } else if (prod instanceof model_1.Terminal) {
    return "CONSUME";
  } else {
    throw Error("non exhaustive match");
  }
}

exports.getProductionDslName = getProductionDslName;

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(21);
/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */


function baseSome(collection, predicate) {
  var result;
  baseEach(collection, function (value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

module.exports = baseSome;

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }

  return true;
}

module.exports = arrayEvery;

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(21);
/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */


function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function (value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(25),
    isArguments = __webpack_require__(48),
    isArray = __webpack_require__(0);
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SetCache = __webpack_require__(79),
    arrayIncludes = __webpack_require__(235),
    arrayIncludesWith = __webpack_require__(236),
    cacheHas = __webpack_require__(80),
    createSet = __webpack_require__(499),
    setToArray = __webpack_require__(81);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Set = __webpack_require__(212),
    noop = __webpack_require__(99),
    setToArray = __webpack_require__(81);
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return array && array.length ? array[0] : undefined;
}

module.exports = head;

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */

function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  return function () {
    var args = arguments;

    switch (args.length) {
      case 0:
        return !predicate.call(this);

      case 1:
        return !predicate.call(this, args[0]);

      case 2:
        return !predicate.call(this, args[0], args[1]);

      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }

    return !predicate.apply(this, args);
  };
}

module.exports = negate;

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SetCache = __webpack_require__(79),
    arrayIncludes = __webpack_require__(235),
    arrayIncludesWith = __webpack_require__(236),
    arrayMap = __webpack_require__(32),
    baseUnary = __webpack_require__(31),
    cacheHas = __webpack_require__(80);
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */

function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }

  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }

  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  } else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;

      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }

      result.push(value);
    } else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }

  return result;
}

module.exports = baseDifference;

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArrayLike = __webpack_require__(8),
    isObjectLike = __webpack_require__(12);
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIndexOf = __webpack_require__(96),
    toInteger = __webpack_require__(38);
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */

function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return -1;
  }

  var index = fromIndex == null ? 0 : toInteger(fromIndex);

  if (index < 0) {
    index = nativeMax(length + index, 0);
  }

  return baseIndexOf(array, value, index);
}

module.exports = indexOf;

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIteratee = __webpack_require__(13),
    isArrayLike = __webpack_require__(8),
    keys = __webpack_require__(5);
/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */


function createFind(findIndexFunc) {
  return function (collection, predicate, fromIndex) {
    var iterable = Object(collection);

    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);

      predicate = function predicate(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }

    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

module.exports = arrayReduce;

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function (value, index, collection) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;

var regexp_to_ast_1 = __webpack_require__(100);

var isArray_1 = __importDefault(__webpack_require__(0));

var every_1 = __importDefault(__webpack_require__(62));

var forEach_1 = __importDefault(__webpack_require__(3));

var find_1 = __importDefault(__webpack_require__(103));

var values_1 = __importDefault(__webpack_require__(15));

var includes_1 = __importDefault(__webpack_require__(18));

var utils_1 = __webpack_require__(37);

var reg_exp_parser_1 = __webpack_require__(105);

var lexer_1 = __webpack_require__(238);

var complementErrorMessage = "Complement Sets are not supported for first char optimization";
exports.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';

function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
  if (ensureOptimizations === void 0) {
    ensureOptimizations = false;
  }

  try {
    var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
    return firstChars;
  } catch (e) {
    /* istanbul ignore next */
    // Testing this relies on the regexp-to-ast library having a bug... */
    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc
    if (e.message === complementErrorMessage) {
      if (ensureOptimizations) {
        (0, utils_1.PRINT_WARNING)("".concat(exports.failedOptimizationPrefixMsg) + "\tUnable to optimize: < ".concat(regExp.toString(), " >\n") + "\tComplement Sets cannot be automatically optimized.\n" + "\tThis will disable the lexer's first char optimizations.\n" + "\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
      }
    } else {
      var msgSuffix = "";

      if (ensureOptimizations) {
        msgSuffix = "\n\tThis will disable the lexer's first char optimizations.\n" + "\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
      }

      (0, utils_1.PRINT_ERROR)("".concat(exports.failedOptimizationPrefixMsg, "\n") + "\tFailed parsing: < ".concat(regExp.toString(), " >\n") + "\tUsing the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
    }
  }

  return [];
}

exports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;

function firstCharOptimizedIndices(ast, result, ignoreCase) {
  switch (ast.type) {
    case "Disjunction":
      for (var i = 0; i < ast.value.length; i++) {
        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
      }

      break;

    case "Alternative":
      var terms = ast.value;

      for (var i = 0; i < terms.length; i++) {
        var term = terms[i]; // skip terms that cannot effect the first char results

        switch (term.type) {
          case "EndAnchor": // A group back reference cannot affect potential starting char.
          // because if a back reference is the first production than automatically
          // the group being referenced has had to come BEFORE so its codes have already been added

          case "GroupBackReference": // assertions do not affect potential starting codes

          case "Lookahead":
          case "NegativeLookahead":
          case "StartAnchor":
          case "WordBoundary":
          case "NonWordBoundary":
            continue;
        }

        var atom = term;

        switch (atom.type) {
          case "Character":
            addOptimizedIdxToResult(atom.value, result, ignoreCase);
            break;

          case "Set":
            if (atom.complement === true) {
              throw Error(complementErrorMessage);
            }

            (0, forEach_1["default"])(atom.value, function (code) {
              if (typeof code === "number") {
                addOptimizedIdxToResult(code, result, ignoreCase);
              } else {
                // range
                var range = code; // cannot optimize when ignoreCase is

                if (ignoreCase === true) {
                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                  }
                } // Optimization (2 orders of magnitude less work for very large ranges)
                else {
                  // handle unoptimized values
                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                  } // Less common charCode where we optimize for faster init time, by using larger "buckets"


                  if (range.to >= lexer_1.minOptimizationVal) {
                    var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                    var maxUnOptVal = range.to;
                    var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                    var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);

                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                      result[currOptIdx] = currOptIdx;
                    }
                  }
                }
              }
            });
            break;

          case "Group":
            firstCharOptimizedIndices(atom.value, result, ignoreCase);
            break;

          /* istanbul ignore next */

          default:
            throw Error("Non Exhaustive Match");
        } // reached a mandatory production, no more **start** codes can be found on this alternative


        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;

        if ( // A group may be optional due to empty contents /(?:)/
        // or if everything inside it is optional /((a)?)/
        atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
        atom.type !== "Group" && isOptionalQuantifier === false) {
          break;
        }
      }

      break;

    /* istanbul ignore next */

    default:
      throw Error("non exhaustive match!");
  } // console.log(Object.keys(result).length)


  return (0, values_1["default"])(result);
}

exports.firstCharOptimizedIndices = firstCharOptimizedIndices;

function addOptimizedIdxToResult(code, result, ignoreCase) {
  var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
  result[optimizedCharIdx] = optimizedCharIdx;

  if (ignoreCase === true) {
    handleIgnoreCase(code, result);
  }
}

function handleIgnoreCase(code, result) {
  var _char = String.fromCharCode(code);

  var upperChar = _char.toUpperCase();
  /* istanbul ignore else */


  if (upperChar !== _char) {
    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
    result[optimizedCharIdx] = optimizedCharIdx;
  } else {
    var lowerChar = _char.toLowerCase();

    if (lowerChar !== _char) {
      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
      result[optimizedCharIdx] = optimizedCharIdx;
    }
  }
}

function findCode(setNode, targetCharCodes) {
  return (0, find_1["default"])(setNode.value, function (codeOrRange) {
    if (typeof codeOrRange === "number") {
      return (0, includes_1["default"])(targetCharCodes, codeOrRange);
    } else {
      // range
      var range_1 = codeOrRange;
      return (0, find_1["default"])(targetCharCodes, function (targetCode) {
        return range_1.from <= targetCode && targetCode <= range_1.to;
      }) !== undefined;
    }
  });
}

function isWholeOptional(ast) {
  var quantifier = ast.quantifier;

  if (quantifier && quantifier.atLeast === 0) {
    return true;
  }

  if (!ast.value) {
    return false;
  }

  return (0, isArray_1["default"])(ast.value) ? (0, every_1["default"])(ast.value, isWholeOptional) : isWholeOptional(ast.value);
}

var CharCodeFinder =
/** @class */
function (_super) {
  __extends(CharCodeFinder, _super);

  function CharCodeFinder(targetCharCodes) {
    var _this = _super.call(this) || this;

    _this.targetCharCodes = targetCharCodes;
    _this.found = false;
    return _this;
  }

  CharCodeFinder.prototype.visitChildren = function (node) {
    // No need to keep looking...
    if (this.found === true) {
      return;
    } // switch lookaheads as they do not actually consume any characters thus
    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.


    switch (node.type) {
      case "Lookahead":
        this.visitLookahead(node);
        return;

      case "NegativeLookahead":
        this.visitNegativeLookahead(node);
        return;
    }

    _super.prototype.visitChildren.call(this, node);
  };

  CharCodeFinder.prototype.visitCharacter = function (node) {
    if ((0, includes_1["default"])(this.targetCharCodes, node.value)) {
      this.found = true;
    }
  };

  CharCodeFinder.prototype.visitSet = function (node) {
    if (node.complement) {
      if (findCode(node, this.targetCharCodes) === undefined) {
        this.found = true;
      }
    } else {
      if (findCode(node, this.targetCharCodes) !== undefined) {
        this.found = true;
      }
    }
  };

  return CharCodeFinder;
}(regexp_to_ast_1.BaseRegExpVisitor);

function canMatchCharCode(charCodes, pattern) {
  if (pattern instanceof RegExp) {
    var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
    var charCodeFinder = new CharCodeFinder(charCodes);
    charCodeFinder.visit(ast);
    return charCodeFinder.found;
  } else {
    return (0, find_1["default"])(pattern, function (_char2) {
      return (0, includes_1["default"])(charCodes, _char2.charCodeAt(0));
    }) !== undefined;
  }
}

exports.canMatchCharCode = canMatchCharCode;

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateGrammar = exports.resolveGrammar = void 0;

var forEach_1 = __importDefault(__webpack_require__(3));

var defaults_1 = __importDefault(__webpack_require__(241));

var resolver_1 = __webpack_require__(510);

var checks_1 = __webpack_require__(243);

var errors_public_1 = __webpack_require__(65);

function resolveGrammar(options) {
  var actualOptions = (0, defaults_1["default"])(options, {
    errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
  });
  var topRulesTable = {};
  (0, forEach_1["default"])(options.rules, function (rule) {
    topRulesTable[rule.name] = rule;
  });
  return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
}

exports.resolveGrammar = resolveGrammar;

function validateGrammar(options) {
  options = (0, defaults_1["default"])(options, {
    errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
  });
  return (0, checks_1.validateGrammar)(options.rules, options.maxLookahead, options.tokenTypes, options.errMsgProvider, options.grammarName);
}

exports.validateGrammar = validateGrammar;

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GastRefResolverVisitor = exports.resolveGrammar = void 0;

var parser_1 = __webpack_require__(6);

var forEach_1 = __importDefault(__webpack_require__(3));

var values_1 = __importDefault(__webpack_require__(15));

var gast_1 = __webpack_require__(2);

function resolveGrammar(topLevels, errMsgProvider) {
  var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
  refResolver.resolveRefs();
  return refResolver.errors;
}

exports.resolveGrammar = resolveGrammar;

var GastRefResolverVisitor =
/** @class */
function (_super) {
  __extends(GastRefResolverVisitor, _super);

  function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {
    var _this = _super.call(this) || this;

    _this.nameToTopRule = nameToTopRule;
    _this.errMsgProvider = errMsgProvider;
    _this.errors = [];
    return _this;
  }

  GastRefResolverVisitor.prototype.resolveRefs = function () {
    var _this = this;

    (0, forEach_1["default"])((0, values_1["default"])(this.nameToTopRule), function (prod) {
      _this.currTopLevel = prod;
      prod.accept(_this);
    });
  };

  GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {
    var ref = this.nameToTopRule[node.nonTerminalName];

    if (!ref) {
      var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
      this.errors.push({
        message: msg,
        type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
        ruleName: this.currTopLevel.name,
        unresolvedRefName: node.nonTerminalName
      });
    } else {
      node.referencedRule = ref;
    }
  };

  return GastRefResolverVisitor;
}(gast_1.GAstVisitor);

exports.GastRefResolverVisitor = GastRefResolverVisitor;

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayAggregator = __webpack_require__(512),
    baseAggregator = __webpack_require__(513),
    baseIteratee = __webpack_require__(13),
    isArray = __webpack_require__(0);
/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */


function createAggregator(setter, initializer) {
  return function (collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

module.exports = createAggregator;

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }

  return accumulator;
}

module.exports = arrayAggregator;

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(21);
/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */


function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function (value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

module.exports = baseAggregator;

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFlatten = __webpack_require__(97),
    map = __webpack_require__(4);
/**
 * Creates a flattened array of values by running each element in `collection`
 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [n, n];
 * }
 *
 * _.flatMap([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */


function flatMap(collection, iteratee) {
  return baseFlatten(map(collection, iteratee), 1);
}

module.exports = flatMap;

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.collectMethods = exports.LooksAhead = void 0;

var lookahead_1 = __webpack_require__(66);

var forEach_1 = __importDefault(__webpack_require__(3));

var has_1 = __importDefault(__webpack_require__(7));

var parser_1 = __webpack_require__(6);

var keys_1 = __webpack_require__(108);

var gast_1 = __webpack_require__(2);

var gast_2 = __webpack_require__(2);
/**
 * Trait responsible for the lookahead related utilities and optimizations.
 */


var LooksAhead =
/** @class */
function () {
  function LooksAhead() {}

  LooksAhead.prototype.initLooksAhead = function (config) {
    this.dynamicTokensEnabled = (0, has_1["default"])(config, "dynamicTokensEnabled") ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
    this.maxLookahead = (0, has_1["default"])(config, "maxLookahead") ? config.maxLookahead // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
    this.lookAheadFuncsCache = new Map();
  };

  LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {
    var _this = this;

    (0, forEach_1["default"])(rules, function (currRule) {
      _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function () {
        var _a = collectMethods(currRule),
            alternation = _a.alternation,
            repetition = _a.repetition,
            option = _a.option,
            repetitionMandatory = _a.repetitionMandatory,
            repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator,
            repetitionWithSeparator = _a.repetitionWithSeparator;

        (0, forEach_1["default"])(alternation, function (currProd) {
          var prodIdx = currProd.idx === 0 ? "" : currProd.idx;

          _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function () {
            var laFunc = (0, lookahead_1.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
            var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);

            _this.setLaFuncCache(key, laFunc);
          });
        });
        (0, forEach_1["default"])(repetition, function (currProd) {
          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, lookahead_1.PROD_TYPE.REPETITION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
        });
        (0, forEach_1["default"])(option, function (currProd) {
          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, lookahead_1.PROD_TYPE.OPTION, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
        });
        (0, forEach_1["default"])(repetitionMandatory, function (currProd) {
          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
        });
        (0, forEach_1["default"])(repetitionMandatoryWithSeparator, function (currProd) {
          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
        });
        (0, forEach_1["default"])(repetitionWithSeparator, function (currProd) {
          _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, lookahead_1.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
        });
      });
    });
  };

  LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
    var _this = this;

    this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function () {
      var laFunc = (0, lookahead_1.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
      var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);

      _this.setLaFuncCache(key, laFunc);
    });
  };

  LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {
    return (0, lookahead_1.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);
  };

  LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
    return (0, lookahead_1.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);
  }; // this actually returns a number, but it is always used as a string (object prop key)


  LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {
    var currRuleShortName = this.getLastExplicitRuleShortName();
    return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
  };

  LooksAhead.prototype.getLaFuncFromCache = function (key) {
    return this.lookAheadFuncsCache.get(key);
  };
  /* istanbul ignore next */


  LooksAhead.prototype.setLaFuncCache = function (key, value) {
    this.lookAheadFuncsCache.set(key, value);
  };

  return LooksAhead;
}();

exports.LooksAhead = LooksAhead;

var DslMethodsCollectorVisitor =
/** @class */
function (_super) {
  __extends(DslMethodsCollectorVisitor, _super);

  function DslMethodsCollectorVisitor() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
    return _this;
  }

  DslMethodsCollectorVisitor.prototype.reset = function () {
    this.dslMethods = {
      option: [],
      alternation: [],
      repetition: [],
      repetitionWithSeparator: [],
      repetitionMandatory: [],
      repetitionMandatoryWithSeparator: []
    };
  };

  DslMethodsCollectorVisitor.prototype.visitOption = function (option) {
    this.dslMethods.option.push(option);
  };

  DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {
    this.dslMethods.repetitionWithSeparator.push(manySep);
  };

  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {
    this.dslMethods.repetitionMandatory.push(atLeastOne);
  };

  DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
  };

  DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {
    this.dslMethods.repetition.push(many);
  };

  DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {
    this.dslMethods.alternation.push(or);
  };

  return DslMethodsCollectorVisitor;
}(gast_1.GAstVisitor);

var collectorVisitor = new DslMethodsCollectorVisitor();

function collectMethods(rule) {
  collectorVisitor.reset();
  rule.accept(collectorVisitor);
  var dslMethods = collectorVisitor.dslMethods; // avoid uncleaned references

  collectorVisitor.reset();
  return dslMethods;
}

exports.collectMethods = collectMethods;

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TreeBuilder = void 0;

var cst_1 = __webpack_require__(517);

var noop_1 = __importDefault(__webpack_require__(99));

var has_1 = __importDefault(__webpack_require__(7));

var keys_1 = __importDefault(__webpack_require__(5));

var isUndefined_1 = __importDefault(__webpack_require__(22));

var cst_visitor_1 = __webpack_require__(518);

var parser_1 = __webpack_require__(6);
/**
 * This trait is responsible for the CST building logic.
 */


var TreeBuilder =
/** @class */
function () {
  function TreeBuilder() {}

  TreeBuilder.prototype.initTreeBuilder = function (config) {
    this.CST_STACK = []; // outputCst is no longer exposed/defined in the pubic API

    this.outputCst = config.outputCst;
    this.nodeLocationTracking = (0, has_1["default"])(config, "nodeLocationTracking") ? config.nodeLocationTracking // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;

    if (!this.outputCst) {
      this.cstInvocationStateUpdate = noop_1["default"];
      this.cstFinallyStateUpdate = noop_1["default"];
      this.cstPostTerminal = noop_1["default"];
      this.cstPostNonTerminal = noop_1["default"];
      this.cstPostRule = noop_1["default"];
    } else {
      if (/full/i.test(this.nodeLocationTracking)) {
        if (this.recoveryEnabled) {
          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
          this.cstPostRule = noop_1["default"];
          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
        } else {
          this.setNodeLocationFromToken = noop_1["default"];
          this.setNodeLocationFromNode = noop_1["default"];
          this.cstPostRule = this.cstPostRuleFull;
          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
        }
      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
        if (this.recoveryEnabled) {
          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
          this.cstPostRule = noop_1["default"];
          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
        } else {
          this.setNodeLocationFromToken = noop_1["default"];
          this.setNodeLocationFromNode = noop_1["default"];
          this.cstPostRule = this.cstPostRuleOnlyOffset;
          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
        }
      } else if (/none/i.test(this.nodeLocationTracking)) {
        this.setNodeLocationFromToken = noop_1["default"];
        this.setNodeLocationFromNode = noop_1["default"];
        this.cstPostRule = noop_1["default"];
        this.setInitialNodeLocation = noop_1["default"];
      } else {
        throw Error("Invalid <nodeLocationTracking> config option: \"".concat(config.nodeLocationTracking, "\""));
      }
    }
  };

  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {
    cstNode.location = {
      startOffset: NaN,
      endOffset: NaN
    };
  };

  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {
    cstNode.location = {
      // without error recovery the starting Location of a new CstNode is guaranteed
      // To be the next Token's startOffset (for valid inputs).
      // For invalid inputs there won't be any CSTOutput so this potential
      // inaccuracy does not matter
      startOffset: this.LA(1).startOffset,
      endOffset: NaN
    };
  };

  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {
    cstNode.location = {
      startOffset: NaN,
      startLine: NaN,
      startColumn: NaN,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  };
  /**
     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
        * @param cstNode
     */


  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {
    var nextToken = this.LA(1);
    cstNode.location = {
      startOffset: nextToken.startOffset,
      startLine: nextToken.startLine,
      startColumn: nextToken.startColumn,
      endOffset: NaN,
      endLine: NaN,
      endColumn: NaN
    };
  };

  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName) {
    var cstNode = {
      name: fullRuleName,
      children: Object.create(null)
    };
    this.setInitialNodeLocation(cstNode);
    this.CST_STACK.push(cstNode);
  };

  TreeBuilder.prototype.cstFinallyStateUpdate = function () {
    this.CST_STACK.pop();
  };

  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {
    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled
    var prevToken = this.LA(0);
    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token
    // In this CstNode.

    if (loc.startOffset <= prevToken.startOffset === true) {
      loc.endOffset = prevToken.endOffset;
      loc.endLine = prevToken.endLine;
      loc.endColumn = prevToken.endColumn;
    } // "empty" CstNode edge case
    else {
      loc.startOffset = NaN;
      loc.startLine = NaN;
      loc.startColumn = NaN;
    }
  };

  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {
    var prevToken = this.LA(0); // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.

    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token
    // In this CstNode.

    if (loc.startOffset <= prevToken.startOffset === true) {
      loc.endOffset = prevToken.endOffset;
    } // "empty" CstNode edge case
    else {
      loc.startOffset = NaN;
    }
  };

  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {
    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
    (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.

    this.setNodeLocationFromToken(rootCst.location, consumedToken);
  };

  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {
    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
    (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.

    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
  };

  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {
    if ((0, isUndefined_1["default"])(this.baseCstVisitorConstructor)) {
      var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1["default"])(this.gastProductionsCache));
      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
      return newBaseCstVisitorConstructor;
    }

    return this.baseCstVisitorConstructor;
  };

  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {
    if ((0, isUndefined_1["default"])(this.baseCstVisitorWithDefaultsConstructor)) {
      var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1["default"])(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
      this.baseCstVisitorWithDefaultsConstructor = newConstructor;
      return newConstructor;
    }

    return this.baseCstVisitorWithDefaultsConstructor;
  };

  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {
    var ruleStack = this.RULE_STACK;
    return ruleStack[ruleStack.length - 1];
  };

  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {
    var ruleStack = this.RULE_STACK;
    return ruleStack[ruleStack.length - 2];
  };

  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {
    var occurrenceStack = this.RULE_OCCURRENCE_STACK;
    return occurrenceStack[occurrenceStack.length - 1];
  };

  return TreeBuilder;
}();

exports.TreeBuilder = TreeBuilder;

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */

function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
  // First (valid) update for this cst node
  if (isNaN(currNodeLocation.startOffset) === true) {
    // assumption1: Token location information is either NaN or a valid number
    // assumption2: Token location information is fully valid if it exist
    // (both start/end offsets exist and are numbers).
    currNodeLocation.startOffset = newLocationInfo.startOffset;
    currNodeLocation.endOffset = newLocationInfo.endOffset;
  } // Once the startOffset has been updated with a valid number it should never receive
  // any farther updates as the Token vector is sorted.
  // We still have to check this this condition for every new possible location info
  // because with error recovery enabled we may encounter invalid tokens (NaN location props)
  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
    currNodeLocation.endOffset = newLocationInfo.endOffset;
  }
}

exports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */

function setNodeLocationFull(currNodeLocation, newLocationInfo) {
  // First (valid) update for this cst node
  if (isNaN(currNodeLocation.startOffset) === true) {
    // assumption1: Token location information is either NaN or a valid number
    // assumption2: Token location information is fully valid if it exist
    // (all start/end props exist and are numbers).
    currNodeLocation.startOffset = newLocationInfo.startOffset;
    currNodeLocation.startColumn = newLocationInfo.startColumn;
    currNodeLocation.startLine = newLocationInfo.startLine;
    currNodeLocation.endOffset = newLocationInfo.endOffset;
    currNodeLocation.endColumn = newLocationInfo.endColumn;
    currNodeLocation.endLine = newLocationInfo.endLine;
  } // Once the start props has been updated with a valid number it should never receive
  // any farther updates as the Token vector is sorted.
  // We still have to check this this condition for every new possible location info
  // because with error recovery enabled we may encounter invalid tokens (NaN location props)
  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
    currNodeLocation.endOffset = newLocationInfo.endOffset;
    currNodeLocation.endColumn = newLocationInfo.endColumn;
    currNodeLocation.endLine = newLocationInfo.endLine;
  }
}

exports.setNodeLocationFull = setNodeLocationFull;

function addTerminalToCst(node, token, tokenTypeName) {
  if (node.children[tokenTypeName] === undefined) {
    node.children[tokenTypeName] = [token];
  } else {
    node.children[tokenTypeName].push(token);
  }
}

exports.addTerminalToCst = addTerminalToCst;

function addNoneTerminalToCst(node, ruleName, ruleResult) {
  if (node.children[ruleName] === undefined) {
    node.children[ruleName] = [ruleResult];
  } else {
    node.children[ruleName].push(ruleResult);
  }
}

exports.addNoneTerminalToCst = addNoneTerminalToCst;

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateMissingCstMethods = exports.validateVisitor = exports.CstVisitorDefinitionError = exports.createBaseVisitorConstructorWithDefaults = exports.createBaseSemanticVisitorConstructor = exports.defaultVisit = void 0;

var isEmpty_1 = __importDefault(__webpack_require__(9));

var compact_1 = __importDefault(__webpack_require__(64));

var isArray_1 = __importDefault(__webpack_require__(0));

var map_1 = __importDefault(__webpack_require__(4));

var forEach_1 = __importDefault(__webpack_require__(3));

var filter_1 = __importDefault(__webpack_require__(104));

var keys_1 = __importDefault(__webpack_require__(5));

var isFunction_1 = __importDefault(__webpack_require__(30));

var isUndefined_1 = __importDefault(__webpack_require__(22));

var lang_extensions_1 = __webpack_require__(519);

function defaultVisit(ctx, param) {
  var childrenNames = (0, keys_1["default"])(ctx);
  var childrenNamesLength = childrenNames.length;

  for (var i = 0; i < childrenNamesLength; i++) {
    var currChildName = childrenNames[i];
    var currChildArray = ctx[currChildName];
    var currChildArrayLength = currChildArray.length;

    for (var j = 0; j < currChildArrayLength; j++) {
      var currChild = currChildArray[j]; // distinction between Tokens Children and CstNode children

      if (currChild.tokenTypeIdx === undefined) {
        this[currChild.name](currChild.children, param);
      }
    }
  } // defaultVisit does not support generic out param

}

exports.defaultVisit = defaultVisit;

function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
  var derivedConstructor = function derivedConstructor() {}; // can be overwritten according to:
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname


  (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
  var semanticProto = {
    visit: function visit(cstNode, param) {
      // enables writing more concise visitor methods when CstNode has only a single child
      if ((0, isArray_1["default"])(cstNode)) {
        // A CST Node's children dictionary can never have empty arrays as values
        // If a key is defined there will be at least one element in the corresponding value array.
        cstNode = cstNode[0];
      } // enables passing optional CstNodes concisely.


      if ((0, isUndefined_1["default"])(cstNode)) {
        return undefined;
      }

      return this[cstNode.name](cstNode.children, param);
    },
    validateVisitor: function validateVisitor() {
      var semanticDefinitionErrors = _validateVisitor(this, ruleNames);

      if (!(0, isEmpty_1["default"])(semanticDefinitionErrors)) {
        var errorMessages = (0, map_1["default"])(semanticDefinitionErrors, function (currDefError) {
          return currDefError.msg;
        });
        throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n\t") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n\t")));
      }
    }
  };
  derivedConstructor.prototype = semanticProto;
  derivedConstructor.prototype.constructor = derivedConstructor;
  derivedConstructor._RULE_NAMES = ruleNames;
  return derivedConstructor;
}

exports.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;

function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
  var derivedConstructor = function derivedConstructor() {}; // can be overwritten according to:
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname


  (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
  var withDefaultsProto = Object.create(baseConstructor.prototype);
  (0, forEach_1["default"])(ruleNames, function (ruleName) {
    withDefaultsProto[ruleName] = defaultVisit;
  });
  derivedConstructor.prototype = withDefaultsProto;
  derivedConstructor.prototype.constructor = derivedConstructor;
  return derivedConstructor;
}

exports.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
var CstVisitorDefinitionError;

(function (CstVisitorDefinitionError) {
  CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
  CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";
})(CstVisitorDefinitionError = exports.CstVisitorDefinitionError || (exports.CstVisitorDefinitionError = {}));

function _validateVisitor(visitorInstance, ruleNames) {
  var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
  return missingErrors;
}

exports.validateVisitor = _validateVisitor;

function validateMissingCstMethods(visitorInstance, ruleNames) {
  var missingRuleNames = (0, filter_1["default"])(ruleNames, function (currRuleName) {
    return (0, isFunction_1["default"])(visitorInstance[currRuleName]) === false;
  });
  var errors = (0, map_1["default"])(missingRuleNames, function (currRuleName) {
    return {
      msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
      type: CstVisitorDefinitionError.MISSING_METHOD,
      methodName: currRuleName
    };
  });
  return (0, compact_1["default"])(errors);
}

exports.validateMissingCstMethods = validateMissingCstMethods;

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineNameProp = void 0;
var NAME = "name";

function defineNameProp(obj, nameValue) {
  Object.defineProperty(obj, NAME, {
    enumerable: false,
    configurable: true,
    writable: false,
    value: nameValue
  });
}

exports.defineNameProp = defineNameProp;

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LexerAdapter = void 0;

var parser_1 = __webpack_require__(6);
/**
 * Trait responsible abstracting over the interaction with Lexer output (Token vector).
 *
 * This could be generalized to support other kinds of lexers, e.g.
 * - Just in Time Lexing / Lexer-Less parsing.
 * - Streaming Lexer.
 */


var LexerAdapter =
/** @class */
function () {
  function LexerAdapter() {}

  LexerAdapter.prototype.initLexerAdapter = function () {
    this.tokVector = [];
    this.tokVectorLength = 0;
    this.currIdx = -1;
  };

  Object.defineProperty(LexerAdapter.prototype, "input", {
    get: function get() {
      return this.tokVector;
    },
    set: function set(newInput) {
      // @ts-ignore - `this parameter` not supported in setters/getters
      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters
      if (this.selfAnalysisDone !== true) {
        throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
      } // @ts-ignore - `this parameter` not supported in setters/getters
      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters


      this.reset();
      this.tokVector = newInput;
      this.tokVectorLength = newInput.length;
    },
    enumerable: false,
    configurable: true
  }); // skips a token and returns the next token

  LexerAdapter.prototype.SKIP_TOKEN = function () {
    if (this.currIdx <= this.tokVector.length - 2) {
      this.consumeToken();
      return this.LA(1);
    } else {
      return parser_1.END_OF_FILE;
    }
  }; // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
  // or lexers dependent on parser context.


  LexerAdapter.prototype.LA = function (howMuch) {
    var soughtIdx = this.currIdx + howMuch;

    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
      return parser_1.END_OF_FILE;
    } else {
      return this.tokVector[soughtIdx];
    }
  };

  LexerAdapter.prototype.consumeToken = function () {
    this.currIdx++;
  };

  LexerAdapter.prototype.exportLexerState = function () {
    return this.currIdx;
  };

  LexerAdapter.prototype.importLexerState = function (newState) {
    this.currIdx = newState;
  };

  LexerAdapter.prototype.resetLexerState = function () {
    this.currIdx = -1;
  };

  LexerAdapter.prototype.moveToTerminatedState = function () {
    this.currIdx = this.tokVector.length - 1;
  };

  LexerAdapter.prototype.getLexerPosition = function () {
    return this.exportLexerState();
  };

  return LexerAdapter;
}();

exports.LexerAdapter = LexerAdapter;

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RecognizerApi = void 0;

var values_1 = __importDefault(__webpack_require__(15));

var includes_1 = __importDefault(__webpack_require__(18));

var exceptions_public_1 = __webpack_require__(41);

var parser_1 = __webpack_require__(6);

var errors_public_1 = __webpack_require__(65);

var checks_1 = __webpack_require__(243);

var gast_1 = __webpack_require__(2);
/**
 * This trait is responsible for implementing the public API
 * for defining Chevrotain parsers, i.e:
 * - CONSUME
 * - RULE
 * - OPTION
 * - ...
 */


var RecognizerApi =
/** @class */
function () {
  function RecognizerApi() {}

  RecognizerApi.prototype.ACTION = function (impl) {
    return impl.call(this);
  };

  RecognizerApi.prototype.consume = function (idx, tokType, options) {
    return this.consumeInternal(tokType, idx, options);
  };

  RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {
    return this.subruleInternal(ruleToCall, idx, options);
  };

  RecognizerApi.prototype.option = function (idx, actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, idx);
  };

  RecognizerApi.prototype.or = function (idx, altsOrOpts) {
    return this.orInternal(altsOrOpts, idx);
  };

  RecognizerApi.prototype.many = function (idx, actionORMethodDef) {
    return this.manyInternal(idx, actionORMethodDef);
  };

  RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {
    return this.atLeastOneInternal(idx, actionORMethodDef);
  };

  RecognizerApi.prototype.CONSUME = function (tokType, options) {
    return this.consumeInternal(tokType, 0, options);
  };

  RecognizerApi.prototype.CONSUME1 = function (tokType, options) {
    return this.consumeInternal(tokType, 1, options);
  };

  RecognizerApi.prototype.CONSUME2 = function (tokType, options) {
    return this.consumeInternal(tokType, 2, options);
  };

  RecognizerApi.prototype.CONSUME3 = function (tokType, options) {
    return this.consumeInternal(tokType, 3, options);
  };

  RecognizerApi.prototype.CONSUME4 = function (tokType, options) {
    return this.consumeInternal(tokType, 4, options);
  };

  RecognizerApi.prototype.CONSUME5 = function (tokType, options) {
    return this.consumeInternal(tokType, 5, options);
  };

  RecognizerApi.prototype.CONSUME6 = function (tokType, options) {
    return this.consumeInternal(tokType, 6, options);
  };

  RecognizerApi.prototype.CONSUME7 = function (tokType, options) {
    return this.consumeInternal(tokType, 7, options);
  };

  RecognizerApi.prototype.CONSUME8 = function (tokType, options) {
    return this.consumeInternal(tokType, 8, options);
  };

  RecognizerApi.prototype.CONSUME9 = function (tokType, options) {
    return this.consumeInternal(tokType, 9, options);
  };

  RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 0, options);
  };

  RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 1, options);
  };

  RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 2, options);
  };

  RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 3, options);
  };

  RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 4, options);
  };

  RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 5, options);
  };

  RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 6, options);
  };

  RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 7, options);
  };

  RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 8, options);
  };

  RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {
    return this.subruleInternal(ruleToCall, 9, options);
  };

  RecognizerApi.prototype.OPTION = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 0);
  };

  RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 1);
  };

  RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 2);
  };

  RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 3);
  };

  RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 4);
  };

  RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 5);
  };

  RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 6);
  };

  RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 7);
  };

  RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 8);
  };

  RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {
    return this.optionInternal(actionORMethodDef, 9);
  };

  RecognizerApi.prototype.OR = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 0);
  };

  RecognizerApi.prototype.OR1 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 1);
  };

  RecognizerApi.prototype.OR2 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 2);
  };

  RecognizerApi.prototype.OR3 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 3);
  };

  RecognizerApi.prototype.OR4 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 4);
  };

  RecognizerApi.prototype.OR5 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 5);
  };

  RecognizerApi.prototype.OR6 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 6);
  };

  RecognizerApi.prototype.OR7 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 7);
  };

  RecognizerApi.prototype.OR8 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 8);
  };

  RecognizerApi.prototype.OR9 = function (altsOrOpts) {
    return this.orInternal(altsOrOpts, 9);
  };

  RecognizerApi.prototype.MANY = function (actionORMethodDef) {
    this.manyInternal(0, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {
    this.manyInternal(1, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {
    this.manyInternal(2, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {
    this.manyInternal(3, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {
    this.manyInternal(4, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {
    this.manyInternal(5, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {
    this.manyInternal(6, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {
    this.manyInternal(7, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {
    this.manyInternal(8, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {
    this.manyInternal(9, actionORMethodDef);
  };

  RecognizerApi.prototype.MANY_SEP = function (options) {
    this.manySepFirstInternal(0, options);
  };

  RecognizerApi.prototype.MANY_SEP1 = function (options) {
    this.manySepFirstInternal(1, options);
  };

  RecognizerApi.prototype.MANY_SEP2 = function (options) {
    this.manySepFirstInternal(2, options);
  };

  RecognizerApi.prototype.MANY_SEP3 = function (options) {
    this.manySepFirstInternal(3, options);
  };

  RecognizerApi.prototype.MANY_SEP4 = function (options) {
    this.manySepFirstInternal(4, options);
  };

  RecognizerApi.prototype.MANY_SEP5 = function (options) {
    this.manySepFirstInternal(5, options);
  };

  RecognizerApi.prototype.MANY_SEP6 = function (options) {
    this.manySepFirstInternal(6, options);
  };

  RecognizerApi.prototype.MANY_SEP7 = function (options) {
    this.manySepFirstInternal(7, options);
  };

  RecognizerApi.prototype.MANY_SEP8 = function (options) {
    this.manySepFirstInternal(8, options);
  };

  RecognizerApi.prototype.MANY_SEP9 = function (options) {
    this.manySepFirstInternal(9, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {
    this.atLeastOneInternal(0, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {
    return this.atLeastOneInternal(1, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {
    this.atLeastOneInternal(2, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {
    this.atLeastOneInternal(3, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {
    this.atLeastOneInternal(4, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {
    this.atLeastOneInternal(5, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {
    this.atLeastOneInternal(6, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {
    this.atLeastOneInternal(7, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {
    this.atLeastOneInternal(8, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {
    this.atLeastOneInternal(9, actionORMethodDef);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {
    this.atLeastOneSepFirstInternal(0, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {
    this.atLeastOneSepFirstInternal(1, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {
    this.atLeastOneSepFirstInternal(2, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {
    this.atLeastOneSepFirstInternal(3, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {
    this.atLeastOneSepFirstInternal(4, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {
    this.atLeastOneSepFirstInternal(5, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {
    this.atLeastOneSepFirstInternal(6, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {
    this.atLeastOneSepFirstInternal(7, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {
    this.atLeastOneSepFirstInternal(8, options);
  };

  RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {
    this.atLeastOneSepFirstInternal(9, options);
  };

  RecognizerApi.prototype.RULE = function (name, implementation, config) {
    if (config === void 0) {
      config = parser_1.DEFAULT_RULE_CONFIG;
    }

    if ((0, includes_1["default"])(this.definedRulesNames, name)) {
      var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
        topLevelRule: name,
        grammarName: this.className
      });
      var error = {
        message: errMsg,
        type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
        ruleName: name
      };
      this.definitionErrors.push(error);
    }

    this.definedRulesNames.push(name);
    var ruleImplementation = this.defineRule(name, implementation, config);
    this[name] = ruleImplementation;
    return ruleImplementation;
  };

  RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {
    if (config === void 0) {
      config = parser_1.DEFAULT_RULE_CONFIG;
    }

    var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
    this.definitionErrors = this.definitionErrors.concat(ruleErrors);
    var ruleImplementation = this.defineRule(name, impl, config);
    this[name] = ruleImplementation;
    return ruleImplementation;
  };

  RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {
    return function () {
      // save org state
      this.isBackTrackingStack.push(1);
      var orgState = this.saveRecogState();

      try {
        grammarRule.apply(this, args); // if no exception was thrown we have succeed parsing the rule.

        return true;
      } catch (e) {
        if ((0, exceptions_public_1.isRecognitionException)(e)) {
          return false;
        } else {
          throw e;
        }
      } finally {
        this.reloadRecogState(orgState);
        this.isBackTrackingStack.pop();
      }
    };
  }; // GAST export APIs


  RecognizerApi.prototype.getGAstProductions = function () {
    return this.gastProductionsCache;
  };

  RecognizerApi.prototype.getSerializedGastProductions = function () {
    return (0, gast_1.serializeGrammar)((0, values_1["default"])(this.gastProductionsCache));
  };

  return RecognizerApi;
}();

exports.RecognizerApi = RecognizerApi;

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RecognizerEngine = void 0;

var isEmpty_1 = __importDefault(__webpack_require__(9));

var isArray_1 = __importDefault(__webpack_require__(0));

var flatten_1 = __importDefault(__webpack_require__(16));

var every_1 = __importDefault(__webpack_require__(62));

var uniq_1 = __importDefault(__webpack_require__(98));

var isObject_1 = __importDefault(__webpack_require__(11));

var has_1 = __importDefault(__webpack_require__(7));

var values_1 = __importDefault(__webpack_require__(15));

var reduce_1 = __importDefault(__webpack_require__(23));

var clone_1 = __importDefault(__webpack_require__(17));

var keys_1 = __webpack_require__(108);

var exceptions_public_1 = __webpack_require__(41);

var lookahead_1 = __webpack_require__(66);

var interpreter_1 = __webpack_require__(67);

var parser_1 = __webpack_require__(6);

var recoverable_1 = __webpack_require__(245);

var tokens_public_1 = __webpack_require__(26);

var tokens_1 = __webpack_require__(27);
/**
 * This trait is responsible for the runtime parsing engine
 * Used by the official API (recognizer_api.ts)
 */


var RecognizerEngine =
/** @class */
function () {
  function RecognizerEngine() {}

  RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {
    this.className = this.constructor.name; // TODO: would using an ES6 Map or plain object be faster (CST building scenario)

    this.shortRuleNameToFull = {};
    this.fullRuleNameToShort = {};
    this.ruleShortNameIdx = 256;
    this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
    this.subruleIdx = 0;
    this.definedRulesNames = [];
    this.tokensMap = {};
    this.isBackTrackingStack = [];
    this.RULE_STACK = [];
    this.RULE_OCCURRENCE_STACK = [];
    this.gastProductionsCache = {};

    if ((0, has_1["default"])(config, "serializedGrammar")) {
      throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n" + "\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n" + "\tFor Further details.");
    }

    if ((0, isArray_1["default"])(tokenVocabulary)) {
      // This only checks for Token vocabularies provided as arrays.
      // That is good enough because the main objective is to detect users of pre-V4.0 APIs
      // rather than all edge cases of empty Token vocabularies.
      if ((0, isEmpty_1["default"])(tokenVocabulary)) {
        throw Error("A Token Vocabulary cannot be empty.\n" + "\tNote that the first argument for the parser constructor\n" + "\tis no longer a Token vector (since v4.0).");
      }

      if (typeof tokenVocabulary[0].startOffset === "number") {
        throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n" + "\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n" + "\tFor Further details.");
      }
    }

    if ((0, isArray_1["default"])(tokenVocabulary)) {
      this.tokensMap = (0, reduce_1["default"])(tokenVocabulary, function (acc, tokType) {
        acc[tokType.name] = tokType;
        return acc;
      }, {});
    } else if ((0, has_1["default"])(tokenVocabulary, "modes") && (0, every_1["default"])((0, flatten_1["default"])((0, values_1["default"])(tokenVocabulary.modes)), tokens_1.isTokenType)) {
      var allTokenTypes_1 = (0, flatten_1["default"])((0, values_1["default"])(tokenVocabulary.modes));
      var uniqueTokens = (0, uniq_1["default"])(allTokenTypes_1);
      this.tokensMap = (0, reduce_1["default"])(uniqueTokens, function (acc, tokType) {
        acc[tokType.name] = tokType;
        return acc;
      }, {});
    } else if ((0, isObject_1["default"])(tokenVocabulary)) {
      this.tokensMap = (0, clone_1["default"])(tokenVocabulary);
    } else {
      throw new Error("<tokensDictionary> argument must be An Array of Token constructors," + " A dictionary of Token constructors or an IMultiModeLexerDefinition");
    } // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been
    // parsed with a clear error message ("expecting EOF but found ...")


    this.tokensMap["EOF"] = tokens_public_1.EOF;
    var allTokenTypes = (0, has_1["default"])(tokenVocabulary, "modes") ? (0, flatten_1["default"])((0, values_1["default"])(tokenVocabulary.modes)) : (0, values_1["default"])(tokenVocabulary);
    var noTokenCategoriesUsed = (0, every_1["default"])(allTokenTypes, function (tokenConstructor) {
      return (0, isEmpty_1["default"])(tokenConstructor.categoryMatches);
    });
    this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher; // Because ES2015+ syntax should be supported for creating Token classes
    // We cannot assume that the Token classes were created using the "extendToken" utilities
    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization

    (0, tokens_1.augmentTokenTypes)((0, values_1["default"])(this.tokensMap));
  };

  RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {
    if (this.selfAnalysisDone) {
      throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
    }

    var resyncEnabled = (0, has_1["default"])(config, "resyncEnabled") ? config.resyncEnabled // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
    var recoveryValueFunc = (0, has_1["default"])(config, "recoveryValueFunc") ? config.recoveryValueFunc // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc; // performance optimization: Use small integers as keys for the longer human readable "full" rule names.
    // this greatly improves Map access time (as much as 8% for some performance benchmarks).

    var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
    this.ruleShortNameIdx++;
    this.shortRuleNameToFull[shortName] = ruleName;
    this.fullRuleNameToShort[ruleName] = shortName;
    var invokeRuleWithTry; // Micro optimization, only check the condition **once** on rule definition
    // instead of **every single** rule invocation.

    if (this.outputCst === true) {
      invokeRuleWithTry = function invokeRuleWithTry() {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        try {
          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
          impl.apply(this, args);
          var cst = this.CST_STACK[this.CST_STACK.length - 1];
          this.cstPostRule(cst);
          return cst;
        } catch (e) {
          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
        } finally {
          this.ruleFinallyStateUpdate();
        }
      };
    } else {
      invokeRuleWithTry = function invokeRuleWithTryCst() {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        try {
          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
          return impl.apply(this, args);
        } catch (e) {
          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
        } finally {
          this.ruleFinallyStateUpdate();
        }
      };
    }

    var wrappedGrammarRule = Object.assign(invokeRuleWithTry, {
      ruleName: ruleName,
      originalGrammarAction: impl
    });
    return wrappedGrammarRule;
  };

  RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {
    var isFirstInvokedRule = this.RULE_STACK.length === 1; // note the reSync is always enabled for the first rule invocation, because we must always be able to
    // reSync with EOF and just output some INVALID ParseTree
    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking
    // path is really the most valid one

    var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;

    if ((0, exceptions_public_1.isRecognitionException)(e)) {
      var recogError = e;

      if (reSyncEnabled) {
        var reSyncTokType = this.findReSyncTokenType();

        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);

          if (this.outputCst) {
            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
            partialCstResult.recoveredNode = true;
            return partialCstResult;
          } else {
            return recoveryValueFunc();
          }
        } else {
          if (this.outputCst) {
            var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
            partialCstResult.recoveredNode = true;
            recogError.partialCstResult = partialCstResult;
          } // to be handled Further up the call stack


          throw recogError;
        }
      } else if (isFirstInvokedRule) {
        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case
        this.moveToTerminatedState(); // the parser should never throw one of its own errors outside its flow.
        // even if error recovery is disabled

        return recoveryValueFunc();
      } else {
        // to be recovered Further up the call stack
        throw recogError;
      }
    } else {
      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)
      throw e;
    }
  }; // Implementation of parsing DSL


  RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {
    var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
    return this.optionInternalLogic(actionORMethodDef, occurrence, key);
  };

  RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {
    var _this = this;

    var lookAheadFunc = this.getLaFuncFromCache(key);
    var action;

    if (typeof actionORMethodDef !== "function") {
      action = actionORMethodDef.DEF;
      var predicate_1 = actionORMethodDef.GATE; // predicate present

      if (predicate_1 !== undefined) {
        var orgLookaheadFunction_1 = lookAheadFunc;

        lookAheadFunc = function lookAheadFunc() {
          return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
        };
      }
    } else {
      action = actionORMethodDef;
    }

    if (lookAheadFunc.call(this) === true) {
      return action.call(this);
    }

    return undefined;
  };

  RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {
    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
    return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
  };

  RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
    var _this = this;

    var lookAheadFunc = this.getLaFuncFromCache(key);
    var action;

    if (typeof actionORMethodDef !== "function") {
      action = actionORMethodDef.DEF;
      var predicate_2 = actionORMethodDef.GATE; // predicate present

      if (predicate_2 !== undefined) {
        var orgLookaheadFunction_2 = lookAheadFunc;

        lookAheadFunc = function lookAheadFunc() {
          return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
        };
      }
    } else {
      action = actionORMethodDef;
    }

    if (lookAheadFunc.call(this) === true) {
      var notStuck = this.doSingleRepetition(action);

      while (lookAheadFunc.call(this) === true && notStuck === true) {
        notStuck = this.doSingleRepetition(action);
      }
    } else {
      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
    } // note that while it may seem that this can cause an error because by using a recursive call to
    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call
    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.
    // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled


    this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
  };

  RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {
    var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
  };

  RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {
    var _this = this;

    var action = options.DEF;
    var separator = options.SEP;
    var firstIterationLookaheadFunc = this.getLaFuncFromCache(key); // 1st iteration

    if (firstIterationLookaheadFunc.call(this) === true) {
      ;
      action.call(this); //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"
      //  because it is only needed in error recovery scenarios.

      var separatorLookAheadFunc = function separatorLookAheadFunc() {
        return _this.tokenMatcher(_this.LA(1), separator);
      }; // 2nd..nth iterations


      while (this.tokenMatcher(this.LA(1), separator) === true) {
        // note that this CONSUME will never enter recovery because
        // the separatorLookAheadFunc checks that the separator really does exist.
        this.CONSUME(separator);
        action.call(this);
      } // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled


      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
    } else {
      throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
    }
  };

  RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {
    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
  };

  RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
    var _this = this;

    var lookaheadFunction = this.getLaFuncFromCache(key);
    var action;

    if (typeof actionORMethodDef !== "function") {
      action = actionORMethodDef.DEF;
      var predicate_3 = actionORMethodDef.GATE; // predicate present

      if (predicate_3 !== undefined) {
        var orgLookaheadFunction_3 = lookaheadFunction;

        lookaheadFunction = function lookaheadFunction() {
          return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
        };
      }
    } else {
      action = actionORMethodDef;
    }

    var notStuck = true;

    while (lookaheadFunction.call(this) === true && notStuck === true) {
      notStuck = this.doSingleRepetition(action);
    } // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled


    this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, keys_1.MANY_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManyWalker, // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
    // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
    // An infinite loop cannot occur as:
    // - Either the lookahead is guaranteed to consume something (Single Token Separator)
    // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
    notStuck);
  };

  RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {
    var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
  };

  RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {
    var _this = this;

    var action = options.DEF;
    var separator = options.SEP;
    var firstIterationLaFunc = this.getLaFuncFromCache(key); // 1st iteration

    if (firstIterationLaFunc.call(this) === true) {
      action.call(this);

      var separatorLookAheadFunc = function separatorLookAheadFunc() {
        return _this.tokenMatcher(_this.LA(1), separator);
      }; // 2nd..nth iterations


      while (this.tokenMatcher(this.LA(1), separator) === true) {
        // note that this CONSUME will never enter recovery because
        // the separatorLookAheadFunc checks that the separator really does exist.
        this.CONSUME(separator); // No need for checking infinite loop here due to consuming the separator.

        action.call(this);
      } // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled


      this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, interpreter_1.NextTerminalAfterManySepWalker], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
    }
  };

  RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
    while (separatorLookAheadFunc()) {
      // note that this CONSUME will never enter recovery because
      // the separatorLookAheadFunc checks that the separator really does exist.
      this.CONSUME(separator);
      action.call(this);
    } // we can only arrive to this function after an error
    // has occurred (hence the name 'second') so the following
    // IF will always be entered, its possible to remove it...
    // however it is kept to avoid confusion and be consistent.
    // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled

    /* istanbul ignore else */


    this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
  };

  RecognizerEngine.prototype.doSingleRepetition = function (action) {
    var beforeIteration = this.getLexerPosition();
    action.call(this);
    var afterIteration = this.getLexerPosition(); // This boolean will indicate if this repetition progressed
    // or if we are "stuck" (potential infinite loop in the repetition).

    return afterIteration > beforeIteration;
  };

  RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {
    var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
    var alts = (0, isArray_1["default"])(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
    var laFunc = this.getLaFuncFromCache(laKey);
    var altIdxToTake = laFunc.call(this, alts);

    if (altIdxToTake !== undefined) {
      var chosenAlternative = alts[altIdxToTake];
      return chosenAlternative.ALT.call(this);
    }

    this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
  };

  RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {
    this.RULE_STACK.pop();
    this.RULE_OCCURRENCE_STACK.pop(); // NOOP when cst is disabled

    this.cstFinallyStateUpdate();

    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
      var firstRedundantTok = this.LA(1);
      var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
        firstRedundant: firstRedundantTok,
        ruleName: this.getCurrRuleFullName()
      });
      this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
    }
  };

  RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {
    var ruleResult;

    try {
      var args = options !== undefined ? options.ARGS : undefined;
      this.subruleIdx = idx;
      ruleResult = ruleToCall.apply(this, args);
      this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName);
      return ruleResult;
    } catch (e) {
      throw this.subruleInternalError(e, options, ruleToCall.ruleName);
    }
  };

  RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {
    if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== undefined) {
      this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName);
      delete e.partialCstResult;
    }

    throw e;
  };

  RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {
    var consumedToken;

    try {
      var nextToken = this.LA(1);

      if (this.tokenMatcher(nextToken, tokType) === true) {
        this.consumeToken();
        consumedToken = nextToken;
      } else {
        this.consumeInternalError(tokType, nextToken, options);
      }
    } catch (eFromConsumption) {
      consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
    }

    this.cstPostTerminal(options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name, consumedToken);
    return consumedToken;
  };

  RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {
    var msg;
    var previousToken = this.LA(0);

    if (options !== undefined && options.ERR_MSG) {
      msg = options.ERR_MSG;
    } else {
      msg = this.errorMessageProvider.buildMismatchTokenMessage({
        expected: tokType,
        actual: nextToken,
        previous: previousToken,
        ruleName: this.getCurrRuleFullName()
      });
    }

    throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
  };

  RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {
    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it
    // but the original syntax could have been parsed successfully without any backtracking + recovery
    if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
    eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
      var follows = this.getFollowsForInRuleRecovery(tokType, idx);

      try {
        return this.tryInRuleRecovery(tokType, follows);
      } catch (eFromInRuleRecovery) {
        if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
          // failed in RuleRecovery.
          // throw the original error in order to trigger reSync error recovery
          throw eFromConsumption;
        } else {
          throw eFromInRuleRecovery;
        }
      }
    } else {
      throw eFromConsumption;
    }
  };

  RecognizerEngine.prototype.saveRecogState = function () {
    // errors is a getter which will clone the errors array
    var savedErrors = this.errors;
    var savedRuleStack = (0, clone_1["default"])(this.RULE_STACK);
    return {
      errors: savedErrors,
      lexerState: this.exportLexerState(),
      RULE_STACK: savedRuleStack,
      CST_STACK: this.CST_STACK
    };
  };

  RecognizerEngine.prototype.reloadRecogState = function (newState) {
    this.errors = newState.errors;
    this.importLexerState(newState.lexerState);
    this.RULE_STACK = newState.RULE_STACK;
  };

  RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {
    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
    this.RULE_STACK.push(shortName); // NOOP when cst is disabled

    this.cstInvocationStateUpdate(fullName);
  };

  RecognizerEngine.prototype.isBackTracking = function () {
    return this.isBackTrackingStack.length !== 0;
  };

  RecognizerEngine.prototype.getCurrRuleFullName = function () {
    var shortName = this.getLastExplicitRuleShortName();
    return this.shortRuleNameToFull[shortName];
  };

  RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {
    return this.shortRuleNameToFull[shortName];
  };

  RecognizerEngine.prototype.isAtEndOfInput = function () {
    return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
  };

  RecognizerEngine.prototype.reset = function () {
    this.resetLexerState();
    this.subruleIdx = 0;
    this.isBackTrackingStack = [];
    this.errors = [];
    this.RULE_STACK = []; // TODO: extract a specific reset for TreeBuilder trait

    this.CST_STACK = [];
    this.RULE_OCCURRENCE_STACK = [];
  };

  return RecognizerEngine;
}();

exports.RecognizerEngine = RecognizerEngine;

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorHandler = void 0;

var exceptions_public_1 = __webpack_require__(41);

var has_1 = __importDefault(__webpack_require__(7));

var clone_1 = __importDefault(__webpack_require__(17));

var lookahead_1 = __webpack_require__(66);

var parser_1 = __webpack_require__(6);
/**
 * Trait responsible for runtime parsing errors.
 */


var ErrorHandler =
/** @class */
function () {
  function ErrorHandler() {}

  ErrorHandler.prototype.initErrorHandler = function (config) {
    this._errors = [];
    this.errorMessageProvider = (0, has_1["default"])(config, "errorMessageProvider") ? config.errorMessageProvider // assumes end user provides the correct config value/type
    : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
  };

  ErrorHandler.prototype.SAVE_ERROR = function (error) {
    if ((0, exceptions_public_1.isRecognitionException)(error)) {
      error.context = {
        ruleStack: this.getHumanReadableRuleStack(),
        ruleOccurrenceStack: (0, clone_1["default"])(this.RULE_OCCURRENCE_STACK)
      };

      this._errors.push(error);

      return error;
    } else {
      throw Error("Trying to save an Error which is not a RecognitionException");
    }
  };

  Object.defineProperty(ErrorHandler.prototype, "errors", {
    get: function get() {
      return (0, clone_1["default"])(this._errors);
    },
    set: function set(newErrors) {
      this._errors = newErrors;
    },
    enumerable: false,
    configurable: true
  }); // TODO: consider caching the error message computed information

  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {
    var ruleName = this.getCurrRuleFullName();
    var ruleGrammar = this.getGAstProductions()[ruleName];
    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
    var insideProdPaths = lookAheadPathsPerAlternative[0];
    var actualTokens = [];

    for (var i = 1; i <= this.maxLookahead; i++) {
      actualTokens.push(this.LA(i));
    }

    var msg = this.errorMessageProvider.buildEarlyExitMessage({
      expectedIterationPaths: insideProdPaths,
      actual: actualTokens,
      previous: this.LA(0),
      customUserDescription: userDefinedErrMsg,
      ruleName: ruleName
    });
    throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
  }; // TODO: consider caching the error message computed information


  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {
    var ruleName = this.getCurrRuleFullName();
    var ruleGrammar = this.getGAstProductions()[ruleName]; // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?

    var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
    var actualTokens = [];

    for (var i = 1; i <= this.maxLookahead; i++) {
      actualTokens.push(this.LA(i));
    }

    var previousToken = this.LA(0);
    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
      expectedPathsPerAlt: lookAheadPathsPerAlternative,
      actual: actualTokens,
      previous: previousToken,
      customUserDescription: errMsgTypes,
      ruleName: this.getCurrRuleFullName()
    });
    throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
  };

  return ErrorHandler;
}();

exports.ErrorHandler = ErrorHandler;

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContentAssist = void 0;

var interpreter_1 = __webpack_require__(67);

var first_1 = __importDefault(__webpack_require__(40));

var isUndefined_1 = __importDefault(__webpack_require__(22));

var ContentAssist =
/** @class */
function () {
  function ContentAssist() {}

  ContentAssist.prototype.initContentAssist = function () {};

  ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {
    var startRuleGast = this.gastProductionsCache[startRuleName];

    if ((0, isUndefined_1["default"])(startRuleGast)) {
      throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
    }

    return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
  }; // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
  // TODO: should this be more explicitly part of the public API?


  ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {
    var topRuleName = (0, first_1["default"])(grammarPath.ruleStack);
    var gastProductions = this.getGAstProductions();
    var topProduction = gastProductions[topRuleName];
    var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
    return nextPossibleTokenTypes;
  };

  return ContentAssist;
}();

exports.ContentAssist = ContentAssist;

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GastRecorder = void 0;

var last_1 = __importDefault(__webpack_require__(106));

var isArray_1 = __importDefault(__webpack_require__(0));

var some_1 = __importDefault(__webpack_require__(95));

var forEach_1 = __importDefault(__webpack_require__(3));

var isFunction_1 = __importDefault(__webpack_require__(30));

var has_1 = __importDefault(__webpack_require__(7));

var gast_1 = __webpack_require__(2);

var lexer_public_1 = __webpack_require__(63);

var tokens_1 = __webpack_require__(27);

var tokens_public_1 = __webpack_require__(26);

var parser_1 = __webpack_require__(6);

var keys_1 = __webpack_require__(108);

var RECORDING_NULL_OBJECT = {
  description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(RECORDING_NULL_OBJECT);
var HANDLE_SEPARATOR = true;
var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
var RFT = (0, tokens_public_1.createToken)({
  name: "RECORDING_PHASE_TOKEN",
  pattern: lexer_public_1.Lexer.NA
});
(0, tokens_1.augmentTokenTypes)([RFT]);
var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(RFT, "This IToken indicates the Parser is in Recording Phase\n\t" + "" + "See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details", // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
-1, -1, -1, -1, -1, -1);
Object.freeze(RECORDING_PHASE_TOKEN);
var RECORDING_PHASE_CSTNODE = {
  name: "This CSTNode indicates the Parser is in Recording Phase\n\t" + "See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
  children: {}
};
/**
 * This trait handles the creation of the GAST structure for Chevrotain Grammars
 */

var GastRecorder =
/** @class */
function () {
  function GastRecorder() {}

  GastRecorder.prototype.initGastRecorder = function (config) {
    this.recordingProdStack = [];
    this.RECORDING_PHASE = false;
  };

  GastRecorder.prototype.enableRecording = function () {
    var _this = this;

    this.RECORDING_PHASE = true;
    this.TRACE_INIT("Enable Recording", function () {
      var _loop_1 = function _loop_1(i) {
        var idx = i > 0 ? i : "";

        _this["CONSUME".concat(idx)] = function (arg1, arg2) {
          return this.consumeInternalRecord(arg1, i, arg2);
        };

        _this["SUBRULE".concat(idx)] = function (arg1, arg2) {
          return this.subruleInternalRecord(arg1, i, arg2);
        };

        _this["OPTION".concat(idx)] = function (arg1) {
          return this.optionInternalRecord(arg1, i);
        };

        _this["OR".concat(idx)] = function (arg1) {
          return this.orInternalRecord(arg1, i);
        };

        _this["MANY".concat(idx)] = function (arg1) {
          this.manyInternalRecord(i, arg1);
        };

        _this["MANY_SEP".concat(idx)] = function (arg1) {
          this.manySepFirstInternalRecord(i, arg1);
        };

        _this["AT_LEAST_ONE".concat(idx)] = function (arg1) {
          this.atLeastOneInternalRecord(i, arg1);
        };

        _this["AT_LEAST_ONE_SEP".concat(idx)] = function (arg1) {
          this.atLeastOneSepFirstInternalRecord(i, arg1);
        };
      };
      /**
       * Warning Dark Voodoo Magic upcoming!
       * We are "replacing" the public parsing DSL methods API
       * With **new** alternative implementations on the Parser **instance**
       *
       * So far this is the only way I've found to avoid performance regressions during parsing time.
       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"
       *   implementations directly instead.
       */


      for (var i = 0; i < 10; i++) {
        _loop_1(i);
      } // DSL methods with the idx(suffix) as an argument


      _this["consume"] = function (idx, arg1, arg2) {
        return this.consumeInternalRecord(arg1, idx, arg2);
      };

      _this["subrule"] = function (idx, arg1, arg2) {
        return this.subruleInternalRecord(arg1, idx, arg2);
      };

      _this["option"] = function (idx, arg1) {
        return this.optionInternalRecord(arg1, idx);
      };

      _this["or"] = function (idx, arg1) {
        return this.orInternalRecord(arg1, idx);
      };

      _this["many"] = function (idx, arg1) {
        this.manyInternalRecord(idx, arg1);
      };

      _this["atLeastOne"] = function (idx, arg1) {
        this.atLeastOneInternalRecord(idx, arg1);
      };

      _this.ACTION = _this.ACTION_RECORD;
      _this.BACKTRACK = _this.BACKTRACK_RECORD;
      _this.LA = _this.LA_RECORD;
    });
  };

  GastRecorder.prototype.disableRecording = function () {
    var _this = this;

    this.RECORDING_PHASE = false; // By deleting these **instance** properties, any future invocation
    // will be deferred to the original methods on the **prototype** object
    // This seems to get rid of any incorrect optimizations that V8 may
    // do during the recording phase.

    this.TRACE_INIT("Deleting Recording methods", function () {
      var that = _this;

      for (var i = 0; i < 10; i++) {
        var idx = i > 0 ? i : "";
        delete that["CONSUME".concat(idx)];
        delete that["SUBRULE".concat(idx)];
        delete that["OPTION".concat(idx)];
        delete that["OR".concat(idx)];
        delete that["MANY".concat(idx)];
        delete that["MANY_SEP".concat(idx)];
        delete that["AT_LEAST_ONE".concat(idx)];
        delete that["AT_LEAST_ONE_SEP".concat(idx)];
      }

      delete that["consume"];
      delete that["subrule"];
      delete that["option"];
      delete that["or"];
      delete that["many"];
      delete that["atLeastOne"];
      delete that.ACTION;
      delete that.BACKTRACK;
      delete that.LA;
    });
  }; //   Parser methods are called inside an ACTION?
  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
  // @ts-expect-error -- noop place holder


  GastRecorder.prototype.ACTION_RECORD = function (impl) {// NO-OP during recording
  }; // Executing backtracking logic will break our recording logic assumptions


  GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {
    return function () {
      return true;
    };
  }; // LA is part of the official API and may be used for custom lookahead logic
  // by end users who may forget to wrap it in ACTION or inside a GATE


  GastRecorder.prototype.LA_RECORD = function (howMuch) {
    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend
    // On LA return EOF at the end of the input so an infinite loop may occur.
    return parser_1.END_OF_FILE;
  };

  GastRecorder.prototype.topLevelRuleRecord = function (name, def) {
    try {
      var newTopLevelRule = new gast_1.Rule({
        definition: [],
        name: name
      });
      newTopLevelRule.name = name;
      this.recordingProdStack.push(newTopLevelRule);
      def.call(this);
      this.recordingProdStack.pop();
      return newTopLevelRule;
    } catch (originalError) {
      if (originalError.KNOWN_RECORDER_ERROR !== true) {
        try {
          originalError.message = originalError.message + '\n\t This error was thrown during the "grammar recording phase" For more info see:\n\t' + "https://chevrotain.io/docs/guide/internals.html#grammar-recording";
        } catch (mutabilityError) {
          // We may not be able to modify the original error object
          throw originalError;
        }
      }

      throw originalError;
    }
  }; // Implementation of parsing DSL


  GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {
    return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
  };

  GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {
    recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
  };

  GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {
    recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
  };

  GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {
    recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
  };

  GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {
    recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
  };

  GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {
    return recordOrProd.call(this, altsOrOpts, occurrence);
  };

  GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {
    assertMethodIdxIsValid(occurrence);

    if (!ruleToCall || (0, has_1["default"])(ruleToCall, "ruleName") === false) {
      var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
      error.KNOWN_RECORDER_ERROR = true;
      throw error;
    }

    var prevProd = (0, last_1["default"])(this.recordingProdStack);
    var ruleName = ruleToCall.ruleName;
    var newNoneTerminal = new gast_1.NonTerminal({
      idx: occurrence,
      nonTerminalName: ruleName,
      label: options === null || options === void 0 ? void 0 : options.LABEL,
      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
      referencedRule: undefined
    });
    prevProd.definition.push(newNoneTerminal);
    return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
  };

  GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {
    assertMethodIdxIsValid(occurrence);

    if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
      var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
      error.KNOWN_RECORDER_ERROR = true;
      throw error;
    }

    var prevProd = (0, last_1["default"])(this.recordingProdStack);
    var newNoneTerminal = new gast_1.Terminal({
      idx: occurrence,
      terminalType: tokType,
      label: options === null || options === void 0 ? void 0 : options.LABEL
    });
    prevProd.definition.push(newNoneTerminal);
    return RECORDING_PHASE_TOKEN;
  };

  return GastRecorder;
}();

exports.GastRecorder = GastRecorder;

function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
  if (handleSep === void 0) {
    handleSep = false;
  }

  assertMethodIdxIsValid(occurrence);
  var prevProd = (0, last_1["default"])(this.recordingProdStack);
  var grammarAction = (0, isFunction_1["default"])(mainProdArg) ? mainProdArg : mainProdArg.DEF;
  var newProd = new prodConstructor({
    definition: [],
    idx: occurrence
  });

  if (handleSep) {
    newProd.separator = mainProdArg.SEP;
  }

  if ((0, has_1["default"])(mainProdArg, "MAX_LOOKAHEAD")) {
    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
  }

  this.recordingProdStack.push(newProd);
  grammarAction.call(this);
  prevProd.definition.push(newProd);
  this.recordingProdStack.pop();
  return RECORDING_NULL_OBJECT;
}

function recordOrProd(mainProdArg, occurrence) {
  var _this = this;

  assertMethodIdxIsValid(occurrence);
  var prevProd = (0, last_1["default"])(this.recordingProdStack); // Only an array of alternatives

  var hasOptions = (0, isArray_1["default"])(mainProdArg) === false;
  var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
  var newOrProd = new gast_1.Alternation({
    definition: [],
    idx: occurrence,
    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
  });

  if ((0, has_1["default"])(mainProdArg, "MAX_LOOKAHEAD")) {
    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
  }

  var hasPredicates = (0, some_1["default"])(alts, function (currAlt) {
    return (0, isFunction_1["default"])(currAlt.GATE);
  });
  newOrProd.hasPredicates = hasPredicates;
  prevProd.definition.push(newOrProd);
  (0, forEach_1["default"])(alts, function (currAlt) {
    var currAltFlat = new gast_1.Alternative({
      definition: []
    });
    newOrProd.definition.push(currAltFlat);

    if ((0, has_1["default"])(currAlt, "IGNORE_AMBIGUITIES")) {
      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type
    } // **implicit** ignoreAmbiguities due to usage of gate
    else if ((0, has_1["default"])(currAlt, "GATE")) {
      currAltFlat.ignoreAmbiguities = true;
    }

    _this.recordingProdStack.push(currAltFlat);

    currAlt.ALT.call(_this);

    _this.recordingProdStack.pop();
  });
  return RECORDING_NULL_OBJECT;
}

function getIdxSuffix(idx) {
  return idx === 0 ? "" : "".concat(idx);
}

function assertMethodIdxIsValid(idx) {
  if (idx < 0 || idx > MAX_METHOD_IDX) {
    var error = new Error( // The stack trace will contain all the needed details
    "Invalid DSL Method idx value: <".concat(idx, ">\n\t") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1));
    error.KNOWN_RECORDER_ERROR = true;
    throw error;
  }
}

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PerformanceTracer = void 0;

var has_1 = __importDefault(__webpack_require__(7));

var utils_1 = __webpack_require__(37);

var parser_1 = __webpack_require__(6);
/**
 * Trait responsible for runtime parsing errors.
 */


var PerformanceTracer =
/** @class */
function () {
  function PerformanceTracer() {}

  PerformanceTracer.prototype.initPerformanceTracer = function (config) {
    if ((0, has_1["default"])(config, "traceInitPerf")) {
      var userTraceInitPerf = config.traceInitPerf;
      var traceIsNumber = typeof userTraceInitPerf === "number";
      this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
      this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf; // assumes end user provides the correct config value/type
    } else {
      this.traceInitMaxIdent = 0;
      this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
    }

    this.traceInitIndent = -1;
  };

  PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
    // No need to optimize this using NOOP pattern because
    // It is not called in a hot spot...
    if (this.traceInitPerf === true) {
      this.traceInitIndent++;
      var indent = new Array(this.traceInitIndent + 1).join("\t");

      if (this.traceInitIndent < this.traceInitMaxIdent) {
        console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
      }

      var _a = (0, utils_1.timer)(phaseImpl),
          time = _a.time,
          value = _a.value;
      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */


      var traceMethod = time > 10 ? console.warn : console.log;

      if (this.traceInitIndent < this.traceInitMaxIdent) {
        traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
      }

      this.traceInitIndent--;
      return value;
    } else {
      return phaseImpl();
    }
  };

  return PerformanceTracer;
}();

exports.PerformanceTracer = PerformanceTracer;

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyMixins = void 0;

function applyMixins(derivedCtor, baseCtors) {
  baseCtors.forEach(function (baseCtor) {
    var baseProto = baseCtor.prototype;
    Object.getOwnPropertyNames(baseProto).forEach(function (propName) {
      if (propName === "constructor") {
        return;
      }

      var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName); // Handle Accessors

      if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
        Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
      } else {
        derivedCtor.prototype[propName] = baseCtor.prototype[propName];
      }
    });
  });
}

exports.applyMixins = applyMixins;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateCstDts = void 0;

var model_1 = __webpack_require__(529);

var generate_1 = __webpack_require__(530);

var defaultOptions = {
  includeVisitorInterface: true,
  visitorInterfaceName: "ICstNodeVisitor"
};

function generateCstDts(productions, options) {
  var effectiveOptions = __assign(__assign({}, defaultOptions), options);

  var model = (0, model_1.buildModel)(productions);
  return (0, generate_1.genDts)(model, effectiveOptions);
}

exports.generateCstDts = generateCstDts;

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || _extends({}, []) instanceof Array && function (d, b) {
      _defaults(d, b);
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildModel = void 0;

var gast_1 = __webpack_require__(2);

var map_1 = __importDefault(__webpack_require__(4));

var flatten_1 = __importDefault(__webpack_require__(16));

var values_1 = __importDefault(__webpack_require__(15));

var some_1 = __importDefault(__webpack_require__(95));

var groupBy_1 = __importDefault(__webpack_require__(244));

var assign_1 = __importDefault(__webpack_require__(60));

function buildModel(productions) {
  var generator = new CstNodeDefinitionGenerator();
  var allRules = (0, values_1["default"])(productions);
  return (0, map_1["default"])(allRules, function (rule) {
    return generator.visitRule(rule);
  });
}

exports.buildModel = buildModel;

var CstNodeDefinitionGenerator =
/** @class */
function (_super) {
  __extends(CstNodeDefinitionGenerator, _super);

  function CstNodeDefinitionGenerator() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  CstNodeDefinitionGenerator.prototype.visitRule = function (node) {
    var rawElements = this.visitEach(node.definition);
    var grouped = (0, groupBy_1["default"])(rawElements, function (el) {
      return el.propertyName;
    });
    var properties = (0, map_1["default"])(grouped, function (group, propertyName) {
      var allNullable = !(0, some_1["default"])(group, function (el) {
        return !el.canBeNull;
      }); // In an alternation with a label a property name can have
      // multiple types.

      var propertyType = group[0].type;

      if (group.length > 1) {
        propertyType = (0, map_1["default"])(group, function (g) {
          return g.type;
        });
      }

      return {
        name: propertyName,
        type: propertyType,
        optional: allNullable
      };
    });
    return {
      name: node.name,
      properties: properties
    };
  };

  CstNodeDefinitionGenerator.prototype.visitAlternative = function (node) {
    return this.visitEachAndOverrideWith(node.definition, {
      canBeNull: true
    });
  };

  CstNodeDefinitionGenerator.prototype.visitOption = function (node) {
    return this.visitEachAndOverrideWith(node.definition, {
      canBeNull: true
    });
  };

  CstNodeDefinitionGenerator.prototype.visitRepetition = function (node) {
    return this.visitEachAndOverrideWith(node.definition, {
      canBeNull: true
    });
  };

  CstNodeDefinitionGenerator.prototype.visitRepetitionMandatory = function (node) {
    return this.visitEach(node.definition);
  };

  CstNodeDefinitionGenerator.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
    return this.visitEach(node.definition).concat({
      propertyName: node.separator.name,
      canBeNull: true,
      type: getType(node.separator)
    });
  };

  CstNodeDefinitionGenerator.prototype.visitRepetitionWithSeparator = function (node) {
    return this.visitEachAndOverrideWith(node.definition, {
      canBeNull: true
    }).concat({
      propertyName: node.separator.name,
      canBeNull: true,
      type: getType(node.separator)
    });
  };

  CstNodeDefinitionGenerator.prototype.visitAlternation = function (node) {
    return this.visitEachAndOverrideWith(node.definition, {
      canBeNull: true
    });
  };

  CstNodeDefinitionGenerator.prototype.visitTerminal = function (node) {
    return [{
      propertyName: node.label || node.terminalType.name,
      canBeNull: false,
      type: getType(node)
    }];
  };

  CstNodeDefinitionGenerator.prototype.visitNonTerminal = function (node) {
    return [{
      propertyName: node.label || node.nonTerminalName,
      canBeNull: false,
      type: getType(node)
    }];
  };

  CstNodeDefinitionGenerator.prototype.visitEachAndOverrideWith = function (definition, override) {
    return (0, map_1["default"])(this.visitEach(definition), function (definition) {
      return (0, assign_1["default"])({}, definition, override);
    });
  };

  CstNodeDefinitionGenerator.prototype.visitEach = function (definition) {
    var _this = this;

    return (0, flatten_1["default"])((0, map_1["default"])(definition, function (definition) {
      return _this.visit(definition);
    }));
  };

  return CstNodeDefinitionGenerator;
}(gast_1.GAstVisitor);

function getType(production) {
  if (production instanceof gast_1.NonTerminal) {
    return {
      kind: "rule",
      name: production.referencedRule.name
    };
  }

  return {
    kind: "token"
  };
}

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.genDts = void 0;

var flatten_1 = __importDefault(__webpack_require__(16));

var isArray_1 = __importDefault(__webpack_require__(0));

var map_1 = __importDefault(__webpack_require__(4));

var reduce_1 = __importDefault(__webpack_require__(23));

var uniq_1 = __importDefault(__webpack_require__(98));

var upperFirst_1 = __importDefault(__webpack_require__(531));

function genDts(model, options) {
  var contentParts = [];
  contentParts = contentParts.concat("import type { CstNode, ICstVisitor, IToken } from \"chevrotain\";");
  contentParts = contentParts.concat((0, flatten_1["default"])((0, map_1["default"])(model, function (node) {
    return genCstNodeTypes(node);
  })));

  if (options.includeVisitorInterface) {
    contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
  }

  return contentParts.join("\n\n") + "\n";
}

exports.genDts = genDts;

function genCstNodeTypes(node) {
  var nodeCstInterface = genNodeInterface(node);
  var nodeChildrenInterface = genNodeChildrenType(node);
  return [nodeCstInterface, nodeChildrenInterface];
}

function genNodeInterface(node) {
  var nodeInterfaceName = getNodeInterfaceName(node.name);
  var childrenTypeName = getNodeChildrenTypeName(node.name);
  return "export interface ".concat(nodeInterfaceName, " extends CstNode {\n  name: \"").concat(node.name, "\";\n  children: ").concat(childrenTypeName, ";\n}");
}

function genNodeChildrenType(node) {
  var typeName = getNodeChildrenTypeName(node.name);
  return "export type ".concat(typeName, " = {\n  ").concat((0, map_1["default"])(node.properties, function (property) {
    return genChildProperty(property);
  }).join("\n  "), "\n};");
}

function genChildProperty(prop) {
  var typeName = buildTypeString(prop.type);
  return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
}

function genVisitor(name, nodes) {
  return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1["default"])(nodes, function (node) {
    return genVisitorFunction(node);
  }).join("\n  "), "\n}");
}

function genVisitorFunction(node) {
  var childrenTypeName = getNodeChildrenTypeName(node.name);
  return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
}

function buildTypeString(type) {
  if ((0, isArray_1["default"])(type)) {
    var typeNames = (0, uniq_1["default"])((0, map_1["default"])(type, function (t) {
      return getTypeString(t);
    }));
    var typeString = (0, reduce_1["default"])(typeNames, function (sum, t) {
      return sum + " | " + t;
    });
    return "(" + typeString + ")";
  } else {
    return getTypeString(type);
  }
}

function getTypeString(type) {
  if (type.kind === "token") {
    return "IToken";
  }

  return getNodeInterfaceName(type.name);
}

function getNodeInterfaceName(ruleName) {
  return (0, upperFirst_1["default"])(ruleName) + "CstNode";
}

function getNodeChildrenTypeName(ruleName) {
  return (0, upperFirst_1["default"])(ruleName) + "CstChildren";
}

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createCaseFirst = __webpack_require__(532);
/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */


var upperFirst = createCaseFirst('toUpperCase');
module.exports = upperFirst;

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castSlice = __webpack_require__(533),
    hasUnicode = __webpack_require__(109),
    stringToArray = __webpack_require__(534),
    toString = __webpack_require__(223);
/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */


function createCaseFirst(methodName) {
  return function (string) {
    string = toString(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
    return chr[methodName]() + trailing;
  };
}

module.exports = createCaseFirst;

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSlice = __webpack_require__(92);
/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */


function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return !start && end >= length ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var asciiToArray = __webpack_require__(535),
    hasUnicode = __webpack_require__(109),
    unicodeToArray = __webpack_require__(536);
/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */


function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}

module.exports = stringToArray;

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */

function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSyntaxDiagramsCode = void 0;

var version_1 = __webpack_require__(208);

function createSyntaxDiagramsCode(grammar, _a) {
  var _b = _a === void 0 ? {} : _a,
      _c = _b.resourceBase,
      resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c,
      _d = _b.css,
      css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;

  var header = "\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n";
  var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
  var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'></script>\n<script src='").concat(resourceBase, "src/main.js'></script>\n");
  var diagramsDiv = "\n<div id=\"diagrams\" align=\"center\"></div>    \n";
  var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n</script>\n");
  var initLogic = "\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n";
  return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
}

exports.createSyntaxDiagramsCode = createSyntaxDiagramsCode;

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseKeys = __webpack_require__(73),
    getTag = __webpack_require__(24),
    isArrayLike = __webpack_require__(8),
    isString = __webpack_require__(39),
    stringSize = __webpack_require__(539);
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */

function size(collection) {
  if (collection == null) {
    return 0;
  }

  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }

  var tag = getTag(collection);

  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }

  return baseKeys(collection).length;
}

module.exports = size;

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var asciiSize = __webpack_require__(540),
    hasUnicode = __webpack_require__(109),
    unicodeSize = __webpack_require__(541);
/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */


function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}

module.exports = stringSize;

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseProperty = __webpack_require__(225);
/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */


var asciiSize = baseProperty('length');
module.exports = asciiSize;

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;

  while (reUnicode.test(string)) {
    ++result;
  }

  return result;
}

module.exports = unicodeSize;

/***/ }),
/* 542 */
/***/ (function(module, exports) {

module.exports = "// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n// http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// ┌────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Eve 0.4.2 - JavaScript Events Library                      │ \\\\\r\n// ├────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\r\n// └────────────────────────────────────────────────────────────┘ \\\\\r\n(function (glob, factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"eve\", function() {\r\n            return factory();\r\n        });\r\n    } else if (typeof exports === \"object\") {\r\n        module.exports = factory();\r\n    } else {\r\n        glob.eve = factory();\r\n    }\r\n}(this, function(){\r\n    var version = \"0.4.2\",\r\n        has = \"hasOwnProperty\",\r\n        separator = /[\\.\\/]/,\r\n        wildcard = \"*\",\r\n        fun = function () {},\r\n        numsort = function (a, b) {\r\n            return a - b;\r\n        },\r\n        current_event,\r\n        stop,\r\n        events = {n: {}},\r\n    /*\\\r\n     * eve\r\n     [ method ]\r\n\r\n     * Fires event with given `name`, given scope and other parameters.\r\n\r\n     > Arguments\r\n\r\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\r\n     - scope (object) context for the event handlers\r\n     - varargs (...) the rest of arguments will be sent to event handlers\r\n\r\n     = (object) array of returned values from the listeners\r\n     \\*/\r\n        eve = function (name, scope) {\r\n            name = String(name);\r\n            var e = events,\r\n                oldstop = stop,\r\n                args = Array.prototype.slice.call(arguments, 2),\r\n                listeners = eve.listeners(name),\r\n                z = 0,\r\n                f = false,\r\n                l,\r\n                indexed = [],\r\n                queue = {},\r\n                out = [],\r\n                ce = current_event,\r\n                errors = [];\r\n            current_event = name;\r\n            stop = 0;\r\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\r\n                indexed.push(listeners[i].zIndex);\r\n                if (listeners[i].zIndex < 0) {\r\n                    queue[listeners[i].zIndex] = listeners[i];\r\n                }\r\n            }\r\n            indexed.sort(numsort);\r\n            while (indexed[z] < 0) {\r\n                l = queue[indexed[z++]];\r\n                out.push(l.apply(scope, args));\r\n                if (stop) {\r\n                    stop = oldstop;\r\n                    return out;\r\n                }\r\n            }\r\n            for (i = 0; i < ii; i++) {\r\n                l = listeners[i];\r\n                if (\"zIndex\" in l) {\r\n                    if (l.zIndex == indexed[z]) {\r\n                        out.push(l.apply(scope, args));\r\n                        if (stop) {\r\n                            break;\r\n                        }\r\n                        do {\r\n                            z++;\r\n                            l = queue[indexed[z]];\r\n                            l && out.push(l.apply(scope, args));\r\n                            if (stop) {\r\n                                break;\r\n                            }\r\n                        } while (l)\r\n                    } else {\r\n                        queue[l.zIndex] = l;\r\n                    }\r\n                } else {\r\n                    out.push(l.apply(scope, args));\r\n                    if (stop) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            stop = oldstop;\r\n            current_event = ce;\r\n            return out.length ? out : null;\r\n        };\r\n    // Undocumented. Debug only.\r\n    eve._events = events;\r\n    /*\\\r\n     * eve.listeners\r\n     [ method ]\r\n\r\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\r\n\r\n     > Arguments\r\n\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\r\n\r\n     = (array) array of event handlers\r\n     \\*/\r\n    eve.listeners = function (name) {\r\n        var names = name.split(separator),\r\n            e = events,\r\n            item,\r\n            items,\r\n            k,\r\n            i,\r\n            ii,\r\n            j,\r\n            jj,\r\n            nes,\r\n            es = [e],\r\n            out = [];\r\n        for (i = 0, ii = names.length; i < ii; i++) {\r\n            nes = [];\r\n            for (j = 0, jj = es.length; j < jj; j++) {\r\n                e = es[j].n;\r\n                items = [e[names[i]], e[wildcard]];\r\n                k = 2;\r\n                while (k--) {\r\n                    item = items[k];\r\n                    if (item) {\r\n                        nes.push(item);\r\n                        out = out.concat(item.f || []);\r\n                    }\r\n                }\r\n            }\r\n            es = nes;\r\n        }\r\n        return out;\r\n    };\r\n\r\n    /*\\\r\n     * eve.on\r\n     [ method ]\r\n     **\r\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\r\n     | eve.on(\"*.under.*\", f);\r\n     | eve(\"mouse.under.floor\"); // triggers f\r\n     * Use @eve to trigger the listener.\r\n     **\r\n     > Arguments\r\n     **\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n     - f (function) event handler function\r\n     **\r\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\r\n     > Example:\r\n     | eve.on(\"mouse\", eatIt)(2);\r\n     | eve.on(\"mouse\", scream);\r\n     | eve.on(\"mouse\", catchIt)(1);\r\n     * This will ensure that `catchIt()` function will be called before `eatIt()`.\r\n     *\r\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\r\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\r\n     \\*/\r\n    eve.on = function (name, f) {\r\n        name = String(name);\r\n        if (typeof f != \"function\") {\r\n            return function () {};\r\n        }\r\n        var names = name.split(separator),\r\n            e = events;\r\n        for (var i = 0, ii = names.length; i < ii; i++) {\r\n            e = e.n;\r\n            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\r\n        }\r\n        e.f = e.f || [];\r\n        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\r\n            return fun;\r\n        }\r\n        e.f.push(f);\r\n        return function (zIndex) {\r\n            if (+zIndex == +zIndex) {\r\n                f.zIndex = +zIndex;\r\n            }\r\n        };\r\n    };\r\n    /*\\\r\n     * eve.f\r\n     [ method ]\r\n     **\r\n     * Returns function that will fire given event with optional arguments.\r\n     * Arguments that will be passed to the result function will be also\r\n     * concated to the list of final arguments.\r\n     | el.onclick = eve.f(\"click\", 1, 2);\r\n     | eve.on(\"click\", function (a, b, c) {\r\n     |     console.log(a, b, c); // 1, 2, [event object]\r\n     | });\r\n     > Arguments\r\n     - event (string) event name\r\n     - varargs (…) and any other arguments\r\n     = (function) possible event handler function\r\n     \\*/\r\n    eve.f = function (event) {\r\n        var attrs = [].slice.call(arguments, 1);\r\n        return function () {\r\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\r\n        };\r\n    };\r\n    /*\\\r\n     * eve.stop\r\n     [ method ]\r\n     **\r\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\r\n     \\*/\r\n    eve.stop = function () {\r\n        stop = 1;\r\n    };\r\n    /*\\\r\n     * eve.nt\r\n     [ method ]\r\n     **\r\n     * Could be used inside event handler to figure out actual name of the event.\r\n     **\r\n     > Arguments\r\n     **\r\n     - subname (string) #optional subname of the event\r\n     **\r\n     = (string) name of the event, if `subname` is not specified\r\n     * or\r\n     = (boolean) `true`, if current event’s name contains `subname`\r\n     \\*/\r\n    eve.nt = function (subname) {\r\n        if (subname) {\r\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(current_event);\r\n        }\r\n        return current_event;\r\n    };\r\n    /*\\\r\n     * eve.nts\r\n     [ method ]\r\n     **\r\n     * Could be used inside event handler to figure out actual name of the event.\r\n     **\r\n     **\r\n     = (array) names of the event\r\n     \\*/\r\n    eve.nts = function () {\r\n        return current_event.split(separator);\r\n    };\r\n    /*\\\r\n     * eve.off\r\n     [ method ]\r\n     **\r\n     * Removes given function from the list of event listeners assigned to given name.\r\n     * If no arguments specified all the events will be cleared.\r\n     **\r\n     > Arguments\r\n     **\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n     - f (function) event handler function\r\n     \\*/\r\n    /*\\\r\n     * eve.unbind\r\n     [ method ]\r\n     **\r\n     * See @eve.off\r\n     \\*/\r\n    eve.off = eve.unbind = function (name, f) {\r\n        if (!name) {\r\n            eve._events = events = {n: {}};\r\n            return;\r\n        }\r\n        var names = name.split(separator),\r\n            e,\r\n            key,\r\n            splice,\r\n            i, ii, j, jj,\r\n            cur = [events];\r\n        for (i = 0, ii = names.length; i < ii; i++) {\r\n            for (j = 0; j < cur.length; j += splice.length - 2) {\r\n                splice = [j, 1];\r\n                e = cur[j].n;\r\n                if (names[i] != wildcard) {\r\n                    if (e[names[i]]) {\r\n                        splice.push(e[names[i]]);\r\n                    }\r\n                } else {\r\n                    for (key in e) if (e[has](key)) {\r\n                        splice.push(e[key]);\r\n                    }\r\n                }\r\n                cur.splice.apply(cur, splice);\r\n            }\r\n        }\r\n        for (i = 0, ii = cur.length; i < ii; i++) {\r\n            e = cur[i];\r\n            while (e.n) {\r\n                if (f) {\r\n                    if (e.f) {\r\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\r\n                            e.f.splice(j, 1);\r\n                            break;\r\n                        }\r\n                        !e.f.length && delete e.f;\r\n                    }\r\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\r\n                        var funcs = e.n[key].f;\r\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\r\n                            funcs.splice(j, 1);\r\n                            break;\r\n                        }\r\n                        !funcs.length && delete e.n[key].f;\r\n                    }\r\n                } else {\r\n                    delete e.f;\r\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\r\n                        delete e.n[key].f;\r\n                    }\r\n                }\r\n                e = e.n;\r\n            }\r\n        }\r\n    };\r\n    /*\\\r\n     * eve.once\r\n     [ method ]\r\n     **\r\n     * Binds given event handler with a given name to only run once then unbind itself.\r\n     | eve.once(\"login\", f);\r\n     | eve(\"login\"); // triggers f\r\n     | eve(\"login\"); // no listeners\r\n     * Use @eve to trigger the listener.\r\n     **\r\n     > Arguments\r\n     **\r\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\r\n     - f (function) event handler function\r\n     **\r\n     = (function) same return function as @eve.on\r\n     \\*/\r\n    eve.once = function (name, f) {\r\n        var f2 = function () {\r\n            eve.unbind(name, f2);\r\n            return f.apply(this, arguments);\r\n        };\r\n        return eve.on(name, f2);\r\n    };\r\n    /*\\\r\n     * eve.version\r\n     [ property (string) ]\r\n     **\r\n     * Current version of the library.\r\n     \\*/\r\n    eve.version = version;\r\n    eve.toString = function () {\r\n        return \"You are running Eve \" + version;\r\n    };\r\n\r\n    return eve;\r\n}));\r\n\r\n// ┌────────────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Raphaël 2.1.4 - JavaScript Vector Library                      │ \\\\\r\n// ├────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Core Module                                                        │ \\\\\r\n// ├────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\\\\r\n// └────────────────────────────────────────────────────────────────────┘ \\\\\r\n\r\n(function (glob, factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"raphael.core\", [\"eve\"], function(eve) {\r\n            return factory(eve);\r\n        });\r\n    } else if (typeof exports === \"object\") {\r\n        module.exports = factory(require(\"eve\"));\r\n    } else {\r\n        glob.Raphael = factory(glob.eve);\r\n    }\r\n}(this, function (eve) {\r\n    /*\\\r\n     * Raphael\r\n     [ method ]\r\n     **\r\n     * Creates a canvas object on which to draw.\r\n     * You must do this first, as all future calls to drawing methods\r\n     * from this instance will be bound to this canvas.\r\n     > Parameters\r\n     **\r\n     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface\r\n     - width (number)\r\n     - height (number)\r\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\r\n     * or\r\n     - x (number)\r\n     - y (number)\r\n     - width (number)\r\n     - height (number)\r\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\r\n     * or\r\n     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.\r\n     - callback (function) #optional callback function which is going to be executed in the context of newly created paper\r\n     * or\r\n     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.\r\n     = (object) @Paper\r\n     > Usage\r\n     | // Each of the following examples create a canvas\r\n     | // that is 320px wide by 200px high.\r\n     | // Canvas is created at the viewport’s 10,50 coordinate.\r\n     | var paper = Raphael(10, 50, 320, 200);\r\n     | // Canvas is created at the top left corner of the #notepad element\r\n     | // (or its top right corner in dir=\"rtl\" elements)\r\n     | var paper = Raphael(document.getElementById(\"notepad\"), 320, 200);\r\n     | // Same as above\r\n     | var paper = Raphael(\"notepad\", 320, 200);\r\n     | // Image dump\r\n     | var set = Raphael([\"notepad\", 320, 200, {\r\n     |     type: \"rect\",\r\n     |     x: 10,\r\n     |     y: 10,\r\n     |     width: 25,\r\n     |     height: 25,\r\n     |     stroke: \"#f00\"\r\n     | }, {\r\n     |     type: \"text\",\r\n     |     x: 30,\r\n     |     y: 40,\r\n     |     text: \"Dump\"\r\n     | }]);\r\n     \\*/\r\n    function R(first) {\r\n        if (R.is(first, \"function\")) {\r\n            return loaded ? first() : eve.on(\"raphael.DOMload\", first);\r\n        } else if (R.is(first, array)) {\r\n            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);\r\n        } else {\r\n            var args = Array.prototype.slice.call(arguments, 0);\r\n            if (R.is(args[args.length - 1], \"function\")) {\r\n                var f = args.pop();\r\n                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on(\"raphael.DOMload\", function () {\r\n                    f.call(R._engine.create[apply](R, args));\r\n                });\r\n            } else {\r\n                return R._engine.create[apply](R, arguments);\r\n            }\r\n        }\r\n    }\r\n    R.version = \"2.1.4\";\r\n    R.eve = eve;\r\n    var loaded,\r\n        separator = /[, ]+/,\r\n        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},\r\n        formatrg = /\\{(\\d+)\\}/g,\r\n        proto = \"prototype\",\r\n        has = \"hasOwnProperty\",\r\n        g = {\r\n            doc: document,\r\n            win: window\r\n        },\r\n        oldRaphael = {\r\n            was: Object.prototype[has].call(g.win, \"Raphael\"),\r\n            is: g.win.Raphael\r\n        },\r\n        Paper = function () {\r\n            /*\\\r\n             * Paper.ca\r\n             [ property (object) ]\r\n             **\r\n             * Shortcut for @Paper.customAttributes\r\n             \\*/\r\n            /*\\\r\n             * Paper.customAttributes\r\n             [ property (object) ]\r\n             **\r\n             * If you have a set of attributes that you would like to represent\r\n             * as a function of some number you can do it easily with custom attributes:\r\n             > Usage\r\n             | paper.customAttributes.hue = function (num) {\r\n             |     num = num % 1;\r\n             |     return {fill: \"hsb(\" + num + \", 0.75, 1)\"};\r\n             | };\r\n             | // Custom attribute “hue” will change fill\r\n             | // to be given hue with fixed saturation and brightness.\r\n             | // Now you can use it like this:\r\n             | var c = paper.circle(10, 10, 10).attr({hue: .45});\r\n             | // or even like this:\r\n             | c.animate({hue: 1}, 1e3);\r\n             |\r\n             | // You could also create custom attribute\r\n             | // with multiple parameters:\r\n             | paper.customAttributes.hsb = function (h, s, b) {\r\n             |     return {fill: \"hsb(\" + [h, s, b].join(\",\") + \")\"};\r\n             | };\r\n             | c.attr({hsb: \"0.5 .8 1\"});\r\n             | c.animate({hsb: [1, 0, 0.5]}, 1e3);\r\n             \\*/\r\n            this.ca = this.customAttributes = {};\r\n        },\r\n        paperproto,\r\n        appendChild = \"appendChild\",\r\n        apply = \"apply\",\r\n        concat = \"concat\",\r\n        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test\r\n        E = \"\",\r\n        S = \" \",\r\n        Str = String,\r\n        split = \"split\",\r\n        events = \"click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel\"[split](S),\r\n        touchMap = {\r\n            mousedown: \"touchstart\",\r\n            mousemove: \"touchmove\",\r\n            mouseup: \"touchend\"\r\n        },\r\n        lowerCase = Str.prototype.toLowerCase,\r\n        math = Math,\r\n        mmax = math.max,\r\n        mmin = math.min,\r\n        abs = math.abs,\r\n        pow = math.pow,\r\n        PI = math.PI,\r\n        nu = \"number\",\r\n        string = \"string\",\r\n        array = \"array\",\r\n        toString = \"toString\",\r\n        fillString = \"fill\",\r\n        objectToString = Object.prototype.toString,\r\n        paper = {},\r\n        push = \"push\",\r\n        ISURL = R._ISURL = /^url\\(['\"]?(.+?)['\"]?\\)$/i,\r\n        colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?)%?\\s*\\))\\s*$/i,\r\n        isnan = {\"NaN\": 1, \"Infinity\": 1, \"-Infinity\": 1},\r\n        bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\r\n        round = math.round,\r\n        setAttribute = \"setAttribute\",\r\n        toFloat = parseFloat,\r\n        toInt = parseInt,\r\n        upperCase = Str.prototype.toUpperCase,\r\n        availableAttrs = R._availableAttrs = {\r\n            \"arrow-end\": \"none\",\r\n            \"arrow-start\": \"none\",\r\n            blur: 0,\r\n            \"clip-rect\": \"0 0 1e9 1e9\",\r\n            cursor: \"default\",\r\n            cx: 0,\r\n            cy: 0,\r\n            fill: \"#fff\",\r\n            \"fill-opacity\": 1,\r\n            font: '10px \"Arial\"',\r\n            \"font-family\": '\"Arial\"',\r\n            \"font-size\": \"10\",\r\n            \"font-style\": \"normal\",\r\n            \"font-weight\": 400,\r\n            gradient: 0,\r\n            height: 0,\r\n            href: \"http://raphaeljs.com/\",\r\n            \"letter-spacing\": 0,\r\n            opacity: 1,\r\n            path: \"M0,0\",\r\n            r: 0,\r\n            rx: 0,\r\n            ry: 0,\r\n            src: \"\",\r\n            stroke: \"#000\",\r\n            \"stroke-dasharray\": \"\",\r\n            \"stroke-linecap\": \"butt\",\r\n            \"stroke-linejoin\": \"butt\",\r\n            \"stroke-miterlimit\": 0,\r\n            \"stroke-opacity\": 1,\r\n            \"stroke-width\": 1,\r\n            target: \"_blank\",\r\n            \"text-anchor\": \"middle\",\r\n            title: \"Raphael\",\r\n            transform: \"\",\r\n            width: 0,\r\n            x: 0,\r\n            y: 0\r\n        },\r\n        availableAnimAttrs = R._availableAnimAttrs = {\r\n            blur: nu,\r\n            \"clip-rect\": \"csv\",\r\n            cx: nu,\r\n            cy: nu,\r\n            fill: \"colour\",\r\n            \"fill-opacity\": nu,\r\n            \"font-size\": nu,\r\n            height: nu,\r\n            opacity: nu,\r\n            path: \"path\",\r\n            r: nu,\r\n            rx: nu,\r\n            ry: nu,\r\n            stroke: \"colour\",\r\n            \"stroke-opacity\": nu,\r\n            \"stroke-width\": nu,\r\n            transform: \"transform\",\r\n            width: nu,\r\n            x: nu,\r\n            y: nu\r\n        },\r\n        whitespace = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]/g,\r\n        commaSpaces = /[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/,\r\n        hsrg = {hs: 1, rg: 1},\r\n        p2s = /,?([achlmqrstvxz]),?/gi,\r\n        pathCommand = /([achlmrqstvz])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\r\n        tCommand = /([rstm])[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*)+)/ig,\r\n        pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,?[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*/ig,\r\n        radial_gradient = R._radial_gradient = /^r(?:\\(([^,]+?)[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*,[\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029]*([^\\)]+?)\\))?/,\r\n        eldata = {},\r\n        sortByKey = function (a, b) {\r\n            return a.key - b.key;\r\n        },\r\n        sortByNumber = function (a, b) {\r\n            return toFloat(a) - toFloat(b);\r\n        },\r\n        fun = function () {},\r\n        pipe = function (x) {\r\n            return x;\r\n        },\r\n        rectPath = R._rectPath = function (x, y, w, h, r) {\r\n            if (r) {\r\n                return [[\"M\", x + r, y], [\"l\", w - r * 2, 0], [\"a\", r, r, 0, 0, 1, r, r], [\"l\", 0, h - r * 2], [\"a\", r, r, 0, 0, 1, -r, r], [\"l\", r * 2 - w, 0], [\"a\", r, r, 0, 0, 1, -r, -r], [\"l\", 0, r * 2 - h], [\"a\", r, r, 0, 0, 1, r, -r], [\"z\"]];\r\n            }\r\n            return [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\r\n        },\r\n        ellipsePath = function (x, y, rx, ry) {\r\n            if (ry == null) {\r\n                ry = rx;\r\n            }\r\n            return [[\"M\", x, y], [\"m\", 0, -ry], [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry], [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry], [\"z\"]];\r\n        },\r\n        getPath = R._getPath = {\r\n            path: function (el) {\r\n                return el.attr(\"path\");\r\n            },\r\n            circle: function (el) {\r\n                var a = el.attrs;\r\n                return ellipsePath(a.cx, a.cy, a.r);\r\n            },\r\n            ellipse: function (el) {\r\n                var a = el.attrs;\r\n                return ellipsePath(a.cx, a.cy, a.rx, a.ry);\r\n            },\r\n            rect: function (el) {\r\n                var a = el.attrs;\r\n                return rectPath(a.x, a.y, a.width, a.height, a.r);\r\n            },\r\n            image: function (el) {\r\n                var a = el.attrs;\r\n                return rectPath(a.x, a.y, a.width, a.height);\r\n            },\r\n            text: function (el) {\r\n                var bbox = el._getBBox();\r\n                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\r\n            },\r\n            set : function(el) {\r\n                var bbox = el._getBBox();\r\n                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\r\n            }\r\n        },\r\n    /*\\\r\n     * Raphael.mapPath\r\n     [ method ]\r\n     **\r\n     * Transform the path string with given matrix.\r\n     > Parameters\r\n     - path (string) path string\r\n     - matrix (object) see @Matrix\r\n     = (string) transformed path string\r\n     \\*/\r\n        mapPath = R.mapPath = function (path, matrix) {\r\n            if (!matrix) {\r\n                return path;\r\n            }\r\n            var x, y, i, j, ii, jj, pathi;\r\n            path = path2curve(path);\r\n            for (i = 0, ii = path.length; i < ii; i++) {\r\n                pathi = path[i];\r\n                for (j = 1, jj = pathi.length; j < jj; j += 2) {\r\n                    x = matrix.x(pathi[j], pathi[j + 1]);\r\n                    y = matrix.y(pathi[j], pathi[j + 1]);\r\n                    pathi[j] = x;\r\n                    pathi[j + 1] = y;\r\n                }\r\n            }\r\n            return path;\r\n        };\r\n\r\n    R._g = g;\r\n    /*\\\r\n     * Raphael.type\r\n     [ property (string) ]\r\n     **\r\n     * Can be “SVG”, “VML” or empty, depending on browser support.\r\n     \\*/\r\n    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\") ? \"SVG\" : \"VML\");\r\n    if (R.type == \"VML\") {\r\n        var d = g.doc.createElement(\"div\"),\r\n            b;\r\n        d.innerHTML = '<v:shape adj=\"1\"/>';\r\n        b = d.firstChild;\r\n        b.style.behavior = \"url(#default#VML)\";\r\n        if (!(b && typeof b.adj == \"object\")) {\r\n            return (R.type = E);\r\n        }\r\n        d = null;\r\n    }\r\n    /*\\\r\n     * Raphael.svg\r\n     [ property (boolean) ]\r\n     **\r\n     * `true` if browser supports SVG.\r\n     \\*/\r\n    /*\\\r\n     * Raphael.vml\r\n     [ property (boolean) ]\r\n     **\r\n     * `true` if browser supports VML.\r\n     \\*/\r\n    R.svg = !(R.vml = R.type == \"VML\");\r\n    R._Paper = Paper;\r\n    /*\\\r\n     * Raphael.fn\r\n     [ property (object) ]\r\n     **\r\n     * You can add your own method to the canvas. For example if you want to draw a pie chart,\r\n     * you can create your own pie chart function and ship it as a Raphaël plugin. To do this\r\n     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a\r\n     * Raphaël instance is created, otherwise it will take no effect. Please note that the\r\n     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to\r\n     * ensure any namespacing ensures proper context.\r\n     > Usage\r\n     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {\r\n     |     return this.path( ... );\r\n     | };\r\n     | // or create namespace\r\n     | Raphael.fn.mystuff = {\r\n     |     arrow: function () {…},\r\n     |     star: function () {…},\r\n     |     // etc…\r\n     | };\r\n     | var paper = Raphael(10, 10, 630, 480);\r\n     | // then use it\r\n     | paper.arrow(10, 10, 30, 30, 5).attr({fill: \"#f00\"});\r\n     | paper.mystuff.arrow();\r\n     | paper.mystuff.star();\r\n     \\*/\r\n    R.fn = paperproto = Paper.prototype = R.prototype;\r\n    R._id = 0;\r\n    R._oid = 0;\r\n    /*\\\r\n     * Raphael.is\r\n     [ method ]\r\n     **\r\n     * Handful of replacements for `typeof` operator.\r\n     > Parameters\r\n     - o (…) any object or primitive\r\n     - type (string) name of the type, i.e. “string”, “function”, “number”, etc.\r\n     = (boolean) is given value is of given type\r\n     \\*/\r\n    R.is = function (o, type) {\r\n        type = lowerCase.call(type);\r\n        if (type == \"finite\") {\r\n            return !isnan[has](+o);\r\n        }\r\n        if (type == \"array\") {\r\n            return o instanceof Array;\r\n        }\r\n        return  (type == \"null\" && o === null) ||\r\n            (type == typeof o && o !== null) ||\r\n            (type == \"object\" && o === Object(o)) ||\r\n            (type == \"array\" && Array.isArray && Array.isArray(o)) ||\r\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\r\n    };\r\n\r\n    function clone(obj) {\r\n        if (typeof obj == \"function\" || Object(obj) !== obj) {\r\n            return obj;\r\n        }\r\n        var res = new obj.constructor;\r\n        for (var key in obj) if (obj[has](key)) {\r\n            res[key] = clone(obj[key]);\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /*\\\r\n     * Raphael.angle\r\n     [ method ]\r\n     **\r\n     * Returns angle between two or three points\r\n     > Parameters\r\n     - x1 (number) x coord of first point\r\n     - y1 (number) y coord of first point\r\n     - x2 (number) x coord of second point\r\n     - y2 (number) y coord of second point\r\n     - x3 (number) #optional x coord of third point\r\n     - y3 (number) #optional y coord of third point\r\n     = (number) angle in degrees.\r\n     \\*/\r\n    R.angle = function (x1, y1, x2, y2, x3, y3) {\r\n        if (x3 == null) {\r\n            var x = x1 - x2,\r\n                y = y1 - y2;\r\n            if (!x && !y) {\r\n                return 0;\r\n            }\r\n            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\r\n        } else {\r\n            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);\r\n        }\r\n    };\r\n    /*\\\r\n     * Raphael.rad\r\n     [ method ]\r\n     **\r\n     * Transform angle to radians\r\n     > Parameters\r\n     - deg (number) angle in degrees\r\n     = (number) angle in radians.\r\n     \\*/\r\n    R.rad = function (deg) {\r\n        return deg % 360 * PI / 180;\r\n    };\r\n    /*\\\r\n     * Raphael.deg\r\n     [ method ]\r\n     **\r\n     * Transform angle to degrees\r\n     > Parameters\r\n     - rad (number) angle in radians\r\n     = (number) angle in degrees.\r\n     \\*/\r\n    R.deg = function (rad) {\r\n        return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;\r\n    };\r\n    /*\\\r\n     * Raphael.snapTo\r\n     [ method ]\r\n     **\r\n     * Snaps given value to given grid.\r\n     > Parameters\r\n     - values (array|number) given array of values or step of the grid\r\n     - value (number) value to adjust\r\n     - tolerance (number) #optional tolerance for snapping. Default is `10`.\r\n     = (number) adjusted value.\r\n     \\*/\r\n    R.snapTo = function (values, value, tolerance) {\r\n        tolerance = R.is(tolerance, \"finite\") ? tolerance : 10;\r\n        if (R.is(values, array)) {\r\n            var i = values.length;\r\n            while (i--) if (abs(values[i] - value) <= tolerance) {\r\n                return values[i];\r\n            }\r\n        } else {\r\n            values = +values;\r\n            var rem = value % values;\r\n            if (rem < tolerance) {\r\n                return value - rem;\r\n            }\r\n            if (rem > values - tolerance) {\r\n                return value - rem + values;\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n\r\n    /*\\\r\n     * Raphael.createUUID\r\n     [ method ]\r\n     **\r\n     * Returns RFC4122, version 4 ID\r\n     \\*/\r\n    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {\r\n        return function () {\r\n            return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(uuidRegEx, uuidReplacer).toUpperCase();\r\n        };\r\n    })(/[xy]/g, function (c) {\r\n        var r = math.random() * 16 | 0,\r\n            v = c == \"x\" ? r : (r & 3 | 8);\r\n        return v.toString(16);\r\n    });\r\n\r\n    /*\\\r\n     * Raphael.setWindow\r\n     [ method ]\r\n     **\r\n     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.\r\n     > Parameters\r\n     - newwin (window) new window object\r\n     \\*/\r\n    R.setWindow = function (newwin) {\r\n        eve(\"raphael.setWindow\", R, g.win, newwin);\r\n        g.win = newwin;\r\n        g.doc = g.win.document;\r\n        if (R._engine.initWin) {\r\n            R._engine.initWin(g.win);\r\n        }\r\n    };\r\n    var toHex = function (color) {\r\n            if (R.vml) {\r\n                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/\r\n                var trim = /^\\s+|\\s+$/g;\r\n                var bod;\r\n                try {\r\n                    var docum = new ActiveXObject(\"htmlfile\");\r\n                    docum.write(\"<body>\");\r\n                    docum.close();\r\n                    bod = docum.body;\r\n                } catch(e) {\r\n                    bod = createPopup().document.body;\r\n                }\r\n                var range = bod.createTextRange();\r\n                toHex = cacher(function (color) {\r\n                    try {\r\n                        bod.style.color = Str(color).replace(trim, E);\r\n                        var value = range.queryCommandValue(\"ForeColor\");\r\n                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);\r\n                        return \"#\" + (\"000000\" + value.toString(16)).slice(-6);\r\n                    } catch(e) {\r\n                        return \"none\";\r\n                    }\r\n                });\r\n            } else {\r\n                var i = g.doc.createElement(\"i\");\r\n                i.title = \"Rapha\\xebl Colour Picker\";\r\n                i.style.display = \"none\";\r\n                g.doc.body.appendChild(i);\r\n                toHex = cacher(function (color) {\r\n                    i.style.color = color;\r\n                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\r\n                });\r\n            }\r\n            return toHex(color);\r\n        },\r\n        hsbtoString = function () {\r\n            return \"hsb(\" + [this.h, this.s, this.b] + \")\";\r\n        },\r\n        hsltoString = function () {\r\n            return \"hsl(\" + [this.h, this.s, this.l] + \")\";\r\n        },\r\n        rgbtoString = function () {\r\n            return this.hex;\r\n        },\r\n        prepareRGB = function (r, g, b) {\r\n            if (g == null && R.is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\r\n                b = r.b;\r\n                g = r.g;\r\n                r = r.r;\r\n            }\r\n            if (g == null && R.is(r, string)) {\r\n                var clr = R.getRGB(r);\r\n                r = clr.r;\r\n                g = clr.g;\r\n                b = clr.b;\r\n            }\r\n            if (r > 1 || g > 1 || b > 1) {\r\n                r /= 255;\r\n                g /= 255;\r\n                b /= 255;\r\n            }\r\n\r\n            return [r, g, b];\r\n        },\r\n        packageRGB = function (r, g, b, o) {\r\n            r *= 255;\r\n            g *= 255;\r\n            b *= 255;\r\n            var rgb = {\r\n                r: r,\r\n                g: g,\r\n                b: b,\r\n                hex: R.rgb(r, g, b),\r\n                toString: rgbtoString\r\n            };\r\n            R.is(o, \"finite\") && (rgb.opacity = o);\r\n            return rgb;\r\n        };\r\n\r\n    /*\\\r\n     * Raphael.color\r\n     [ method ]\r\n     **\r\n     * Parses the color string and returns object with all values for the given color.\r\n     > Parameters\r\n     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)\r\n     = (object) Combined RGB & HSB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue,\r\n     o     hex (string) color in HTML/CSS format: #••••••,\r\n     o     error (boolean) `true` if string can’t be parsed,\r\n     o     h (number) hue,\r\n     o     s (number) saturation,\r\n     o     v (number) value (brightness),\r\n     o     l (number) lightness\r\n     o }\r\n     \\*/\r\n    R.color = function (clr) {\r\n        var rgb;\r\n        if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\r\n            rgb = R.hsb2rgb(clr);\r\n            clr.r = rgb.r;\r\n            clr.g = rgb.g;\r\n            clr.b = rgb.b;\r\n            clr.hex = rgb.hex;\r\n        } else if (R.is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\r\n            rgb = R.hsl2rgb(clr);\r\n            clr.r = rgb.r;\r\n            clr.g = rgb.g;\r\n            clr.b = rgb.b;\r\n            clr.hex = rgb.hex;\r\n        } else {\r\n            if (R.is(clr, \"string\")) {\r\n                clr = R.getRGB(clr);\r\n            }\r\n            if (R.is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr) {\r\n                rgb = R.rgb2hsl(clr);\r\n                clr.h = rgb.h;\r\n                clr.s = rgb.s;\r\n                clr.l = rgb.l;\r\n                rgb = R.rgb2hsb(clr);\r\n                clr.v = rgb.b;\r\n            } else {\r\n                clr = {hex: \"none\"};\r\n                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\r\n            }\r\n        }\r\n        clr.toString = rgbtoString;\r\n        return clr;\r\n    };\r\n    /*\\\r\n     * Raphael.hsb2rgb\r\n     [ method ]\r\n     **\r\n     * Converts HSB values to RGB object.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - v (number) value or brightness\r\n     = (object) RGB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue,\r\n     o     hex (string) color in HTML/CSS format: #••••••\r\n     o }\r\n     \\*/\r\n    R.hsb2rgb = function (h, s, v, o) {\r\n        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\r\n            v = h.b;\r\n            s = h.s;\r\n            o = h.o;\r\n            h = h.h;\r\n        }\r\n        h *= 360;\r\n        var R, G, B, X, C;\r\n        h = (h % 360) / 60;\r\n        C = v * s;\r\n        X = C * (1 - abs(h % 2 - 1));\r\n        R = G = B = v - C;\r\n\r\n        h = ~~h;\r\n        R += [C, X, 0, 0, X, C][h];\r\n        G += [X, C, C, X, 0, 0][h];\r\n        B += [0, 0, X, C, C, X][h];\r\n        return packageRGB(R, G, B, o);\r\n    };\r\n    /*\\\r\n     * Raphael.hsl2rgb\r\n     [ method ]\r\n     **\r\n     * Converts HSL values to RGB object.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - l (number) luminosity\r\n     = (object) RGB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue,\r\n     o     hex (string) color in HTML/CSS format: #••••••\r\n     o }\r\n     \\*/\r\n    R.hsl2rgb = function (h, s, l, o) {\r\n        if (this.is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\r\n            l = h.l;\r\n            s = h.s;\r\n            h = h.h;\r\n        }\r\n        if (h > 1 || s > 1 || l > 1) {\r\n            h /= 360;\r\n            s /= 100;\r\n            l /= 100;\r\n        }\r\n        h *= 360;\r\n        var R, G, B, X, C;\r\n        h = (h % 360) / 60;\r\n        C = 2 * s * (l < .5 ? l : 1 - l);\r\n        X = C * (1 - abs(h % 2 - 1));\r\n        R = G = B = l - C / 2;\r\n\r\n        h = ~~h;\r\n        R += [C, X, 0, 0, X, C][h];\r\n        G += [X, C, C, X, 0, 0][h];\r\n        B += [0, 0, X, C, C, X][h];\r\n        return packageRGB(R, G, B, o);\r\n    };\r\n    /*\\\r\n     * Raphael.rgb2hsb\r\n     [ method ]\r\n     **\r\n     * Converts RGB values to HSB object.\r\n     > Parameters\r\n     - r (number) red\r\n     - g (number) green\r\n     - b (number) blue\r\n     = (object) HSB object in format:\r\n     o {\r\n     o     h (number) hue\r\n     o     s (number) saturation\r\n     o     b (number) brightness\r\n     o }\r\n     \\*/\r\n    R.rgb2hsb = function (r, g, b) {\r\n        b = prepareRGB(r, g, b);\r\n        r = b[0];\r\n        g = b[1];\r\n        b = b[2];\r\n\r\n        var H, S, V, C;\r\n        V = mmax(r, g, b);\r\n        C = V - mmin(r, g, b);\r\n        H = (C == 0 ? null :\r\n                V == r ? (g - b) / C :\r\n                    V == g ? (b - r) / C + 2 :\r\n                    (r - g) / C + 4\r\n        );\r\n        H = ((H + 360) % 6) * 60 / 360;\r\n        S = C == 0 ? 0 : C / V;\r\n        return {h: H, s: S, b: V, toString: hsbtoString};\r\n    };\r\n    /*\\\r\n     * Raphael.rgb2hsl\r\n     [ method ]\r\n     **\r\n     * Converts RGB values to HSL object.\r\n     > Parameters\r\n     - r (number) red\r\n     - g (number) green\r\n     - b (number) blue\r\n     = (object) HSL object in format:\r\n     o {\r\n     o     h (number) hue\r\n     o     s (number) saturation\r\n     o     l (number) luminosity\r\n     o }\r\n     \\*/\r\n    R.rgb2hsl = function (r, g, b) {\r\n        b = prepareRGB(r, g, b);\r\n        r = b[0];\r\n        g = b[1];\r\n        b = b[2];\r\n\r\n        var H, S, L, M, m, C;\r\n        M = mmax(r, g, b);\r\n        m = mmin(r, g, b);\r\n        C = M - m;\r\n        H = (C == 0 ? null :\r\n            M == r ? (g - b) / C :\r\n                M == g ? (b - r) / C + 2 :\r\n                (r - g) / C + 4);\r\n        H = ((H + 360) % 6) * 60 / 360;\r\n        L = (M + m) / 2;\r\n        S = (C == 0 ? 0 :\r\n            L < .5 ? C / (2 * L) :\r\n            C / (2 - 2 * L));\r\n        return {h: H, s: S, l: L, toString: hsltoString};\r\n    };\r\n    R._path2string = function () {\r\n        return this.join(\",\").replace(p2s, \"$1\");\r\n    };\r\n    function repush(array, item) {\r\n        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\r\n            return array.push(array.splice(i, 1)[0]);\r\n        }\r\n    }\r\n    function cacher(f, scope, postprocessor) {\r\n        function newf() {\r\n            var arg = Array.prototype.slice.call(arguments, 0),\r\n                args = arg.join(\"\\u2400\"),\r\n                cache = newf.cache = newf.cache || {},\r\n                count = newf.count = newf.count || [];\r\n            if (cache[has](args)) {\r\n                repush(count, args);\r\n                return postprocessor ? postprocessor(cache[args]) : cache[args];\r\n            }\r\n            count.length >= 1e3 && delete cache[count.shift()];\r\n            count.push(args);\r\n            cache[args] = f[apply](scope, arg);\r\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\r\n        }\r\n        return newf;\r\n    }\r\n\r\n    var preload = R._preload = function (src, f) {\r\n        var img = g.doc.createElement(\"img\");\r\n        img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\r\n        img.onload = function () {\r\n            f.call(this);\r\n            this.onload = null;\r\n            g.doc.body.removeChild(this);\r\n        };\r\n        img.onerror = function () {\r\n            g.doc.body.removeChild(this);\r\n        };\r\n        g.doc.body.appendChild(img);\r\n        img.src = src;\r\n    };\r\n\r\n    function clrToString() {\r\n        return this.hex;\r\n    }\r\n\r\n    /*\\\r\n     * Raphael.getRGB\r\n     [ method ]\r\n     **\r\n     * Parses colour string as RGB object\r\n     > Parameters\r\n     - colour (string) colour string in one of formats:\r\n     # <ul>\r\n     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\r\n     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\r\n     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\r\n     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\r\n     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\r\n     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\r\n     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\r\n     #     <li>hsl(•••, •••, •••) — same as hsb</li>\r\n     #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>\r\n     # </ul>\r\n     = (object) RGB object in format:\r\n     o {\r\n     o     r (number) red,\r\n     o     g (number) green,\r\n     o     b (number) blue\r\n     o     hex (string) color in HTML/CSS format: #••••••,\r\n     o     error (boolean) true if string can’t be parsed\r\n     o }\r\n     \\*/\r\n    R.getRGB = cacher(function (colour) {\r\n        if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\r\n            return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\r\n        }\r\n        if (colour == \"none\") {\r\n            return {r: -1, g: -1, b: -1, hex: \"none\", toString: clrToString};\r\n        }\r\n        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\r\n        var res,\r\n            red,\r\n            green,\r\n            blue,\r\n            opacity,\r\n            t,\r\n            values,\r\n            rgb = colour.match(colourRegExp);\r\n        if (rgb) {\r\n            if (rgb[2]) {\r\n                blue = toInt(rgb[2].substring(5), 16);\r\n                green = toInt(rgb[2].substring(3, 5), 16);\r\n                red = toInt(rgb[2].substring(1, 3), 16);\r\n            }\r\n            if (rgb[3]) {\r\n                blue = toInt((t = rgb[3].charAt(3)) + t, 16);\r\n                green = toInt((t = rgb[3].charAt(2)) + t, 16);\r\n                red = toInt((t = rgb[3].charAt(1)) + t, 16);\r\n            }\r\n            if (rgb[4]) {\r\n                values = rgb[4][split](commaSpaces);\r\n                red = toFloat(values[0]);\r\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\r\n                green = toFloat(values[1]);\r\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\r\n                blue = toFloat(values[2]);\r\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\r\n                rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\r\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\r\n            }\r\n            if (rgb[5]) {\r\n                values = rgb[5][split](commaSpaces);\r\n                red = toFloat(values[0]);\r\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\r\n                green = toFloat(values[1]);\r\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\r\n                blue = toFloat(values[2]);\r\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\r\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\r\n                rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\r\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\r\n                return R.hsb2rgb(red, green, blue, opacity);\r\n            }\r\n            if (rgb[6]) {\r\n                values = rgb[6][split](commaSpaces);\r\n                red = toFloat(values[0]);\r\n                values[0].slice(-1) == \"%\" && (red *= 2.55);\r\n                green = toFloat(values[1]);\r\n                values[1].slice(-1) == \"%\" && (green *= 2.55);\r\n                blue = toFloat(values[2]);\r\n                values[2].slice(-1) == \"%\" && (blue *= 2.55);\r\n                (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\r\n                rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\r\n                values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\r\n                return R.hsl2rgb(red, green, blue, opacity);\r\n            }\r\n            rgb = {r: red, g: green, b: blue, toString: clrToString};\r\n            rgb.hex = \"#\" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);\r\n            R.is(opacity, \"finite\") && (rgb.opacity = opacity);\r\n            return rgb;\r\n        }\r\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: clrToString};\r\n    }, R);\r\n    /*\\\r\n     * Raphael.hsb\r\n     [ method ]\r\n     **\r\n     * Converts HSB values to hex representation of the colour.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - b (number) value or brightness\r\n     = (string) hex representation of the colour.\r\n     \\*/\r\n    R.hsb = cacher(function (h, s, b) {\r\n        return R.hsb2rgb(h, s, b).hex;\r\n    });\r\n    /*\\\r\n     * Raphael.hsl\r\n     [ method ]\r\n     **\r\n     * Converts HSL values to hex representation of the colour.\r\n     > Parameters\r\n     - h (number) hue\r\n     - s (number) saturation\r\n     - l (number) luminosity\r\n     = (string) hex representation of the colour.\r\n     \\*/\r\n    R.hsl = cacher(function (h, s, l) {\r\n        return R.hsl2rgb(h, s, l).hex;\r\n    });\r\n    /*\\\r\n     * Raphael.rgb\r\n     [ method ]\r\n     **\r\n     * Converts RGB values to hex representation of the colour.\r\n     > Parameters\r\n     - r (number) red\r\n     - g (number) green\r\n     - b (number) blue\r\n     = (string) hex representation of the colour.\r\n     \\*/\r\n    R.rgb = cacher(function (r, g, b) {\r\n        function round(x) { return (x + 0.5) | 0; }\r\n        return \"#\" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);\r\n    });\r\n    /*\\\r\n     * Raphael.getColor\r\n     [ method ]\r\n     **\r\n     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset\r\n     > Parameters\r\n     - value (number) #optional brightness, default is `0.75`\r\n     = (string) hex representation of the colour.\r\n     \\*/\r\n    R.getColor = function (value) {\r\n        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},\r\n            rgb = this.hsb2rgb(start.h, start.s, start.b);\r\n        start.h += .075;\r\n        if (start.h > 1) {\r\n            start.h = 0;\r\n            start.s -= .2;\r\n            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});\r\n        }\r\n        return rgb.hex;\r\n    };\r\n    /*\\\r\n     * Raphael.getColor.reset\r\n     [ method ]\r\n     **\r\n     * Resets spectrum position for @Raphael.getColor back to red.\r\n     \\*/\r\n    R.getColor.reset = function () {\r\n        delete this.start;\r\n    };\r\n\r\n    // http://schepers.cc/getting-to-the-point\r\n    function catmullRom2bezier(crp, z) {\r\n        var d = [];\r\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\r\n            var p = [\r\n                {x: +crp[i - 2], y: +crp[i - 1]},\r\n                {x: +crp[i],     y: +crp[i + 1]},\r\n                {x: +crp[i + 2], y: +crp[i + 3]},\r\n                {x: +crp[i + 4], y: +crp[i + 5]}\r\n            ];\r\n            if (z) {\r\n                if (!i) {\r\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\r\n                } else if (iLen - 4 == i) {\r\n                    p[3] = {x: +crp[0], y: +crp[1]};\r\n                } else if (iLen - 2 == i) {\r\n                    p[2] = {x: +crp[0], y: +crp[1]};\r\n                    p[3] = {x: +crp[2], y: +crp[3]};\r\n                }\r\n            } else {\r\n                if (iLen - 4 == i) {\r\n                    p[3] = p[2];\r\n                } else if (!i) {\r\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\r\n                }\r\n            }\r\n            d.push([\"C\",\r\n                (-p[0].x + 6 * p[1].x + p[2].x) / 6,\r\n                (-p[0].y + 6 * p[1].y + p[2].y) / 6,\r\n                (p[1].x + 6 * p[2].x - p[3].x) / 6,\r\n                (p[1].y + 6*p[2].y - p[3].y) / 6,\r\n                p[2].x,\r\n                p[2].y\r\n            ]);\r\n        }\r\n\r\n        return d;\r\n    }\r\n    /*\\\r\n     * Raphael.parsePathString\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Parses given path string into an array of arrays of path segments.\r\n     > Parameters\r\n     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)\r\n     = (array) array of segments.\r\n     \\*/\r\n    R.parsePathString = function (pathString) {\r\n        if (!pathString) {\r\n            return null;\r\n        }\r\n        var pth = paths(pathString);\r\n        if (pth.arr) {\r\n            return pathClone(pth.arr);\r\n        }\r\n\r\n        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},\r\n            data = [];\r\n        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption\r\n            data = pathClone(pathString);\r\n        }\r\n        if (!data.length) {\r\n            Str(pathString).replace(pathCommand, function (a, b, c) {\r\n                var params = [],\r\n                    name = b.toLowerCase();\r\n                c.replace(pathValues, function (a, b) {\r\n                    b && params.push(+b);\r\n                });\r\n                if (name == \"m\" && params.length > 2) {\r\n                    data.push([b][concat](params.splice(0, 2)));\r\n                    name = \"l\";\r\n                    b = b == \"m\" ? \"l\" : \"L\";\r\n                }\r\n                if (name == \"r\") {\r\n                    data.push([b][concat](params));\r\n                } else while (params.length >= paramCounts[name]) {\r\n                    data.push([b][concat](params.splice(0, paramCounts[name])));\r\n                    if (!paramCounts[name]) {\r\n                        break;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        data.toString = R._path2string;\r\n        pth.arr = pathClone(data);\r\n        return data;\r\n    };\r\n    /*\\\r\n     * Raphael.parseTransformString\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Parses given path string into an array of transformations.\r\n     > Parameters\r\n     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)\r\n     = (array) array of transformations.\r\n     \\*/\r\n    R.parseTransformString = cacher(function (TString) {\r\n        if (!TString) {\r\n            return null;\r\n        }\r\n        var paramCounts = {r: 3, s: 4, t: 2, m: 6},\r\n            data = [];\r\n        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption\r\n            data = pathClone(TString);\r\n        }\r\n        if (!data.length) {\r\n            Str(TString).replace(tCommand, function (a, b, c) {\r\n                var params = [],\r\n                    name = lowerCase.call(b);\r\n                c.replace(pathValues, function (a, b) {\r\n                    b && params.push(+b);\r\n                });\r\n                data.push([b][concat](params));\r\n            });\r\n        }\r\n        data.toString = R._path2string;\r\n        return data;\r\n    });\r\n    // PATHS\r\n    var paths = function (ps) {\r\n        var p = paths.ps = paths.ps || {};\r\n        if (p[ps]) {\r\n            p[ps].sleep = 100;\r\n        } else {\r\n            p[ps] = {\r\n                sleep: 100\r\n            };\r\n        }\r\n        setTimeout(function () {\r\n            for (var key in p) if (p[has](key) && key != ps) {\r\n                p[key].sleep--;\r\n                !p[key].sleep && delete p[key];\r\n            }\r\n        });\r\n        return p[ps];\r\n    };\r\n    /*\\\r\n     * Raphael.findDotsAtSegment\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Find dot coordinates on the given cubic bezier curve at the given t.\r\n     > Parameters\r\n     - p1x (number) x of the first point of the curve\r\n     - p1y (number) y of the first point of the curve\r\n     - c1x (number) x of the first anchor of the curve\r\n     - c1y (number) y of the first anchor of the curve\r\n     - c2x (number) x of the second anchor of the curve\r\n     - c2y (number) y of the second anchor of the curve\r\n     - p2x (number) x of the second point of the curve\r\n     - p2y (number) y of the second point of the curve\r\n     - t (number) position on the curve (0..1)\r\n     = (object) point information in format:\r\n     o {\r\n     o     x: (number) x coordinate of the point\r\n     o     y: (number) y coordinate of the point\r\n     o     m: {\r\n     o         x: (number) x coordinate of the left anchor\r\n     o         y: (number) y coordinate of the left anchor\r\n     o     }\r\n     o     n: {\r\n     o         x: (number) x coordinate of the right anchor\r\n     o         y: (number) y coordinate of the right anchor\r\n     o     }\r\n     o     start: {\r\n     o         x: (number) x coordinate of the start of the curve\r\n     o         y: (number) y coordinate of the start of the curve\r\n     o     }\r\n     o     end: {\r\n     o         x: (number) x coordinate of the end of the curve\r\n     o         y: (number) y coordinate of the end of the curve\r\n     o     }\r\n     o     alpha: (number) angle of the curve derivative at the point\r\n     o }\r\n     \\*/\r\n    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\r\n        var t1 = 1 - t,\r\n            t13 = pow(t1, 3),\r\n            t12 = pow(t1, 2),\r\n            t2 = t * t,\r\n            t3 = t2 * t,\r\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\r\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\r\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\r\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\r\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\r\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\r\n            ax = t1 * p1x + t * c1x,\r\n            ay = t1 * p1y + t * c1y,\r\n            cx = t1 * c2x + t * p2x,\r\n            cy = t1 * c2y + t * p2y,\r\n            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);\r\n        (mx > nx || my < ny) && (alpha += 180);\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            m: {x: mx, y: my},\r\n            n: {x: nx, y: ny},\r\n            start: {x: ax, y: ay},\r\n            end: {x: cx, y: cy},\r\n            alpha: alpha\r\n        };\r\n    };\r\n    /*\\\r\n     * Raphael.bezierBBox\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Return bounding box of a given cubic bezier curve\r\n     > Parameters\r\n     - p1x (number) x of the first point of the curve\r\n     - p1y (number) y of the first point of the curve\r\n     - c1x (number) x of the first anchor of the curve\r\n     - c1y (number) y of the first anchor of the curve\r\n     - c2x (number) x of the second anchor of the curve\r\n     - c2y (number) y of the second anchor of the curve\r\n     - p2x (number) x of the second point of the curve\r\n     - p2y (number) y of the second point of the curve\r\n     * or\r\n     - bez (array) array of six points for bezier curve\r\n     = (object) point information in format:\r\n     o {\r\n     o     min: {\r\n     o         x: (number) x coordinate of the left point\r\n     o         y: (number) y coordinate of the top point\r\n     o     }\r\n     o     max: {\r\n     o         x: (number) x coordinate of the right point\r\n     o         y: (number) y coordinate of the bottom point\r\n     o     }\r\n     o }\r\n     \\*/\r\n    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n        if (!R.is(p1x, \"array\")) {\r\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\r\n        }\r\n        var bbox = curveDim.apply(null, p1x);\r\n        return {\r\n            x: bbox.min.x,\r\n            y: bbox.min.y,\r\n            x2: bbox.max.x,\r\n            y2: bbox.max.y,\r\n            width: bbox.max.x - bbox.min.x,\r\n            height: bbox.max.y - bbox.min.y\r\n        };\r\n    };\r\n    /*\\\r\n     * Raphael.isPointInsideBBox\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns `true` if given point is inside bounding boxes.\r\n     > Parameters\r\n     - bbox (string) bounding box\r\n     - x (string) x coordinate of the point\r\n     - y (string) y coordinate of the point\r\n     = (boolean) `true` if point inside\r\n     \\*/\r\n    R.isPointInsideBBox = function (bbox, x, y) {\r\n        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;\r\n    };\r\n    /*\\\r\n     * Raphael.isBBoxIntersect\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns `true` if two bounding boxes intersect\r\n     > Parameters\r\n     - bbox1 (string) first bounding box\r\n     - bbox2 (string) second bounding box\r\n     = (boolean) `true` if they intersect\r\n     \\*/\r\n    R.isBBoxIntersect = function (bbox1, bbox2) {\r\n        var i = R.isPointInsideBBox;\r\n        return i(bbox2, bbox1.x, bbox1.y)\r\n            || i(bbox2, bbox1.x2, bbox1.y)\r\n            || i(bbox2, bbox1.x, bbox1.y2)\r\n            || i(bbox2, bbox1.x2, bbox1.y2)\r\n            || i(bbox1, bbox2.x, bbox2.y)\r\n            || i(bbox1, bbox2.x2, bbox2.y)\r\n            || i(bbox1, bbox2.x, bbox2.y2)\r\n            || i(bbox1, bbox2.x2, bbox2.y2)\r\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\r\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\r\n    };\r\n    function base3(t, p1, p2, p3, p4) {\r\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\r\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\r\n        return t * t2 - 3 * p1 + 3 * p2;\r\n    }\r\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\r\n        if (z == null) {\r\n            z = 1;\r\n        }\r\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\r\n        var z2 = z / 2,\r\n            n = 12,\r\n            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],\r\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\r\n            sum = 0;\r\n        for (var i = 0; i < n; i++) {\r\n            var ct = z2 * Tvalues[i] + z2,\r\n                xbase = base3(ct, x1, x2, x3, x4),\r\n                ybase = base3(ct, y1, y2, y3, y4),\r\n                comb = xbase * xbase + ybase * ybase;\r\n            sum += Cvalues[i] * math.sqrt(comb);\r\n        }\r\n        return z2 * sum;\r\n    }\r\n    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\r\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\r\n            return;\r\n        }\r\n        var t = 1,\r\n            step = t / 2,\r\n            t2 = t - step,\r\n            l,\r\n            e = .01;\r\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\r\n        while (abs(l - ll) > e) {\r\n            step /= 2;\r\n            t2 += (l < ll ? 1 : -1) * step;\r\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\r\n        }\r\n        return t2;\r\n    }\r\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\r\n        if (\r\n            mmax(x1, x2) < mmin(x3, x4) ||\r\n            mmin(x1, x2) > mmax(x3, x4) ||\r\n            mmax(y1, y2) < mmin(y3, y4) ||\r\n            mmin(y1, y2) > mmax(y3, y4)\r\n        ) {\r\n            return;\r\n        }\r\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\r\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\r\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n        if (!denominator) {\r\n            return;\r\n        }\r\n        var px = nx / denominator,\r\n            py = ny / denominator,\r\n            px2 = +px.toFixed(2),\r\n            py2 = +py.toFixed(2);\r\n        if (\r\n            px2 < +mmin(x1, x2).toFixed(2) ||\r\n            px2 > +mmax(x1, x2).toFixed(2) ||\r\n            px2 < +mmin(x3, x4).toFixed(2) ||\r\n            px2 > +mmax(x3, x4).toFixed(2) ||\r\n            py2 < +mmin(y1, y2).toFixed(2) ||\r\n            py2 > +mmax(y1, y2).toFixed(2) ||\r\n            py2 < +mmin(y3, y4).toFixed(2) ||\r\n            py2 > +mmax(y3, y4).toFixed(2)\r\n        ) {\r\n            return;\r\n        }\r\n        return {x: px, y: py};\r\n    }\r\n    function inter(bez1, bez2) {\r\n        return interHelper(bez1, bez2);\r\n    }\r\n    function interCount(bez1, bez2) {\r\n        return interHelper(bez1, bez2, 1);\r\n    }\r\n    function interHelper(bez1, bez2, justCount) {\r\n        var bbox1 = R.bezierBBox(bez1),\r\n            bbox2 = R.bezierBBox(bez2);\r\n        if (!R.isBBoxIntersect(bbox1, bbox2)) {\r\n            return justCount ? 0 : [];\r\n        }\r\n        var l1 = bezlen.apply(0, bez1),\r\n            l2 = bezlen.apply(0, bez2),\r\n            n1 = mmax(~~(l1 / 5), 1),\r\n            n2 = mmax(~~(l2 / 5), 1),\r\n            dots1 = [],\r\n            dots2 = [],\r\n            xy = {},\r\n            res = justCount ? 0 : [];\r\n        for (var i = 0; i < n1 + 1; i++) {\r\n            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));\r\n            dots1.push({x: p.x, y: p.y, t: i / n1});\r\n        }\r\n        for (i = 0; i < n2 + 1; i++) {\r\n            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));\r\n            dots2.push({x: p.x, y: p.y, t: i / n2});\r\n        }\r\n        for (i = 0; i < n1; i++) {\r\n            for (var j = 0; j < n2; j++) {\r\n                var di = dots1[i],\r\n                    di1 = dots1[i + 1],\r\n                    dj = dots2[j],\r\n                    dj1 = dots2[j + 1],\r\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\r\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\r\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\r\n                if (is) {\r\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\r\n                        continue;\r\n                    }\r\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\r\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\r\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\r\n                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {\r\n                        if (justCount) {\r\n                            res++;\r\n                        } else {\r\n                            res.push({\r\n                                x: is.x,\r\n                                y: is.y,\r\n                                t1: mmin(t1, 1),\r\n                                t2: mmin(t2, 1)\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    /*\\\r\n     * Raphael.pathIntersection\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Finds intersections of two paths\r\n     > Parameters\r\n     - path1 (string) path string\r\n     - path2 (string) path string\r\n     = (array) dots of intersection\r\n     o [\r\n     o     {\r\n     o         x: (number) x coordinate of the point\r\n     o         y: (number) y coordinate of the point\r\n     o         t1: (number) t value for segment of path1\r\n     o         t2: (number) t value for segment of path2\r\n     o         segment1: (number) order number for segment of path1\r\n     o         segment2: (number) order number for segment of path2\r\n     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1\r\n     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2\r\n     o     }\r\n     o ]\r\n     \\*/\r\n    R.pathIntersection = function (path1, path2) {\r\n        return interPathHelper(path1, path2);\r\n    };\r\n    R.pathIntersectionNumber = function (path1, path2) {\r\n        return interPathHelper(path1, path2, 1);\r\n    };\r\n    function interPathHelper(path1, path2, justCount) {\r\n        path1 = R._path2curve(path1);\r\n        path2 = R._path2curve(path2);\r\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\r\n            res = justCount ? 0 : [];\r\n        for (var i = 0, ii = path1.length; i < ii; i++) {\r\n            var pi = path1[i];\r\n            if (pi[0] == \"M\") {\r\n                x1 = x1m = pi[1];\r\n                y1 = y1m = pi[2];\r\n            } else {\r\n                if (pi[0] == \"C\") {\r\n                    bez1 = [x1, y1].concat(pi.slice(1));\r\n                    x1 = bez1[6];\r\n                    y1 = bez1[7];\r\n                } else {\r\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\r\n                    x1 = x1m;\r\n                    y1 = y1m;\r\n                }\r\n                for (var j = 0, jj = path2.length; j < jj; j++) {\r\n                    var pj = path2[j];\r\n                    if (pj[0] == \"M\") {\r\n                        x2 = x2m = pj[1];\r\n                        y2 = y2m = pj[2];\r\n                    } else {\r\n                        if (pj[0] == \"C\") {\r\n                            bez2 = [x2, y2].concat(pj.slice(1));\r\n                            x2 = bez2[6];\r\n                            y2 = bez2[7];\r\n                        } else {\r\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\r\n                            x2 = x2m;\r\n                            y2 = y2m;\r\n                        }\r\n                        var intr = interHelper(bez1, bez2, justCount);\r\n                        if (justCount) {\r\n                            res += intr;\r\n                        } else {\r\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\r\n                                intr[k].segment1 = i;\r\n                                intr[k].segment2 = j;\r\n                                intr[k].bez1 = bez1;\r\n                                intr[k].bez2 = bez2;\r\n                            }\r\n                            res = res.concat(intr);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    /*\\\r\n     * Raphael.isPointInsidePath\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns `true` if given point is inside a given closed path.\r\n     > Parameters\r\n     - path (string) path string\r\n     - x (number) x of the point\r\n     - y (number) y of the point\r\n     = (boolean) true, if point is inside the path\r\n     \\*/\r\n    R.isPointInsidePath = function (path, x, y) {\r\n        var bbox = R.pathBBox(path);\r\n        return R.isPointInsideBBox(bbox, x, y) &&\r\n            interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\r\n    };\r\n    R._removedFactory = function (methodname) {\r\n        return function () {\r\n            eve(\"raphael.log\", null, \"Rapha\\xebl: you are calling to method \\u201c\" + methodname + \"\\u201d of removed object\", methodname);\r\n        };\r\n    };\r\n    /*\\\r\n     * Raphael.pathBBox\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Return bounding box of a given path\r\n     > Parameters\r\n     - path (string) path string\r\n     = (object) bounding box\r\n     o {\r\n     o     x: (number) x coordinate of the left top point of the box\r\n     o     y: (number) y coordinate of the left top point of the box\r\n     o     x2: (number) x coordinate of the right bottom point of the box\r\n     o     y2: (number) y coordinate of the right bottom point of the box\r\n     o     width: (number) width of the box\r\n     o     height: (number) height of the box\r\n     o     cx: (number) x coordinate of the center of the box\r\n     o     cy: (number) y coordinate of the center of the box\r\n     o }\r\n     \\*/\r\n    var pathDimensions = R.pathBBox = function (path) {\r\n            var pth = paths(path);\r\n            if (pth.bbox) {\r\n                return clone(pth.bbox);\r\n            }\r\n            if (!path) {\r\n                return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};\r\n            }\r\n            path = path2curve(path);\r\n            var x = 0,\r\n                y = 0,\r\n                X = [],\r\n                Y = [],\r\n                p;\r\n            for (var i = 0, ii = path.length; i < ii; i++) {\r\n                p = path[i];\r\n                if (p[0] == \"M\") {\r\n                    x = p[1];\r\n                    y = p[2];\r\n                    X.push(x);\r\n                    Y.push(y);\r\n                } else {\r\n                    var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\r\n                    X = X[concat](dim.min.x, dim.max.x);\r\n                    Y = Y[concat](dim.min.y, dim.max.y);\r\n                    x = p[5];\r\n                    y = p[6];\r\n                }\r\n            }\r\n            var xmin = mmin[apply](0, X),\r\n                ymin = mmin[apply](0, Y),\r\n                xmax = mmax[apply](0, X),\r\n                ymax = mmax[apply](0, Y),\r\n                width = xmax - xmin,\r\n                height = ymax - ymin,\r\n                bb = {\r\n                    x: xmin,\r\n                    y: ymin,\r\n                    x2: xmax,\r\n                    y2: ymax,\r\n                    width: width,\r\n                    height: height,\r\n                    cx: xmin + width / 2,\r\n                    cy: ymin + height / 2\r\n                };\r\n            pth.bbox = clone(bb);\r\n            return bb;\r\n        },\r\n        pathClone = function (pathArray) {\r\n            var res = clone(pathArray);\r\n            res.toString = R._path2string;\r\n            return res;\r\n        },\r\n        pathToRelative = R._pathToRelative = function (pathArray) {\r\n            var pth = paths(pathArray);\r\n            if (pth.rel) {\r\n                return pathClone(pth.rel);\r\n            }\r\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\r\n                pathArray = R.parsePathString(pathArray);\r\n            }\r\n            var res = [],\r\n                x = 0,\r\n                y = 0,\r\n                mx = 0,\r\n                my = 0,\r\n                start = 0;\r\n            if (pathArray[0][0] == \"M\") {\r\n                x = pathArray[0][1];\r\n                y = pathArray[0][2];\r\n                mx = x;\r\n                my = y;\r\n                start++;\r\n                res.push([\"M\", x, y]);\r\n            }\r\n            for (var i = start, ii = pathArray.length; i < ii; i++) {\r\n                var r = res[i] = [],\r\n                    pa = pathArray[i];\r\n                if (pa[0] != lowerCase.call(pa[0])) {\r\n                    r[0] = lowerCase.call(pa[0]);\r\n                    switch (r[0]) {\r\n                        case \"a\":\r\n                            r[1] = pa[1];\r\n                            r[2] = pa[2];\r\n                            r[3] = pa[3];\r\n                            r[4] = pa[4];\r\n                            r[5] = pa[5];\r\n                            r[6] = +(pa[6] - x).toFixed(3);\r\n                            r[7] = +(pa[7] - y).toFixed(3);\r\n                            break;\r\n                        case \"v\":\r\n                            r[1] = +(pa[1] - y).toFixed(3);\r\n                            break;\r\n                        case \"m\":\r\n                            mx = pa[1];\r\n                            my = pa[2];\r\n                        default:\r\n                            for (var j = 1, jj = pa.length; j < jj; j++) {\r\n                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);\r\n                            }\r\n                    }\r\n                } else {\r\n                    r = res[i] = [];\r\n                    if (pa[0] == \"m\") {\r\n                        mx = pa[1] + x;\r\n                        my = pa[2] + y;\r\n                    }\r\n                    for (var k = 0, kk = pa.length; k < kk; k++) {\r\n                        res[i][k] = pa[k];\r\n                    }\r\n                }\r\n                var len = res[i].length;\r\n                switch (res[i][0]) {\r\n                    case \"z\":\r\n                        x = mx;\r\n                        y = my;\r\n                        break;\r\n                    case \"h\":\r\n                        x += +res[i][len - 1];\r\n                        break;\r\n                    case \"v\":\r\n                        y += +res[i][len - 1];\r\n                        break;\r\n                    default:\r\n                        x += +res[i][len - 2];\r\n                        y += +res[i][len - 1];\r\n                }\r\n            }\r\n            res.toString = R._path2string;\r\n            pth.rel = pathClone(res);\r\n            return res;\r\n        },\r\n        pathToAbsolute = R._pathToAbsolute = function (pathArray) {\r\n            var pth = paths(pathArray);\r\n            if (pth.abs) {\r\n                return pathClone(pth.abs);\r\n            }\r\n            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption\r\n                pathArray = R.parsePathString(pathArray);\r\n            }\r\n            if (!pathArray || !pathArray.length) {\r\n                return [[\"M\", 0, 0]];\r\n            }\r\n            var res = [],\r\n                x = 0,\r\n                y = 0,\r\n                mx = 0,\r\n                my = 0,\r\n                start = 0;\r\n            if (pathArray[0][0] == \"M\") {\r\n                x = +pathArray[0][1];\r\n                y = +pathArray[0][2];\r\n                mx = x;\r\n                my = y;\r\n                start++;\r\n                res[0] = [\"M\", x, y];\r\n            }\r\n            var crz = pathArray.length == 3 && pathArray[0][0] == \"M\" && pathArray[1][0].toUpperCase() == \"R\" && pathArray[2][0].toUpperCase() == \"Z\";\r\n            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\r\n                res.push(r = []);\r\n                pa = pathArray[i];\r\n                if (pa[0] != upperCase.call(pa[0])) {\r\n                    r[0] = upperCase.call(pa[0]);\r\n                    switch (r[0]) {\r\n                        case \"A\":\r\n                            r[1] = pa[1];\r\n                            r[2] = pa[2];\r\n                            r[3] = pa[3];\r\n                            r[4] = pa[4];\r\n                            r[5] = pa[5];\r\n                            r[6] = +(pa[6] + x);\r\n                            r[7] = +(pa[7] + y);\r\n                            break;\r\n                        case \"V\":\r\n                            r[1] = +pa[1] + y;\r\n                            break;\r\n                        case \"H\":\r\n                            r[1] = +pa[1] + x;\r\n                            break;\r\n                        case \"R\":\r\n                            var dots = [x, y][concat](pa.slice(1));\r\n                            for (var j = 2, jj = dots.length; j < jj; j++) {\r\n                                dots[j] = +dots[j] + x;\r\n                                dots[++j] = +dots[j] + y;\r\n                            }\r\n                            res.pop();\r\n                            res = res[concat](catmullRom2bezier(dots, crz));\r\n                            break;\r\n                        case \"M\":\r\n                            mx = +pa[1] + x;\r\n                            my = +pa[2] + y;\r\n                        default:\r\n                            for (j = 1, jj = pa.length; j < jj; j++) {\r\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\r\n                            }\r\n                    }\r\n                } else if (pa[0] == \"R\") {\r\n                    dots = [x, y][concat](pa.slice(1));\r\n                    res.pop();\r\n                    res = res[concat](catmullRom2bezier(dots, crz));\r\n                    r = [\"R\"][concat](pa.slice(-2));\r\n                } else {\r\n                    for (var k = 0, kk = pa.length; k < kk; k++) {\r\n                        r[k] = pa[k];\r\n                    }\r\n                }\r\n                switch (r[0]) {\r\n                    case \"Z\":\r\n                        x = mx;\r\n                        y = my;\r\n                        break;\r\n                    case \"H\":\r\n                        x = r[1];\r\n                        break;\r\n                    case \"V\":\r\n                        y = r[1];\r\n                        break;\r\n                    case \"M\":\r\n                        mx = r[r.length - 2];\r\n                        my = r[r.length - 1];\r\n                    default:\r\n                        x = r[r.length - 2];\r\n                        y = r[r.length - 1];\r\n                }\r\n            }\r\n            res.toString = R._path2string;\r\n            pth.abs = pathClone(res);\r\n            return res;\r\n        },\r\n        l2c = function (x1, y1, x2, y2) {\r\n            return [x1, y1, x2, y2, x2, y2];\r\n        },\r\n        q2c = function (x1, y1, ax, ay, x2, y2) {\r\n            var _13 = 1 / 3,\r\n                _23 = 2 / 3;\r\n            return [\r\n                _13 * x1 + _23 * ax,\r\n                _13 * y1 + _23 * ay,\r\n                _13 * x2 + _23 * ax,\r\n                _13 * y2 + _23 * ay,\r\n                x2,\r\n                y2\r\n            ];\r\n        },\r\n        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\r\n            // for more information of where this math came from visit:\r\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n            var _120 = PI * 120 / 180,\r\n                rad = PI / 180 * (+angle || 0),\r\n                res = [],\r\n                xy,\r\n                rotate = cacher(function (x, y, rad) {\r\n                    var X = x * math.cos(rad) - y * math.sin(rad),\r\n                        Y = x * math.sin(rad) + y * math.cos(rad);\r\n                    return {x: X, y: Y};\r\n                });\r\n            if (!recursive) {\r\n                xy = rotate(x1, y1, -rad);\r\n                x1 = xy.x;\r\n                y1 = xy.y;\r\n                xy = rotate(x2, y2, -rad);\r\n                x2 = xy.x;\r\n                y2 = xy.y;\r\n                var cos = math.cos(PI / 180 * angle),\r\n                    sin = math.sin(PI / 180 * angle),\r\n                    x = (x1 - x2) / 2,\r\n                    y = (y1 - y2) / 2;\r\n                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\r\n                if (h > 1) {\r\n                    h = math.sqrt(h);\r\n                    rx = h * rx;\r\n                    ry = h * ry;\r\n                }\r\n                var rx2 = rx * rx,\r\n                    ry2 = ry * ry,\r\n                    k = (large_arc_flag == sweep_flag ? -1 : 1) *\r\n                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\r\n                    cx = k * rx * y / ry + (x1 + x2) / 2,\r\n                    cy = k * -ry * x / rx + (y1 + y2) / 2,\r\n                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\r\n                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));\r\n\r\n                f1 = x1 < cx ? PI - f1 : f1;\r\n                f2 = x2 < cx ? PI - f2 : f2;\r\n                f1 < 0 && (f1 = PI * 2 + f1);\r\n                f2 < 0 && (f2 = PI * 2 + f2);\r\n                if (sweep_flag && f1 > f2) {\r\n                    f1 = f1 - PI * 2;\r\n                }\r\n                if (!sweep_flag && f2 > f1) {\r\n                    f2 = f2 - PI * 2;\r\n                }\r\n            } else {\r\n                f1 = recursive[0];\r\n                f2 = recursive[1];\r\n                cx = recursive[2];\r\n                cy = recursive[3];\r\n            }\r\n            var df = f2 - f1;\r\n            if (abs(df) > _120) {\r\n                var f2old = f2,\r\n                    x2old = x2,\r\n                    y2old = y2;\r\n                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\r\n                x2 = cx + rx * math.cos(f2);\r\n                y2 = cy + ry * math.sin(f2);\r\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\r\n            }\r\n            df = f2 - f1;\r\n            var c1 = math.cos(f1),\r\n                s1 = math.sin(f1),\r\n                c2 = math.cos(f2),\r\n                s2 = math.sin(f2),\r\n                t = math.tan(df / 4),\r\n                hx = 4 / 3 * rx * t,\r\n                hy = 4 / 3 * ry * t,\r\n                m1 = [x1, y1],\r\n                m2 = [x1 + hx * s1, y1 - hy * c1],\r\n                m3 = [x2 + hx * s2, y2 - hy * c2],\r\n                m4 = [x2, y2];\r\n            m2[0] = 2 * m1[0] - m2[0];\r\n            m2[1] = 2 * m1[1] - m2[1];\r\n            if (recursive) {\r\n                return [m2, m3, m4][concat](res);\r\n            } else {\r\n                res = [m2, m3, m4][concat](res).join()[split](\",\");\r\n                var newres = [];\r\n                for (var i = 0, ii = res.length; i < ii; i++) {\r\n                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\r\n                }\r\n                return newres;\r\n            }\r\n        },\r\n        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\r\n            var t1 = 1 - t;\r\n            return {\r\n                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\r\n                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\r\n            };\r\n        },\r\n        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),\r\n                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),\r\n                c = p1x - c1x,\r\n                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,\r\n                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,\r\n                y = [p1y, p2y],\r\n                x = [p1x, p2x],\r\n                dot;\r\n            abs(t1) > \"1e12\" && (t1 = .5);\r\n            abs(t2) > \"1e12\" && (t2 = .5);\r\n            if (t1 > 0 && t1 < 1) {\r\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\r\n                x.push(dot.x);\r\n                y.push(dot.y);\r\n            }\r\n            if (t2 > 0 && t2 < 1) {\r\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\r\n                x.push(dot.x);\r\n                y.push(dot.y);\r\n            }\r\n            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);\r\n            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);\r\n            c = p1y - c1y;\r\n            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n            abs(t1) > \"1e12\" && (t1 = .5);\r\n            abs(t2) > \"1e12\" && (t2 = .5);\r\n            if (t1 > 0 && t1 < 1) {\r\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);\r\n                x.push(dot.x);\r\n                y.push(dot.y);\r\n            }\r\n            if (t2 > 0 && t2 < 1) {\r\n                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);\r\n                x.push(dot.x);\r\n                y.push(dot.y);\r\n            }\r\n            return {\r\n                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},\r\n                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}\r\n            };\r\n        }),\r\n        path2curve = R._path2curve = cacher(function (path, path2) {\r\n            var pth = !path2 && paths(path);\r\n            if (!path2 && pth.curve) {\r\n                return pathClone(pth.curve);\r\n            }\r\n            var p = pathToAbsolute(path),\r\n                p2 = path2 && pathToAbsolute(path2),\r\n                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\r\n                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\r\n                processPath = function (path, d, pcom) {\r\n                    var nx, ny, tq = {T:1, Q:1};\r\n                    if (!path) {\r\n                        return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\r\n                    }\r\n                    !(path[0] in tq) && (d.qx = d.qy = null);\r\n                    switch (path[0]) {\r\n                        case \"M\":\r\n                            d.X = path[1];\r\n                            d.Y = path[2];\r\n                            break;\r\n                        case \"A\":\r\n                            path = [\"C\"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));\r\n                            break;\r\n                        case \"S\":\r\n                            if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\r\n                                nx = d.x * 2 - d.bx;          // And reflect the previous\r\n                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.\r\n                            }\r\n                            else {                            // or some else or nothing\r\n                                nx = d.x;\r\n                                ny = d.y;\r\n                            }\r\n                            path = [\"C\", nx, ny][concat](path.slice(1));\r\n                            break;\r\n                        case \"T\":\r\n                            if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\r\n                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar\r\n                                d.qy = d.y * 2 - d.qy;        // to case \"S\".\r\n                            }\r\n                            else {                            // or something else or nothing\r\n                                d.qx = d.x;\r\n                                d.qy = d.y;\r\n                            }\r\n                            path = [\"C\"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\r\n                            break;\r\n                        case \"Q\":\r\n                            d.qx = path[1];\r\n                            d.qy = path[2];\r\n                            path = [\"C\"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\r\n                            break;\r\n                        case \"L\":\r\n                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], path[2]));\r\n                            break;\r\n                        case \"H\":\r\n                            path = [\"C\"][concat](l2c(d.x, d.y, path[1], d.y));\r\n                            break;\r\n                        case \"V\":\r\n                            path = [\"C\"][concat](l2c(d.x, d.y, d.x, path[1]));\r\n                            break;\r\n                        case \"Z\":\r\n                            path = [\"C\"][concat](l2c(d.x, d.y, d.X, d.Y));\r\n                            break;\r\n                    }\r\n                    return path;\r\n                },\r\n                fixArc = function (pp, i) {\r\n                    if (pp[i].length > 7) {\r\n                        pp[i].shift();\r\n                        var pi = pp[i];\r\n                        while (pi.length) {\r\n                            pcoms1[i]=\"A\"; // if created multiple C:s, their original seg is saved\r\n                            p2 && (pcoms2[i]=\"A\"); // the same as above\r\n                            pp.splice(i++, 0, [\"C\"][concat](pi.splice(0, 6)));\r\n                        }\r\n                        pp.splice(i, 1);\r\n                        ii = mmax(p.length, p2 && p2.length || 0);\r\n                    }\r\n                },\r\n                fixM = function (path1, path2, a1, a2, i) {\r\n                    if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\r\n                        path2.splice(i, 0, [\"M\", a2.x, a2.y]);\r\n                        a1.bx = 0;\r\n                        a1.by = 0;\r\n                        a1.x = path1[i][1];\r\n                        a1.y = path1[i][2];\r\n                        ii = mmax(p.length, p2 && p2.length || 0);\r\n                    }\r\n                },\r\n                pcoms1 = [], // path commands of original path p\r\n                pcoms2 = [], // path commands of original path p2\r\n                pfirst = \"\", // temporary holder for original path command\r\n                pcom = \"\"; // holder for previous path command of original path\r\n            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\r\n                p[i] && (pfirst = p[i][0]); // save current path command\r\n\r\n                if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\r\n                {\r\n                    pcoms1[i] = pfirst; // Save current path command\r\n                    i && ( pcom = pcoms1[i-1]); // Get previous path command pcom\r\n                }\r\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\r\n\r\n                if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\r\n                // which may produce multiple C:s\r\n                // so we have to make sure that C is also C in original path\r\n\r\n                fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\r\n\r\n                if (p2) { // the same procedures is done to p2\r\n                    p2[i] && (pfirst = p2[i][0]);\r\n                    if (pfirst != \"C\")\r\n                    {\r\n                        pcoms2[i] = pfirst;\r\n                        i && (pcom = pcoms2[i-1]);\r\n                    }\r\n                    p2[i] = processPath(p2[i], attrs2, pcom);\r\n\r\n                    if (pcoms2[i]!=\"A\" && pfirst==\"C\") pcoms2[i]=\"C\";\r\n\r\n                    fixArc(p2, i);\r\n                }\r\n                fixM(p, p2, attrs, attrs2, i);\r\n                fixM(p2, p, attrs2, attrs, i);\r\n                var seg = p[i],\r\n                    seg2 = p2 && p2[i],\r\n                    seglen = seg.length,\r\n                    seg2len = p2 && seg2.length;\r\n                attrs.x = seg[seglen - 2];\r\n                attrs.y = seg[seglen - 1];\r\n                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\r\n                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\r\n                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\r\n                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\r\n                attrs2.x = p2 && seg2[seg2len - 2];\r\n                attrs2.y = p2 && seg2[seg2len - 1];\r\n            }\r\n            if (!p2) {\r\n                pth.curve = pathClone(p);\r\n            }\r\n            return p2 ? [p, p2] : p;\r\n        }, null, pathClone),\r\n        parseDots = R._parseDots = cacher(function (gradient) {\r\n            var dots = [];\r\n            for (var i = 0, ii = gradient.length; i < ii; i++) {\r\n                var dot = {},\r\n                    par = gradient[i].match(/^([^:]*):?([\\d\\.]*)/);\r\n                dot.color = R.getRGB(par[1]);\r\n                if (dot.color.error) {\r\n                    return null;\r\n                }\r\n                dot.opacity = dot.color.opacity;\r\n                dot.color = dot.color.hex;\r\n                par[2] && (dot.offset = par[2] + \"%\");\r\n                dots.push(dot);\r\n            }\r\n            for (i = 1, ii = dots.length - 1; i < ii; i++) {\r\n                if (!dots[i].offset) {\r\n                    var start = toFloat(dots[i - 1].offset || 0),\r\n                        end = 0;\r\n                    for (var j = i + 1; j < ii; j++) {\r\n                        if (dots[j].offset) {\r\n                            end = dots[j].offset;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!end) {\r\n                        end = 100;\r\n                        j = ii;\r\n                    }\r\n                    end = toFloat(end);\r\n                    var d = (end - start) / (j - i + 1);\r\n                    for (; i < j; i++) {\r\n                        start += d;\r\n                        dots[i].offset = start + \"%\";\r\n                    }\r\n                }\r\n            }\r\n            return dots;\r\n        }),\r\n        tear = R._tear = function (el, paper) {\r\n            el == paper.top && (paper.top = el.prev);\r\n            el == paper.bottom && (paper.bottom = el.next);\r\n            el.next && (el.next.prev = el.prev);\r\n            el.prev && (el.prev.next = el.next);\r\n        },\r\n        tofront = R._tofront = function (el, paper) {\r\n            if (paper.top === el) {\r\n                return;\r\n            }\r\n            tear(el, paper);\r\n            el.next = null;\r\n            el.prev = paper.top;\r\n            paper.top.next = el;\r\n            paper.top = el;\r\n        },\r\n        toback = R._toback = function (el, paper) {\r\n            if (paper.bottom === el) {\r\n                return;\r\n            }\r\n            tear(el, paper);\r\n            el.next = paper.bottom;\r\n            el.prev = null;\r\n            paper.bottom.prev = el;\r\n            paper.bottom = el;\r\n        },\r\n        insertafter = R._insertafter = function (el, el2, paper) {\r\n            tear(el, paper);\r\n            el2 == paper.top && (paper.top = el);\r\n            el2.next && (el2.next.prev = el);\r\n            el.next = el2.next;\r\n            el.prev = el2;\r\n            el2.next = el;\r\n        },\r\n        insertbefore = R._insertbefore = function (el, el2, paper) {\r\n            tear(el, paper);\r\n            el2 == paper.bottom && (paper.bottom = el);\r\n            el2.prev && (el2.prev.next = el);\r\n            el.prev = el2.prev;\r\n            el2.prev = el;\r\n            el.next = el2;\r\n        },\r\n    /*\\\r\n     * Raphael.toMatrix\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns matrix of transformations applied to a given path\r\n     > Parameters\r\n     - path (string) path string\r\n     - transform (string|array) transformation string\r\n     = (object) @Matrix\r\n     \\*/\r\n        toMatrix = R.toMatrix = function (path, transform) {\r\n            var bb = pathDimensions(path),\r\n                el = {\r\n                    _: {\r\n                        transform: E\r\n                    },\r\n                    getBBox: function () {\r\n                        return bb;\r\n                    }\r\n                };\r\n            extractTransform(el, transform);\r\n            return el.matrix;\r\n        },\r\n    /*\\\r\n     * Raphael.transformPath\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns path transformed by a given transformation\r\n     > Parameters\r\n     - path (string) path string\r\n     - transform (string|array) transformation string\r\n     = (string) path\r\n     \\*/\r\n        transformPath = R.transformPath = function (path, transform) {\r\n            return mapPath(path, toMatrix(path, transform));\r\n        },\r\n        extractTransform = R._extractTransform = function (el, tstr) {\r\n            if (tstr == null) {\r\n                return el._.transform;\r\n            }\r\n            tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || E);\r\n            var tdata = R.parseTransformString(tstr),\r\n                deg = 0,\r\n                dx = 0,\r\n                dy = 0,\r\n                sx = 1,\r\n                sy = 1,\r\n                _ = el._,\r\n                m = new Matrix;\r\n            _.transform = tdata || [];\r\n            if (tdata) {\r\n                for (var i = 0, ii = tdata.length; i < ii; i++) {\r\n                    var t = tdata[i],\r\n                        tlen = t.length,\r\n                        command = Str(t[0]).toLowerCase(),\r\n                        absolute = t[0] != command,\r\n                        inver = absolute ? m.invert() : 0,\r\n                        x1,\r\n                        y1,\r\n                        x2,\r\n                        y2,\r\n                        bb;\r\n                    if (command == \"t\" && tlen == 3) {\r\n                        if (absolute) {\r\n                            x1 = inver.x(0, 0);\r\n                            y1 = inver.y(0, 0);\r\n                            x2 = inver.x(t[1], t[2]);\r\n                            y2 = inver.y(t[1], t[2]);\r\n                            m.translate(x2 - x1, y2 - y1);\r\n                        } else {\r\n                            m.translate(t[1], t[2]);\r\n                        }\r\n                    } else if (command == \"r\") {\r\n                        if (tlen == 2) {\r\n                            bb = bb || el.getBBox(1);\r\n                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\r\n                            deg += t[1];\r\n                        } else if (tlen == 4) {\r\n                            if (absolute) {\r\n                                x2 = inver.x(t[2], t[3]);\r\n                                y2 = inver.y(t[2], t[3]);\r\n                                m.rotate(t[1], x2, y2);\r\n                            } else {\r\n                                m.rotate(t[1], t[2], t[3]);\r\n                            }\r\n                            deg += t[1];\r\n                        }\r\n                    } else if (command == \"s\") {\r\n                        if (tlen == 2 || tlen == 3) {\r\n                            bb = bb || el.getBBox(1);\r\n                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\r\n                            sx *= t[1];\r\n                            sy *= t[tlen - 1];\r\n                        } else if (tlen == 5) {\r\n                            if (absolute) {\r\n                                x2 = inver.x(t[3], t[4]);\r\n                                y2 = inver.y(t[3], t[4]);\r\n                                m.scale(t[1], t[2], x2, y2);\r\n                            } else {\r\n                                m.scale(t[1], t[2], t[3], t[4]);\r\n                            }\r\n                            sx *= t[1];\r\n                            sy *= t[2];\r\n                        }\r\n                    } else if (command == \"m\" && tlen == 7) {\r\n                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\r\n                    }\r\n                    _.dirtyT = 1;\r\n                    el.matrix = m;\r\n                }\r\n            }\r\n\r\n            /*\\\r\n             * Element.matrix\r\n             [ property (object) ]\r\n             **\r\n             * Keeps @Matrix object, which represents element transformation\r\n             \\*/\r\n            el.matrix = m;\r\n\r\n            _.sx = sx;\r\n            _.sy = sy;\r\n            _.deg = deg;\r\n            _.dx = dx = m.e;\r\n            _.dy = dy = m.f;\r\n\r\n            if (sx == 1 && sy == 1 && !deg && _.bbox) {\r\n                _.bbox.x += +dx;\r\n                _.bbox.y += +dy;\r\n            } else {\r\n                _.dirtyT = 1;\r\n            }\r\n        },\r\n        getEmpty = function (item) {\r\n            var l = item[0];\r\n            switch (l.toLowerCase()) {\r\n                case \"t\": return [l, 0, 0];\r\n                case \"m\": return [l, 1, 0, 0, 1, 0, 0];\r\n                case \"r\": if (item.length == 4) {\r\n                    return [l, 0, item[2], item[3]];\r\n                } else {\r\n                    return [l, 0];\r\n                }\r\n                case \"s\": if (item.length == 5) {\r\n                    return [l, 1, 1, item[3], item[4]];\r\n                } else if (item.length == 3) {\r\n                    return [l, 1, 1];\r\n                } else {\r\n                    return [l, 1];\r\n                }\r\n            }\r\n        },\r\n        equaliseTransform = R._equaliseTransform = function (t1, t2) {\r\n            t2 = Str(t2).replace(/\\.{3}|\\u2026/g, t1);\r\n            t1 = R.parseTransformString(t1) || [];\r\n            t2 = R.parseTransformString(t2) || [];\r\n            var maxlength = mmax(t1.length, t2.length),\r\n                from = [],\r\n                to = [],\r\n                i = 0, j, jj,\r\n                tt1, tt2;\r\n            for (; i < maxlength; i++) {\r\n                tt1 = t1[i] || getEmpty(t2[i]);\r\n                tt2 = t2[i] || getEmpty(tt1);\r\n                if ((tt1[0] != tt2[0]) ||\r\n                    (tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||\r\n                    (tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))\r\n                ) {\r\n                    return;\r\n                }\r\n                from[i] = [];\r\n                to[i] = [];\r\n                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {\r\n                    j in tt1 && (from[i][j] = tt1[j]);\r\n                    j in tt2 && (to[i][j] = tt2[j]);\r\n                }\r\n            }\r\n            return {\r\n                from: from,\r\n                to: to\r\n            };\r\n        };\r\n    R._getContainer = function (x, y, w, h) {\r\n        var container;\r\n        container = h == null && !R.is(x, \"object\") ? g.doc.getElementById(x) : x;\r\n        if (container == null) {\r\n            return;\r\n        }\r\n        if (container.tagName) {\r\n            if (y == null) {\r\n                return {\r\n                    container: container,\r\n                    width: container.style.pixelWidth || container.offsetWidth,\r\n                    height: container.style.pixelHeight || container.offsetHeight\r\n                };\r\n            } else {\r\n                return {\r\n                    container: container,\r\n                    width: y,\r\n                    height: w\r\n                };\r\n            }\r\n        }\r\n        return {\r\n            container: 1,\r\n            x: x,\r\n            y: y,\r\n            width: w,\r\n            height: h\r\n        };\r\n    };\r\n    /*\\\r\n     * Raphael.pathToRelative\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Converts path to relative form\r\n     > Parameters\r\n     - pathString (string|array) path string or array of segments\r\n     = (array) array of segments.\r\n     \\*/\r\n    R.pathToRelative = pathToRelative;\r\n    R._engine = {};\r\n    /*\\\r\n     * Raphael.path2curve\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Converts path to a new path where all segments are cubic bezier curves.\r\n     > Parameters\r\n     - pathString (string|array) path string or array of segments\r\n     = (array) array of segments.\r\n     \\*/\r\n    R.path2curve = path2curve;\r\n    /*\\\r\n     * Raphael.matrix\r\n     [ method ]\r\n     **\r\n     * Utility method\r\n     **\r\n     * Returns matrix based on given parameters.\r\n     > Parameters\r\n     - a (number)\r\n     - b (number)\r\n     - c (number)\r\n     - d (number)\r\n     - e (number)\r\n     - f (number)\r\n     = (object) @Matrix\r\n     \\*/\r\n    R.matrix = function (a, b, c, d, e, f) {\r\n        return new Matrix(a, b, c, d, e, f);\r\n    };\r\n    function Matrix(a, b, c, d, e, f) {\r\n        if (a != null) {\r\n            this.a = +a;\r\n            this.b = +b;\r\n            this.c = +c;\r\n            this.d = +d;\r\n            this.e = +e;\r\n            this.f = +f;\r\n        } else {\r\n            this.a = 1;\r\n            this.b = 0;\r\n            this.c = 0;\r\n            this.d = 1;\r\n            this.e = 0;\r\n            this.f = 0;\r\n        }\r\n    }\r\n    (function (matrixproto) {\r\n        /*\\\r\n         * Matrix.add\r\n         [ method ]\r\n         **\r\n         * Adds given matrix to existing one.\r\n         > Parameters\r\n         - a (number)\r\n         - b (number)\r\n         - c (number)\r\n         - d (number)\r\n         - e (number)\r\n         - f (number)\r\n         or\r\n         - matrix (object) @Matrix\r\n         \\*/\r\n        matrixproto.add = function (a, b, c, d, e, f) {\r\n            var out = [[], [], []],\r\n                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],\r\n                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],\r\n                x, y, z, res;\r\n\r\n            if (a && a instanceof Matrix) {\r\n                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];\r\n            }\r\n\r\n            for (x = 0; x < 3; x++) {\r\n                for (y = 0; y < 3; y++) {\r\n                    res = 0;\r\n                    for (z = 0; z < 3; z++) {\r\n                        res += m[x][z] * matrix[z][y];\r\n                    }\r\n                    out[x][y] = res;\r\n                }\r\n            }\r\n            this.a = out[0][0];\r\n            this.b = out[1][0];\r\n            this.c = out[0][1];\r\n            this.d = out[1][1];\r\n            this.e = out[0][2];\r\n            this.f = out[1][2];\r\n        };\r\n        /*\\\r\n         * Matrix.invert\r\n         [ method ]\r\n         **\r\n         * Returns inverted version of the matrix\r\n         = (object) @Matrix\r\n         \\*/\r\n        matrixproto.invert = function () {\r\n            var me = this,\r\n                x = me.a * me.d - me.b * me.c;\r\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\r\n        };\r\n        /*\\\r\n         * Matrix.clone\r\n         [ method ]\r\n         **\r\n         * Returns copy of the matrix\r\n         = (object) @Matrix\r\n         \\*/\r\n        matrixproto.clone = function () {\r\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\r\n        };\r\n        /*\\\r\n         * Matrix.translate\r\n         [ method ]\r\n         **\r\n         * Translate the matrix\r\n         > Parameters\r\n         - x (number)\r\n         - y (number)\r\n         \\*/\r\n        matrixproto.translate = function (x, y) {\r\n            this.add(1, 0, 0, 1, x, y);\r\n        };\r\n        /*\\\r\n         * Matrix.scale\r\n         [ method ]\r\n         **\r\n         * Scales the matrix\r\n         > Parameters\r\n         - x (number)\r\n         - y (number) #optional\r\n         - cx (number) #optional\r\n         - cy (number) #optional\r\n         \\*/\r\n        matrixproto.scale = function (x, y, cx, cy) {\r\n            y == null && (y = x);\r\n            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);\r\n            this.add(x, 0, 0, y, 0, 0);\r\n            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);\r\n        };\r\n        /*\\\r\n         * Matrix.rotate\r\n         [ method ]\r\n         **\r\n         * Rotates the matrix\r\n         > Parameters\r\n         - a (number)\r\n         - x (number)\r\n         - y (number)\r\n         \\*/\r\n        matrixproto.rotate = function (a, x, y) {\r\n            a = R.rad(a);\r\n            x = x || 0;\r\n            y = y || 0;\r\n            var cos = +math.cos(a).toFixed(9),\r\n                sin = +math.sin(a).toFixed(9);\r\n            this.add(cos, sin, -sin, cos, x, y);\r\n            this.add(1, 0, 0, 1, -x, -y);\r\n        };\r\n        /*\\\r\n         * Matrix.x\r\n         [ method ]\r\n         **\r\n         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y\r\n         > Parameters\r\n         - x (number)\r\n         - y (number)\r\n         = (number) x\r\n         \\*/\r\n        matrixproto.x = function (x, y) {\r\n            return x * this.a + y * this.c + this.e;\r\n        };\r\n        /*\\\r\n         * Matrix.y\r\n         [ method ]\r\n         **\r\n         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x\r\n         > Parameters\r\n         - x (number)\r\n         - y (number)\r\n         = (number) y\r\n         \\*/\r\n        matrixproto.y = function (x, y) {\r\n            return x * this.b + y * this.d + this.f;\r\n        };\r\n        matrixproto.get = function (i) {\r\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\r\n        };\r\n        matrixproto.toString = function () {\r\n            return R.svg ?\r\n            \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\" :\r\n                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();\r\n        };\r\n        matrixproto.toFilter = function () {\r\n            return \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + this.get(0) +\r\n                \", M12=\" + this.get(2) + \", M21=\" + this.get(1) + \", M22=\" + this.get(3) +\r\n                \", Dx=\" + this.get(4) + \", Dy=\" + this.get(5) + \", sizingmethod='auto expand')\";\r\n        };\r\n        matrixproto.offset = function () {\r\n            return [this.e.toFixed(4), this.f.toFixed(4)];\r\n        };\r\n        function norm(a) {\r\n            return a[0] * a[0] + a[1] * a[1];\r\n        }\r\n        function normalize(a) {\r\n            var mag = math.sqrt(norm(a));\r\n            a[0] && (a[0] /= mag);\r\n            a[1] && (a[1] /= mag);\r\n        }\r\n        /*\\\r\n         * Matrix.split\r\n         [ method ]\r\n         **\r\n         * Splits matrix into primitive transformations\r\n         = (object) in format:\r\n         o dx (number) translation by x\r\n         o dy (number) translation by y\r\n         o scalex (number) scale by x\r\n         o scaley (number) scale by y\r\n         o shear (number) shear\r\n         o rotate (number) rotation in deg\r\n         o isSimple (boolean) could it be represented via simple transformations\r\n         \\*/\r\n        matrixproto.split = function () {\r\n            var out = {};\r\n            // translation\r\n            out.dx = this.e;\r\n            out.dy = this.f;\r\n\r\n            // scale and shear\r\n            var row = [[this.a, this.c], [this.b, this.d]];\r\n            out.scalex = math.sqrt(norm(row[0]));\r\n            normalize(row[0]);\r\n\r\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\r\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\r\n\r\n            out.scaley = math.sqrt(norm(row[1]));\r\n            normalize(row[1]);\r\n            out.shear /= out.scaley;\r\n\r\n            // rotation\r\n            var sin = -row[0][1],\r\n                cos = row[1][1];\r\n            if (cos < 0) {\r\n                out.rotate = R.deg(math.acos(cos));\r\n                if (sin < 0) {\r\n                    out.rotate = 360 - out.rotate;\r\n                }\r\n            } else {\r\n                out.rotate = R.deg(math.asin(sin));\r\n            }\r\n\r\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\r\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\r\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\r\n            return out;\r\n        };\r\n        /*\\\r\n         * Matrix.toTransformString\r\n         [ method ]\r\n         **\r\n         * Return transform string that represents given matrix\r\n         = (string) transform string\r\n         \\*/\r\n        matrixproto.toTransformString = function (shorter) {\r\n            var s = shorter || this[split]();\r\n            if (s.isSimple) {\r\n                s.scalex = +s.scalex.toFixed(4);\r\n                s.scaley = +s.scaley.toFixed(4);\r\n                s.rotate = +s.rotate.toFixed(4);\r\n                return  (s.dx || s.dy ? \"t\" + [s.dx, s.dy] : E) +\r\n                    (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E) +\r\n                    (s.rotate ? \"r\" + [s.rotate, 0, 0] : E);\r\n            } else {\r\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\r\n            }\r\n        };\r\n    })(Matrix.prototype);\r\n\r\n    var preventDefault = function () {\r\n            this.returnValue = false;\r\n        },\r\n        preventTouch = function () {\r\n            return this.originalEvent.preventDefault();\r\n        },\r\n        stopPropagation = function () {\r\n            this.cancelBubble = true;\r\n        },\r\n        stopTouch = function () {\r\n            return this.originalEvent.stopPropagation();\r\n        },\r\n        getEventPosition = function (e) {\r\n            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\r\n\r\n            return {\r\n                x: e.clientX + scrollX,\r\n                y: e.clientY + scrollY\r\n            };\r\n        },\r\n        addEvent = (function () {\r\n            if (g.doc.addEventListener) {\r\n                return function (obj, type, fn, element) {\r\n                    var f = function (e) {\r\n                        var pos = getEventPosition(e);\r\n                        return fn.call(element, e, pos.x, pos.y);\r\n                    };\r\n                    obj.addEventListener(type, f, false);\r\n\r\n                    if (supportsTouch && touchMap[type]) {\r\n                        var _f = function (e) {\r\n                            var pos = getEventPosition(e),\r\n                                olde = e;\r\n\r\n                            for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\r\n                                if (e.targetTouches[i].target == obj) {\r\n                                    e = e.targetTouches[i];\r\n                                    e.originalEvent = olde;\r\n                                    e.preventDefault = preventTouch;\r\n                                    e.stopPropagation = stopTouch;\r\n                                    break;\r\n                                }\r\n                            }\r\n\r\n                            return fn.call(element, e, pos.x, pos.y);\r\n                        };\r\n                        obj.addEventListener(touchMap[type], _f, false);\r\n                    }\r\n\r\n                    return function () {\r\n                        obj.removeEventListener(type, f, false);\r\n\r\n                        if (supportsTouch && touchMap[type])\r\n                            obj.removeEventListener(touchMap[type], _f, false);\r\n\r\n                        return true;\r\n                    };\r\n                };\r\n            } else if (g.doc.attachEvent) {\r\n                return function (obj, type, fn, element) {\r\n                    var f = function (e) {\r\n                        e = e || g.win.event;\r\n                        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\r\n                            x = e.clientX + scrollX,\r\n                            y = e.clientY + scrollY;\r\n                        e.preventDefault = e.preventDefault || preventDefault;\r\n                        e.stopPropagation = e.stopPropagation || stopPropagation;\r\n                        return fn.call(element, e, x, y);\r\n                    };\r\n                    obj.attachEvent(\"on\" + type, f);\r\n                    var detacher = function () {\r\n                        obj.detachEvent(\"on\" + type, f);\r\n                        return true;\r\n                    };\r\n                    return detacher;\r\n                };\r\n            }\r\n        })(),\r\n        drag = [],\r\n        dragMove = function (e) {\r\n            var x = e.clientX,\r\n                y = e.clientY,\r\n                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,\r\n                dragi,\r\n                j = drag.length;\r\n            while (j--) {\r\n                dragi = drag[j];\r\n                if (supportsTouch && e.touches) {\r\n                    var i = e.touches.length,\r\n                        touch;\r\n                    while (i--) {\r\n                        touch = e.touches[i];\r\n                        if (touch.identifier == dragi.el._drag.id) {\r\n                            x = touch.clientX;\r\n                            y = touch.clientY;\r\n                            (e.originalEvent ? e.originalEvent : e).preventDefault();\r\n                            break;\r\n                        }\r\n                    }\r\n                } else {\r\n                    e.preventDefault();\r\n                }\r\n                var node = dragi.el.node,\r\n                    o,\r\n                    next = node.nextSibling,\r\n                    parent = node.parentNode,\r\n                    display = node.style.display;\r\n                g.win.opera && parent.removeChild(node);\r\n                node.style.display = \"none\";\r\n                o = dragi.el.paper.getElementByPoint(x, y);\r\n                node.style.display = display;\r\n                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\r\n                o && eve(\"raphael.drag.over.\" + dragi.el.id, dragi.el, o);\r\n                x += scrollX;\r\n                y += scrollY;\r\n                eve(\"raphael.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\r\n            }\r\n        },\r\n        dragUp = function (e) {\r\n            R.unmousemove(dragMove).unmouseup(dragUp);\r\n            var i = drag.length,\r\n                dragi;\r\n            while (i--) {\r\n                dragi = drag[i];\r\n                dragi.el._drag = {};\r\n                eve(\"raphael.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\r\n            }\r\n            drag = [];\r\n        },\r\n    /*\\\r\n     * Raphael.el\r\n     [ property (object) ]\r\n     **\r\n     * You can add your own method to elements. This is usefull when you want to hack default functionality or\r\n     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,\r\n     * you can redefine element method at any time. Expending element methods wouldn’t affect set.\r\n     > Usage\r\n     | Raphael.el.red = function () {\r\n     |     this.attr({fill: \"#f00\"});\r\n     | };\r\n     | // then use it\r\n     | paper.circle(100, 100, 20).red();\r\n     \\*/\r\n        elproto = R.el = {};\r\n    /*\\\r\n     * Element.click\r\n     [ method ]\r\n     **\r\n     * Adds event handler for click for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.unclick\r\n     [ method ]\r\n     **\r\n     * Removes event handler for click for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.dblclick\r\n     [ method ]\r\n     **\r\n     * Adds event handler for double click for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.undblclick\r\n     [ method ]\r\n     **\r\n     * Removes event handler for double click for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.mousedown\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mousedown for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.unmousedown\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mousedown for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.mousemove\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mousemove for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.unmousemove\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mousemove for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.mouseout\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mouseout for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.unmouseout\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mouseout for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.mouseover\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mouseover for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.unmouseover\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mouseover for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.mouseup\r\n     [ method ]\r\n     **\r\n     * Adds event handler for mouseup for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.unmouseup\r\n     [ method ]\r\n     **\r\n     * Removes event handler for mouseup for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.touchstart\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchstart for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.untouchstart\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchstart for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.touchmove\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchmove for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.untouchmove\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchmove for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.touchend\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchend for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.untouchend\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchend for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n\r\n    /*\\\r\n     * Element.touchcancel\r\n     [ method ]\r\n     **\r\n     * Adds event handler for touchcancel for the element.\r\n     > Parameters\r\n     - handler (function) handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    /*\\\r\n     * Element.untouchcancel\r\n     [ method ]\r\n     **\r\n     * Removes event handler for touchcancel for the element.\r\n     > Parameters\r\n     - handler (function) #optional handler for the event\r\n     = (object) @Element\r\n     \\*/\r\n    for (var i = events.length; i--;) {\r\n        (function (eventName) {\r\n            R[eventName] = elproto[eventName] = function (fn, scope) {\r\n                if (R.is(fn, \"function\")) {\r\n                    this.events = this.events || [];\r\n                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});\r\n                }\r\n                return this;\r\n            };\r\n            R[\"un\" + eventName] = elproto[\"un\" + eventName] = function (fn) {\r\n                var events = this.events || [],\r\n                    l = events.length;\r\n                while (l--){\r\n                    if (events[l].name == eventName && (R.is(fn, \"undefined\") || events[l].f == fn)) {\r\n                        events[l].unbind();\r\n                        events.splice(l, 1);\r\n                        !events.length && delete this.events;\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n        })(events[i]);\r\n    }\r\n\r\n    /*\\\r\n     * Element.data\r\n     [ method ]\r\n     **\r\n     * Adds or retrieves given value asociated with given key.\r\n     **\r\n     * See also @Element.removeData\r\n     > Parameters\r\n     - key (string) key to store data\r\n     - value (any) #optional value to store\r\n     = (object) @Element\r\n     * or, if value is not specified:\r\n     = (any) value\r\n     * or, if key and value are not specified:\r\n     = (object) Key/value pairs for all the data associated with the element.\r\n     > Usage\r\n     | for (var i = 0, i < 5, i++) {\r\n     |     paper.circle(10 + 15 * i, 10, 10)\r\n     |          .attr({fill: \"#000\"})\r\n     |          .data(\"i\", i)\r\n     |          .click(function () {\r\n     |             alert(this.data(\"i\"));\r\n     |          });\r\n     | }\r\n     \\*/\r\n    elproto.data = function (key, value) {\r\n        var data = eldata[this.id] = eldata[this.id] || {};\r\n        if (arguments.length == 0) {\r\n            return data;\r\n        }\r\n        if (arguments.length == 1) {\r\n            if (R.is(key, \"object\")) {\r\n                for (var i in key) if (key[has](i)) {\r\n                    this.data(i, key[i]);\r\n                }\r\n                return this;\r\n            }\r\n            eve(\"raphael.data.get.\" + this.id, this, data[key], key);\r\n            return data[key];\r\n        }\r\n        data[key] = value;\r\n        eve(\"raphael.data.set.\" + this.id, this, value, key);\r\n        return this;\r\n    };\r\n\r\n    elproto.datum = function(){\r\n        return arguments.length == 0 ? this._bindData : ((this._bindData = arguments[0]), this);\r\n    };\r\n\r\n    /*\\\r\n     * Element.removeData\r\n     [ method ]\r\n     **\r\n     * Removes value associated with an element by given key.\r\n     * If key is not provided, removes all the data of the element.\r\n     > Parameters\r\n     - key (string) #optional key\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.removeData = function (key) {\r\n        if (key == null) {\r\n            eldata[this.id] = {};\r\n        } else {\r\n            eldata[this.id] && delete eldata[this.id][key];\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.getData\r\n     [ method ]\r\n     **\r\n     * Retrieves the element data\r\n     = (object) data\r\n     \\*/\r\n    elproto.getData = function () {\r\n        return clone(eldata[this.id] || {});\r\n    };\r\n    /*\\\r\n     * Element.hover\r\n     [ method ]\r\n     **\r\n     * Adds event handlers for hover for the element.\r\n     > Parameters\r\n     - f_in (function) handler for hover in\r\n     - f_out (function) handler for hover out\r\n     - icontext (object) #optional context for hover in handler\r\n     - ocontext (object) #optional context for hover out handler\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\r\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\r\n    };\r\n    /*\\\r\n     * Element.unhover\r\n     [ method ]\r\n     **\r\n     * Removes event handlers for hover for the element.\r\n     > Parameters\r\n     - f_in (function) handler for hover in\r\n     - f_out (function) handler for hover out\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.unhover = function (f_in, f_out) {\r\n        return this.unmouseover(f_in).unmouseout(f_out);\r\n    };\r\n    var draggable = [];\r\n    /*\\\r\n     * Element.drag\r\n     [ method ]\r\n     **\r\n     * Adds event handlers for drag of the element.\r\n     > Parameters\r\n     - onmove (function) handler for moving\r\n     - onstart (function) handler for drag start\r\n     - onend (function) handler for drag end\r\n     - mcontext (object) #optional context for moving handler\r\n     - scontext (object) #optional context for drag start handler\r\n     - econtext (object) #optional context for drag end handler\r\n     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,\r\n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element\r\n     * `drag.over.<id>` will be fired as well.\r\n     *\r\n     * Start event and start handler will be called in specified context or in context of the element with following parameters:\r\n     o x (number) x position of the mouse\r\n     o y (number) y position of the mouse\r\n     o event (object) DOM event object\r\n     * Move event and move handler will be called in specified context or in context of the element with following parameters:\r\n     o dx (number) shift by x from the start point\r\n     o dy (number) shift by y from the start point\r\n     o x (number) x position of the mouse\r\n     o y (number) y position of the mouse\r\n     o event (object) DOM event object\r\n     * End event and end handler will be called in specified context or in context of the element with following parameters:\r\n     o event (object) DOM event object\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\r\n        function start(e) {\r\n            (e.originalEvent || e).preventDefault();\r\n            var x = e.clientX,\r\n                y = e.clientY,\r\n                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,\r\n                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;\r\n            this._drag.id = e.identifier;\r\n            if (supportsTouch && e.touches) {\r\n                var i = e.touches.length, touch;\r\n                while (i--) {\r\n                    touch = e.touches[i];\r\n                    this._drag.id = touch.identifier;\r\n                    if (touch.identifier == this._drag.id) {\r\n                        x = touch.clientX;\r\n                        y = touch.clientY;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this._drag.x = x + scrollX;\r\n            this._drag.y = y + scrollY;\r\n            !drag.length && R.mousemove(dragMove).mouseup(dragUp);\r\n            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\r\n            onstart && eve.on(\"raphael.drag.start.\" + this.id, onstart);\r\n            onmove && eve.on(\"raphael.drag.move.\" + this.id, onmove);\r\n            onend && eve.on(\"raphael.drag.end.\" + this.id, onend);\r\n            eve(\"raphael.drag.start.\" + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);\r\n        }\r\n        this._drag = {};\r\n        draggable.push({el: this, start: start});\r\n        this.mousedown(start);\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.onDragOver\r\n     [ method ]\r\n     **\r\n     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).\r\n     > Parameters\r\n     - f (function) handler for event, first argument would be the element you are dragging over\r\n     \\*/\r\n    elproto.onDragOver = function (f) {\r\n        f ? eve.on(\"raphael.drag.over.\" + this.id, f) : eve.unbind(\"raphael.drag.over.\" + this.id);\r\n    };\r\n    /*\\\r\n     * Element.undrag\r\n     [ method ]\r\n     **\r\n     * Removes all drag event handlers from given element.\r\n     \\*/\r\n    elproto.undrag = function () {\r\n        var i = draggable.length;\r\n        while (i--) if (draggable[i].el == this) {\r\n            this.unmousedown(draggable[i].start);\r\n            draggable.splice(i, 1);\r\n            eve.unbind(\"raphael.drag.*.\" + this.id);\r\n        }\r\n        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);\r\n        drag = [];\r\n    };\r\n    /*\\\r\n     * Paper.circle\r\n     [ method ]\r\n     **\r\n     * Draws a circle.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the centre\r\n     - y (number) y coordinate of the centre\r\n     - r (number) radius\r\n     = (object) Raphaël element object with type “circle”\r\n     **\r\n     > Usage\r\n     | var c = paper.circle(50, 50, 40);\r\n     \\*/\r\n    paperproto.circle = function (x, y, r) {\r\n        var out = R._engine.circle(this, x || 0, y || 0, r || 0);\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.rect\r\n     [ method ]\r\n     *\r\n     * Draws a rectangle.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the top left corner\r\n     - y (number) y coordinate of the top left corner\r\n     - width (number) width\r\n     - height (number) height\r\n     - r (number) #optional radius for rounded corners, default is 0\r\n     = (object) Raphaël element object with type “rect”\r\n     **\r\n     > Usage\r\n     | // regular rectangle\r\n     | var c = paper.rect(10, 10, 50, 50);\r\n     | // rectangle with rounded corners\r\n     | var c = paper.rect(40, 40, 50, 50, 10);\r\n     \\*/\r\n    paperproto.rect = function (x, y, w, h, r) {\r\n        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.ellipse\r\n     [ method ]\r\n     **\r\n     * Draws an ellipse.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the centre\r\n     - y (number) y coordinate of the centre\r\n     - rx (number) horizontal radius\r\n     - ry (number) vertical radius\r\n     = (object) Raphaël element object with type “ellipse”\r\n     **\r\n     > Usage\r\n     | var c = paper.ellipse(50, 50, 40, 20);\r\n     \\*/\r\n    paperproto.ellipse = function (x, y, rx, ry) {\r\n        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.path\r\n     [ method ]\r\n     **\r\n     * Creates a path element by given path data string.\r\n     > Parameters\r\n     - pathString (string) #optional path string in SVG format.\r\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:\r\n     | \"M10,20L30,40\"\r\n     * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.\r\n     *\r\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a>.</p>\r\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\r\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\r\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\r\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\r\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\r\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\r\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\r\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\r\n     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>\r\n     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>\r\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\r\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\r\n     * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.\r\n     * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.\r\n     > Usage\r\n     | var c = paper.path(\"M10 10L90 90\");\r\n     | // draw a diagonal line:\r\n     | // move to 10,10, line to 90,90\r\n     * For example of path strings, check out these icons: http://raphaeljs.com/icons/\r\n     \\*/\r\n    paperproto.path = function (pathString) {\r\n        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);\r\n        var out = R._engine.path(R.format[apply](R, arguments), this);\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.image\r\n     [ method ]\r\n     **\r\n     * Embeds an image into the surface.\r\n     **\r\n     > Parameters\r\n     **\r\n     - src (string) URI of the source image\r\n     - x (number) x coordinate position\r\n     - y (number) y coordinate position\r\n     - width (number) width of the image\r\n     - height (number) height of the image\r\n     = (object) Raphaël element object with type “image”\r\n     **\r\n     > Usage\r\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\r\n     \\*/\r\n    paperproto.image = function (src, x, y, w, h) {\r\n        var out = R._engine.image(this, src || \"about:blank\", x || 0, y || 0, w || 0, h || 0);\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.text\r\n     [ method ]\r\n     **\r\n     * Draws a text string. If you need line breaks, put “\\n” in the string.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate position\r\n     - y (number) y coordinate position\r\n     - text (string) The text string to draw\r\n     = (object) Raphaël element object with type “text”\r\n     **\r\n     > Usage\r\n     | var t = paper.text(50, 50, \"Raphaël\\nkicks\\nbutt!\");\r\n     \\*/\r\n    paperproto.text = function (x, y, text) {\r\n        var out = R._engine.text(this, x || 0, y || 0, Str(text));\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.set\r\n     [ method ]\r\n     **\r\n     * Creates array-like object to keep and operate several elements at once.\r\n     * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.\r\n     * Sets act as pseudo elements — all methods available to an element can be used on a set.\r\n     = (object) array-like object that represents set of elements\r\n     **\r\n     > Usage\r\n     | var st = paper.set();\r\n     | st.push(\r\n     |     paper.circle(10, 10, 5),\r\n     |     paper.circle(30, 10, 5)\r\n     | );\r\n     | st.attr({fill: \"red\"}); // changes the fill of both circles\r\n     \\*/\r\n    paperproto.set = function (itemsArray) {\r\n        !R.is(itemsArray, \"array\") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));\r\n        var out = new Set(itemsArray);\r\n        this.__set__ && this.__set__.push(out);\r\n        out[\"paper\"] = this;\r\n        out[\"type\"] = \"set\";\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.setStart\r\n     [ method ]\r\n     **\r\n     * Creates @Paper.set. All elements that will be created after calling this method and before calling\r\n     * @Paper.setFinish will be added to the set.\r\n     **\r\n     > Usage\r\n     | paper.setStart();\r\n     | paper.circle(10, 10, 5),\r\n     | paper.circle(30, 10, 5)\r\n     | var st = paper.setFinish();\r\n     | st.attr({fill: \"red\"}); // changes the fill of both circles\r\n     \\*/\r\n    paperproto.setStart = function (set) {\r\n        this.__set__ = set || this.set();\r\n    };\r\n    /*\\\r\n     * Paper.setFinish\r\n     [ method ]\r\n     **\r\n     * See @Paper.setStart. This method finishes catching and returns resulting set.\r\n     **\r\n     = (object) set\r\n     \\*/\r\n    paperproto.setFinish = function (set) {\r\n        var out = this.__set__;\r\n        delete this.__set__;\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Paper.getSize\r\n     [ method ]\r\n     **\r\n     * Obtains current paper actual size.\r\n     **\r\n     = (object)\r\n     \\*/\r\n    paperproto.getSize = function () {\r\n        var container = this.canvas.parentNode;\r\n        return {\r\n            width: container.offsetWidth,\r\n            height: container.offsetHeight\r\n        };\r\n    };\r\n    /*\\\r\n     * Paper.setSize\r\n     [ method ]\r\n     **\r\n     * If you need to change dimensions of the canvas call this method\r\n     **\r\n     > Parameters\r\n     **\r\n     - width (number) new width of the canvas\r\n     - height (number) new height of the canvas\r\n     \\*/\r\n    paperproto.setSize = function (width, height) {\r\n        return R._engine.setSize.call(this, width, height);\r\n    };\r\n    /*\\\r\n     * Paper.setViewBox\r\n     [ method ]\r\n     **\r\n     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by\r\n     * specifying new boundaries.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) new x position, default is `0`\r\n     - y (number) new y position, default is `0`\r\n     - w (number) new width of the canvas\r\n     - h (number) new height of the canvas\r\n     - fit (boolean) `true` if you want graphics to fit into new boundary box\r\n     \\*/\r\n    paperproto.setViewBox = function (x, y, w, h, fit) {\r\n        return R._engine.setViewBox.call(this, x, y, w, h, fit);\r\n    };\r\n    /*\\\r\n     * Paper.top\r\n     [ property ]\r\n     **\r\n     * Points to the topmost element on the paper\r\n     \\*/\r\n    /*\\\r\n     * Paper.bottom\r\n     [ property ]\r\n     **\r\n     * Points to the bottom element on the paper\r\n     \\*/\r\n    paperproto.top = paperproto.bottom = null;\r\n    /*\\\r\n     * Paper.raphael\r\n     [ property ]\r\n     **\r\n     * Points to the @Raphael object/function\r\n     \\*/\r\n    paperproto.raphael = R;\r\n    var getOffset = function (elem) {\r\n        var box = elem.getBoundingClientRect(),\r\n            doc = elem.ownerDocument,\r\n            body = doc.body,\r\n            docElem = doc.documentElement,\r\n            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\r\n            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\r\n            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\r\n        return {\r\n            y: top,\r\n            x: left\r\n        };\r\n    };\r\n    /*\\\r\n     * Paper.getElementByPoint\r\n     [ method ]\r\n     **\r\n     * Returns you topmost element under given point.\r\n     **\r\n     = (object) Raphaël element object\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate from the top left corner of the window\r\n     - y (number) y coordinate from the top left corner of the window\r\n     > Usage\r\n     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\r\n     \\*/\r\n    paperproto.getElementByPoint = function (x, y) {\r\n        var paper = this,\r\n            svg = paper.canvas,\r\n            target = g.doc.elementFromPoint(x, y);\r\n        if (g.win.opera && target.tagName == \"svg\") {\r\n            var so = getOffset(svg),\r\n                sr = svg.createSVGRect();\r\n            sr.x = x - so.x;\r\n            sr.y = y - so.y;\r\n            sr.width = sr.height = 1;\r\n            var hits = svg.getIntersectionList(sr, null);\r\n            if (hits.length) {\r\n                target = hits[hits.length - 1];\r\n            }\r\n        }\r\n        if (!target) {\r\n            return null;\r\n        }\r\n        while (target.parentNode && target != svg.parentNode && !target.raphael) {\r\n            target = target.parentNode;\r\n        }\r\n        target == paper.canvas.parentNode && (target = svg);\r\n        target = target && target.raphael ? paper.getById(target.raphaelid) : null;\r\n        return target;\r\n    };\r\n\r\n    /*\\\r\n     * Paper.getElementsByBBox\r\n     [ method ]\r\n     **\r\n     * Returns set of elements that have an intersecting bounding box\r\n     **\r\n     > Parameters\r\n     **\r\n     - bbox (object) bbox to check with\r\n     = (object) @Set\r\n     \\*/\r\n    paperproto.getElementsByBBox = function (bbox) {\r\n        var set = this.set();\r\n        this.forEach(function (el) {\r\n            if (R.isBBoxIntersect(el.getBBox(), bbox)) {\r\n                set.push(el);\r\n            }\r\n        });\r\n        return set;\r\n    };\r\n\r\n    /*\\\r\n     * Paper.getById\r\n     [ method ]\r\n     **\r\n     * Returns you element by its internal ID.\r\n     **\r\n     > Parameters\r\n     **\r\n     - id (number) id\r\n     = (object) Raphaël element object\r\n     \\*/\r\n    paperproto.getById = function (id) {\r\n        var bot = this.bottom;\r\n        while (bot) {\r\n            if (bot.id == id) {\r\n                return bot;\r\n            }\r\n            bot = bot.next;\r\n        }\r\n        return null;\r\n    };\r\n    /*\\\r\n     * Paper.forEach\r\n     [ method ]\r\n     **\r\n     * Executes given function for each element on the paper\r\n     *\r\n     * If callback function returns `false` it will stop loop running.\r\n     **\r\n     > Parameters\r\n     **\r\n     - callback (function) function to run\r\n     - thisArg (object) context object for the callback\r\n     = (object) Paper object\r\n     > Usage\r\n     | paper.forEach(function (el) {\r\n     |     el.attr({ stroke: \"blue\" });\r\n     | });\r\n     \\*/\r\n    paperproto.forEach = function (callback, thisArg) {\r\n        var bot = this.bottom;\r\n        while (bot) {\r\n            if (callback.call(thisArg, bot) === false) {\r\n                return this;\r\n            }\r\n            bot = bot.next;\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Paper.getElementsByPoint\r\n     [ method ]\r\n     **\r\n     * Returns set of elements that have common point inside\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the point\r\n     - y (number) y coordinate of the point\r\n     = (object) @Set\r\n     \\*/\r\n    paperproto.getElementsByPoint = function (x, y) {\r\n        var set = this.set();\r\n        this.forEach(function (el) {\r\n            if (el.isPointInside(x, y)) {\r\n                set.push(el);\r\n            }\r\n        });\r\n        return set;\r\n    };\r\n    function x_y() {\r\n        return this.x + S + this.y;\r\n    }\r\n    function x_y_w_h() {\r\n        return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\r\n    }\r\n    /*\\\r\n     * Element.isPointInside\r\n     [ method ]\r\n     **\r\n     * Determine if given point is inside this element’s shape\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the point\r\n     - y (number) y coordinate of the point\r\n     = (boolean) `true` if point inside the shape\r\n     \\*/\r\n    elproto.isPointInside = function (x, y) {\r\n        var rp = this.realPath = getPath[this.type](this);\r\n        if (this.attr('transform') && this.attr('transform').length) {\r\n            rp = R.transformPath(rp, this.attr('transform'));\r\n        }\r\n        return R.isPointInsidePath(rp, x, y);\r\n    };\r\n    /*\\\r\n     * Element.getBBox\r\n     [ method ]\r\n     **\r\n     * Return bounding box for a given element\r\n     **\r\n     > Parameters\r\n     **\r\n     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.\r\n     = (object) Bounding box object:\r\n     o {\r\n     o     x: (number) top left corner x\r\n     o     y: (number) top left corner y\r\n     o     x2: (number) bottom right corner x\r\n     o     y2: (number) bottom right corner y\r\n     o     width: (number) width\r\n     o     height: (number) height\r\n     o }\r\n     \\*/\r\n    elproto.getBBox = function (isWithoutTransform) {\r\n        if (this.removed) {\r\n            return {};\r\n        }\r\n        var _ = this._;\r\n        if (isWithoutTransform) {\r\n            if (_.dirty || !_.bboxwt) {\r\n                this.realPath = getPath[this.type](this);\r\n                _.bboxwt = pathDimensions(this.realPath);\r\n                _.bboxwt.toString = x_y_w_h;\r\n                _.dirty = 0;\r\n            }\r\n            return _.bboxwt;\r\n        }\r\n        if (_.dirty || _.dirtyT || !_.bbox) {\r\n            if (_.dirty || !this.realPath) {\r\n                _.bboxwt = 0;\r\n                this.realPath = getPath[this.type](this);\r\n            }\r\n            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));\r\n            _.bbox.toString = x_y_w_h;\r\n            _.dirty = _.dirtyT = 0;\r\n        }\r\n        return _.bbox;\r\n    };\r\n    /*\\\r\n     * Element.clone\r\n     [ method ]\r\n     **\r\n     = (object) clone of a given element\r\n     **\r\n     \\*/\r\n    elproto.clone = function () {\r\n        if (this.removed) {\r\n            return null;\r\n        }\r\n        var out = this.paper[this.type]().attr(this.attr());\r\n        this.__set__ && this.__set__.push(out);\r\n        return out;\r\n    };\r\n    /*\\\r\n     * Element.glow\r\n     [ method ]\r\n     **\r\n     * Return set of elements that create glow-like effect around given element. See @Paper.set.\r\n     *\r\n     * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.\r\n     **\r\n     > Parameters\r\n     **\r\n     - glow (object) #optional parameters object with all properties optional:\r\n     o {\r\n     o     width (number) size of the glow, default is `10`\r\n     o     fill (boolean) will it be filled, default is `false`\r\n     o     opacity (number) opacity, default is `0.5`\r\n     o     offsetx (number) horizontal offset, default is `0`\r\n     o     offsety (number) vertical offset, default is `0`\r\n     o     color (string) glow colour, default is `black`\r\n     o }\r\n     = (object) @Paper.set of elements that represents glow\r\n     \\*/\r\n    elproto.glow = function (glow) {\r\n        if (this.type == \"text\") {\r\n            return null;\r\n        }\r\n        glow = glow || {};\r\n        var s = {\r\n                width: (glow.width || 10) + (+this.attr(\"stroke-width\") || 1),\r\n                fill: glow.fill || false,\r\n                opacity: glow.opacity == null ? .5 : glow.opacity,\r\n                offsetx: glow.offsetx || 0,\r\n                offsety: glow.offsety || 0,\r\n                color: glow.color || \"#000\"\r\n            },\r\n            c = s.width / 2,\r\n            r = this.paper,\r\n            out = r.set(),\r\n            path = this.realPath || getPath[this.type](this);\r\n        path = this.matrix ? mapPath(path, this.matrix) : path;\r\n        for (var i = 1; i < c + 1; i++) {\r\n            out.push(r.path(path).attr({\r\n                stroke: s.color,\r\n                fill: s.fill ? s.color : \"none\",\r\n                \"stroke-linejoin\": \"round\",\r\n                \"stroke-linecap\": \"round\",\r\n                \"stroke-width\": +(s.width / c * i).toFixed(3),\r\n                opacity: +(s.opacity / c).toFixed(3)\r\n            }));\r\n        }\r\n        return out.insertBefore(this).translate(s.offsetx, s.offsety);\r\n    };\r\n    var curveslengths = {},\r\n        getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\r\n            if (length == null) {\r\n                return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\r\n            } else {\r\n                return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\r\n            }\r\n        },\r\n        getLengthFactory = function (istotal, subpath) {\r\n            return function (path, length, onlystart) {\r\n                path = path2curve(path);\r\n                var x, y, p, l, sp = \"\", subpaths = {}, point,\r\n                    len = 0;\r\n                for (var i = 0, ii = path.length; i < ii; i++) {\r\n                    p = path[i];\r\n                    if (p[0] == \"M\") {\r\n                        x = +p[1];\r\n                        y = +p[2];\r\n                    } else {\r\n                        l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\r\n                        if (len + l > length) {\r\n                            if (subpath && !subpaths.start) {\r\n                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\r\n                                sp += [\"C\" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];\r\n                                if (onlystart) {return sp;}\r\n                                subpaths.start = sp;\r\n                                sp = [\"M\" + point.x, point.y + \"C\" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();\r\n                                len += l;\r\n                                x = +p[5];\r\n                                y = +p[6];\r\n                                continue;\r\n                            }\r\n                            if (!istotal && !subpath) {\r\n                                point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\r\n                                return {x: point.x, y: point.y, alpha: point.alpha};\r\n                            }\r\n                        }\r\n                        len += l;\r\n                        x = +p[5];\r\n                        y = +p[6];\r\n                    }\r\n                    sp += p.shift() + p;\r\n                }\r\n                subpaths.end = sp;\r\n                point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\r\n                point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});\r\n                return point;\r\n            };\r\n        };\r\n    var getTotalLength = getLengthFactory(1),\r\n        getPointAtLength = getLengthFactory(),\r\n        getSubpathsAtLength = getLengthFactory(0, 1);\r\n    /*\\\r\n     * Raphael.getTotalLength\r\n     [ method ]\r\n     **\r\n     * Returns length of the given path in pixels.\r\n     **\r\n     > Parameters\r\n     **\r\n     - path (string) SVG path string.\r\n     **\r\n     = (number) length.\r\n     \\*/\r\n    R.getTotalLength = getTotalLength;\r\n    /*\\\r\n     * Raphael.getPointAtLength\r\n     [ method ]\r\n     **\r\n     * Return coordinates of the point located at the given length on the given path.\r\n     **\r\n     > Parameters\r\n     **\r\n     - path (string) SVG path string\r\n     - length (number)\r\n     **\r\n     = (object) representation of the point:\r\n     o {\r\n     o     x: (number) x coordinate\r\n     o     y: (number) y coordinate\r\n     o     alpha: (number) angle of derivative\r\n     o }\r\n     \\*/\r\n    R.getPointAtLength = getPointAtLength;\r\n    /*\\\r\n     * Raphael.getSubpath\r\n     [ method ]\r\n     **\r\n     * Return subpath of a given path from given length to given length.\r\n     **\r\n     > Parameters\r\n     **\r\n     - path (string) SVG path string\r\n     - from (number) position of the start of the segment\r\n     - to (number) position of the end of the segment\r\n     **\r\n     = (string) pathstring for the segment\r\n     \\*/\r\n    R.getSubpath = function (path, from, to) {\r\n        if (this.getTotalLength(path) - to < 1e-6) {\r\n            return getSubpathsAtLength(path, from).end;\r\n        }\r\n        var a = getSubpathsAtLength(path, to, 1);\r\n        return from ? getSubpathsAtLength(a, from).end : a;\r\n    };\r\n    /*\\\r\n     * Element.getTotalLength\r\n     [ method ]\r\n     **\r\n     * Returns length of the path in pixels. Only works for element of “path” type.\r\n     = (number) length.\r\n     \\*/\r\n    elproto.getTotalLength = function () {\r\n        var path = this.getPath();\r\n        if (!path) {\r\n            return;\r\n        }\r\n\r\n        if (this.node.getTotalLength) {\r\n            return this.node.getTotalLength();\r\n        }\r\n\r\n        return getTotalLength(path);\r\n    };\r\n    /*\\\r\n     * Element.getPointAtLength\r\n     [ method ]\r\n     **\r\n     * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.\r\n     **\r\n     > Parameters\r\n     **\r\n     - length (number)\r\n     **\r\n     = (object) representation of the point:\r\n     o {\r\n     o     x: (number) x coordinate\r\n     o     y: (number) y coordinate\r\n     o     alpha: (number) angle of derivative\r\n     o }\r\n     \\*/\r\n    elproto.getPointAtLength = function (length) {\r\n        var path = this.getPath();\r\n        if (!path) {\r\n            return;\r\n        }\r\n\r\n        return getPointAtLength(path, length);\r\n    };\r\n    /*\\\r\n     * Element.getPath\r\n     [ method ]\r\n     **\r\n     * Returns path of the element. Only works for elements of “path” type and simple elements like circle.\r\n     = (object) path\r\n     **\r\n     \\*/\r\n    elproto.getPath = function () {\r\n        var path,\r\n            getPath = R._getPath[this.type];\r\n\r\n        if (this.type == \"text\" || this.type == \"set\") {\r\n            return;\r\n        }\r\n\r\n        if (getPath) {\r\n            path = getPath(this);\r\n        }\r\n\r\n        return path;\r\n    };\r\n    /*\\\r\n     * Element.getSubpath\r\n     [ method ]\r\n     **\r\n     * Return subpath of a given element from given length to given length. Only works for element of “path” type.\r\n     **\r\n     > Parameters\r\n     **\r\n     - from (number) position of the start of the segment\r\n     - to (number) position of the end of the segment\r\n     **\r\n     = (string) pathstring for the segment\r\n     \\*/\r\n    elproto.getSubpath = function (from, to) {\r\n        var path = this.getPath();\r\n        if (!path) {\r\n            return;\r\n        }\r\n\r\n        return R.getSubpath(path, from, to);\r\n    };\r\n    /*\\\r\n     * Raphael.easing_formulas\r\n     [ property ]\r\n     **\r\n     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:\r\n     # <ul>\r\n     #     <li>“linear”</li>\r\n     #     <li>“&lt;” or “easeIn” or “ease-in”</li>\r\n     #     <li>“>” or “easeOut” or “ease-out”</li>\r\n     #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>\r\n     #     <li>“backIn” or “back-in”</li>\r\n     #     <li>“backOut” or “back-out”</li>\r\n     #     <li>“elastic”</li>\r\n     #     <li>“bounce”</li>\r\n     # </ul>\r\n     # <p>See also <a href=\"http://raphaeljs.com/easing.html\">Easing demo</a>.</p>\r\n     \\*/\r\n    var ef = R.easing_formulas = {\r\n        linear: function (n) {\r\n            return n;\r\n        },\r\n        \"<\": function (n) {\r\n            return pow(n, 1.7);\r\n        },\r\n        \">\": function (n) {\r\n            return pow(n, .48);\r\n        },\r\n        \"<>\": function (n) {\r\n            var q = .48 - n / 1.04,\r\n                Q = math.sqrt(.1734 + q * q),\r\n                x = Q - q,\r\n                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),\r\n                y = -Q - q,\r\n                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),\r\n                t = X + Y + .5;\r\n            return (1 - t) * 3 * t * t + t * t * t;\r\n        },\r\n        backIn: function (n) {\r\n            var s = 1.70158;\r\n            return n * n * ((s + 1) * n - s);\r\n        },\r\n        backOut: function (n) {\r\n            n = n - 1;\r\n            var s = 1.70158;\r\n            return n * n * ((s + 1) * n + s) + 1;\r\n        },\r\n        elastic: function (n) {\r\n            if (n == !!n) {\r\n                return n;\r\n            }\r\n            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;\r\n        },\r\n        bounce: function (n) {\r\n            var s = 7.5625,\r\n                p = 2.75,\r\n                l;\r\n            if (n < (1 / p)) {\r\n                l = s * n * n;\r\n            } else {\r\n                if (n < (2 / p)) {\r\n                    n -= (1.5 / p);\r\n                    l = s * n * n + .75;\r\n                } else {\r\n                    if (n < (2.5 / p)) {\r\n                        n -= (2.25 / p);\r\n                        l = s * n * n + .9375;\r\n                    } else {\r\n                        n -= (2.625 / p);\r\n                        l = s * n * n + .984375;\r\n                    }\r\n                }\r\n            }\r\n            return l;\r\n        }\r\n    };\r\n    ef.easeIn = ef[\"ease-in\"] = ef[\"<\"];\r\n    ef.easeOut = ef[\"ease-out\"] = ef[\">\"];\r\n    ef.easeInOut = ef[\"ease-in-out\"] = ef[\"<>\"];\r\n    ef[\"back-in\"] = ef.backIn;\r\n    ef[\"back-out\"] = ef.backOut;\r\n\r\n    var animationElements = [],\r\n        requestAnimFrame = window.requestAnimationFrame       ||\r\n            window.webkitRequestAnimationFrame ||\r\n            window.mozRequestAnimationFrame    ||\r\n            window.oRequestAnimationFrame      ||\r\n            window.msRequestAnimationFrame     ||\r\n            function (callback) {\r\n                setTimeout(callback, 16);\r\n            },\r\n        animation = function () {\r\n            var Now = +new Date,\r\n                l = 0;\r\n            for (; l < animationElements.length; l++) {\r\n                var e = animationElements[l];\r\n                if (e.el.removed || e.paused) {\r\n                    continue;\r\n                }\r\n                var time = Now - e.start,\r\n                    ms = e.ms,\r\n                    easing = e.easing,\r\n                    from = e.from,\r\n                    diff = e.diff,\r\n                    to = e.to,\r\n                    t = e.t,\r\n                    that = e.el,\r\n                    set = {},\r\n                    now,\r\n                    init = {},\r\n                    key;\r\n                if (e.initstatus) {\r\n                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;\r\n                    e.status = e.initstatus;\r\n                    delete e.initstatus;\r\n                    e.stop && animationElements.splice(l--, 1);\r\n                } else {\r\n                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;\r\n                }\r\n                if (time < 0) {\r\n                    continue;\r\n                }\r\n                if (time < ms) {\r\n                    var pos = easing(time / ms);\r\n                    for (var attr in from) if (from[has](attr)) {\r\n                        switch (availableAnimAttrs[attr]) {\r\n                            case nu:\r\n                                now = +from[attr] + pos * ms * diff[attr];\r\n                                break;\r\n                            case \"colour\":\r\n                                now = \"rgb(\" + [\r\n                                        upto255(round(from[attr].r + pos * ms * diff[attr].r)),\r\n                                        upto255(round(from[attr].g + pos * ms * diff[attr].g)),\r\n                                        upto255(round(from[attr].b + pos * ms * diff[attr].b))\r\n                                    ].join(\",\") + \")\";\r\n                                break;\r\n                            case \"path\":\r\n                                now = [];\r\n                                for (var i = 0, ii = from[attr].length; i < ii; i++) {\r\n                                    now[i] = [from[attr][i][0]];\r\n                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\r\n                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];\r\n                                    }\r\n                                    now[i] = now[i].join(S);\r\n                                }\r\n                                now = now.join(S);\r\n                                break;\r\n                            case \"transform\":\r\n                                if (diff[attr].real) {\r\n                                    now = [];\r\n                                    for (i = 0, ii = from[attr].length; i < ii; i++) {\r\n                                        now[i] = [from[attr][i][0]];\r\n                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {\r\n                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    var get = function (i) {\r\n                                        return +from[attr][i] + pos * ms * diff[attr][i];\r\n                                    };\r\n                                    // now = [[\"r\", get(2), 0, 0], [\"t\", get(3), get(4)], [\"s\", get(0), get(1), 0, 0]];\r\n                                    now = [[\"m\", get(0), get(1), get(2), get(3), get(4), get(5)]];\r\n                                }\r\n                                break;\r\n                            case \"csv\":\r\n                                if (attr == \"clip-rect\") {\r\n                                    now = [];\r\n                                    i = 4;\r\n                                    while (i--) {\r\n                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];\r\n                                    }\r\n                                }\r\n                                break;\r\n                            default:\r\n                                var from2 = [][concat](from[attr]);\r\n                                now = [];\r\n                                i = that.paper.customAttributes[attr].length;\r\n                                while (i--) {\r\n                                    now[i] = +from2[i] + pos * ms * diff[attr][i];\r\n                                }\r\n                                break;\r\n                        }\r\n                        set[attr] = now;\r\n                    }\r\n                    that.attr(set);\r\n                    (function (id, that, anim) {\r\n                        setTimeout(function () {\r\n                            eve(\"raphael.anim.frame.\" + id, that, anim);\r\n                        });\r\n                    })(that.id, that, e.anim);\r\n                } else {\r\n                    (function(f, el, a) {\r\n                        setTimeout(function() {\r\n                            eve(\"raphael.anim.frame.\" + el.id, el, a);\r\n                            eve(\"raphael.anim.finish.\" + el.id, el, a);\r\n                            R.is(f, \"function\") && f.call(el);\r\n                        });\r\n                    })(e.callback, that, e.anim);\r\n                    that.attr(to);\r\n                    animationElements.splice(l--, 1);\r\n                    if (e.repeat > 1 && !e.next) {\r\n                        for (key in to) if (to[has](key)) {\r\n                            init[key] = e.totalOrigin[key];\r\n                        }\r\n                        e.el.attr(init);\r\n                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);\r\n                    }\r\n                    if (e.next && !e.stop) {\r\n                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);\r\n                    }\r\n                }\r\n            }\r\n            animationElements.length && requestAnimFrame(animation);\r\n        },\r\n        upto255 = function (color) {\r\n            return color > 255 ? 255 : color < 0 ? 0 : color;\r\n        };\r\n    /*\\\r\n     * Element.animateWith\r\n     [ method ]\r\n     **\r\n     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - el (object) element to sync with\r\n     - anim (object) animation to sync with\r\n     - params (object) #optional final attributes for the element, see also @Element.attr\r\n     - ms (number) #optional number of milliseconds for animation to run\r\n     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\r\n     - callback (function) #optional callback function. Will be called at the end of animation.\r\n     * or\r\n     - element (object) element to sync with\r\n     - anim (object) animation to sync with\r\n     - animation (object) #optional animation object, see @Raphael.animation\r\n     **\r\n     = (object) original element\r\n     \\*/\r\n    elproto.animateWith = function (el, anim, params, ms, easing, callback) {\r\n        var element = this;\r\n        if (element.removed) {\r\n            callback && callback.call(element);\r\n            return element;\r\n        }\r\n        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),\r\n            x, y;\r\n        runAnimation(a, element, a.percents[0], null, element.attr());\r\n        for (var i = 0, ii = animationElements.length; i < ii; i++) {\r\n            if (animationElements[i].anim == anim && animationElements[i].el == el) {\r\n                animationElements[ii - 1].start = animationElements[i].start;\r\n                break;\r\n            }\r\n        }\r\n        return element;\r\n        //\r\n        //\r\n        // var a = params ? R.animation(params, ms, easing, callback) : anim,\r\n        //     status = element.status(anim);\r\n        // return this.animate(a).status(a, status * anim.ms / a.ms);\r\n    };\r\n    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {\r\n        var cx = 3 * p1x,\r\n            bx = 3 * (p2x - p1x) - cx,\r\n            ax = 1 - cx - bx,\r\n            cy = 3 * p1y,\r\n            by = 3 * (p2y - p1y) - cy,\r\n            ay = 1 - cy - by;\r\n        function sampleCurveX(t) {\r\n            return ((ax * t + bx) * t + cx) * t;\r\n        }\r\n        function solve(x, epsilon) {\r\n            var t = solveCurveX(x, epsilon);\r\n            return ((ay * t + by) * t + cy) * t;\r\n        }\r\n        function solveCurveX(x, epsilon) {\r\n            var t0, t1, t2, x2, d2, i;\r\n            for(t2 = x, i = 0; i < 8; i++) {\r\n                x2 = sampleCurveX(t2) - x;\r\n                if (abs(x2) < epsilon) {\r\n                    return t2;\r\n                }\r\n                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;\r\n                if (abs(d2) < 1e-6) {\r\n                    break;\r\n                }\r\n                t2 = t2 - x2 / d2;\r\n            }\r\n            t0 = 0;\r\n            t1 = 1;\r\n            t2 = x;\r\n            if (t2 < t0) {\r\n                return t0;\r\n            }\r\n            if (t2 > t1) {\r\n                return t1;\r\n            }\r\n            while (t0 < t1) {\r\n                x2 = sampleCurveX(t2);\r\n                if (abs(x2 - x) < epsilon) {\r\n                    return t2;\r\n                }\r\n                if (x > x2) {\r\n                    t0 = t2;\r\n                } else {\r\n                    t1 = t2;\r\n                }\r\n                t2 = (t1 - t0) / 2 + t0;\r\n            }\r\n            return t2;\r\n        }\r\n        return solve(t, 1 / (200 * duration));\r\n    }\r\n    elproto.onAnimation = function (f) {\r\n        f ? eve.on(\"raphael.anim.frame.\" + this.id, f) : eve.unbind(\"raphael.anim.frame.\" + this.id);\r\n        return this;\r\n    };\r\n    function Animation(anim, ms) {\r\n        var percents = [],\r\n            newAnim = {};\r\n        this.ms = ms;\r\n        this.times = 1;\r\n        if (anim) {\r\n            for (var attr in anim) if (anim[has](attr)) {\r\n                newAnim[toFloat(attr)] = anim[attr];\r\n                percents.push(toFloat(attr));\r\n            }\r\n            percents.sort(sortByNumber);\r\n        }\r\n        this.anim = newAnim;\r\n        this.top = percents[percents.length - 1];\r\n        this.percents = percents;\r\n    }\r\n    /*\\\r\n     * Animation.delay\r\n     [ method ]\r\n     **\r\n     * Creates a copy of existing animation object with given delay.\r\n     **\r\n     > Parameters\r\n     **\r\n     - delay (number) number of ms to pass between animation start and actual animation\r\n     **\r\n     = (object) new altered Animation object\r\n     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);\r\n     | circle1.animate(anim); // run the given animation immediately\r\n     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms\r\n     \\*/\r\n    Animation.prototype.delay = function (delay) {\r\n        var a = new Animation(this.anim, this.ms);\r\n        a.times = this.times;\r\n        a.del = +delay || 0;\r\n        return a;\r\n    };\r\n    /*\\\r\n     * Animation.repeat\r\n     [ method ]\r\n     **\r\n     * Creates a copy of existing animation object with given repetition.\r\n     **\r\n     > Parameters\r\n     **\r\n     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`\r\n     **\r\n     = (object) new altered Animation object\r\n     \\*/\r\n    Animation.prototype.repeat = function (times) {\r\n        var a = new Animation(this.anim, this.ms);\r\n        a.del = this.del;\r\n        a.times = math.floor(mmax(times, 0)) || 1;\r\n        return a;\r\n    };\r\n    function runAnimation(anim, element, percent, status, totalOrigin, times) {\r\n        percent = toFloat(percent);\r\n        var params,\r\n            isInAnim,\r\n            isInAnimSet,\r\n            percents = [],\r\n            next,\r\n            prev,\r\n            timestamp,\r\n            ms = anim.ms,\r\n            from = {},\r\n            to = {},\r\n            diff = {};\r\n        if (status) {\r\n            for (i = 0, ii = animationElements.length; i < ii; i++) {\r\n                var e = animationElements[i];\r\n                if (e.el.id == element.id && e.anim == anim) {\r\n                    if (e.percent != percent) {\r\n                        animationElements.splice(i, 1);\r\n                        isInAnimSet = 1;\r\n                    } else {\r\n                        isInAnim = e;\r\n                    }\r\n                    element.attr(e.totalOrigin);\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            status = +to; // NaN\r\n        }\r\n        for (var i = 0, ii = anim.percents.length; i < ii; i++) {\r\n            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {\r\n                percent = anim.percents[i];\r\n                prev = anim.percents[i - 1] || 0;\r\n                ms = ms / anim.top * (percent - prev);\r\n                next = anim.percents[i + 1];\r\n                params = anim.anim[percent];\r\n                break;\r\n            } else if (status) {\r\n                element.attr(anim.anim[anim.percents[i]]);\r\n            }\r\n        }\r\n        if (!params) {\r\n            return;\r\n        }\r\n        if (!isInAnim) {\r\n            for (var attr in params) if (params[has](attr)) {\r\n                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {\r\n                    from[attr] = element.attr(attr);\r\n                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);\r\n                    to[attr] = params[attr];\r\n                    switch (availableAnimAttrs[attr]) {\r\n                        case nu:\r\n                            diff[attr] = (to[attr] - from[attr]) / ms;\r\n                            break;\r\n                        case \"colour\":\r\n                            from[attr] = R.getRGB(from[attr]);\r\n                            var toColour = R.getRGB(to[attr]);\r\n                            diff[attr] = {\r\n                                r: (toColour.r - from[attr].r) / ms,\r\n                                g: (toColour.g - from[attr].g) / ms,\r\n                                b: (toColour.b - from[attr].b) / ms\r\n                            };\r\n                            break;\r\n                        case \"path\":\r\n                            var pathes = path2curve(from[attr], to[attr]),\r\n                                toPath = pathes[1];\r\n                            from[attr] = pathes[0];\r\n                            diff[attr] = [];\r\n                            for (i = 0, ii = from[attr].length; i < ii; i++) {\r\n                                diff[attr][i] = [0];\r\n                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {\r\n                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"transform\":\r\n                            var _ = element._,\r\n                                eq = equaliseTransform(_[attr], to[attr]);\r\n                            if (eq) {\r\n                                from[attr] = eq.from;\r\n                                to[attr] = eq.to;\r\n                                diff[attr] = [];\r\n                                diff[attr].real = true;\r\n                                for (i = 0, ii = from[attr].length; i < ii; i++) {\r\n                                    diff[attr][i] = [from[attr][i][0]];\r\n                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {\r\n                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                var m = (element.matrix || new Matrix),\r\n                                    to2 = {\r\n                                        _: {transform: _.transform},\r\n                                        getBBox: function () {\r\n                                            return element.getBBox(1);\r\n                                        }\r\n                                    };\r\n                                from[attr] = [\r\n                                    m.a,\r\n                                    m.b,\r\n                                    m.c,\r\n                                    m.d,\r\n                                    m.e,\r\n                                    m.f\r\n                                ];\r\n                                extractTransform(to2, to[attr]);\r\n                                to[attr] = to2._.transform;\r\n                                diff[attr] = [\r\n                                    (to2.matrix.a - m.a) / ms,\r\n                                    (to2.matrix.b - m.b) / ms,\r\n                                    (to2.matrix.c - m.c) / ms,\r\n                                    (to2.matrix.d - m.d) / ms,\r\n                                    (to2.matrix.e - m.e) / ms,\r\n                                    (to2.matrix.f - m.f) / ms\r\n                                ];\r\n                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];\r\n                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};\r\n                                // extractTransform(to2, to[attr]);\r\n                                // diff[attr] = [\r\n                                //     (to2._.sx - _.sx) / ms,\r\n                                //     (to2._.sy - _.sy) / ms,\r\n                                //     (to2._.deg - _.deg) / ms,\r\n                                //     (to2._.dx - _.dx) / ms,\r\n                                //     (to2._.dy - _.dy) / ms\r\n                                // ];\r\n                            }\r\n                            break;\r\n                        case \"csv\":\r\n                            var values = Str(params[attr])[split](separator),\r\n                                from2 = Str(from[attr])[split](separator);\r\n                            if (attr == \"clip-rect\") {\r\n                                from[attr] = from2;\r\n                                diff[attr] = [];\r\n                                i = from2.length;\r\n                                while (i--) {\r\n                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;\r\n                                }\r\n                            }\r\n                            to[attr] = values;\r\n                            break;\r\n                        default:\r\n                            values = [][concat](params[attr]);\r\n                            from2 = [][concat](from[attr]);\r\n                            diff[attr] = [];\r\n                            i = element.paper.customAttributes[attr].length;\r\n                            while (i--) {\r\n                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            var easing = params.easing,\r\n                easyeasy = R.easing_formulas[easing];\r\n            if (!easyeasy) {\r\n                easyeasy = Str(easing).match(bezierrg);\r\n                if (easyeasy && easyeasy.length == 5) {\r\n                    var curve = easyeasy;\r\n                    easyeasy = function (t) {\r\n                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);\r\n                    };\r\n                } else {\r\n                    easyeasy = pipe;\r\n                }\r\n            }\r\n            timestamp = params.start || anim.start || +new Date;\r\n            e = {\r\n                anim: anim,\r\n                percent: percent,\r\n                timestamp: timestamp,\r\n                start: timestamp + (anim.del || 0),\r\n                status: 0,\r\n                initstatus: status || 0,\r\n                stop: false,\r\n                ms: ms,\r\n                easing: easyeasy,\r\n                from: from,\r\n                diff: diff,\r\n                to: to,\r\n                el: element,\r\n                callback: params.callback,\r\n                prev: prev,\r\n                next: next,\r\n                repeat: times || anim.times,\r\n                origin: element.attr(),\r\n                totalOrigin: totalOrigin\r\n            };\r\n            animationElements.push(e);\r\n            if (status && !isInAnim && !isInAnimSet) {\r\n                e.stop = true;\r\n                e.start = new Date - ms * status;\r\n                if (animationElements.length == 1) {\r\n                    return animation();\r\n                }\r\n            }\r\n            if (isInAnimSet) {\r\n                e.start = new Date - e.ms * status;\r\n            }\r\n            animationElements.length == 1 && requestAnimFrame(animation);\r\n        } else {\r\n            isInAnim.initstatus = status;\r\n            isInAnim.start = new Date - isInAnim.ms * status;\r\n        }\r\n        eve(\"raphael.anim.start.\" + element.id, element, anim);\r\n    }\r\n    /*\\\r\n     * Raphael.animation\r\n     [ method ]\r\n     **\r\n     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.\r\n     * See also @Animation.delay and @Animation.repeat methods.\r\n     **\r\n     > Parameters\r\n     **\r\n     - params (object) final attributes for the element, see also @Element.attr\r\n     - ms (number) number of milliseconds for animation to run\r\n     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\r\n     - callback (function) #optional callback function. Will be called at the end of animation.\r\n     **\r\n     = (object) @Animation\r\n     \\*/\r\n    R.animation = function (params, ms, easing, callback) {\r\n        if (params instanceof Animation) {\r\n            return params;\r\n        }\r\n        if (R.is(easing, \"function\") || !easing) {\r\n            callback = callback || easing || null;\r\n            easing = null;\r\n        }\r\n        params = Object(params);\r\n        ms = +ms || 0;\r\n        var p = {},\r\n            json,\r\n            attr;\r\n        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + \"%\" != attr) {\r\n            json = true;\r\n            p[attr] = params[attr];\r\n        }\r\n        if (!json) {\r\n            // if percent-like syntax is used and end-of-all animation callback used\r\n            if(callback){\r\n                // find the last one\r\n                var lastKey = 0;\r\n                for(var i in params){\r\n                    var percent = toInt(i);\r\n                    if(params[has](i) && percent > lastKey){\r\n                        lastKey = percent;\r\n                    }\r\n                }\r\n                lastKey += '%';\r\n                // if already defined callback in the last keyframe, skip\r\n                !params[lastKey].callback && (params[lastKey].callback = callback);\r\n            }\r\n            return new Animation(params, ms);\r\n        } else {\r\n            easing && (p.easing = easing);\r\n            callback && (p.callback = callback);\r\n            return new Animation({100: p}, ms);\r\n        }\r\n    };\r\n    /*\\\r\n     * Element.animate\r\n     [ method ]\r\n     **\r\n     * Creates and starts animation for given element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - params (object) final attributes for the element, see also @Element.attr\r\n     - ms (number) number of milliseconds for animation to run\r\n     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`\r\n     - callback (function) #optional callback function. Will be called at the end of animation.\r\n     * or\r\n     - animation (object) animation object, see @Raphael.animation\r\n     **\r\n     = (object) original element\r\n     \\*/\r\n    elproto.animate = function (params, ms, easing, callback) {\r\n        var element = this;\r\n        if (element.removed) {\r\n            callback && callback.call(element);\r\n            return element;\r\n        }\r\n        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);\r\n        runAnimation(anim, element, anim.percents[0], null, element.attr());\r\n        return element;\r\n    };\r\n    /*\\\r\n     * Element.setTime\r\n     [ method ]\r\n     **\r\n     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) animation object\r\n     - value (number) number of milliseconds from the beginning of the animation\r\n     **\r\n     = (object) original element if `value` is specified\r\n     * Note, that during animation following events are triggered:\r\n     *\r\n     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.\r\n     \\*/\r\n    elproto.setTime = function (anim, value) {\r\n        if (anim && value != null) {\r\n            this.status(anim, mmin(value, anim.ms) / anim.ms);\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.status\r\n     [ method ]\r\n     **\r\n     * Gets or sets the status of animation of the element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.\r\n     **\r\n     = (number) status\r\n     * or\r\n     = (array) status if `anim` is not specified. Array of objects in format:\r\n     o {\r\n     o     anim: (object) animation object\r\n     o     status: (number) status\r\n     o }\r\n     * or\r\n     = (object) original element if `value` is specified\r\n     \\*/\r\n    elproto.status = function (anim, value) {\r\n        var out = [],\r\n            i = 0,\r\n            len,\r\n            e;\r\n        if (value != null) {\r\n            runAnimation(anim, this, -1, mmin(value, 1));\r\n            return this;\r\n        } else {\r\n            len = animationElements.length;\r\n            for (; i < len; i++) {\r\n                e = animationElements[i];\r\n                if (e.el.id == this.id && (!anim || e.anim == anim)) {\r\n                    if (anim) {\r\n                        return e.status;\r\n                    }\r\n                    out.push({\r\n                        anim: e.anim,\r\n                        status: e.status\r\n                    });\r\n                }\r\n            }\r\n            if (anim) {\r\n                return 0;\r\n            }\r\n            return out;\r\n        }\r\n    };\r\n    /*\\\r\n     * Element.pause\r\n     [ method ]\r\n     **\r\n     * Stops animation of the element with ability to resume it later on.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     **\r\n     = (object) original element\r\n     \\*/\r\n    elproto.pause = function (anim) {\r\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\r\n            if (eve(\"raphael.anim.pause.\" + this.id, this, animationElements[i].anim) !== false) {\r\n                animationElements[i].paused = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.resume\r\n     [ method ]\r\n     **\r\n     * Resumes animation if it was paused with @Element.pause method.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     **\r\n     = (object) original element\r\n     \\*/\r\n    elproto.resume = function (anim) {\r\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\r\n            var e = animationElements[i];\r\n            if (eve(\"raphael.anim.resume.\" + this.id, this, e.anim) !== false) {\r\n                delete e.paused;\r\n                this.status(e.anim, e.status);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.stop\r\n     [ method ]\r\n     **\r\n     * Stops animation of the element.\r\n     **\r\n     > Parameters\r\n     **\r\n     - anim (object) #optional animation object\r\n     **\r\n     = (object) original element\r\n     \\*/\r\n    elproto.stop = function (anim) {\r\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {\r\n            if (eve(\"raphael.anim.stop.\" + this.id, this, animationElements[i].anim) !== false) {\r\n                animationElements.splice(i--, 1);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    function stopAnimation(paper) {\r\n        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {\r\n            animationElements.splice(i--, 1);\r\n        }\r\n    }\r\n    eve.on(\"raphael.remove\", stopAnimation);\r\n    eve.on(\"raphael.clear\", stopAnimation);\r\n    elproto.toString = function () {\r\n        return \"Rapha\\xebl\\u2019s object\";\r\n    };\r\n\r\n    // Set\r\n    var Set = function (items) {\r\n            this.items = [];\r\n            this.length = 0;\r\n            this.type = \"set\";\r\n            if (items) {\r\n                for (var i = 0, ii = items.length; i < ii; i++) {\r\n                    if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {\r\n                        this[this.items.length] = this.items[this.items.length] = items[i];\r\n                        this.length++;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        setproto = Set.prototype;\r\n    /*\\\r\n     * Set.push\r\n     [ method ]\r\n     **\r\n     * Adds each argument to the current set.\r\n     = (object) original element\r\n     \\*/\r\n    setproto.push = function () {\r\n        var item,\r\n            len;\r\n        for (var i = 0, ii = arguments.length; i < ii; i++) {\r\n            item = arguments[i];\r\n            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {\r\n                len = this.items.length;\r\n                this[len] = this.items[len] = item;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Set.pop\r\n     [ method ]\r\n     **\r\n     * Removes last element and returns it.\r\n     = (object) element\r\n     \\*/\r\n    setproto.pop = function () {\r\n        this.length && delete this[this.length--];\r\n        return this.items.pop();\r\n    };\r\n    /*\\\r\n     * Set.forEach\r\n     [ method ]\r\n     **\r\n     * Executes given function for each element in the set.\r\n     *\r\n     * If function returns `false` it will stop loop running.\r\n     **\r\n     > Parameters\r\n     **\r\n     - callback (function) function to run\r\n     - thisArg (object) context object for the callback\r\n     = (object) Set object\r\n     \\*/\r\n    setproto.forEach = function (callback, thisArg) {\r\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\r\n            if (callback.call(thisArg, this.items[i], i) === false) {\r\n                return this;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    for (var method in elproto) if (elproto[has](method)) {\r\n        setproto[method] = (function (methodname) {\r\n            return function () {\r\n                var arg = arguments;\r\n                return this.forEach(function (el) {\r\n                    el[methodname][apply](el, arg);\r\n                });\r\n            };\r\n        })(method);\r\n    }\r\n    setproto.attr = function (name, value) {\r\n        if (name && R.is(name, array) && R.is(name[0], \"object\")) {\r\n            for (var j = 0, jj = name.length; j < jj; j++) {\r\n                this.items[j].attr(name[j]);\r\n            }\r\n        } else {\r\n            for (var i = 0, ii = this.items.length; i < ii; i++) {\r\n                this.items[i].attr(name, value);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Set.clear\r\n     [ method ]\r\n     **\r\n     * Removes all elements from the set\r\n     \\*/\r\n    setproto.clear = function () {\r\n        while (this.length) {\r\n            this.pop();\r\n        }\r\n    };\r\n    /*\\\r\n     * Set.splice\r\n     [ method ]\r\n     **\r\n     * Removes given element from the set\r\n     **\r\n     > Parameters\r\n     **\r\n     - index (number) position of the deletion\r\n     - count (number) number of element to remove\r\n     - insertion… (object) #optional elements to insert\r\n     = (object) set elements that were deleted\r\n     \\*/\r\n    setproto.splice = function (index, count, insertion) {\r\n        index = index < 0 ? mmax(this.length + index, 0) : index;\r\n        count = mmax(0, mmin(this.length - index, count));\r\n        var tail = [],\r\n            todel = [],\r\n            args = [],\r\n            i;\r\n        for (i = 2; i < arguments.length; i++) {\r\n            args.push(arguments[i]);\r\n        }\r\n        for (i = 0; i < count; i++) {\r\n            todel.push(this[index + i]);\r\n        }\r\n        for (; i < this.length - index; i++) {\r\n            tail.push(this[index + i]);\r\n        }\r\n        var arglen = args.length;\r\n        for (i = 0; i < arglen + tail.length; i++) {\r\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\r\n        }\r\n        i = this.items.length = this.length -= count - arglen;\r\n        while (this[i]) {\r\n            delete this[i++];\r\n        }\r\n        return new Set(todel);\r\n    };\r\n    /*\\\r\n     * Set.exclude\r\n     [ method ]\r\n     **\r\n     * Removes given element from the set\r\n     **\r\n     > Parameters\r\n     **\r\n     - element (object) element to remove\r\n     = (boolean) `true` if object was found & removed from the set\r\n     \\*/\r\n    setproto.exclude = function (el) {\r\n        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\r\n            this.splice(i, 1);\r\n            return true;\r\n        }\r\n    };\r\n    setproto.animate = function (params, ms, easing, callback) {\r\n        (R.is(easing, \"function\") || !easing) && (callback = easing || null);\r\n        var len = this.items.length,\r\n            i = len,\r\n            item,\r\n            set = this,\r\n            collector;\r\n        if (!len) {\r\n            return this;\r\n        }\r\n        callback && (collector = function () {\r\n            !--len && callback.call(set);\r\n        });\r\n        easing = R.is(easing, string) ? easing : collector;\r\n        var anim = R.animation(params, ms, easing, collector);\r\n        item = this.items[--i].animate(anim);\r\n        while (i--) {\r\n            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);\r\n            (this.items[i] && !this.items[i].removed) || len--;\r\n        }\r\n        return this;\r\n    };\r\n    setproto.insertAfter = function (el) {\r\n        var i = this.items.length;\r\n        while (i--) {\r\n            this.items[i].insertAfter(el);\r\n        }\r\n        return this;\r\n    };\r\n    setproto.getBBox = function () {\r\n        var x = [],\r\n            y = [],\r\n            x2 = [],\r\n            y2 = [];\r\n        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\r\n            var box = this.items[i].getBBox();\r\n            x.push(box.x);\r\n            y.push(box.y);\r\n            x2.push(box.x + box.width);\r\n            y2.push(box.y + box.height);\r\n        }\r\n        x = mmin[apply](0, x);\r\n        y = mmin[apply](0, y);\r\n        x2 = mmax[apply](0, x2);\r\n        y2 = mmax[apply](0, y2);\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            x2: x2,\r\n            y2: y2,\r\n            width: x2 - x,\r\n            height: y2 - y\r\n        };\r\n    };\r\n    setproto.clone = function (s) {\r\n        s = this.paper.set();\r\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\r\n            s.push(this.items[i].clone());\r\n        }\r\n        return s;\r\n    };\r\n    setproto.toString = function () {\r\n        return \"Rapha\\xebl\\u2018s set\";\r\n    };\r\n\r\n    setproto.glow = function(glowConfig) {\r\n        var ret = this.paper.set();\r\n        this.forEach(function(shape, index){\r\n            var g = shape.glow(glowConfig);\r\n            if(g != null){\r\n                g.forEach(function(shape2, index2){\r\n                    ret.push(shape2);\r\n                });\r\n            }\r\n        });\r\n        return ret;\r\n    };\r\n\r\n\r\n    /*\\\r\n     * Set.isPointInside\r\n     [ method ]\r\n     **\r\n     * Determine if given point is inside this set’s elements\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x coordinate of the point\r\n     - y (number) y coordinate of the point\r\n     = (boolean) `true` if point is inside any of the set's elements\r\n     \\*/\r\n    setproto.isPointInside = function (x, y) {\r\n        var isPointInside = false;\r\n        this.forEach(function (el) {\r\n            if (el.isPointInside(x, y)) {\r\n                isPointInside = true;\r\n                return false; // stop loop\r\n            }\r\n        });\r\n        return isPointInside;\r\n    };\r\n\r\n    /*\\\r\n     * Raphael.registerFont\r\n     [ method ]\r\n     **\r\n     * Adds given font to the registered set of font for Raphaël. Should be used as an internal call from within Cufón’s font file.\r\n     * Returns original parameter, so it could be used with chaining.\r\n     # <a href=\"http://wiki.github.com/sorccu/cufon/about\">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>\r\n     **\r\n     > Parameters\r\n     **\r\n     - font (object) the font to register\r\n     = (object) the font you passed in\r\n     > Usage\r\n     | Cufon.registerFont(Raphael.registerFont({…}));\r\n     \\*/\r\n    R.registerFont = function (font) {\r\n        if (!font.face) {\r\n            return font;\r\n        }\r\n        this.fonts = this.fonts || {};\r\n        var fontcopy = {\r\n                w: font.w,\r\n                face: {},\r\n                glyphs: {}\r\n            },\r\n            family = font.face[\"font-family\"];\r\n        for (var prop in font.face) if (font.face[has](prop)) {\r\n            fontcopy.face[prop] = font.face[prop];\r\n        }\r\n        if (this.fonts[family]) {\r\n            this.fonts[family].push(fontcopy);\r\n        } else {\r\n            this.fonts[family] = [fontcopy];\r\n        }\r\n        if (!font.svg) {\r\n            fontcopy.face[\"units-per-em\"] = toInt(font.face[\"units-per-em\"], 10);\r\n            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {\r\n                var path = font.glyphs[glyph];\r\n                fontcopy.glyphs[glyph] = {\r\n                    w: path.w,\r\n                    k: {},\r\n                    d: path.d && \"M\" + path.d.replace(/[mlcxtrv]/g, function (command) {\r\n                        return {l: \"L\", c: \"C\", x: \"z\", t: \"m\", r: \"l\", v: \"c\"}[command] || \"M\";\r\n                    }) + \"z\"\r\n                };\r\n                if (path.k) {\r\n                    for (var k in path.k) if (path[has](k)) {\r\n                        fontcopy.glyphs[glyph].k[k] = path.k[k];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return font;\r\n    };\r\n    /*\\\r\n     * Paper.getFont\r\n     [ method ]\r\n     **\r\n     * Finds font object in the registered font by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.\r\n     **\r\n     > Parameters\r\n     **\r\n     - family (string) font family name or any word from it\r\n     - weight (string) #optional font weight\r\n     - style (string) #optional font style\r\n     - stretch (string) #optional font stretch\r\n     = (object) the font object\r\n     > Usage\r\n     | paper.print(100, 100, \"Test string\", paper.getFont(\"Times\", 800), 30);\r\n     \\*/\r\n    paperproto.getFont = function (family, weight, style, stretch) {\r\n        stretch = stretch || \"normal\";\r\n        style = style || \"normal\";\r\n        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;\r\n        if (!R.fonts) {\r\n            return;\r\n        }\r\n        var font = R.fonts[family];\r\n        if (!font) {\r\n            var name = new RegExp(\"(^|\\\\s)\" + family.replace(/[^\\w\\d\\s+!~.:_-]/g, E) + \"(\\\\s|$)\", \"i\");\r\n            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {\r\n                if (name.test(fontName)) {\r\n                    font = R.fonts[fontName];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        var thefont;\r\n        if (font) {\r\n            for (var i = 0, ii = font.length; i < ii; i++) {\r\n                thefont = font[i];\r\n                if (thefont.face[\"font-weight\"] == weight && (thefont.face[\"font-style\"] == style || !thefont.face[\"font-style\"]) && thefont.face[\"font-stretch\"] == stretch) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return thefont;\r\n    };\r\n    /*\\\r\n     * Paper.print\r\n     [ method ]\r\n     **\r\n     * Creates path that represent given text written using given font at given position with given size.\r\n     * Result of the method is path element that contains whole text as a separate path.\r\n     **\r\n     > Parameters\r\n     **\r\n     - x (number) x position of the text\r\n     - y (number) y position of the text\r\n     - string (string) text to print\r\n     - font (object) font object, see @Paper.getFont\r\n     - size (number) #optional size of the font, default is `16`\r\n     - origin (string) #optional could be `\"baseline\"` or `\"middle\"`, default is `\"middle\"`\r\n     - letter_spacing (number) #optional number in range `-1..1`, default is `0`\r\n     - line_spacing (number) #optional number in range `1..3`, default is `1`\r\n     = (object) resulting path element, which consist of all letters\r\n     > Usage\r\n     | var txt = r.print(10, 50, \"print\", r.getFont(\"Museo\"), 30).attr({fill: \"#fff\"});\r\n     \\*/\r\n    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {\r\n        origin = origin || \"middle\"; // baseline|middle\r\n        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);\r\n        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);\r\n        var letters = Str(string)[split](E),\r\n            shift = 0,\r\n            notfirst = 0,\r\n            path = E,\r\n            scale;\r\n        R.is(font, \"string\") && (font = this.getFont(font));\r\n        if (font) {\r\n            scale = (size || 16) / font.face[\"units-per-em\"];\r\n            var bb = font.face.bbox[split](separator),\r\n                top = +bb[0],\r\n                lineHeight = bb[3] - bb[1],\r\n                shifty = 0,\r\n                height = +bb[1] + (origin == \"baseline\" ? lineHeight + (+font.face.descent) : lineHeight / 2);\r\n            for (var i = 0, ii = letters.length; i < ii; i++) {\r\n                if (letters[i] == \"\\n\") {\r\n                    shift = 0;\r\n                    curr = 0;\r\n                    notfirst = 0;\r\n                    shifty += lineHeight * line_spacing;\r\n                } else {\r\n                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},\r\n                        curr = font.glyphs[letters[i]];\r\n                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;\r\n                    notfirst = 1;\r\n                }\r\n                if (curr && curr.d) {\r\n                    path += R.transformPath(curr.d, [\"t\", shift * scale, shifty * scale, \"s\", scale, scale, top, height, \"t\", (x - top) / scale, (y - height) / scale]);\r\n                }\r\n            }\r\n        }\r\n        return this.path(path).attr({\r\n            fill: \"#000\",\r\n            stroke: \"none\"\r\n        });\r\n    };\r\n\r\n    /*\\\r\n     * Paper.add\r\n     [ method ]\r\n     **\r\n     * Imports elements in JSON array in format `{type: type, <attributes>}`\r\n     **\r\n     > Parameters\r\n     **\r\n     - json (array)\r\n     = (object) resulting set of imported elements\r\n     > Usage\r\n     | paper.add([\r\n     |     {\r\n     |         type: \"circle\",\r\n     |         cx: 10,\r\n     |         cy: 10,\r\n     |         r: 5\r\n     |     },\r\n     |     {\r\n     |         type: \"rect\",\r\n     |         x: 10,\r\n     |         y: 10,\r\n     |         width: 10,\r\n     |         height: 10,\r\n     |         fill: \"#fc0\"\r\n     |     }\r\n     | ]);\r\n     \\*/\r\n    paperproto.add = function (json) {\r\n        if (R.is(json, \"array\")) {\r\n            var res = this.set(),\r\n                i = 0,\r\n                ii = json.length,\r\n                j;\r\n            for (; i < ii; i++) {\r\n                j = json[i] || {};\r\n                elements[has](j.type) && res.push(this[j.type]().attr(j));\r\n            }\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /*\\\r\n     * Raphael.format\r\n     [ method ]\r\n     **\r\n     * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.\r\n     **\r\n     > Parameters\r\n     **\r\n     - token (string) string to format\r\n     - … (string) rest of arguments will be treated as parameters for replacement\r\n     = (string) formated string\r\n     > Usage\r\n     | var x = 10,\r\n     |     y = 20,\r\n     |     width = 40,\r\n     |     height = 50;\r\n     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\r\n     | paper.path(Raphael.format(\"M{0},{1}h{2}v{3}h{4}z\", x, y, width, height, -width));\r\n     \\*/\r\n    R.format = function (token, params) {\r\n        var args = R.is(params, array) ? [0][concat](params) : arguments;\r\n        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {\r\n            return args[++i] == null ? E : args[i];\r\n        }));\r\n        return token || E;\r\n    };\r\n    /*\\\r\n     * Raphael.fullfill\r\n     [ method ]\r\n     **\r\n     * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.\r\n     **\r\n     > Parameters\r\n     **\r\n     - token (string) string to format\r\n     - json (object) object which properties will be used as a replacement\r\n     = (string) formated string\r\n     > Usage\r\n     | // this will draw a rectangular shape equivalent to \"M10,20h40v50h-40z\"\r\n     | paper.path(Raphael.fullfill(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\r\n     |     x: 10,\r\n     |     y: 20,\r\n     |     dim: {\r\n     |         width: 40,\r\n     |         height: 50,\r\n     |         \"negative width\": -40\r\n     |     }\r\n     | }));\r\n     \\*/\r\n    R.fullfill = (function () {\r\n        var tokenRegex = /\\{([^\\}]+)\\}/g,\r\n            objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\r\n            replacer = function (all, key, obj) {\r\n                var res = obj;\r\n                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\r\n                    name = name || quotedName;\r\n                    if (res) {\r\n                        if (name in res) {\r\n                            res = res[name];\r\n                        }\r\n                        typeof res == \"function\" && isFunc && (res = res());\r\n                    }\r\n                });\r\n                res = (res == null || res == obj ? all : res) + \"\";\r\n                return res;\r\n            };\r\n        return function (str, obj) {\r\n            return String(str).replace(tokenRegex, function (all, key) {\r\n                return replacer(all, key, obj);\r\n            });\r\n        };\r\n    })();\r\n    /*\\\r\n     * Raphael.ninja\r\n     [ method ]\r\n     **\r\n     * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.\r\n     * Beware, that in this case plugins could stop working, because they are depending on global variable existence.\r\n     **\r\n     = (object) Raphael object\r\n     > Usage\r\n     | (function (local_raphael) {\r\n     |     var paper = local_raphael(10, 10, 320, 200);\r\n     |     …\r\n     | })(Raphael.ninja());\r\n     \\*/\r\n    R.ninja = function () {\r\n        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;\r\n        return R;\r\n    };\r\n    /*\\\r\n     * Raphael.st\r\n     [ property (object) ]\r\n     **\r\n     * You can add your own method to elements and sets. It is wise to add a set method for each element method\r\n     * you added, so you will be able to call the same method on sets too.\r\n     **\r\n     * See also @Raphael.el.\r\n     > Usage\r\n     | Raphael.el.red = function () {\r\n     |     this.attr({fill: \"#f00\"});\r\n     | };\r\n     | Raphael.st.red = function () {\r\n     |     this.forEach(function (el) {\r\n     |         el.red();\r\n     |     });\r\n     | };\r\n     | // then use it\r\n     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();\r\n     \\*/\r\n    R.st = setproto;\r\n\r\n    eve.on(\"raphael.DOMload\", function () {\r\n        loaded = true;\r\n    });\r\n\r\n    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html\r\n    (function (doc, loaded, f) {\r\n        if (doc.readyState == null && doc.addEventListener){\r\n            doc.addEventListener(loaded, f = function () {\r\n                doc.removeEventListener(loaded, f, false);\r\n                doc.readyState = \"complete\";\r\n            }, false);\r\n            doc.readyState = \"loading\";\r\n        }\r\n        function isLoaded() {\r\n            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve(\"raphael.DOMload\");\r\n        }\r\n        isLoaded();\r\n    })(document, \"DOMContentLoaded\");\r\n\r\n    return R;\r\n}));\r\n\r\n// ┌─────────────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Raphaël 2.1.4 - JavaScript Vector Library                       │ \\\\\r\n// ├─────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ SVG Module                                                          │ \\\\\r\n// ├─────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\\\\r\n// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\\\\r\n// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\\\\r\n// └─────────────────────────────────────────────────────────────────────┘ \\\\\r\n\r\n(function (glob, factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"raphael.svg\", [\"raphael.core\"], function(raphael) {\r\n            return factory(raphael);\r\n        });\r\n    } else if (typeof exports === \"object\") {\r\n        factory(require(\"raphael.core\"));\r\n    } else {\r\n        factory(glob.Raphael);\r\n    }\r\n}(this, function(R) {\r\n    if (R && !R.svg) {\r\n        return;\r\n    }\r\n\r\n    var has = \"hasOwnProperty\",\r\n        Str = String,\r\n        toFloat = parseFloat,\r\n        toInt = parseInt,\r\n        math = Math,\r\n        mmax = math.max,\r\n        abs = math.abs,\r\n        pow = math.pow,\r\n        separator = /[, ]+/,\r\n        eve = R.eve,\r\n        E = \"\",\r\n        S = \" \";\r\n    var xlink = \"http://www.w3.org/1999/xlink\",\r\n        markers = {\r\n            block: \"M5,0 0,2.5 5,5z\",\r\n            classic: \"M5,0 0,2.5 5,5 3.5,3 3.5,2z\",\r\n            diamond: \"M2.5,0 5,2.5 2.5,5 0,2.5z\",\r\n            open: \"M6,1 1,3.5 6,6\",\r\n            oval: \"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z\"\r\n        },\r\n        markerCounter = {};\r\n    R.toString = function () {\r\n        return  \"Your browser supports SVG.\\nYou are running Rapha\\xebl \" + this.version;\r\n    };\r\n    var $ = function (el, attr) {\r\n            if (attr) {\r\n                if (typeof el == \"string\") {\r\n                    el = $(el);\r\n                }\r\n                for (var key in attr) if (attr[has](key)) {\r\n                    if (key.substring(0, 6) == \"xlink:\") {\r\n                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));\r\n                    } else {\r\n                        el.setAttribute(key, Str(attr[key]));\r\n                    }\r\n                }\r\n            } else {\r\n                el = R._g.doc.createElementNS(\"http://www.w3.org/2000/svg\", el);\r\n                el.style && (el.style.webkitTapHighlightColor = \"rgba(0,0,0,0)\");\r\n            }\r\n            return el;\r\n        },\r\n        addGradientFill = function (element, gradient) {\r\n            var type = \"linear\",\r\n                id = element.id + gradient,\r\n                fx = .5, fy = .5,\r\n                o = element.node,\r\n                SVG = element.paper,\r\n                s = o.style,\r\n                el = R._g.doc.getElementById(id);\r\n            if (!el) {\r\n                gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {\r\n                    type = \"radial\";\r\n                    if (_fx && _fy) {\r\n                        fx = toFloat(_fx);\r\n                        fy = toFloat(_fy);\r\n                        var dir = ((fy > .5) * 2 - 1);\r\n                        pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&\r\n                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&\r\n                        fy != .5 &&\r\n                        (fy = fy.toFixed(5) - 1e-5 * dir);\r\n                    }\r\n                    return E;\r\n                });\r\n                gradient = gradient.split(/\\s*\\-\\s*/);\r\n                if (type == \"linear\") {\r\n                    var angle = gradient.shift();\r\n                    angle = -toFloat(angle);\r\n                    if (isNaN(angle)) {\r\n                        return null;\r\n                    }\r\n                    var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],\r\n                        max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);\r\n                    vector[2] *= max;\r\n                    vector[3] *= max;\r\n                    if (vector[2] < 0) {\r\n                        vector[0] = -vector[2];\r\n                        vector[2] = 0;\r\n                    }\r\n                    if (vector[3] < 0) {\r\n                        vector[1] = -vector[3];\r\n                        vector[3] = 0;\r\n                    }\r\n                }\r\n                var dots = R._parseDots(gradient);\r\n                if (!dots) {\r\n                    return null;\r\n                }\r\n                id = id.replace(/[\\(\\)\\s,\\xb0#]/g, \"_\");\r\n\r\n                if (element.gradient && id != element.gradient.id) {\r\n                    SVG.defs.removeChild(element.gradient);\r\n                    delete element.gradient;\r\n                }\r\n\r\n                if (!element.gradient) {\r\n                    el = $(type + \"Gradient\", {id: id});\r\n                    element.gradient = el;\r\n                    $(el, type == \"radial\" ? {\r\n                        fx: fx,\r\n                        fy: fy\r\n                    } : {\r\n                        x1: vector[0],\r\n                        y1: vector[1],\r\n                        x2: vector[2],\r\n                        y2: vector[3],\r\n                        gradientTransform: element.matrix.invert()\r\n                    });\r\n                    SVG.defs.appendChild(el);\r\n                    for (var i = 0, ii = dots.length; i < ii; i++) {\r\n                        el.appendChild($(\"stop\", {\r\n                            offset: dots[i].offset ? dots[i].offset : i ? \"100%\" : \"0%\",\r\n                            \"stop-color\": dots[i].color || \"#fff\",\r\n                            \"stop-opacity\": isFinite(dots[i].opacity) ? dots[i].opacity : 1\r\n                        }));\r\n                    }\r\n                }\r\n            }\r\n            $(o, {\r\n                fill: \"url('\" + document.location.origin + document.location.pathname + \"#\" + id + \"')\",\r\n                opacity: 1,\r\n                \"fill-opacity\": 1\r\n            });\r\n            s.fill = E;\r\n            s.opacity = 1;\r\n            s.fillOpacity = 1;\r\n            return 1;\r\n        },\r\n        updatePosition = function (o) {\r\n            var bbox = o.getBBox(1);\r\n            $(o.pattern, {patternTransform: o.matrix.invert() + \" translate(\" + bbox.x + \",\" + bbox.y + \")\"});\r\n        },\r\n        addArrow = function (o, value, isEnd) {\r\n            if (o.type == \"path\") {\r\n                var values = Str(value).toLowerCase().split(\"-\"),\r\n                    p = o.paper,\r\n                    se = isEnd ? \"end\" : \"start\",\r\n                    node = o.node,\r\n                    attrs = o.attrs,\r\n                    stroke = attrs[\"stroke-width\"],\r\n                    i = values.length,\r\n                    type = \"classic\",\r\n                    from,\r\n                    to,\r\n                    dx,\r\n                    refX,\r\n                    attr,\r\n                    w = 3,\r\n                    h = 3,\r\n                    t = 5;\r\n                while (i--) {\r\n                    switch (values[i]) {\r\n                        case \"block\":\r\n                        case \"classic\":\r\n                        case \"oval\":\r\n                        case \"diamond\":\r\n                        case \"open\":\r\n                        case \"none\":\r\n                            type = values[i];\r\n                            break;\r\n                        case \"wide\": h = 5; break;\r\n                        case \"narrow\": h = 2; break;\r\n                        case \"long\": w = 5; break;\r\n                        case \"short\": w = 2; break;\r\n                    }\r\n                }\r\n                if (type == \"open\") {\r\n                    w += 2;\r\n                    h += 2;\r\n                    t += 2;\r\n                    dx = 1;\r\n                    refX = isEnd ? 4 : 1;\r\n                    attr = {\r\n                        fill: \"none\",\r\n                        stroke: attrs.stroke\r\n                    };\r\n                } else {\r\n                    refX = dx = w / 2;\r\n                    attr = {\r\n                        fill: attrs.stroke,\r\n                        stroke: \"none\"\r\n                    };\r\n                }\r\n                if (o._.arrows) {\r\n                    if (isEnd) {\r\n                        o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;\r\n                        o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;\r\n                    } else {\r\n                        o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;\r\n                        o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;\r\n                    }\r\n                } else {\r\n                    o._.arrows = {};\r\n                }\r\n                if (type != \"none\") {\r\n                    var pathId = \"raphael-marker-\" + type,\r\n                        markerId = \"raphael-marker-\" + se + type + w + h + \"-obj\" + o.id;\r\n                    if (!R._g.doc.getElementById(pathId)) {\r\n                        p.defs.appendChild($($(\"path\"), {\r\n                            \"stroke-linecap\": \"round\",\r\n                            d: markers[type],\r\n                            id: pathId\r\n                        }));\r\n                        markerCounter[pathId] = 1;\r\n                    } else {\r\n                        markerCounter[pathId]++;\r\n                    }\r\n                    var marker = R._g.doc.getElementById(markerId),\r\n                        use;\r\n                    if (!marker) {\r\n                        marker = $($(\"marker\"), {\r\n                            id: markerId,\r\n                            markerHeight: h,\r\n                            markerWidth: w,\r\n                            orient: \"auto\",\r\n                            refX: refX,\r\n                            refY: h / 2\r\n                        });\r\n                        use = $($(\"use\"), {\r\n                            \"xlink:href\": \"#\" + pathId,\r\n                            transform: (isEnd ? \"rotate(180 \" + w / 2 + \" \" + h / 2 + \") \" : E) + \"scale(\" + w / t + \",\" + h / t + \")\",\r\n                            \"stroke-width\": (1 / ((w / t + h / t) / 2)).toFixed(4)\r\n                        });\r\n                        marker.appendChild(use);\r\n                        p.defs.appendChild(marker);\r\n                        markerCounter[markerId] = 1;\r\n                    } else {\r\n                        markerCounter[markerId]++;\r\n                        use = marker.getElementsByTagName(\"use\")[0];\r\n                    }\r\n                    $(use, attr);\r\n                    var delta = dx * (type != \"diamond\" && type != \"oval\");\r\n                    if (isEnd) {\r\n                        from = o._.arrows.startdx * stroke || 0;\r\n                        to = R.getTotalLength(attrs.path) - delta * stroke;\r\n                    } else {\r\n                        from = delta * stroke;\r\n                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\r\n                    }\r\n                    attr = {};\r\n                    attr[\"marker-\" + se] = \"url(#\" + markerId + \")\";\r\n                    if (to || from) {\r\n                        attr.d = R.getSubpath(attrs.path, from, to);\r\n                    }\r\n                    $(node, attr);\r\n                    o._.arrows[se + \"Path\"] = pathId;\r\n                    o._.arrows[se + \"Marker\"] = markerId;\r\n                    o._.arrows[se + \"dx\"] = delta;\r\n                    o._.arrows[se + \"Type\"] = type;\r\n                    o._.arrows[se + \"String\"] = value;\r\n                } else {\r\n                    if (isEnd) {\r\n                        from = o._.arrows.startdx * stroke || 0;\r\n                        to = R.getTotalLength(attrs.path) - from;\r\n                    } else {\r\n                        from = 0;\r\n                        to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);\r\n                    }\r\n                    o._.arrows[se + \"Path\"] && $(node, {d: R.getSubpath(attrs.path, from, to)});\r\n                    delete o._.arrows[se + \"Path\"];\r\n                    delete o._.arrows[se + \"Marker\"];\r\n                    delete o._.arrows[se + \"dx\"];\r\n                    delete o._.arrows[se + \"Type\"];\r\n                    delete o._.arrows[se + \"String\"];\r\n                }\r\n                for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {\r\n                    var item = R._g.doc.getElementById(attr);\r\n                    item && item.parentNode.removeChild(item);\r\n                }\r\n            }\r\n        },\r\n        dasharray = {\r\n            \"-\": [3, 1],\r\n            \".\": [1, 1],\r\n            \"-.\": [3, 1, 1, 1],\r\n            \"-..\": [3, 1, 1, 1, 1, 1],\r\n            \". \": [1, 3],\r\n            \"- \": [4, 3],\r\n            \"--\": [8, 3],\r\n            \"- .\": [4, 3, 1, 3],\r\n            \"--.\": [8, 3, 1, 3],\r\n            \"--..\": [8, 3, 1, 3, 1, 3]\r\n        },\r\n        addDashes = function (o, value, params) {\r\n            value = dasharray[Str(value).toLowerCase()];\r\n            if (value) {\r\n                var width = o.attrs[\"stroke-width\"] || \"1\",\r\n                    butt = {round: width, square: width, butt: 0}[o.attrs[\"stroke-linecap\"] || params[\"stroke-linecap\"]] || 0,\r\n                    dashes = [],\r\n                    i = value.length;\r\n                while (i--) {\r\n                    dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;\r\n                }\r\n                $(o.node, {\"stroke-dasharray\": dashes.join(\",\")});\r\n            }\r\n            else {\r\n                $(o.node, {\"stroke-dasharray\": \"none\"});\r\n            }\r\n        },\r\n        setFillAndStroke = function (o, params) {\r\n            var node = o.node,\r\n                attrs = o.attrs,\r\n                vis = node.style.visibility;\r\n            node.style.visibility = \"hidden\";\r\n            for (var att in params) {\r\n                if (params[has](att)) {\r\n                    if (!R._availableAttrs[has](att)) {\r\n                        continue;\r\n                    }\r\n                    var value = params[att];\r\n                    attrs[att] = value;\r\n                    switch (att) {\r\n                        case \"blur\":\r\n                            o.blur(value);\r\n                            break;\r\n                        case \"title\":\r\n                            var title = node.getElementsByTagName(\"title\");\r\n\r\n                            // Use the existing <title>.\r\n                            if (title.length && (title = title[0])) {\r\n                                title.firstChild.nodeValue = value;\r\n                            } else {\r\n                                title = $(\"title\");\r\n                                var val = R._g.doc.createTextNode(value);\r\n                                title.appendChild(val);\r\n                                node.appendChild(title);\r\n                            }\r\n                            break;\r\n                        case \"href\":\r\n                        case \"target\":\r\n                            var pn = node.parentNode;\r\n                            if (pn.tagName.toLowerCase() != \"a\") {\r\n                                var hl = $(\"a\");\r\n                                pn.insertBefore(hl, node);\r\n                                hl.appendChild(node);\r\n                                pn = hl;\r\n                            }\r\n                            if (att == \"target\") {\r\n                                pn.setAttributeNS(xlink, \"show\", value == \"blank\" ? \"new\" : value);\r\n                            } else {\r\n                                pn.setAttributeNS(xlink, att, value);\r\n                            }\r\n                            break;\r\n                        case \"cursor\":\r\n                            node.style.cursor = value;\r\n                            break;\r\n                        case \"transform\":\r\n                            o.transform(value);\r\n                            break;\r\n                        case \"arrow-start\":\r\n                            addArrow(o, value);\r\n                            break;\r\n                        case \"arrow-end\":\r\n                            addArrow(o, value, 1);\r\n                            break;\r\n                        case \"clip-rect\":\r\n                            var rect = Str(value).split(separator);\r\n                            if (rect.length == 4) {\r\n                                o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);\r\n                                var el = $(\"clipPath\"),\r\n                                    rc = $(\"rect\");\r\n                                el.id = R.createUUID();\r\n                                $(rc, {\r\n                                    x: rect[0],\r\n                                    y: rect[1],\r\n                                    width: rect[2],\r\n                                    height: rect[3]\r\n                                });\r\n                                el.appendChild(rc);\r\n                                o.paper.defs.appendChild(el);\r\n                                $(node, {\"clip-path\": \"url(#\" + el.id + \")\"});\r\n                                o.clip = rc;\r\n                            }\r\n                            if (!value) {\r\n                                var path = node.getAttribute(\"clip-path\");\r\n                                if (path) {\r\n                                    var clip = R._g.doc.getElementById(path.replace(/(^url\\(#|\\)$)/g, E));\r\n                                    clip && clip.parentNode.removeChild(clip);\r\n                                    $(node, {\"clip-path\": E});\r\n                                    delete o.clip;\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"path\":\r\n                            if (o.type == \"path\") {\r\n                                $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : \"M0,0\"});\r\n                                o._.dirty = 1;\r\n                                if (o._.arrows) {\r\n                                    \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\r\n                                    \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\r\n                                }\r\n                            }\r\n                            break;\r\n                        case \"width\":\r\n                            node.setAttribute(att, value);\r\n                            o._.dirty = 1;\r\n                            if (attrs.fx) {\r\n                                att = \"x\";\r\n                                value = attrs.x;\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        case \"x\":\r\n                            if (attrs.fx) {\r\n                                value = -attrs.x - (attrs.width || 0);\r\n                            }\r\n                        case \"rx\":\r\n                            if (att == \"rx\" && o.type == \"rect\") {\r\n                                break;\r\n                            }\r\n                        case \"cx\":\r\n                            node.setAttribute(att, value);\r\n                            o.pattern && updatePosition(o);\r\n                            o._.dirty = 1;\r\n                            break;\r\n                        case \"height\":\r\n                            node.setAttribute(att, value);\r\n                            o._.dirty = 1;\r\n                            if (attrs.fy) {\r\n                                att = \"y\";\r\n                                value = attrs.y;\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        case \"y\":\r\n                            if (attrs.fy) {\r\n                                value = -attrs.y - (attrs.height || 0);\r\n                            }\r\n                        case \"ry\":\r\n                            if (att == \"ry\" && o.type == \"rect\") {\r\n                                break;\r\n                            }\r\n                        case \"cy\":\r\n                            node.setAttribute(att, value);\r\n                            o.pattern && updatePosition(o);\r\n                            o._.dirty = 1;\r\n                            break;\r\n                        case \"r\":\r\n                            if (o.type == \"rect\") {\r\n                                $(node, {rx: value, ry: value});\r\n                            } else {\r\n                                node.setAttribute(att, value);\r\n                            }\r\n                            o._.dirty = 1;\r\n                            break;\r\n                        case \"src\":\r\n                            if (o.type == \"image\") {\r\n                                node.setAttributeNS(xlink, \"href\", value);\r\n                            }\r\n                            break;\r\n                        case \"stroke-width\":\r\n                            if (o._.sx != 1 || o._.sy != 1) {\r\n                                value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;\r\n                            }\r\n                            node.setAttribute(att, value);\r\n                            if (attrs[\"stroke-dasharray\"]) {\r\n                                addDashes(o, attrs[\"stroke-dasharray\"], params);\r\n                            }\r\n                            if (o._.arrows) {\r\n                                \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\r\n                                \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\r\n                            }\r\n                            break;\r\n                        case \"stroke-dasharray\":\r\n                            addDashes(o, value, params);\r\n                            break;\r\n                        case \"fill\":\r\n                            var isURL = Str(value).match(R._ISURL);\r\n                            if (isURL) {\r\n                                el = $(\"pattern\");\r\n                                var ig = $(\"image\");\r\n                                el.id = R.createUUID();\r\n                                $(el, {x: 0, y: 0, patternUnits: \"userSpaceOnUse\", height: 1, width: 1});\r\n                                $(ig, {x: 0, y: 0, \"xlink:href\": isURL[1]});\r\n                                el.appendChild(ig);\r\n\r\n                                (function (el) {\r\n                                    R._preload(isURL[1], function () {\r\n                                        var w = this.offsetWidth,\r\n                                            h = this.offsetHeight;\r\n                                        $(el, {width: w, height: h});\r\n                                        $(ig, {width: w, height: h});\r\n                                    });\r\n                                })(el);\r\n                                o.paper.defs.appendChild(el);\r\n                                $(node, {fill: \"url(#\" + el.id + \")\"});\r\n                                o.pattern = el;\r\n                                o.pattern && updatePosition(o);\r\n                                break;\r\n                            }\r\n                            var clr = R.getRGB(value);\r\n                            if (!clr.error) {\r\n                                delete params.gradient;\r\n                                delete attrs.gradient;\r\n                                !R.is(attrs.opacity, \"undefined\") &&\r\n                                R.is(params.opacity, \"undefined\") &&\r\n                                $(node, {opacity: attrs.opacity});\r\n                                !R.is(attrs[\"fill-opacity\"], \"undefined\") &&\r\n                                R.is(params[\"fill-opacity\"], \"undefined\") &&\r\n                                $(node, {\"fill-opacity\": attrs[\"fill-opacity\"]});\r\n                            } else if ((o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value)) {\r\n                                if (\"opacity\" in attrs || \"fill-opacity\" in attrs) {\r\n                                    var gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\r\n                                    if (gradient) {\r\n                                        var stops = gradient.getElementsByTagName(\"stop\");\r\n                                        $(stops[stops.length - 1], {\"stop-opacity\": (\"opacity\" in attrs ? attrs.opacity : 1) * (\"fill-opacity\" in attrs ? attrs[\"fill-opacity\"] : 1)});\r\n                                    }\r\n                                }\r\n                                attrs.gradient = value;\r\n                                attrs.fill = \"none\";\r\n                                break;\r\n                            }\r\n                            clr[has](\"opacity\") && $(node, {\"fill-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\r\n                        case \"stroke\":\r\n                            clr = R.getRGB(value);\r\n                            node.setAttribute(att, clr.hex);\r\n                            att == \"stroke\" && clr[has](\"opacity\") && $(node, {\"stroke-opacity\": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});\r\n                            if (att == \"stroke\" && o._.arrows) {\r\n                                \"startString\" in o._.arrows && addArrow(o, o._.arrows.startString);\r\n                                \"endString\" in o._.arrows && addArrow(o, o._.arrows.endString, 1);\r\n                            }\r\n                            break;\r\n                        case \"gradient\":\r\n                            (o.type == \"circle\" || o.type == \"ellipse\" || Str(value).charAt() != \"r\") && addGradientFill(o, value);\r\n                            break;\r\n                        case \"opacity\":\r\n                            if (attrs.gradient && !attrs[has](\"stroke-opacity\")) {\r\n                                $(node, {\"stroke-opacity\": value > 1 ? value / 100 : value});\r\n                            }\r\n                        // fall\r\n                        case \"fill-opacity\":\r\n                            if (attrs.gradient) {\r\n                                gradient = R._g.doc.getElementById(node.getAttribute(\"fill\").replace(/^url\\(#|\\)$/g, E));\r\n                                if (gradient) {\r\n                                    stops = gradient.getElementsByTagName(\"stop\");\r\n                                    $(stops[stops.length - 1], {\"stop-opacity\": value});\r\n                                }\r\n                                break;\r\n                            }\r\n                        default:\r\n                            att == \"font-size\" && (value = toInt(value, 10) + \"px\");\r\n                            var cssrule = att.replace(/(\\-.)/g, function (w) {\r\n                                return w.substring(1).toUpperCase();\r\n                            });\r\n                            node.style[cssrule] = value;\r\n                            o._.dirty = 1;\r\n                            node.setAttribute(att, value);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            tuneText(o, params);\r\n            node.style.visibility = vis;\r\n        },\r\n        leading = 1.2,\r\n        tuneText = function (el, params) {\r\n            if (el.type != \"text\" || !(params[has](\"text\") || params[has](\"font\") || params[has](\"font-size\") || params[has](\"x\") || params[has](\"y\"))) {\r\n                return;\r\n            }\r\n            var a = el.attrs,\r\n                node = el.node,\r\n                fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue(\"font-size\"), 10) : 10;\r\n\r\n            if (params[has](\"text\")) {\r\n                a.text = params.text;\r\n                while (node.firstChild) {\r\n                    node.removeChild(node.firstChild);\r\n                }\r\n                var texts = Str(params.text).split(\"\\n\"),\r\n                    tspans = [],\r\n                    tspan;\r\n                for (var i = 0, ii = texts.length; i < ii; i++) {\r\n                    tspan = $(\"tspan\");\r\n                    i && $(tspan, {dy: fontSize * leading, x: a.x});\r\n                    tspan.appendChild(R._g.doc.createTextNode(texts[i]));\r\n                    node.appendChild(tspan);\r\n                    tspans[i] = tspan;\r\n                }\r\n            } else {\r\n                tspans = node.getElementsByTagName(\"tspan\");\r\n                for (i = 0, ii = tspans.length; i < ii; i++) if (i) {\r\n                    $(tspans[i], {dy: fontSize * leading, x: a.x});\r\n                } else {\r\n                    $(tspans[0], {dy: 0});\r\n                }\r\n            }\r\n            $(node, {x: a.x, y: a.y});\r\n            el._.dirty = 1;\r\n            var bb = el._getBBox(),\r\n                dif = a.y - (bb.y + bb.height / 2);\r\n            dif && R.is(dif, \"finite\") && $(tspans[0], {dy: dif});\r\n        },\r\n        getRealNode = function (node) {\r\n            if (node.parentNode && node.parentNode.tagName.toLowerCase() === \"a\") {\r\n                return node.parentNode;\r\n            } else {\r\n                return node;\r\n            }\r\n        },\r\n        Element = function (node, svg) {\r\n            var X = 0,\r\n                Y = 0;\r\n            /*\\\r\n             * Element.node\r\n             [ property (object) ]\r\n             **\r\n             * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\r\n             **\r\n             * Note: Don’t mess with it.\r\n             > Usage\r\n             | // draw a circle at coordinate 10,10 with radius of 10\r\n             | var c = paper.circle(10, 10, 10);\r\n             | c.node.onclick = function () {\r\n             |     c.attr(\"fill\", \"red\");\r\n             | };\r\n             \\*/\r\n            this[0] = this.node = node;\r\n            /*\\\r\n             * Element.raphael\r\n             [ property (object) ]\r\n             **\r\n             * Internal reference to @Raphael object. In case it is not available.\r\n             > Usage\r\n             | Raphael.el.red = function () {\r\n             |     var hsb = this.paper.raphael.rgb2hsb(this.attr(\"fill\"));\r\n             |     hsb.h = 1;\r\n             |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});\r\n             | }\r\n             \\*/\r\n            node.raphael = true;\r\n            /*\\\r\n             * Element.id\r\n             [ property (number) ]\r\n             **\r\n             * Unique id of the element. Especially useful when you want to listen to events of the element,\r\n             * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.\r\n             \\*/\r\n            this.id = R._oid++;\r\n            node.raphaelid = this.id;\r\n            this.matrix = R.matrix();\r\n            this.realPath = null;\r\n            /*\\\r\n             * Element.paper\r\n             [ property (object) ]\r\n             **\r\n             * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.\r\n             > Usage\r\n             | Raphael.el.cross = function () {\r\n             |     this.attr({fill: \"red\"});\r\n             |     this.paper.path(\"M10,10L50,50M50,10L10,50\")\r\n             |         .attr({stroke: \"red\"});\r\n             | }\r\n             \\*/\r\n            this.paper = svg;\r\n            this.attrs = this.attrs || {};\r\n            this._ = {\r\n                transform: [],\r\n                sx: 1,\r\n                sy: 1,\r\n                deg: 0,\r\n                dx: 0,\r\n                dy: 0,\r\n                dirty: 1\r\n            };\r\n            !svg.bottom && (svg.bottom = this);\r\n            /*\\\r\n             * Element.prev\r\n             [ property (object) ]\r\n             **\r\n             * Reference to the previous element in the hierarchy.\r\n             \\*/\r\n            this.prev = svg.top;\r\n            svg.top && (svg.top.next = this);\r\n            svg.top = this;\r\n            /*\\\r\n             * Element.next\r\n             [ property (object) ]\r\n             **\r\n             * Reference to the next element in the hierarchy.\r\n             \\*/\r\n            this.next = null;\r\n        },\r\n        elproto = R.el;\r\n\r\n    Element.prototype = elproto;\r\n    elproto.constructor = Element;\r\n\r\n    R._engine.path = function (pathString, SVG) {\r\n        var el = $(\"path\");\r\n        SVG.canvas && SVG.canvas.appendChild(el);\r\n        var p = new Element(el, SVG);\r\n        p.type = \"path\";\r\n        setFillAndStroke(p, {\r\n            fill: \"none\",\r\n            stroke: \"#000\",\r\n            path: pathString\r\n        });\r\n        return p;\r\n    };\r\n    /*\\\r\n     * Element.rotate\r\n     [ method ]\r\n     **\r\n     * Deprecated! Use @Element.transform instead.\r\n     * Adds rotation by given angle around given point to the list of\r\n     * transformations of the element.\r\n     > Parameters\r\n     - deg (number) angle in degrees\r\n     - cx (number) #optional x coordinate of the centre of rotation\r\n     - cy (number) #optional y coordinate of the centre of rotation\r\n     * If cx & cy aren’t specified centre of the shape is used as a point of rotation.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.rotate = function (deg, cx, cy) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        deg = Str(deg).split(separator);\r\n        if (deg.length - 1) {\r\n            cx = toFloat(deg[1]);\r\n            cy = toFloat(deg[2]);\r\n        }\r\n        deg = toFloat(deg[0]);\r\n        (cy == null) && (cx = cy);\r\n        if (cx == null || cy == null) {\r\n            var bbox = this.getBBox(1);\r\n            cx = bbox.x + bbox.width / 2;\r\n            cy = bbox.y + bbox.height / 2;\r\n        }\r\n        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.scale\r\n     [ method ]\r\n     **\r\n     * Deprecated! Use @Element.transform instead.\r\n     * Adds scale by given amount relative to given point to the list of\r\n     * transformations of the element.\r\n     > Parameters\r\n     - sx (number) horisontal scale amount\r\n     - sy (number) vertical scale amount\r\n     - cx (number) #optional x coordinate of the centre of scale\r\n     - cy (number) #optional y coordinate of the centre of scale\r\n     * If cx & cy aren’t specified centre of the shape is used instead.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.scale = function (sx, sy, cx, cy) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        sx = Str(sx).split(separator);\r\n        if (sx.length - 1) {\r\n            sy = toFloat(sx[1]);\r\n            cx = toFloat(sx[2]);\r\n            cy = toFloat(sx[3]);\r\n        }\r\n        sx = toFloat(sx[0]);\r\n        (sy == null) && (sy = sx);\r\n        (cy == null) && (cx = cy);\r\n        if (cx == null || cy == null) {\r\n            var bbox = this.getBBox(1);\r\n        }\r\n        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\r\n        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\r\n        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.translate\r\n     [ method ]\r\n     **\r\n     * Deprecated! Use @Element.transform instead.\r\n     * Adds translation by given amount to the list of transformations of the element.\r\n     > Parameters\r\n     - dx (number) horisontal shift\r\n     - dy (number) vertical shift\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.translate = function (dx, dy) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        dx = Str(dx).split(separator);\r\n        if (dx.length - 1) {\r\n            dy = toFloat(dx[1]);\r\n        }\r\n        dx = toFloat(dx[0]) || 0;\r\n        dy = +dy || 0;\r\n        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.transform\r\n     [ method ]\r\n     **\r\n     * Adds transformation to the element which is separate to other attributes,\r\n     * i.e. translation doesn’t change `x` or `y` of the rectange. The format\r\n     * of transformation string is similar to the path string syntax:\r\n     | \"t100,100r30,100,100s2,2,100,100r45s1.5\"\r\n     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for\r\n     * scale and `m` is for matrix.\r\n     *\r\n     * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.\r\n     *\r\n     * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;\r\n     * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin\r\n     * coordinates as optional parameters, the default is the centre point of the element.\r\n     * Matrix accepts six parameters.\r\n     > Usage\r\n     | var el = paper.rect(10, 20, 300, 200);\r\n     | // translate 100, 100, rotate 45°, translate -100, 0\r\n     | el.transform(\"t100,100r45t-100,0\");\r\n     | // if you want you can append or prepend transformations\r\n     | el.transform(\"...t50,50\");\r\n     | el.transform(\"s2...\");\r\n     | // or even wrap\r\n     | el.transform(\"t50,50...t-50-50\");\r\n     | // to reset transformation call method with empty string\r\n     | el.transform(\"\");\r\n     | // to get current value call it without parameters\r\n     | console.log(el.transform());\r\n     > Parameters\r\n     - tstr (string) #optional transformation string\r\n     * If tstr isn’t specified\r\n     = (string) current transformation string\r\n     * else\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.transform = function (tstr) {\r\n        var _ = this._;\r\n        if (tstr == null) {\r\n            return _.transform;\r\n        }\r\n        R._extractTransform(this, tstr);\r\n\r\n        this.clip && $(this.clip, {transform: this.matrix.invert()});\r\n        this.pattern && updatePosition(this);\r\n        this.node && $(this.node, {transform: this.matrix});\r\n\r\n        if (_.sx != 1 || _.sy != 1) {\r\n            var sw = this.attrs[has](\"stroke-width\") ? this.attrs[\"stroke-width\"] : 1;\r\n            this.attr({\"stroke-width\": sw});\r\n        }\r\n\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.hide\r\n     [ method ]\r\n     **\r\n     * Makes element invisible. See @Element.show.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.hide = function () {\r\n        if(!this.removed) this.node.style.display = \"none\";\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.show\r\n     [ method ]\r\n     **\r\n     * Makes element visible. See @Element.hide.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.show = function () {\r\n        if(!this.removed) this.node.style.display = \"\";\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.remove\r\n     [ method ]\r\n     **\r\n     * Removes element from the paper.\r\n     \\*/\r\n    elproto.remove = function () {\r\n        var node = getRealNode(this.node);\r\n        if (this.removed || !node.parentNode) {\r\n            return;\r\n        }\r\n        var paper = this.paper;\r\n        paper.__set__ && paper.__set__.exclude(this);\r\n        eve.unbind(\"raphael.*.*.\" + this.id);\r\n        if (this.gradient) {\r\n            paper.defs.removeChild(this.gradient);\r\n        }\r\n        R._tear(this, paper);\r\n\r\n        node.parentNode.removeChild(node);\r\n\r\n        // Remove custom data for element\r\n        this.removeData();\r\n\r\n        for (var i in this) {\r\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\r\n        }\r\n        this.removed = true;\r\n    };\r\n    elproto._getBBox = function () {\r\n        if (this.node.style.display == \"none\") {\r\n            this.show();\r\n            var hide = true;\r\n        }\r\n        var canvasHidden = false,\r\n            containerStyle;\r\n        if (this.paper.canvas.parentElement) {\r\n            containerStyle = this.paper.canvas.parentElement.style;\r\n        } //IE10+ can't find parentElement\r\n        else if (this.paper.canvas.parentNode) {\r\n            containerStyle = this.paper.canvas.parentNode.style;\r\n        }\r\n\r\n        if(containerStyle && containerStyle.display == \"none\") {\r\n            canvasHidden = true;\r\n            containerStyle.display = \"\";\r\n        }\r\n        var bbox = {};\r\n        try {\r\n            bbox = this.node.getBBox();\r\n        } catch(e) {\r\n            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix\r\n            bbox = {\r\n                x: this.node.clientLeft,\r\n                y: this.node.clientTop,\r\n                width: this.node.clientWidth,\r\n                height: this.node.clientHeight\r\n            }\r\n        } finally {\r\n            bbox = bbox || {};\r\n            if(canvasHidden){\r\n                containerStyle.display = \"none\";\r\n            }\r\n        }\r\n        hide && this.hide();\r\n        return bbox;\r\n    };\r\n    /*\\\r\n     * Element.attr\r\n     [ method ]\r\n     **\r\n     * Sets the attributes of the element.\r\n     > Parameters\r\n     - attrName (string) attribute’s name\r\n     - value (string) value\r\n     * or\r\n     - params (object) object of name/value pairs\r\n     * or\r\n     - attrName (string) attribute’s name\r\n     * or\r\n     - attrNames (array) in this case method returns array of current values for given attribute names\r\n     = (object) @Element if attrsName & value or params are passed in.\r\n     = (...) value of the attribute if only attrsName is passed in.\r\n     = (array) array of values of the attribute if attrsNames is passed in.\r\n     = (object) object of attributes if nothing is passed in.\r\n     > Possible parameters\r\n     # <p>Please refer to the <a href=\"http://www.w3.org/TR/SVG/\" title=\"The W3C Recommendation for the SVG language describes these properties in detail.\">SVG specification</a> for an explanation of these parameters.</p>\r\n     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.\r\n     o clip-rect (string) comma or space separated values: x, y, width and height\r\n     o cursor (string) CSS type of the cursor\r\n     o cx (number) the x-axis coordinate of the center of the circle, or ellipse\r\n     o cy (number) the y-axis coordinate of the center of the circle, or ellipse\r\n     o fill (string) colour, gradient or image\r\n     o fill-opacity (number)\r\n     o font (string)\r\n     o font-family (string)\r\n     o font-size (number) font size in pixels\r\n     o font-weight (string)\r\n     o height (number)\r\n     o href (string) URL, if specified element behaves as hyperlink\r\n     o opacity (number)\r\n     o path (string) SVG path string format\r\n     o r (number) radius of the circle, ellipse or rounded corner on the rect\r\n     o rx (number) horisontal radius of the ellipse\r\n     o ry (number) vertical radius of the ellipse\r\n     o src (string) image URL, only works for @Element.image element\r\n     o stroke (string) stroke colour\r\n     o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]\r\n     o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]\r\n     o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]\r\n     o stroke-miterlimit (number)\r\n     o stroke-opacity (number)\r\n     o stroke-width (number) stroke width in pixels, default is '1'\r\n     o target (string) used with href\r\n     o text (string) contents of the text element. Use `\\n` for multiline text\r\n     o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”\r\n     o title (string) will create tooltip with a given text\r\n     o transform (string) see @Element.transform\r\n     o width (number)\r\n     o x (number)\r\n     o y (number)\r\n     > Gradients\r\n     * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°\r\n     * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.\r\n     *\r\n     * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –\r\n     * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point\r\n     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.\r\n     > Path String\r\n     # <p>Please refer to <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path’s data attribute’s format are described in the SVG specification.\">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>\r\n     > Colour Parsing\r\n     # <ul>\r\n     #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>\r\n     #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>\r\n     #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>\r\n     #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>\r\n     #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>\r\n     #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>\r\n     #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>\r\n     #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>\r\n     #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>\r\n     #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>\r\n     #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href=\"http://en.wikipedia.org/wiki/HSL_and_HSV\" title=\"HSL and HSV - Wikipedia, the free encyclopedia\">Wikipedia page</a></li>\r\n     #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>\r\n     #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>\r\n     #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>\r\n     # </ul>\r\n     \\*/\r\n    elproto.attr = function (name, value) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        if (name == null) {\r\n            var res = {};\r\n            for (var a in this.attrs) if (this.attrs[has](a)) {\r\n                res[a] = this.attrs[a];\r\n            }\r\n            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\r\n            res.transform = this._.transform;\r\n            return res;\r\n        }\r\n        if (value == null && R.is(name, \"string\")) {\r\n            if (name == \"fill\" && this.attrs.fill == \"none\" && this.attrs.gradient) {\r\n                return this.attrs.gradient;\r\n            }\r\n            if (name == \"transform\") {\r\n                return this._.transform;\r\n            }\r\n            var names = name.split(separator),\r\n                out = {};\r\n            for (var i = 0, ii = names.length; i < ii; i++) {\r\n                name = names[i];\r\n                if (name in this.attrs) {\r\n                    out[name] = this.attrs[name];\r\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\r\n                    out[name] = this.paper.customAttributes[name].def;\r\n                } else {\r\n                    out[name] = R._availableAttrs[name];\r\n                }\r\n            }\r\n            return ii - 1 ? out : out[names[0]];\r\n        }\r\n        if (value == null && R.is(name, \"array\")) {\r\n            out = {};\r\n            for (i = 0, ii = name.length; i < ii; i++) {\r\n                out[name[i]] = this.attr(name[i]);\r\n            }\r\n            return out;\r\n        }\r\n        if (value != null) {\r\n            var params = {};\r\n            params[name] = value;\r\n        } else if (name != null && R.is(name, \"object\")) {\r\n            params = name;\r\n        }\r\n        for (var key in params) {\r\n            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\r\n        }\r\n        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\r\n            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\r\n            this.attrs[key] = params[key];\r\n            for (var subkey in par) if (par[has](subkey)) {\r\n                params[subkey] = par[subkey];\r\n            }\r\n        }\r\n        setFillAndStroke(this, params);\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.toFront\r\n     [ method ]\r\n     **\r\n     * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.toFront = function () {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        var node = getRealNode(this.node);\r\n        node.parentNode.appendChild(node);\r\n        var svg = this.paper;\r\n        svg.top != this && R._tofront(this, svg);\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.toBack\r\n     [ method ]\r\n     **\r\n     * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.toBack = function () {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        var node = getRealNode(this.node);\r\n        var parentNode = node.parentNode;\r\n        parentNode.insertBefore(node, parentNode.firstChild);\r\n        R._toback(this, this.paper);\r\n        var svg = this.paper;\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.insertAfter\r\n     [ method ]\r\n     **\r\n     * Inserts current object after the given one.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.insertAfter = function (element) {\r\n        if (this.removed || !element) {\r\n            return this;\r\n        }\r\n\r\n        var node = getRealNode(this.node);\r\n        var afterNode = getRealNode(element.node || element[element.length - 1].node);\r\n        if (afterNode.nextSibling) {\r\n            afterNode.parentNode.insertBefore(node, afterNode.nextSibling);\r\n        } else {\r\n            afterNode.parentNode.appendChild(node);\r\n        }\r\n        R._insertafter(this, element, this.paper);\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Element.insertBefore\r\n     [ method ]\r\n     **\r\n     * Inserts current object before the given one.\r\n     = (object) @Element\r\n     \\*/\r\n    elproto.insertBefore = function (element) {\r\n        if (this.removed || !element) {\r\n            return this;\r\n        }\r\n\r\n        var node = getRealNode(this.node);\r\n        var beforeNode = getRealNode(element.node || element[0].node);\r\n        beforeNode.parentNode.insertBefore(node, beforeNode);\r\n        R._insertbefore(this, element, this.paper);\r\n        return this;\r\n    };\r\n    elproto.blur = function (size) {\r\n        // Experimental. No Safari support. Use it on your own risk.\r\n        var t = this;\r\n        if (+size !== 0) {\r\n            var fltr = $(\"filter\"),\r\n                blur = $(\"feGaussianBlur\");\r\n            t.attrs.blur = size;\r\n            fltr.id = R.createUUID();\r\n            $(blur, {stdDeviation: +size || 1.5});\r\n            fltr.appendChild(blur);\r\n            t.paper.defs.appendChild(fltr);\r\n            t._blur = fltr;\r\n            $(t.node, {filter: \"url(#\" + fltr.id + \")\"});\r\n        } else {\r\n            if (t._blur) {\r\n                t._blur.parentNode.removeChild(t._blur);\r\n                delete t._blur;\r\n                delete t.attrs.blur;\r\n            }\r\n            t.node.removeAttribute(\"filter\");\r\n        }\r\n        return t;\r\n    };\r\n    R._engine.circle = function (svg, x, y, r) {\r\n        var el = $(\"circle\");\r\n        svg.canvas && svg.canvas.appendChild(el);\r\n        var res = new Element(el, svg);\r\n        res.attrs = {cx: x, cy: y, r: r, fill: \"none\", stroke: \"#000\"};\r\n        res.type = \"circle\";\r\n        $(el, res.attrs);\r\n        return res;\r\n    };\r\n    R._engine.rect = function (svg, x, y, w, h, r) {\r\n        var el = $(\"rect\");\r\n        svg.canvas && svg.canvas.appendChild(el);\r\n        var res = new Element(el, svg);\r\n        res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: \"none\", stroke: \"#000\"};\r\n        res.type = \"rect\";\r\n        $(el, res.attrs);\r\n        return res;\r\n    };\r\n    R._engine.ellipse = function (svg, x, y, rx, ry) {\r\n        var el = $(\"ellipse\");\r\n        svg.canvas && svg.canvas.appendChild(el);\r\n        var res = new Element(el, svg);\r\n        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: \"none\", stroke: \"#000\"};\r\n        res.type = \"ellipse\";\r\n        $(el, res.attrs);\r\n        return res;\r\n    };\r\n    R._engine.image = function (svg, src, x, y, w, h) {\r\n        var el = $(\"image\");\r\n        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: \"none\"});\r\n        el.setAttributeNS(xlink, \"href\", src);\r\n        svg.canvas && svg.canvas.appendChild(el);\r\n        var res = new Element(el, svg);\r\n        res.attrs = {x: x, y: y, width: w, height: h, src: src};\r\n        res.type = \"image\";\r\n        return res;\r\n    };\r\n    R._engine.text = function (svg, x, y, text) {\r\n        var el = $(\"text\");\r\n        svg.canvas && svg.canvas.appendChild(el);\r\n        var res = new Element(el, svg);\r\n        res.attrs = {\r\n            x: x,\r\n            y: y,\r\n            \"text-anchor\": \"middle\",\r\n            text: text,\r\n            \"font-family\": R._availableAttrs[\"font-family\"],\r\n            \"font-size\": R._availableAttrs[\"font-size\"],\r\n            stroke: \"none\",\r\n            fill: \"#000\"\r\n        };\r\n        res.type = \"text\";\r\n        setFillAndStroke(res, res.attrs);\r\n        return res;\r\n    };\r\n    R._engine.setSize = function (width, height) {\r\n        this.width = width || this.width;\r\n        this.height = height || this.height;\r\n        this.canvas.setAttribute(\"width\", this.width);\r\n        this.canvas.setAttribute(\"height\", this.height);\r\n        if (this._viewBox) {\r\n            this.setViewBox.apply(this, this._viewBox);\r\n        }\r\n        return this;\r\n    };\r\n    R._engine.create = function () {\r\n        var con = R._getContainer.apply(0, arguments),\r\n            container = con && con.container,\r\n            x = con.x,\r\n            y = con.y,\r\n            width = con.width,\r\n            height = con.height;\r\n        if (!container) {\r\n            throw new Error(\"SVG container not found.\");\r\n        }\r\n        var cnvs = $(\"svg\"),\r\n            css = \"overflow:hidden;\",\r\n            isFloating;\r\n        x = x || 0;\r\n        y = y || 0;\r\n        width = width || 512;\r\n        height = height || 342;\r\n        $(cnvs, {\r\n            height: height,\r\n            version: 1.1,\r\n            width: width,\r\n            xmlns: \"http://www.w3.org/2000/svg\",\r\n            \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\r\n        });\r\n        if (container == 1) {\r\n            cnvs.style.cssText = css + \"position:absolute;left:\" + x + \"px;top:\" + y + \"px\";\r\n            R._g.doc.body.appendChild(cnvs);\r\n            isFloating = 1;\r\n        } else {\r\n            cnvs.style.cssText = css + \"position:relative\";\r\n            if (container.firstChild) {\r\n                container.insertBefore(cnvs, container.firstChild);\r\n            } else {\r\n                container.appendChild(cnvs);\r\n            }\r\n        }\r\n        container = new R._Paper;\r\n        container.width = width;\r\n        container.height = height;\r\n        container.canvas = cnvs;\r\n        container.clear();\r\n        container._left = container._top = 0;\r\n        isFloating && (container.renderfix = function () {});\r\n        container.renderfix();\r\n        return container;\r\n    };\r\n    R._engine.setViewBox = function (x, y, w, h, fit) {\r\n        eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\r\n        var paperSize = this.getSize(),\r\n            size = mmax(w / paperSize.width, h / paperSize.height),\r\n            top = this.top,\r\n            aspectRatio = fit ? \"xMidYMid meet\" : \"xMinYMin\",\r\n            vb,\r\n            sw;\r\n        if (x == null) {\r\n            if (this._vbSize) {\r\n                size = 1;\r\n            }\r\n            delete this._vbSize;\r\n            vb = \"0 0 \" + this.width + S + this.height;\r\n        } else {\r\n            this._vbSize = size;\r\n            vb = x + S + y + S + w + S + h;\r\n        }\r\n        $(this.canvas, {\r\n            viewBox: vb,\r\n            preserveAspectRatio: aspectRatio\r\n        });\r\n        while (size && top) {\r\n            sw = \"stroke-width\" in top.attrs ? top.attrs[\"stroke-width\"] : 1;\r\n            top.attr({\"stroke-width\": sw});\r\n            top._.dirty = 1;\r\n            top._.dirtyT = 1;\r\n            top = top.prev;\r\n        }\r\n        this._viewBox = [x, y, w, h, !!fit];\r\n        return this;\r\n    };\r\n    /*\\\r\n     * Paper.renderfix\r\n     [ method ]\r\n     **\r\n     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant\r\n     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.\r\n     * This method fixes the issue.\r\n     **\r\n     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.\r\n     \\*/\r\n    R.prototype.renderfix = function () {\r\n        var cnvs = this.canvas,\r\n            s = cnvs.style,\r\n            pos;\r\n        try {\r\n            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();\r\n        } catch (e) {\r\n            pos = cnvs.createSVGMatrix();\r\n        }\r\n        var left = -pos.e % 1,\r\n            top = -pos.f % 1;\r\n        if (left || top) {\r\n            if (left) {\r\n                this._left = (this._left + left) % 1;\r\n                s.left = this._left + \"px\";\r\n            }\r\n            if (top) {\r\n                this._top = (this._top + top) % 1;\r\n                s.top = this._top + \"px\";\r\n            }\r\n        }\r\n    };\r\n    /*\\\r\n     * Paper.clear\r\n     [ method ]\r\n     **\r\n     * Clears the paper, i.e. removes all the elements.\r\n     \\*/\r\n    R.prototype.clear = function () {\r\n        R.eve(\"raphael.clear\", this);\r\n        var c = this.canvas;\r\n        while (c.firstChild) {\r\n            c.removeChild(c.firstChild);\r\n        }\r\n        this.bottom = this.top = null;\r\n        (this.desc = $(\"desc\")).appendChild(R._g.doc.createTextNode(\"Created with Rapha\\xebl \" + R.version));\r\n        c.appendChild(this.desc);\r\n        c.appendChild(this.defs = $(\"defs\"));\r\n    };\r\n    /*\\\r\n     * Paper.remove\r\n     [ method ]\r\n     **\r\n     * Removes the paper from the DOM.\r\n     \\*/\r\n    R.prototype.remove = function () {\r\n        eve(\"raphael.remove\", this);\r\n        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);\r\n        for (var i in this) {\r\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\r\n        }\r\n    };\r\n    var setproto = R.st;\r\n    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\r\n        setproto[method] = (function (methodname) {\r\n            return function () {\r\n                var arg = arguments;\r\n                return this.forEach(function (el) {\r\n                    el[methodname].apply(el, arg);\r\n                });\r\n            };\r\n        })(method);\r\n    }\r\n}));\r\n\r\n// ┌─────────────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Raphaël 2.1.4 - JavaScript Vector Library                       │ \\\\\r\n// ├─────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ VML Module                                                          │ \\\\\r\n// ├─────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   │ \\\\\r\n// │ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             │ \\\\\r\n// │ Licensed under the MIT (http://raphaeljs.com/license.html) license. │ \\\\\r\n// └─────────────────────────────────────────────────────────────────────┘ \\\\\r\n\r\n(function (glob, factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"raphael.vml\", [\"raphael.core\"], function(raphael) {\r\n            return factory(raphael);\r\n        });\r\n    } else if (typeof exports === \"object\") {\r\n        factory(require(\"raphael\"));\r\n    } else {\r\n        factory(glob.Raphael);\r\n    }\r\n}(this, function(R) {\r\n    if (R && !R.vml) {\r\n        return;\r\n    }\r\n\r\n    var has = \"hasOwnProperty\",\r\n        Str = String,\r\n        toFloat = parseFloat,\r\n        math = Math,\r\n        round = math.round,\r\n        mmax = math.max,\r\n        mmin = math.min,\r\n        abs = math.abs,\r\n        fillString = \"fill\",\r\n        separator = /[, ]+/,\r\n        eve = R.eve,\r\n        ms = \" progid:DXImageTransform.Microsoft\",\r\n        S = \" \",\r\n        E = \"\",\r\n        map = {M: \"m\", L: \"l\", C: \"c\", Z: \"x\", m: \"t\", l: \"r\", c: \"v\", z: \"x\"},\r\n        bites = /([clmz]),?([^clmz]*)/gi,\r\n        blurregexp = / progid:\\S+Blur\\([^\\)]+\\)/g,\r\n        val = /-?[^,\\s-]+/g,\r\n        cssDot = \"position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)\",\r\n        zoom = 21600,\r\n        pathTypes = {path: 1, rect: 1, image: 1},\r\n        ovalTypes = {circle: 1, ellipse: 1},\r\n        path2vml = function (path) {\r\n            var total =  /[ahqstv]/ig,\r\n                command = R._pathToAbsolute;\r\n            Str(path).match(total) && (command = R._path2curve);\r\n            total = /[clmz]/g;\r\n            if (command == R._pathToAbsolute && !Str(path).match(total)) {\r\n                var res = Str(path).replace(bites, function (all, command, args) {\r\n                    var vals = [],\r\n                        isMove = command.toLowerCase() == \"m\",\r\n                        res = map[command];\r\n                    args.replace(val, function (value) {\r\n                        if (isMove && vals.length == 2) {\r\n                            res += vals + map[command == \"m\" ? \"l\" : \"L\"];\r\n                            vals = [];\r\n                        }\r\n                        vals.push(round(value * zoom));\r\n                    });\r\n                    return res + vals;\r\n                });\r\n                return res;\r\n            }\r\n            var pa = command(path), p, r;\r\n            res = [];\r\n            for (var i = 0, ii = pa.length; i < ii; i++) {\r\n                p = pa[i];\r\n                r = pa[i][0].toLowerCase();\r\n                r == \"z\" && (r = \"x\");\r\n                for (var j = 1, jj = p.length; j < jj; j++) {\r\n                    r += round(p[j] * zoom) + (j != jj - 1 ? \",\" : E);\r\n                }\r\n                res.push(r);\r\n            }\r\n            return res.join(S);\r\n        },\r\n        compensation = function (deg, dx, dy) {\r\n            var m = R.matrix();\r\n            m.rotate(-deg, .5, .5);\r\n            return {\r\n                dx: m.x(dx, dy),\r\n                dy: m.y(dx, dy)\r\n            };\r\n        },\r\n        setCoords = function (p, sx, sy, dx, dy, deg) {\r\n            var _ = p._,\r\n                m = p.matrix,\r\n                fillpos = _.fillpos,\r\n                o = p.node,\r\n                s = o.style,\r\n                y = 1,\r\n                flip = \"\",\r\n                dxdy,\r\n                kx = zoom / sx,\r\n                ky = zoom / sy;\r\n            s.visibility = \"hidden\";\r\n            if (!sx || !sy) {\r\n                return;\r\n            }\r\n            o.coordsize = abs(kx) + S + abs(ky);\r\n            s.rotation = deg * (sx * sy < 0 ? -1 : 1);\r\n            if (deg) {\r\n                var c = compensation(deg, dx, dy);\r\n                dx = c.dx;\r\n                dy = c.dy;\r\n            }\r\n            sx < 0 && (flip += \"x\");\r\n            sy < 0 && (flip += \" y\") && (y = -1);\r\n            s.flip = flip;\r\n            o.coordorigin = (dx * -kx) + S + (dy * -ky);\r\n            if (fillpos || _.fillsize) {\r\n                var fill = o.getElementsByTagName(fillString);\r\n                fill = fill && fill[0];\r\n                o.removeChild(fill);\r\n                if (fillpos) {\r\n                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));\r\n                    fill.position = c.dx * y + S + c.dy * y;\r\n                }\r\n                if (_.fillsize) {\r\n                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);\r\n                }\r\n                o.appendChild(fill);\r\n            }\r\n            s.visibility = \"visible\";\r\n        };\r\n    R.toString = function () {\r\n        return  \"Your browser doesn\\u2019t support SVG. Falling down to VML.\\nYou are running Rapha\\xebl \" + this.version;\r\n    };\r\n    var addArrow = function (o, value, isEnd) {\r\n            var values = Str(value).toLowerCase().split(\"-\"),\r\n                se = isEnd ? \"end\" : \"start\",\r\n                i = values.length,\r\n                type = \"classic\",\r\n                w = \"medium\",\r\n                h = \"medium\";\r\n            while (i--) {\r\n                switch (values[i]) {\r\n                    case \"block\":\r\n                    case \"classic\":\r\n                    case \"oval\":\r\n                    case \"diamond\":\r\n                    case \"open\":\r\n                    case \"none\":\r\n                        type = values[i];\r\n                        break;\r\n                    case \"wide\":\r\n                    case \"narrow\": h = values[i]; break;\r\n                    case \"long\":\r\n                    case \"short\": w = values[i]; break;\r\n                }\r\n            }\r\n            var stroke = o.node.getElementsByTagName(\"stroke\")[0];\r\n            stroke[se + \"arrow\"] = type;\r\n            stroke[se + \"arrowlength\"] = w;\r\n            stroke[se + \"arrowwidth\"] = h;\r\n        },\r\n        setFillAndStroke = function (o, params) {\r\n            // o.paper.canvas.style.display = \"none\";\r\n            o.attrs = o.attrs || {};\r\n            var node = o.node,\r\n                a = o.attrs,\r\n                s = node.style,\r\n                xy,\r\n                newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),\r\n                isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),\r\n                res = o;\r\n\r\n\r\n            for (var par in params) if (params[has](par)) {\r\n                a[par] = params[par];\r\n            }\r\n            if (newpath) {\r\n                a.path = R._getPath[o.type](o);\r\n                o._.dirty = 1;\r\n            }\r\n            params.href && (node.href = params.href);\r\n            params.title && (node.title = params.title);\r\n            params.target && (node.target = params.target);\r\n            params.cursor && (s.cursor = params.cursor);\r\n            \"blur\" in params && o.blur(params.blur);\r\n            if (params.path && o.type == \"path\" || newpath) {\r\n                node.path = path2vml(~Str(a.path).toLowerCase().indexOf(\"r\") ? R._pathToAbsolute(a.path) : a.path);\r\n                o._.dirty = 1;\r\n                if (o.type == \"image\") {\r\n                    o._.fillpos = [a.x, a.y];\r\n                    o._.fillsize = [a.width, a.height];\r\n                    setCoords(o, 1, 1, 0, 0, 0);\r\n                }\r\n            }\r\n            \"transform\" in params && o.transform(params.transform);\r\n            if (isOval) {\r\n                var cx = +a.cx,\r\n                    cy = +a.cy,\r\n                    rx = +a.rx || +a.r || 0,\r\n                    ry = +a.ry || +a.r || 0;\r\n                node.path = R.format(\"ar{0},{1},{2},{3},{4},{1},{4},{1}x\", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));\r\n                o._.dirty = 1;\r\n            }\r\n            if (\"clip-rect\" in params) {\r\n                var rect = Str(params[\"clip-rect\"]).split(separator);\r\n                if (rect.length == 4) {\r\n                    rect[2] = +rect[2] + (+rect[0]);\r\n                    rect[3] = +rect[3] + (+rect[1]);\r\n                    var div = node.clipRect || R._g.doc.createElement(\"div\"),\r\n                        dstyle = div.style;\r\n                    dstyle.clip = R.format(\"rect({1}px {2}px {3}px {0}px)\", rect);\r\n                    if (!node.clipRect) {\r\n                        dstyle.position = \"absolute\";\r\n                        dstyle.top = 0;\r\n                        dstyle.left = 0;\r\n                        dstyle.width = o.paper.width + \"px\";\r\n                        dstyle.height = o.paper.height + \"px\";\r\n                        node.parentNode.insertBefore(div, node);\r\n                        div.appendChild(node);\r\n                        node.clipRect = div;\r\n                    }\r\n                }\r\n                if (!params[\"clip-rect\"]) {\r\n                    node.clipRect && (node.clipRect.style.clip = \"auto\");\r\n                }\r\n            }\r\n            if (o.textpath) {\r\n                var textpathStyle = o.textpath.style;\r\n                params.font && (textpathStyle.font = params.font);\r\n                params[\"font-family\"] && (textpathStyle.fontFamily = '\"' + params[\"font-family\"].split(\",\")[0].replace(/^['\"]+|['\"]+$/g, E) + '\"');\r\n                params[\"font-size\"] && (textpathStyle.fontSize = params[\"font-size\"]);\r\n                params[\"font-weight\"] && (textpathStyle.fontWeight = params[\"font-weight\"]);\r\n                params[\"font-style\"] && (textpathStyle.fontStyle = params[\"font-style\"]);\r\n            }\r\n            if (\"arrow-start\" in params) {\r\n                addArrow(res, params[\"arrow-start\"]);\r\n            }\r\n            if (\"arrow-end\" in params) {\r\n                addArrow(res, params[\"arrow-end\"], 1);\r\n            }\r\n            if (params.opacity != null ||\r\n                params[\"stroke-width\"] != null ||\r\n                params.fill != null ||\r\n                params.src != null ||\r\n                params.stroke != null ||\r\n                params[\"stroke-width\"] != null ||\r\n                params[\"stroke-opacity\"] != null ||\r\n                params[\"fill-opacity\"] != null ||\r\n                params[\"stroke-dasharray\"] != null ||\r\n                params[\"stroke-miterlimit\"] != null ||\r\n                params[\"stroke-linejoin\"] != null ||\r\n                params[\"stroke-linecap\"] != null) {\r\n                var fill = node.getElementsByTagName(fillString),\r\n                    newfill = false;\r\n                fill = fill && fill[0];\r\n                !fill && (newfill = fill = createNode(fillString));\r\n                if (o.type == \"image\" && params.src) {\r\n                    fill.src = params.src;\r\n                }\r\n                params.fill && (fill.on = true);\r\n                if (fill.on == null || params.fill == \"none\" || params.fill === null) {\r\n                    fill.on = false;\r\n                }\r\n                if (fill.on && params.fill) {\r\n                    var isURL = Str(params.fill).match(R._ISURL);\r\n                    if (isURL) {\r\n                        fill.parentNode == node && node.removeChild(fill);\r\n                        fill.rotate = true;\r\n                        fill.src = isURL[1];\r\n                        fill.type = \"tile\";\r\n                        var bbox = o.getBBox(1);\r\n                        fill.position = bbox.x + S + bbox.y;\r\n                        o._.fillpos = [bbox.x, bbox.y];\r\n\r\n                        R._preload(isURL[1], function () {\r\n                            o._.fillsize = [this.offsetWidth, this.offsetHeight];\r\n                        });\r\n                    } else {\r\n                        fill.color = R.getRGB(params.fill).hex;\r\n                        fill.src = E;\r\n                        fill.type = \"solid\";\r\n                        if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != \"r\") && addGradientFill(res, params.fill, fill)) {\r\n                            a.fill = \"none\";\r\n                            a.gradient = params.fill;\r\n                            fill.rotate = false;\r\n                        }\r\n                    }\r\n                }\r\n                if (\"fill-opacity\" in params || \"opacity\" in params) {\r\n                    var opacity = ((+a[\"fill-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);\r\n                    opacity = mmin(mmax(opacity, 0), 1);\r\n                    fill.opacity = opacity;\r\n                    if (fill.src) {\r\n                        fill.color = \"none\";\r\n                    }\r\n                }\r\n                node.appendChild(fill);\r\n                var stroke = (node.getElementsByTagName(\"stroke\") && node.getElementsByTagName(\"stroke\")[0]),\r\n                    newstroke = false;\r\n                !stroke && (newstroke = stroke = createNode(\"stroke\"));\r\n                if ((params.stroke && params.stroke != \"none\") ||\r\n                    params[\"stroke-width\"] ||\r\n                    params[\"stroke-opacity\"] != null ||\r\n                    params[\"stroke-dasharray\"] ||\r\n                    params[\"stroke-miterlimit\"] ||\r\n                    params[\"stroke-linejoin\"] ||\r\n                    params[\"stroke-linecap\"]) {\r\n                    stroke.on = true;\r\n                }\r\n                (params.stroke == \"none\" || params.stroke === null || stroke.on == null || params.stroke == 0 || params[\"stroke-width\"] == 0) && (stroke.on = false);\r\n                var strokeColor = R.getRGB(params.stroke);\r\n                stroke.on && params.stroke && (stroke.color = strokeColor.hex);\r\n                opacity = ((+a[\"stroke-opacity\"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);\r\n                var width = (toFloat(params[\"stroke-width\"]) || 1) * .75;\r\n                opacity = mmin(mmax(opacity, 0), 1);\r\n                params[\"stroke-width\"] == null && (width = a[\"stroke-width\"]);\r\n                params[\"stroke-width\"] && (stroke.weight = width);\r\n                width && width < 1 && (opacity *= width) && (stroke.weight = 1);\r\n                stroke.opacity = opacity;\r\n\r\n                params[\"stroke-linejoin\"] && (stroke.joinstyle = params[\"stroke-linejoin\"] || \"miter\");\r\n                stroke.miterlimit = params[\"stroke-miterlimit\"] || 8;\r\n                params[\"stroke-linecap\"] && (stroke.endcap = params[\"stroke-linecap\"] == \"butt\" ? \"flat\" : params[\"stroke-linecap\"] == \"square\" ? \"square\" : \"round\");\r\n                if (\"stroke-dasharray\" in params) {\r\n                    var dasharray = {\r\n                        \"-\": \"shortdash\",\r\n                        \".\": \"shortdot\",\r\n                        \"-.\": \"shortdashdot\",\r\n                        \"-..\": \"shortdashdotdot\",\r\n                        \". \": \"dot\",\r\n                        \"- \": \"dash\",\r\n                        \"--\": \"longdash\",\r\n                        \"- .\": \"dashdot\",\r\n                        \"--.\": \"longdashdot\",\r\n                        \"--..\": \"longdashdotdot\"\r\n                    };\r\n                    stroke.dashstyle = dasharray[has](params[\"stroke-dasharray\"]) ? dasharray[params[\"stroke-dasharray\"]] : E;\r\n                }\r\n                newstroke && node.appendChild(stroke);\r\n            }\r\n            if (res.type == \"text\") {\r\n                res.paper.canvas.style.display = E;\r\n                var span = res.paper.span,\r\n                    m = 100,\r\n                    fontSize = a.font && a.font.match(/\\d+(?:\\.\\d*)?(?=px)/);\r\n                s = span.style;\r\n                a.font && (s.font = a.font);\r\n                a[\"font-family\"] && (s.fontFamily = a[\"font-family\"]);\r\n                a[\"font-weight\"] && (s.fontWeight = a[\"font-weight\"]);\r\n                a[\"font-style\"] && (s.fontStyle = a[\"font-style\"]);\r\n                fontSize = toFloat(a[\"font-size\"] || fontSize && fontSize[0]) || 10;\r\n                s.fontSize = fontSize * m + \"px\";\r\n                res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, \"&#60;\").replace(/&/g, \"&#38;\").replace(/\\n/g, \"<br>\"));\r\n                var brect = span.getBoundingClientRect();\r\n                res.W = a.w = (brect.right - brect.left) / m;\r\n                res.H = a.h = (brect.bottom - brect.top) / m;\r\n                // res.paper.canvas.style.display = \"none\";\r\n                res.X = a.x;\r\n                res.Y = a.y + res.H / 2;\r\n\r\n                (\"x\" in params || \"y\" in params) && (res.path.v = R.format(\"m{0},{1}l{2},{1}\", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));\r\n                var dirtyattrs = [\"x\", \"y\", \"text\", \"font\", \"font-family\", \"font-weight\", \"font-style\", \"font-size\"];\r\n                for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {\r\n                    res._.dirty = 1;\r\n                    break;\r\n                }\r\n\r\n                // text-anchor emulation\r\n                switch (a[\"text-anchor\"]) {\r\n                    case \"start\":\r\n                        res.textpath.style[\"v-text-align\"] = \"left\";\r\n                        res.bbx = res.W / 2;\r\n                        break;\r\n                    case \"end\":\r\n                        res.textpath.style[\"v-text-align\"] = \"right\";\r\n                        res.bbx = -res.W / 2;\r\n                        break;\r\n                    default:\r\n                        res.textpath.style[\"v-text-align\"] = \"center\";\r\n                        res.bbx = 0;\r\n                        break;\r\n                }\r\n                res.textpath.style[\"v-text-kern\"] = true;\r\n            }\r\n            // res.paper.canvas.style.display = E;\r\n        },\r\n        addGradientFill = function (o, gradient, fill) {\r\n            o.attrs = o.attrs || {};\r\n            var attrs = o.attrs,\r\n                pow = Math.pow,\r\n                opacity,\r\n                oindex,\r\n                type = \"linear\",\r\n                fxfy = \".5 .5\";\r\n            o.attrs.gradient = gradient;\r\n            gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {\r\n                type = \"radial\";\r\n                if (fx && fy) {\r\n                    fx = toFloat(fx);\r\n                    fy = toFloat(fy);\r\n                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);\r\n                    fxfy = fx + S + fy;\r\n                }\r\n                return E;\r\n            });\r\n            gradient = gradient.split(/\\s*\\-\\s*/);\r\n            if (type == \"linear\") {\r\n                var angle = gradient.shift();\r\n                angle = -toFloat(angle);\r\n                if (isNaN(angle)) {\r\n                    return null;\r\n                }\r\n            }\r\n            var dots = R._parseDots(gradient);\r\n            if (!dots) {\r\n                return null;\r\n            }\r\n            o = o.shape || o.node;\r\n            if (dots.length) {\r\n                o.removeChild(fill);\r\n                fill.on = true;\r\n                fill.method = \"none\";\r\n                fill.color = dots[0].color;\r\n                fill.color2 = dots[dots.length - 1].color;\r\n                var clrs = [];\r\n                for (var i = 0, ii = dots.length; i < ii; i++) {\r\n                    dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);\r\n                }\r\n                fill.colors = clrs.length ? clrs.join() : \"0% \" + fill.color;\r\n                if (type == \"radial\") {\r\n                    fill.type = \"gradientTitle\";\r\n                    fill.focus = \"100%\";\r\n                    fill.focussize = \"0 0\";\r\n                    fill.focusposition = fxfy;\r\n                    fill.angle = 0;\r\n                } else {\r\n                    // fill.rotate= true;\r\n                    fill.type = \"gradient\";\r\n                    fill.angle = (270 - angle) % 360;\r\n                }\r\n                o.appendChild(fill);\r\n            }\r\n            return 1;\r\n        },\r\n        Element = function (node, vml) {\r\n            this[0] = this.node = node;\r\n            node.raphael = true;\r\n            this.id = R._oid++;\r\n            node.raphaelid = this.id;\r\n            this.X = 0;\r\n            this.Y = 0;\r\n            this.attrs = {};\r\n            this.paper = vml;\r\n            this.matrix = R.matrix();\r\n            this._ = {\r\n                transform: [],\r\n                sx: 1,\r\n                sy: 1,\r\n                dx: 0,\r\n                dy: 0,\r\n                deg: 0,\r\n                dirty: 1,\r\n                dirtyT: 1\r\n            };\r\n            !vml.bottom && (vml.bottom = this);\r\n            this.prev = vml.top;\r\n            vml.top && (vml.top.next = this);\r\n            vml.top = this;\r\n            this.next = null;\r\n        };\r\n    var elproto = R.el;\r\n\r\n    Element.prototype = elproto;\r\n    elproto.constructor = Element;\r\n    elproto.transform = function (tstr) {\r\n        if (tstr == null) {\r\n            return this._.transform;\r\n        }\r\n        var vbs = this.paper._viewBoxShift,\r\n            vbt = vbs ? \"s\" + [vbs.scale, vbs.scale] + \"-1-1t\" + [vbs.dx, vbs.dy] : E,\r\n            oldt;\r\n        if (vbs) {\r\n            oldt = tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, this._.transform || E);\r\n        }\r\n        R._extractTransform(this, vbt + tstr);\r\n        var matrix = this.matrix.clone(),\r\n            skew = this.skew,\r\n            o = this.node,\r\n            split,\r\n            isGrad = ~Str(this.attrs.fill).indexOf(\"-\"),\r\n            isPatt = !Str(this.attrs.fill).indexOf(\"url(\");\r\n        matrix.translate(1, 1);\r\n        if (isPatt || isGrad || this.type == \"image\") {\r\n            skew.matrix = \"1 0 0 1\";\r\n            skew.offset = \"0 0\";\r\n            split = matrix.split();\r\n            if ((isGrad && split.noRotation) || !split.isSimple) {\r\n                o.style.filter = matrix.toFilter();\r\n                var bb = this.getBBox(),\r\n                    bbt = this.getBBox(1),\r\n                    dx = bb.x - bbt.x,\r\n                    dy = bb.y - bbt.y;\r\n                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);\r\n                setCoords(this, 1, 1, dx, dy, 0);\r\n            } else {\r\n                o.style.filter = E;\r\n                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);\r\n            }\r\n        } else {\r\n            o.style.filter = E;\r\n            skew.matrix = Str(matrix);\r\n            skew.offset = matrix.offset();\r\n        }\r\n        if (oldt !== null) { // empty string value is true as well\r\n            this._.transform = oldt;\r\n            R._extractTransform(this, oldt);\r\n        }\r\n        return this;\r\n    };\r\n    elproto.rotate = function (deg, cx, cy) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        if (deg == null) {\r\n            return;\r\n        }\r\n        deg = Str(deg).split(separator);\r\n        if (deg.length - 1) {\r\n            cx = toFloat(deg[1]);\r\n            cy = toFloat(deg[2]);\r\n        }\r\n        deg = toFloat(deg[0]);\r\n        (cy == null) && (cx = cy);\r\n        if (cx == null || cy == null) {\r\n            var bbox = this.getBBox(1);\r\n            cx = bbox.x + bbox.width / 2;\r\n            cy = bbox.y + bbox.height / 2;\r\n        }\r\n        this._.dirtyT = 1;\r\n        this.transform(this._.transform.concat([[\"r\", deg, cx, cy]]));\r\n        return this;\r\n    };\r\n    elproto.translate = function (dx, dy) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        dx = Str(dx).split(separator);\r\n        if (dx.length - 1) {\r\n            dy = toFloat(dx[1]);\r\n        }\r\n        dx = toFloat(dx[0]) || 0;\r\n        dy = +dy || 0;\r\n        if (this._.bbox) {\r\n            this._.bbox.x += dx;\r\n            this._.bbox.y += dy;\r\n        }\r\n        this.transform(this._.transform.concat([[\"t\", dx, dy]]));\r\n        return this;\r\n    };\r\n    elproto.scale = function (sx, sy, cx, cy) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        sx = Str(sx).split(separator);\r\n        if (sx.length - 1) {\r\n            sy = toFloat(sx[1]);\r\n            cx = toFloat(sx[2]);\r\n            cy = toFloat(sx[3]);\r\n            isNaN(cx) && (cx = null);\r\n            isNaN(cy) && (cy = null);\r\n        }\r\n        sx = toFloat(sx[0]);\r\n        (sy == null) && (sy = sx);\r\n        (cy == null) && (cx = cy);\r\n        if (cx == null || cy == null) {\r\n            var bbox = this.getBBox(1);\r\n        }\r\n        cx = cx == null ? bbox.x + bbox.width / 2 : cx;\r\n        cy = cy == null ? bbox.y + bbox.height / 2 : cy;\r\n\r\n        this.transform(this._.transform.concat([[\"s\", sx, sy, cx, cy]]));\r\n        this._.dirtyT = 1;\r\n        return this;\r\n    };\r\n    elproto.hide = function () {\r\n        !this.removed && (this.node.style.display = \"none\");\r\n        return this;\r\n    };\r\n    elproto.show = function () {\r\n        !this.removed && (this.node.style.display = E);\r\n        return this;\r\n    };\r\n    // Needed to fix the vml setViewBox issues\r\n    elproto.auxGetBBox = R.el.getBBox;\r\n    elproto.getBBox = function(){\r\n        var b = this.auxGetBBox();\r\n        if (this.paper && this.paper._viewBoxShift)\r\n        {\r\n            var c = {};\r\n            var z = 1/this.paper._viewBoxShift.scale;\r\n            c.x = b.x - this.paper._viewBoxShift.dx;\r\n            c.x *= z;\r\n            c.y = b.y - this.paper._viewBoxShift.dy;\r\n            c.y *= z;\r\n            c.width  = b.width  * z;\r\n            c.height = b.height * z;\r\n            c.x2 = c.x + c.width;\r\n            c.y2 = c.y + c.height;\r\n            return c;\r\n        }\r\n        return b;\r\n    };\r\n    elproto._getBBox = function () {\r\n        if (this.removed) {\r\n            return {};\r\n        }\r\n        return {\r\n            x: this.X + (this.bbx || 0) - this.W / 2,\r\n            y: this.Y - this.H,\r\n            width: this.W,\r\n            height: this.H\r\n        };\r\n    };\r\n    elproto.remove = function () {\r\n        if (this.removed || !this.node.parentNode) {\r\n            return;\r\n        }\r\n        this.paper.__set__ && this.paper.__set__.exclude(this);\r\n        R.eve.unbind(\"raphael.*.*.\" + this.id);\r\n        R._tear(this, this.paper);\r\n        this.node.parentNode.removeChild(this.node);\r\n        this.shape && this.shape.parentNode.removeChild(this.shape);\r\n        for (var i in this) {\r\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\r\n        }\r\n        this.removed = true;\r\n    };\r\n    elproto.attr = function (name, value) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        if (name == null) {\r\n            var res = {};\r\n            for (var a in this.attrs) if (this.attrs[has](a)) {\r\n                res[a] = this.attrs[a];\r\n            }\r\n            res.gradient && res.fill == \"none\" && (res.fill = res.gradient) && delete res.gradient;\r\n            res.transform = this._.transform;\r\n            return res;\r\n        }\r\n        if (value == null && R.is(name, \"string\")) {\r\n            if (name == fillString && this.attrs.fill == \"none\" && this.attrs.gradient) {\r\n                return this.attrs.gradient;\r\n            }\r\n            var names = name.split(separator),\r\n                out = {};\r\n            for (var i = 0, ii = names.length; i < ii; i++) {\r\n                name = names[i];\r\n                if (name in this.attrs) {\r\n                    out[name] = this.attrs[name];\r\n                } else if (R.is(this.paper.customAttributes[name], \"function\")) {\r\n                    out[name] = this.paper.customAttributes[name].def;\r\n                } else {\r\n                    out[name] = R._availableAttrs[name];\r\n                }\r\n            }\r\n            return ii - 1 ? out : out[names[0]];\r\n        }\r\n        if (this.attrs && value == null && R.is(name, \"array\")) {\r\n            out = {};\r\n            for (i = 0, ii = name.length; i < ii; i++) {\r\n                out[name[i]] = this.attr(name[i]);\r\n            }\r\n            return out;\r\n        }\r\n        var params;\r\n        if (value != null) {\r\n            params = {};\r\n            params[name] = value;\r\n        }\r\n        value == null && R.is(name, \"object\") && (params = name);\r\n        for (var key in params) {\r\n            eve(\"raphael.attr.\" + key + \".\" + this.id, this, params[key]);\r\n        }\r\n        if (params) {\r\n            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], \"function\")) {\r\n                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));\r\n                this.attrs[key] = params[key];\r\n                for (var subkey in par) if (par[has](subkey)) {\r\n                    params[subkey] = par[subkey];\r\n                }\r\n            }\r\n            // this.paper.canvas.style.display = \"none\";\r\n            if (params.text && this.type == \"text\") {\r\n                this.textpath.string = params.text;\r\n            }\r\n            setFillAndStroke(this, params);\r\n            // this.paper.canvas.style.display = E;\r\n        }\r\n        return this;\r\n    };\r\n    elproto.toFront = function () {\r\n        !this.removed && this.node.parentNode.appendChild(this.node);\r\n        this.paper && this.paper.top != this && R._tofront(this, this.paper);\r\n        return this;\r\n    };\r\n    elproto.toBack = function () {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        if (this.node.parentNode.firstChild != this.node) {\r\n            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);\r\n            R._toback(this, this.paper);\r\n        }\r\n        return this;\r\n    };\r\n    elproto.insertAfter = function (element) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        if (element.constructor == R.st.constructor) {\r\n            element = element[element.length - 1];\r\n        }\r\n        if (element.node.nextSibling) {\r\n            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);\r\n        } else {\r\n            element.node.parentNode.appendChild(this.node);\r\n        }\r\n        R._insertafter(this, element, this.paper);\r\n        return this;\r\n    };\r\n    elproto.insertBefore = function (element) {\r\n        if (this.removed) {\r\n            return this;\r\n        }\r\n        if (element.constructor == R.st.constructor) {\r\n            element = element[0];\r\n        }\r\n        element.node.parentNode.insertBefore(this.node, element.node);\r\n        R._insertbefore(this, element, this.paper);\r\n        return this;\r\n    };\r\n    elproto.blur = function (size) {\r\n        var s = this.node.runtimeStyle,\r\n            f = s.filter;\r\n        f = f.replace(blurregexp, E);\r\n        if (+size !== 0) {\r\n            this.attrs.blur = size;\r\n            s.filter = f + S + ms + \".Blur(pixelradius=\" + (+size || 1.5) + \")\";\r\n            s.margin = R.format(\"-{0}px 0 0 -{0}px\", round(+size || 1.5));\r\n        } else {\r\n            s.filter = f;\r\n            s.margin = 0;\r\n            delete this.attrs.blur;\r\n        }\r\n        return this;\r\n    };\r\n\r\n    R._engine.path = function (pathString, vml) {\r\n        var el = createNode(\"shape\");\r\n        el.style.cssText = cssDot;\r\n        el.coordsize = zoom + S + zoom;\r\n        el.coordorigin = vml.coordorigin;\r\n        var p = new Element(el, vml),\r\n            attr = {fill: \"none\", stroke: \"#000\"};\r\n        pathString && (attr.path = pathString);\r\n        p.type = \"path\";\r\n        p.path = [];\r\n        p.Path = E;\r\n        setFillAndStroke(p, attr);\r\n        vml.canvas.appendChild(el);\r\n        var skew = createNode(\"skew\");\r\n        skew.on = true;\r\n        el.appendChild(skew);\r\n        p.skew = skew;\r\n        p.transform(E);\r\n        return p;\r\n    };\r\n    R._engine.rect = function (vml, x, y, w, h, r) {\r\n        var path = R._rectPath(x, y, w, h, r),\r\n            res = vml.path(path),\r\n            a = res.attrs;\r\n        res.X = a.x = x;\r\n        res.Y = a.y = y;\r\n        res.W = a.width = w;\r\n        res.H = a.height = h;\r\n        a.r = r;\r\n        a.path = path;\r\n        res.type = \"rect\";\r\n        return res;\r\n    };\r\n    R._engine.ellipse = function (vml, x, y, rx, ry) {\r\n        var res = vml.path(),\r\n            a = res.attrs;\r\n        res.X = x - rx;\r\n        res.Y = y - ry;\r\n        res.W = rx * 2;\r\n        res.H = ry * 2;\r\n        res.type = \"ellipse\";\r\n        setFillAndStroke(res, {\r\n            cx: x,\r\n            cy: y,\r\n            rx: rx,\r\n            ry: ry\r\n        });\r\n        return res;\r\n    };\r\n    R._engine.circle = function (vml, x, y, r) {\r\n        var res = vml.path(),\r\n            a = res.attrs;\r\n        res.X = x - r;\r\n        res.Y = y - r;\r\n        res.W = res.H = r * 2;\r\n        res.type = \"circle\";\r\n        setFillAndStroke(res, {\r\n            cx: x,\r\n            cy: y,\r\n            r: r\r\n        });\r\n        return res;\r\n    };\r\n    R._engine.image = function (vml, src, x, y, w, h) {\r\n        var path = R._rectPath(x, y, w, h),\r\n            res = vml.path(path).attr({stroke: \"none\"}),\r\n            a = res.attrs,\r\n            node = res.node,\r\n            fill = node.getElementsByTagName(fillString)[0];\r\n        a.src = src;\r\n        res.X = a.x = x;\r\n        res.Y = a.y = y;\r\n        res.W = a.width = w;\r\n        res.H = a.height = h;\r\n        a.path = path;\r\n        res.type = \"image\";\r\n        fill.parentNode == node && node.removeChild(fill);\r\n        fill.rotate = true;\r\n        fill.src = src;\r\n        fill.type = \"tile\";\r\n        res._.fillpos = [x, y];\r\n        res._.fillsize = [w, h];\r\n        node.appendChild(fill);\r\n        setCoords(res, 1, 1, 0, 0, 0);\r\n        return res;\r\n    };\r\n    R._engine.text = function (vml, x, y, text) {\r\n        var el = createNode(\"shape\"),\r\n            path = createNode(\"path\"),\r\n            o = createNode(\"textpath\");\r\n        x = x || 0;\r\n        y = y || 0;\r\n        text = text || \"\";\r\n        path.v = R.format(\"m{0},{1}l{2},{1}\", round(x * zoom), round(y * zoom), round(x * zoom) + 1);\r\n        path.textpathok = true;\r\n        o.string = Str(text);\r\n        o.on = true;\r\n        el.style.cssText = cssDot;\r\n        el.coordsize = zoom + S + zoom;\r\n        el.coordorigin = \"0 0\";\r\n        var p = new Element(el, vml),\r\n            attr = {\r\n                fill: \"#000\",\r\n                stroke: \"none\",\r\n                font: R._availableAttrs.font,\r\n                text: text\r\n            };\r\n        p.shape = el;\r\n        p.path = path;\r\n        p.textpath = o;\r\n        p.type = \"text\";\r\n        p.attrs.text = Str(text);\r\n        p.attrs.x = x;\r\n        p.attrs.y = y;\r\n        p.attrs.w = 1;\r\n        p.attrs.h = 1;\r\n        setFillAndStroke(p, attr);\r\n        el.appendChild(o);\r\n        el.appendChild(path);\r\n        vml.canvas.appendChild(el);\r\n        var skew = createNode(\"skew\");\r\n        skew.on = true;\r\n        el.appendChild(skew);\r\n        p.skew = skew;\r\n        p.transform(E);\r\n        return p;\r\n    };\r\n    R._engine.setSize = function (width, height) {\r\n        var cs = this.canvas.style;\r\n        this.width = width;\r\n        this.height = height;\r\n        width == +width && (width += \"px\");\r\n        height == +height && (height += \"px\");\r\n        cs.width = width;\r\n        cs.height = height;\r\n        cs.clip = \"rect(0 \" + width + \" \" + height + \" 0)\";\r\n        if (this._viewBox) {\r\n            R._engine.setViewBox.apply(this, this._viewBox);\r\n        }\r\n        return this;\r\n    };\r\n    R._engine.setViewBox = function (x, y, w, h, fit) {\r\n        R.eve(\"raphael.setViewBox\", this, this._viewBox, [x, y, w, h, fit]);\r\n        var paperSize = this.getSize(),\r\n            width = paperSize.width,\r\n            height = paperSize.height,\r\n            H, W;\r\n        if (fit) {\r\n            H = height / h;\r\n            W = width / w;\r\n            if (w * H < width) {\r\n                x -= (width - w * H) / 2 / H;\r\n            }\r\n            if (h * W < height) {\r\n                y -= (height - h * W) / 2 / W;\r\n            }\r\n        }\r\n        this._viewBox = [x, y, w, h, !!fit];\r\n        this._viewBoxShift = {\r\n            dx: -x,\r\n            dy: -y,\r\n            scale: paperSize\r\n        };\r\n        this.forEach(function (el) {\r\n            el.transform(\"...\");\r\n        });\r\n        return this;\r\n    };\r\n    var createNode;\r\n    R._engine.initWin = function (win) {\r\n        var doc = win.document;\r\n        if (doc.styleSheets.length < 31) {\r\n            doc.createStyleSheet().addRule(\".rvml\", \"behavior:url(#default#VML)\");\r\n        } else {\r\n            // no more room, add to the existing one\r\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\r\n            doc.styleSheets[0].addRule(\".rvml\", \"behavior:url(#default#VML)\");\r\n        }\r\n        try {\r\n            !doc.namespaces.rvml && doc.namespaces.add(\"rvml\", \"urn:schemas-microsoft-com:vml\");\r\n            createNode = function (tagName) {\r\n                return doc.createElement('<rvml:' + tagName + ' class=\"rvml\">');\r\n            };\r\n        } catch (e) {\r\n            createNode = function (tagName) {\r\n                return doc.createElement('<' + tagName + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"rvml\">');\r\n            };\r\n        }\r\n    };\r\n    R._engine.initWin(R._g.win);\r\n    R._engine.create = function () {\r\n        var con = R._getContainer.apply(0, arguments),\r\n            container = con.container,\r\n            height = con.height,\r\n            s,\r\n            width = con.width,\r\n            x = con.x,\r\n            y = con.y;\r\n        if (!container) {\r\n            throw new Error(\"VML container not found.\");\r\n        }\r\n        var res = new R._Paper,\r\n            c = res.canvas = R._g.doc.createElement(\"div\"),\r\n            cs = c.style;\r\n        x = x || 0;\r\n        y = y || 0;\r\n        width = width || 512;\r\n        height = height || 342;\r\n        res.width = width;\r\n        res.height = height;\r\n        width == +width && (width += \"px\");\r\n        height == +height && (height += \"px\");\r\n        res.coordsize = zoom * 1e3 + S + zoom * 1e3;\r\n        res.coordorigin = \"0 0\";\r\n        res.span = R._g.doc.createElement(\"span\");\r\n        res.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;\";\r\n        c.appendChild(res.span);\r\n        cs.cssText = R.format(\"top:0;left:0;display:inline-block;position:absolute;clip:rect(0 {0} {1} 0);\", width, height);\r\n        if (container == 1) {\r\n            R._g.doc.body.appendChild(c);\r\n            cs.left = x + \"px\";\r\n            cs.top = y + \"px\";\r\n            cs.position = \"absolute\";\r\n        } else {\r\n            if (container.firstChild) {\r\n                container.insertBefore(c, container.firstChild);\r\n            } else {\r\n                container.appendChild(c);\r\n            }\r\n        }\r\n        res.renderfix = function () {};\r\n        return res;\r\n    };\r\n    R.prototype.clear = function () {\r\n        R.eve(\"raphael.clear\", this);\r\n        this.canvas.innerHTML = E;\r\n        this.span = R._g.doc.createElement(\"span\");\r\n        this.span.style.cssText = \"position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;\";\r\n        this.canvas.appendChild(this.span);\r\n        this.bottom = this.top = null;\r\n    };\r\n    R.prototype.remove = function () {\r\n        R.eve(\"raphael.remove\", this);\r\n        this.canvas.parentNode.removeChild(this.canvas);\r\n        for (var i in this) {\r\n            this[i] = typeof this[i] == \"function\" ? R._removedFactory(i) : null;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    var setproto = R.st;\r\n    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {\r\n        setproto[method] = (function (methodname) {\r\n            return function () {\r\n                var arg = arguments;\r\n                return this.forEach(function (el) {\r\n                    el[methodname].apply(el, arg);\r\n                });\r\n            };\r\n        })(method);\r\n    }\r\n}));\r\n\r\n// ┌────────────────────────────────────────────────────────────────────┐ \\\\\r\n// │ Raphaël 2.1.4 - JavaScript Vector Library                      │ \\\\\r\n// ├────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Copyright © 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    │ \\\\\r\n// │ Copyright © 2008-2012 Sencha Labs (http://sencha.com)              │ \\\\\r\n// ├────────────────────────────────────────────────────────────────────┤ \\\\\r\n// │ Licensed under the MIT (http://raphaeljs.com/license.html) license.│ \\\\\r\n// └────────────────────────────────────────────────────────────────────┘ \\\\\r\n\r\n(function (glob, factory) {\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"raphael\", [\"raphael.core\", \"raphael.svg\", \"raphael.vml\"], function(Raphael) {\r\n            return factory(Raphael);\r\n        });\r\n    } else if (typeof exports === \"object\") {\r\n        var raphael = require(\"raphael.core\");\r\n\r\n        require(\"raphael.svg\");\r\n        require(\"raphael.vml\");\r\n\r\n        module.exports = factory(raphael);\r\n    } else {\r\n        //glob.Raphael = factory(glob.Raphael);\r\n    }\r\n}(this, function (Raphael) {\r\n    return Raphael.ninja();\r\n}));"

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(323);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(326);
__webpack_require__(327);
__webpack_require__(328);
__webpack_require__(329);
__webpack_require__(330);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(333);
__webpack_require__(334);
__webpack_require__(335);
__webpack_require__(336);
__webpack_require__(337);
__webpack_require__(338);
__webpack_require__(339);
__webpack_require__(340);
__webpack_require__(341);
__webpack_require__(342);
__webpack_require__(343);
__webpack_require__(344);
__webpack_require__(345);
__webpack_require__(346);
__webpack_require__(347);
__webpack_require__(348);
__webpack_require__(349);
__webpack_require__(350);
__webpack_require__(351);
__webpack_require__(352);
__webpack_require__(353);
__webpack_require__(354);
__webpack_require__(355);
__webpack_require__(356);
__webpack_require__(357);
__webpack_require__(358);
__webpack_require__(359);
__webpack_require__(360);
__webpack_require__(361);
__webpack_require__(362);
__webpack_require__(363);
__webpack_require__(364);
__webpack_require__(365);
__webpack_require__(366);
__webpack_require__(367);
__webpack_require__(368);
__webpack_require__(369);
__webpack_require__(370);
__webpack_require__(371);
__webpack_require__(372);
__webpack_require__(373);
__webpack_require__(374);
__webpack_require__(375);
__webpack_require__(376);
__webpack_require__(377);
__webpack_require__(378);
__webpack_require__(379);
__webpack_require__(380);
__webpack_require__(381);
__webpack_require__(382);
__webpack_require__(383);
__webpack_require__(384);
__webpack_require__(385);
__webpack_require__(386);
__webpack_require__(246);
__webpack_require__(113);
__webpack_require__(247);
__webpack_require__(114);
__webpack_require__(115);
__webpack_require__(116);
__webpack_require__(117);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(120);
__webpack_require__(121);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(122);
__webpack_require__(123);
__webpack_require__(124);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(387);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(111);
__webpack_require__(260);
__webpack_require__(70);
__webpack_require__(69);
__webpack_require__(112);
__webpack_require__(43);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(125);
__webpack_require__(126);
__webpack_require__(127);
__webpack_require__(128);
__webpack_require__(129);
__webpack_require__(130);
__webpack_require__(131);
__webpack_require__(132);
__webpack_require__(133);
__webpack_require__(134);
__webpack_require__(135);
__webpack_require__(136);
__webpack_require__(137);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(138);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(146);
__webpack_require__(147);
__webpack_require__(148);
__webpack_require__(149);
__webpack_require__(150);
__webpack_require__(151);
__webpack_require__(152);
__webpack_require__(153);
__webpack_require__(154);
__webpack_require__(155);
__webpack_require__(156);
__webpack_require__(157);
__webpack_require__(158);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(159);
__webpack_require__(160);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(164);
__webpack_require__(165);
__webpack_require__(166);
__webpack_require__(167);
__webpack_require__(168);
__webpack_require__(169);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(71);
__webpack_require__(204);
__webpack_require__(72);
__webpack_require__(42);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(544);
__webpack_require__(247);
__webpack_require__(246);
__webpack_require__(114);
__webpack_require__(115);
__webpack_require__(116);
__webpack_require__(117);
__webpack_require__(118);
__webpack_require__(119);
__webpack_require__(120);
__webpack_require__(121);
__webpack_require__(113);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(122);
__webpack_require__(123);
__webpack_require__(124);
__webpack_require__(250);
__webpack_require__(251);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(254);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(111);
__webpack_require__(260);
__webpack_require__(70);
__webpack_require__(69);
__webpack_require__(112);
__webpack_require__(43);
__webpack_require__(261);
__webpack_require__(262);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(125);
__webpack_require__(126);
__webpack_require__(127);
__webpack_require__(128);
__webpack_require__(129);
__webpack_require__(130);
__webpack_require__(131);
__webpack_require__(132);
__webpack_require__(133);
__webpack_require__(134);
__webpack_require__(135);
__webpack_require__(136);
__webpack_require__(137);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(138);
__webpack_require__(139);
__webpack_require__(140);
__webpack_require__(141);
__webpack_require__(142);
__webpack_require__(143);
__webpack_require__(144);
__webpack_require__(145);
__webpack_require__(146);
__webpack_require__(147);
__webpack_require__(148);
__webpack_require__(149);
__webpack_require__(150);
__webpack_require__(151);
__webpack_require__(152);
__webpack_require__(153);
__webpack_require__(154);
__webpack_require__(155);
__webpack_require__(156);
__webpack_require__(157);
__webpack_require__(158);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(159);
__webpack_require__(160);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(164);
__webpack_require__(165);
__webpack_require__(166);
__webpack_require__(167);
__webpack_require__(168);
__webpack_require__(169);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(71);
__webpack_require__(204);
__webpack_require__(72);
__webpack_require__(42);
__webpack_require__(205);
__webpack_require__(206);
module.exports = __webpack_require__(301);


/***/ }),
/* 544 */
/***/ (function(module, exports) {

BI.resourceURL = "file?path=/com/fr/web/ui/resource/";

/***/ })
/******/ ]);
//# sourceMappingURL=./materials.js.map